"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/x402-axios";
exports.ids = ["vendor-chunks/x402-axios"];
exports.modules = {

/***/ "(rsc)/./node_modules/x402-axios/dist/cjs/index.js":
/*!***************************************************!*\
  !*** ./node_modules/x402-axios/dist/cjs/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  decodeXPaymentResponse: () => import_shared.decodeXPaymentResponse,\n  withPaymentInterceptor: () => withPaymentInterceptor\n});\nmodule.exports = __toCommonJS(src_exports);\nvar import_types = __webpack_require__(/*! x402/types */ \"(rsc)/./node_modules/x402-axios/node_modules/x402/dist/cjs/types/index.js\");\nvar import_types2 = __webpack_require__(/*! x402/types */ \"(rsc)/./node_modules/x402-axios/node_modules/x402/dist/cjs/types/index.js\");\nvar import_client = __webpack_require__(/*! x402/client */ \"(rsc)/./node_modules/x402-axios/node_modules/x402/dist/cjs/client/index.js\");\nvar import_shared = __webpack_require__(/*! x402/shared */ \"(rsc)/./node_modules/x402-axios/node_modules/x402/dist/cjs/shared/index.js\");\nfunction withPaymentInterceptor(axiosClient, walletClient, paymentRequirementsSelector = import_client.selectPaymentRequirements) {\n  axiosClient.interceptors.response.use(\n    (response) => response,\n    async (error) => {\n      var _a, _b, _c;\n      if (!error.response || error.response.status !== 402) {\n        return Promise.reject(error);\n      }\n      try {\n        const originalConfig = error.config;\n        if (!originalConfig || !originalConfig.headers) {\n          return Promise.reject(new Error(\"Missing axios request configuration\"));\n        }\n        if (originalConfig.__is402Retry) {\n          return Promise.reject(error);\n        }\n        const { x402Version, accepts } = error.response.data;\n        const parsed = accepts.map((x) => import_types.PaymentRequirementsSchema.parse(x));\n        const chainId = import_types2.evm.isSignerWallet(walletClient) ? (_a = walletClient.chain) == null ? void 0 : _a.id : import_types2.evm.isAccount(walletClient) ? (_c = (_b = walletClient.client) == null ? void 0 : _b.chain) == null ? void 0 : _c.id : void 0;\n        const selectedPaymentRequirements = paymentRequirementsSelector(\n          parsed,\n          chainId ? import_types.ChainIdToNetwork[chainId] : void 0,\n          \"exact\"\n        );\n        const paymentHeader = await (0, import_client.createPaymentHeader)(\n          walletClient,\n          x402Version,\n          selectedPaymentRequirements\n        );\n        originalConfig.__is402Retry = true;\n        originalConfig.headers[\"X-PAYMENT\"] = paymentHeader;\n        originalConfig.headers[\"Access-Control-Expose-Headers\"] = \"X-PAYMENT-RESPONSE\";\n        const secondResponse = await axiosClient.request(originalConfig);\n        return secondResponse;\n      } catch (paymentError) {\n        return Promise.reject(paymentError);\n      }\n    }\n  );\n  return axiosClient;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveDQwMi1heGlvcy9kaXN0L2Nqcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsNkZBQVk7QUFDdkMsb0JBQW9CLG1CQUFPLENBQUMsNkZBQVk7QUFDeEMsb0JBQW9CLG1CQUFPLENBQUMsK0ZBQWE7QUFDekMsb0JBQW9CLG1CQUFPLENBQUMsK0ZBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBR0w7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL29uY2hhaW4tYWdlbnQvLi9ub2RlX21vZHVsZXMveDQwMi1heGlvcy9kaXN0L2Nqcy9pbmRleC5qcz83NWRiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgc3JjX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHNyY19leHBvcnRzLCB7XG4gIGRlY29kZVhQYXltZW50UmVzcG9uc2U6ICgpID0+IGltcG9ydF9zaGFyZWQuZGVjb2RlWFBheW1lbnRSZXNwb25zZSxcbiAgd2l0aFBheW1lbnRJbnRlcmNlcHRvcjogKCkgPT4gd2l0aFBheW1lbnRJbnRlcmNlcHRvclxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhzcmNfZXhwb3J0cyk7XG52YXIgaW1wb3J0X3R5cGVzID0gcmVxdWlyZShcIng0MDIvdHlwZXNcIik7XG52YXIgaW1wb3J0X3R5cGVzMiA9IHJlcXVpcmUoXCJ4NDAyL3R5cGVzXCIpO1xudmFyIGltcG9ydF9jbGllbnQgPSByZXF1aXJlKFwieDQwMi9jbGllbnRcIik7XG52YXIgaW1wb3J0X3NoYXJlZCA9IHJlcXVpcmUoXCJ4NDAyL3NoYXJlZFwiKTtcbmZ1bmN0aW9uIHdpdGhQYXltZW50SW50ZXJjZXB0b3IoYXhpb3NDbGllbnQsIHdhbGxldENsaWVudCwgcGF5bWVudFJlcXVpcmVtZW50c1NlbGVjdG9yID0gaW1wb3J0X2NsaWVudC5zZWxlY3RQYXltZW50UmVxdWlyZW1lbnRzKSB7XG4gIGF4aW9zQ2xpZW50LmludGVyY2VwdG9ycy5yZXNwb25zZS51c2UoXG4gICAgKHJlc3BvbnNlKSA9PiByZXNwb25zZSxcbiAgICBhc3luYyAoZXJyb3IpID0+IHtcbiAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgaWYgKCFlcnJvci5yZXNwb25zZSB8fCBlcnJvci5yZXNwb25zZS5zdGF0dXMgIT09IDQwMikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxDb25maWcgPSBlcnJvci5jb25maWc7XG4gICAgICAgIGlmICghb3JpZ2luYWxDb25maWcgfHwgIW9yaWdpbmFsQ29uZmlnLmhlYWRlcnMpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiTWlzc2luZyBheGlvcyByZXF1ZXN0IGNvbmZpZ3VyYXRpb25cIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmlnaW5hbENvbmZpZy5fX2lzNDAyUmV0cnkpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgeDQwMlZlcnNpb24sIGFjY2VwdHMgfSA9IGVycm9yLnJlc3BvbnNlLmRhdGE7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IGFjY2VwdHMubWFwKCh4KSA9PiBpbXBvcnRfdHlwZXMuUGF5bWVudFJlcXVpcmVtZW50c1NjaGVtYS5wYXJzZSh4KSk7XG4gICAgICAgIGNvbnN0IGNoYWluSWQgPSBpbXBvcnRfdHlwZXMyLmV2bS5pc1NpZ25lcldhbGxldCh3YWxsZXRDbGllbnQpID8gKF9hID0gd2FsbGV0Q2xpZW50LmNoYWluKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaWQgOiBpbXBvcnRfdHlwZXMyLmV2bS5pc0FjY291bnQod2FsbGV0Q2xpZW50KSA/IChfYyA9IChfYiA9IHdhbGxldENsaWVudC5jbGllbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jaGFpbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmlkIDogdm9pZCAwO1xuICAgICAgICBjb25zdCBzZWxlY3RlZFBheW1lbnRSZXF1aXJlbWVudHMgPSBwYXltZW50UmVxdWlyZW1lbnRzU2VsZWN0b3IoXG4gICAgICAgICAgcGFyc2VkLFxuICAgICAgICAgIGNoYWluSWQgPyBpbXBvcnRfdHlwZXMuQ2hhaW5JZFRvTmV0d29ya1tjaGFpbklkXSA6IHZvaWQgMCxcbiAgICAgICAgICBcImV4YWN0XCJcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcGF5bWVudEhlYWRlciA9IGF3YWl0ICgwLCBpbXBvcnRfY2xpZW50LmNyZWF0ZVBheW1lbnRIZWFkZXIpKFxuICAgICAgICAgIHdhbGxldENsaWVudCxcbiAgICAgICAgICB4NDAyVmVyc2lvbixcbiAgICAgICAgICBzZWxlY3RlZFBheW1lbnRSZXF1aXJlbWVudHNcbiAgICAgICAgKTtcbiAgICAgICAgb3JpZ2luYWxDb25maWcuX19pczQwMlJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgb3JpZ2luYWxDb25maWcuaGVhZGVyc1tcIlgtUEFZTUVOVFwiXSA9IHBheW1lbnRIZWFkZXI7XG4gICAgICAgIG9yaWdpbmFsQ29uZmlnLmhlYWRlcnNbXCJBY2Nlc3MtQ29udHJvbC1FeHBvc2UtSGVhZGVyc1wiXSA9IFwiWC1QQVlNRU5ULVJFU1BPTlNFXCI7XG4gICAgICAgIGNvbnN0IHNlY29uZFJlc3BvbnNlID0gYXdhaXQgYXhpb3NDbGllbnQucmVxdWVzdChvcmlnaW5hbENvbmZpZyk7XG4gICAgICAgIHJldHVybiBzZWNvbmRSZXNwb25zZTtcbiAgICAgIH0gY2F0Y2ggKHBheW1lbnRFcnJvcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocGF5bWVudEVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIHJldHVybiBheGlvc0NsaWVudDtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBkZWNvZGVYUGF5bWVudFJlc3BvbnNlLFxuICB3aXRoUGF5bWVudEludGVyY2VwdG9yXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/x402-axios/dist/cjs/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/x402-axios/node_modules/x402/dist/cjs/client/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/x402-axios/node_modules/x402/dist/cjs/client/index.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/client/index.ts\nvar client_exports = {};\n__export(client_exports, {\n  createPaymentHeader: () => createPaymentHeader2,\n  preparePaymentHeader: () => preparePaymentHeader2,\n  selectPaymentRequirements: () => selectPaymentRequirements,\n  signPaymentHeader: () => signPaymentHeader2\n});\nmodule.exports = __toCommonJS(client_exports);\n\n// src/types/shared/evm/config.ts\nvar config = {\n  \"84532\": {\n    usdcAddress: \"0x036CbD53842c5426634e7929541eC2318f3dCF7e\",\n    usdcName: \"USDC\"\n  },\n  \"8453\": {\n    usdcAddress: \"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\",\n    usdcName: \"USDC\"\n  },\n  \"43113\": {\n    usdcAddress: \"0x5425890298aed601595a70AB815c96711a31Bc65\",\n    usdcName: \"USD Coin\"\n  },\n  \"43114\": {\n    usdcAddress: \"0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E\",\n    usdcName: \"USDC\"\n  },\n  \"4689\": {\n    usdcAddress: \"0xcdf79194c6c285077a58da47641d4dbe51f63542\",\n    usdcName: \"Bridged USDC\"\n  }\n};\n\n// src/types/shared/evm/eip3009.ts\nvar authorizationTypes = {\n  TransferWithAuthorization: [\n    { name: \"from\", type: \"address\" },\n    { name: \"to\", type: \"address\" },\n    { name: \"value\", type: \"uint256\" },\n    { name: \"validAfter\", type: \"uint256\" },\n    { name: \"validBefore\", type: \"uint256\" },\n    { name: \"nonce\", type: \"bytes32\" }\n  ]\n};\n\n// src/types/shared/evm/wallet.ts\nvar import_viem = __webpack_require__(/*! viem */ \"(rsc)/./node_modules/viem/_cjs/index.js\");\nvar import_chains = __webpack_require__(/*! viem/chains */ \"(rsc)/./node_modules/viem/_cjs/chains/index.js\");\nvar import_accounts = __webpack_require__(/*! viem/accounts */ \"(rsc)/./node_modules/viem/_cjs/accounts/index.js\");\nfunction isSignerWallet(wallet) {\n  return \"chain\" in wallet && \"transport\" in wallet;\n}\nfunction isAccount(wallet) {\n  return \"address\" in wallet && \"type\" in wallet;\n}\n\n// src/schemes/exact/evm/sign.ts\nvar import_viem2 = __webpack_require__(/*! viem */ \"(rsc)/./node_modules/viem/_cjs/index.js\");\n\n// src/shared/base64.ts\nfunction safeBase64Encode(data) {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.btoa === \"function\") {\n    return globalThis.btoa(data);\n  }\n  return Buffer.from(data).toString(\"base64\");\n}\n\n// src/types/shared/money.ts\nvar import_zod = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/index.cjs\");\nvar moneySchema = import_zod.z.union([import_zod.z.string().transform((x) => x.replace(/[^0-9.-]+/g, \"\")), import_zod.z.number()]).pipe(import_zod.z.coerce.number().min(1e-4).max(999999999));\n\n// src/types/shared/network.ts\nvar import_zod2 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/index.cjs\");\nvar NetworkSchema = import_zod2.z.enum([\n  \"base-sepolia\",\n  \"base\",\n  \"avalanche-fuji\",\n  \"avalanche\",\n  \"iotex\"\n]);\nvar SupportedEVMNetworks = [\n  \"base-sepolia\",\n  \"base\",\n  \"avalanche-fuji\",\n  \"avalanche\",\n  \"iotex\"\n];\nvar EvmNetworkToChainId = /* @__PURE__ */ new Map([\n  [\"base-sepolia\", 84532],\n  [\"base\", 8453],\n  [\"avalanche-fuji\", 43113],\n  [\"avalanche\", 43114],\n  [\"iotex\", 4689]\n]);\nvar ChainIdToNetwork = Object.fromEntries(\n  SupportedEVMNetworks.map((network) => [EvmNetworkToChainId.get(network), network])\n);\n\n// src/shared/network.ts\nfunction getNetworkId(network) {\n  if (EvmNetworkToChainId.has(network)) {\n    return EvmNetworkToChainId.get(network);\n  }\n  throw new Error(`Unsupported network: ${network}`);\n}\n\n// src/types/verify/x402Specs.ts\nvar import_zod3 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/index.cjs\");\nvar EvmMaxAtomicUnits = 18;\nvar EvmAddressRegex = /^0x[0-9a-fA-F]{40}$/;\nvar MixedAddressRegex = /^0x[a-fA-F0-9]{40}|[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$/;\nvar HexEncoded64ByteRegex = /^0x[0-9a-fA-F]{64}$/;\nvar EvmSignatureRegex = /^0x[0-9a-fA-F]{130}$/;\nvar schemes = [\"exact\"];\nvar x402Versions = [1];\nvar ErrorReasons = [\n  \"insufficient_funds\",\n  \"invalid_exact_evm_payload_authorization_valid_after\",\n  \"invalid_exact_evm_payload_authorization_valid_before\",\n  \"invalid_exact_evm_payload_authorization_value\",\n  \"invalid_exact_evm_payload_signature\",\n  \"invalid_exact_evm_payload_recipient_mismatch\",\n  \"invalid_network\",\n  \"invalid_payload\",\n  \"invalid_payment_requirements\",\n  \"invalid_scheme\",\n  \"unsupported_scheme\",\n  \"invalid_x402_version\",\n  \"invalid_transaction_state\",\n  \"unexpected_verify_error\",\n  \"unexpected_settle_error\"\n];\nvar isInteger = (value) => Number.isInteger(Number(value)) && Number(value) >= 0;\nvar hasMaxLength = (maxLength) => (value) => value.length <= maxLength;\nvar PaymentRequirementsSchema = import_zod3.z.object({\n  scheme: import_zod3.z.enum(schemes),\n  network: NetworkSchema,\n  maxAmountRequired: import_zod3.z.string().refine(isInteger),\n  resource: import_zod3.z.string().url(),\n  description: import_zod3.z.string(),\n  mimeType: import_zod3.z.string(),\n  outputSchema: import_zod3.z.record(import_zod3.z.any()).optional(),\n  payTo: import_zod3.z.string().regex(MixedAddressRegex),\n  maxTimeoutSeconds: import_zod3.z.number().int(),\n  asset: import_zod3.z.string().regex(MixedAddressRegex),\n  extra: import_zod3.z.record(import_zod3.z.any()).optional()\n});\nvar ExactEvmPayloadAuthorizationSchema = import_zod3.z.object({\n  from: import_zod3.z.string().regex(EvmAddressRegex),\n  to: import_zod3.z.string().regex(EvmAddressRegex),\n  value: import_zod3.z.string().refine(isInteger).refine(hasMaxLength(EvmMaxAtomicUnits)),\n  validAfter: import_zod3.z.string().refine(isInteger),\n  validBefore: import_zod3.z.string().refine(isInteger),\n  nonce: import_zod3.z.string().regex(HexEncoded64ByteRegex)\n});\nvar ExactEvmPayloadSchema = import_zod3.z.object({\n  signature: import_zod3.z.string().regex(EvmSignatureRegex),\n  authorization: ExactEvmPayloadAuthorizationSchema\n});\nvar PaymentPayloadSchema = import_zod3.z.object({\n  x402Version: import_zod3.z.number().refine((val) => x402Versions.includes(val)),\n  scheme: import_zod3.z.enum(schemes),\n  network: NetworkSchema,\n  payload: ExactEvmPayloadSchema\n});\nvar VerifyResponseSchema = import_zod3.z.object({\n  isValid: import_zod3.z.boolean(),\n  invalidReason: import_zod3.z.enum(ErrorReasons).optional(),\n  payer: import_zod3.z.string().regex(MixedAddressRegex).optional()\n});\nvar SettleResponseSchema = import_zod3.z.object({\n  success: import_zod3.z.boolean(),\n  errorReason: import_zod3.z.enum(ErrorReasons).optional(),\n  payer: import_zod3.z.string().regex(MixedAddressRegex).optional(),\n  transaction: import_zod3.z.string().regex(MixedAddressRegex),\n  network: NetworkSchema\n});\nvar SupportedPaymentKindSchema = import_zod3.z.object({\n  x402Version: import_zod3.z.number().refine((val) => x402Versions.includes(val)),\n  scheme: import_zod3.z.enum(schemes),\n  network: NetworkSchema\n});\nvar SupportedPaymentKindsResponseSchema = import_zod3.z.object({\n  kinds: import_zod3.z.array(SupportedPaymentKindSchema)\n});\n\n// src/types/verify/facilitator.ts\nvar import_zod4 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/index.cjs\");\nvar facilitatorRequestSchema = import_zod4.z.object({\n  paymentHeader: import_zod4.z.string(),\n  paymentRequirements: PaymentRequirementsSchema\n});\n\n// src/shared/evm/usdc.ts\nfunction getUsdcAddressForChain(chainId) {\n  return config[chainId.toString()].usdcAddress;\n}\n\n// src/schemes/exact/evm/sign.ts\nasync function signAuthorization(walletClient, { from, to, value, validAfter, validBefore, nonce }, { asset, network, extra }) {\n  const chainId = getNetworkId(network);\n  const name = extra?.name;\n  const version = extra?.version;\n  const account = isSignerWallet(walletClient) ? walletClient.account : walletClient;\n  const data = {\n    account,\n    types: authorizationTypes,\n    domain: {\n      name,\n      version,\n      chainId,\n      verifyingContract: asset\n    },\n    primaryType: \"TransferWithAuthorization\",\n    message: {\n      from,\n      to,\n      value,\n      validAfter,\n      validBefore,\n      nonce\n    }\n  };\n  if (isSignerWallet(walletClient)) {\n    const signature = await walletClient.signTypedData(data);\n    return {\n      signature\n    };\n  } else if (isAccount(walletClient) && walletClient.signTypedData) {\n    const signature = await walletClient.signTypedData(data);\n    return {\n      signature\n    };\n  } else {\n    throw new Error(\"Invalid wallet client provided does not support signTypedData\");\n  }\n}\nfunction createNonce() {\n  const cryptoObj = typeof globalThis.crypto !== \"undefined\" && typeof globalThis.crypto.getRandomValues === \"function\" ? globalThis.crypto : (\n    // Dynamic require is needed to support node.js\n    // eslint-disable-next-line @typescript-eslint/no-require-imports\n    (__webpack_require__(/*! crypto */ \"crypto\").webcrypto)\n  );\n  return (0, import_viem2.toHex)(cryptoObj.getRandomValues(new Uint8Array(32)));\n}\n\n// src/schemes/exact/evm/utils/paymentUtils.ts\nfunction encodePayment(payment) {\n  const safe = {\n    ...payment,\n    payload: {\n      ...payment.payload,\n      authorization: Object.fromEntries(\n        Object.entries(payment.payload.authorization).map(([key, value]) => [\n          key,\n          typeof value === \"bigint\" ? value.toString() : value\n        ])\n      )\n    }\n  };\n  return safeBase64Encode(JSON.stringify(safe));\n}\n\n// src/schemes/exact/evm/client.ts\nfunction preparePaymentHeader(from, x402Version, paymentRequirements) {\n  const nonce = createNonce();\n  const validAfter = BigInt(\n    Math.floor(Date.now() / 1e3) - 600\n    // 10 minutes before\n  ).toString();\n  const validBefore = BigInt(\n    Math.floor(Date.now() / 1e3 + paymentRequirements.maxTimeoutSeconds)\n  ).toString();\n  return {\n    x402Version,\n    scheme: paymentRequirements.scheme,\n    network: paymentRequirements.network,\n    payload: {\n      signature: void 0,\n      authorization: {\n        from,\n        to: paymentRequirements.payTo,\n        value: paymentRequirements.maxAmountRequired,\n        validAfter: validAfter.toString(),\n        validBefore: validBefore.toString(),\n        nonce\n      }\n    }\n  };\n}\nasync function signPaymentHeader(client, paymentRequirements, unsignedPaymentHeader) {\n  const { signature } = await signAuthorization(\n    client,\n    unsignedPaymentHeader.payload.authorization,\n    paymentRequirements\n  );\n  return {\n    ...unsignedPaymentHeader,\n    payload: {\n      ...unsignedPaymentHeader.payload,\n      signature\n    }\n  };\n}\nasync function createPayment(client, x402Version, paymentRequirements) {\n  const from = isSignerWallet(client) ? client.account.address : client.address;\n  const unsignedPaymentHeader = preparePaymentHeader(from, x402Version, paymentRequirements);\n  return signPaymentHeader(client, paymentRequirements, unsignedPaymentHeader);\n}\nasync function createPaymentHeader(client, x402Version, paymentRequirements) {\n  const payment = await createPayment(client, x402Version, paymentRequirements);\n  return encodePayment(payment);\n}\n\n// src/client/createPaymentHeader.ts\nasync function createPaymentHeader2(client, x402Version, paymentRequirements) {\n  if (paymentRequirements.scheme === \"exact\" && SupportedEVMNetworks.includes(paymentRequirements.network)) {\n    return await createPaymentHeader(client, x402Version, paymentRequirements);\n  }\n  throw new Error(\"Unsupported scheme\");\n}\n\n// src/client/preparePaymentHeader.ts\nfunction preparePaymentHeader2(from, x402Version, paymentRequirements) {\n  if (paymentRequirements.scheme === \"exact\" && SupportedEVMNetworks.includes(paymentRequirements.network)) {\n    return preparePaymentHeader(from, x402Version, paymentRequirements);\n  }\n  throw new Error(\"Unsupported scheme\");\n}\n\n// src/client/selectPaymentRequirements.ts\nfunction selectPaymentRequirements(paymentRequirements, network, scheme) {\n  paymentRequirements.sort((a, b) => {\n    if (a.network === \"base\" && b.network !== \"base\") {\n      return -1;\n    }\n    if (a.network !== \"base\" && b.network === \"base\") {\n      return 1;\n    }\n    return 0;\n  });\n  const broadlyAcceptedPaymentRequirements = paymentRequirements.filter((requirement) => {\n    const isExpectedScheme = !scheme || requirement.scheme === scheme;\n    const isExpectedChain = !network || network == requirement.network;\n    return isExpectedScheme && isExpectedChain;\n  });\n  const usdcRequirements = broadlyAcceptedPaymentRequirements.filter((requirement) => {\n    return requirement.asset === getUsdcAddressForChain(getNetworkId(requirement.network));\n  });\n  if (usdcRequirements.length > 0) {\n    return usdcRequirements[0];\n  }\n  if (broadlyAcceptedPaymentRequirements.length > 0) {\n    return broadlyAcceptedPaymentRequirements[0];\n  }\n  return paymentRequirements[0];\n}\n\n// src/client/signPaymentHeader.ts\nasync function signPaymentHeader2(client, paymentRequirements, unsignedPaymentHeader) {\n  if (paymentRequirements.scheme === \"exact\" && SupportedEVMNetworks.includes(paymentRequirements.network)) {\n    const signedPaymentHeader = await signPaymentHeader(client, paymentRequirements, unsignedPaymentHeader);\n    return encodePayment(signedPaymentHeader);\n  }\n  throw new Error(\"Unsupported scheme\");\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveDQwMi1heGlvcy9ub2RlX21vZHVsZXMveDQwMi9kaXN0L2Nqcy9jbGllbnQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sK0JBQStCO0FBQ3JDLE1BQU0sNkJBQTZCO0FBQ25DLE1BQU0sZ0NBQWdDO0FBQ3RDLE1BQU0scUNBQXFDO0FBQzNDLE1BQU0sc0NBQXNDO0FBQzVDLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMscURBQU07QUFDaEMsb0JBQW9CLG1CQUFPLENBQUMsbUVBQWE7QUFDekMsc0JBQXNCLG1CQUFPLENBQUMsdUVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMscURBQU07O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsK0NBQUs7QUFDOUI7O0FBRUE7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQywrQ0FBSztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEOztBQUVBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsK0NBQUs7QUFDL0I7QUFDQSxzQ0FBc0MsR0FBRztBQUN6Qyx3Q0FBd0MsR0FBRyx5QkFBeUIsS0FBSztBQUN6RSw0Q0FBNEMsR0FBRztBQUMvQyx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsK0NBQUs7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCxpREFBaUQsSUFBSSx1QkFBdUI7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksdURBQTJCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FLTDtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb25jaGFpbi1hZ2VudC8uL25vZGVfbW9kdWxlcy94NDAyLWF4aW9zL25vZGVfbW9kdWxlcy94NDAyL2Rpc3QvY2pzL2NsaWVudC9pbmRleC5qcz81NGM4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcblxuLy8gc3JjL2NsaWVudC9pbmRleC50c1xudmFyIGNsaWVudF9leHBvcnRzID0ge307XG5fX2V4cG9ydChjbGllbnRfZXhwb3J0cywge1xuICBjcmVhdGVQYXltZW50SGVhZGVyOiAoKSA9PiBjcmVhdGVQYXltZW50SGVhZGVyMixcbiAgcHJlcGFyZVBheW1lbnRIZWFkZXI6ICgpID0+IHByZXBhcmVQYXltZW50SGVhZGVyMixcbiAgc2VsZWN0UGF5bWVudFJlcXVpcmVtZW50czogKCkgPT4gc2VsZWN0UGF5bWVudFJlcXVpcmVtZW50cyxcbiAgc2lnblBheW1lbnRIZWFkZXI6ICgpID0+IHNpZ25QYXltZW50SGVhZGVyMlxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhjbGllbnRfZXhwb3J0cyk7XG5cbi8vIHNyYy90eXBlcy9zaGFyZWQvZXZtL2NvbmZpZy50c1xudmFyIGNvbmZpZyA9IHtcbiAgXCI4NDUzMlwiOiB7XG4gICAgdXNkY0FkZHJlc3M6IFwiMHgwMzZDYkQ1Mzg0MmM1NDI2NjM0ZTc5Mjk1NDFlQzIzMThmM2RDRjdlXCIsXG4gICAgdXNkY05hbWU6IFwiVVNEQ1wiXG4gIH0sXG4gIFwiODQ1M1wiOiB7XG4gICAgdXNkY0FkZHJlc3M6IFwiMHg4MzM1ODlmQ0Q2ZURiNkUwOGY0YzdDMzJENGY3MWI1NGJkQTAyOTEzXCIsXG4gICAgdXNkY05hbWU6IFwiVVNEQ1wiXG4gIH0sXG4gIFwiNDMxMTNcIjoge1xuICAgIHVzZGNBZGRyZXNzOiBcIjB4NTQyNTg5MDI5OGFlZDYwMTU5NWE3MEFCODE1Yzk2NzExYTMxQmM2NVwiLFxuICAgIHVzZGNOYW1lOiBcIlVTRCBDb2luXCJcbiAgfSxcbiAgXCI0MzExNFwiOiB7XG4gICAgdXNkY0FkZHJlc3M6IFwiMHhCOTdFRjlFZjg3MzRDNzE5MDREODAwMkY4YjZCYzY2RGQ5YzQ4YTZFXCIsXG4gICAgdXNkY05hbWU6IFwiVVNEQ1wiXG4gIH0sXG4gIFwiNDY4OVwiOiB7XG4gICAgdXNkY0FkZHJlc3M6IFwiMHhjZGY3OTE5NGM2YzI4NTA3N2E1OGRhNDc2NDFkNGRiZTUxZjYzNTQyXCIsXG4gICAgdXNkY05hbWU6IFwiQnJpZGdlZCBVU0RDXCJcbiAgfVxufTtcblxuLy8gc3JjL3R5cGVzL3NoYXJlZC9ldm0vZWlwMzAwOS50c1xudmFyIGF1dGhvcml6YXRpb25UeXBlcyA9IHtcbiAgVHJhbnNmZXJXaXRoQXV0aG9yaXphdGlvbjogW1xuICAgIHsgbmFtZTogXCJmcm9tXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgeyBuYW1lOiBcInRvXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgeyBuYW1lOiBcInZhbHVlXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXG4gICAgeyBuYW1lOiBcInZhbGlkQWZ0ZXJcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICB7IG5hbWU6IFwidmFsaWRCZWZvcmVcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICB7IG5hbWU6IFwibm9uY2VcIiwgdHlwZTogXCJieXRlczMyXCIgfVxuICBdXG59O1xuXG4vLyBzcmMvdHlwZXMvc2hhcmVkL2V2bS93YWxsZXQudHNcbnZhciBpbXBvcnRfdmllbSA9IHJlcXVpcmUoXCJ2aWVtXCIpO1xudmFyIGltcG9ydF9jaGFpbnMgPSByZXF1aXJlKFwidmllbS9jaGFpbnNcIik7XG52YXIgaW1wb3J0X2FjY291bnRzID0gcmVxdWlyZShcInZpZW0vYWNjb3VudHNcIik7XG5mdW5jdGlvbiBpc1NpZ25lcldhbGxldCh3YWxsZXQpIHtcbiAgcmV0dXJuIFwiY2hhaW5cIiBpbiB3YWxsZXQgJiYgXCJ0cmFuc3BvcnRcIiBpbiB3YWxsZXQ7XG59XG5mdW5jdGlvbiBpc0FjY291bnQod2FsbGV0KSB7XG4gIHJldHVybiBcImFkZHJlc3NcIiBpbiB3YWxsZXQgJiYgXCJ0eXBlXCIgaW4gd2FsbGV0O1xufVxuXG4vLyBzcmMvc2NoZW1lcy9leGFjdC9ldm0vc2lnbi50c1xudmFyIGltcG9ydF92aWVtMiA9IHJlcXVpcmUoXCJ2aWVtXCIpO1xuXG4vLyBzcmMvc2hhcmVkL2Jhc2U2NC50c1xuZnVuY3Rpb24gc2FmZUJhc2U2NEVuY29kZShkYXRhKSB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgZ2xvYmFsVGhpcy5idG9hID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gZ2xvYmFsVGhpcy5idG9hKGRhdGEpO1xuICB9XG4gIHJldHVybiBCdWZmZXIuZnJvbShkYXRhKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbn1cblxuLy8gc3JjL3R5cGVzL3NoYXJlZC9tb25leS50c1xudmFyIGltcG9ydF96b2QgPSByZXF1aXJlKFwiem9kXCIpO1xudmFyIG1vbmV5U2NoZW1hID0gaW1wb3J0X3pvZC56LnVuaW9uKFtpbXBvcnRfem9kLnouc3RyaW5nKCkudHJhbnNmb3JtKCh4KSA9PiB4LnJlcGxhY2UoL1teMC05Li1dKy9nLCBcIlwiKSksIGltcG9ydF96b2Quei5udW1iZXIoKV0pLnBpcGUoaW1wb3J0X3pvZC56LmNvZXJjZS5udW1iZXIoKS5taW4oMWUtNCkubWF4KDk5OTk5OTk5OSkpO1xuXG4vLyBzcmMvdHlwZXMvc2hhcmVkL25ldHdvcmsudHNcbnZhciBpbXBvcnRfem9kMiA9IHJlcXVpcmUoXCJ6b2RcIik7XG52YXIgTmV0d29ya1NjaGVtYSA9IGltcG9ydF96b2QyLnouZW51bShbXG4gIFwiYmFzZS1zZXBvbGlhXCIsXG4gIFwiYmFzZVwiLFxuICBcImF2YWxhbmNoZS1mdWppXCIsXG4gIFwiYXZhbGFuY2hlXCIsXG4gIFwiaW90ZXhcIlxuXSk7XG52YXIgU3VwcG9ydGVkRVZNTmV0d29ya3MgPSBbXG4gIFwiYmFzZS1zZXBvbGlhXCIsXG4gIFwiYmFzZVwiLFxuICBcImF2YWxhbmNoZS1mdWppXCIsXG4gIFwiYXZhbGFuY2hlXCIsXG4gIFwiaW90ZXhcIlxuXTtcbnZhciBFdm1OZXR3b3JrVG9DaGFpbklkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICBbXCJiYXNlLXNlcG9saWFcIiwgODQ1MzJdLFxuICBbXCJiYXNlXCIsIDg0NTNdLFxuICBbXCJhdmFsYW5jaGUtZnVqaVwiLCA0MzExM10sXG4gIFtcImF2YWxhbmNoZVwiLCA0MzExNF0sXG4gIFtcImlvdGV4XCIsIDQ2ODldXG5dKTtcbnZhciBDaGFpbklkVG9OZXR3b3JrID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICBTdXBwb3J0ZWRFVk1OZXR3b3Jrcy5tYXAoKG5ldHdvcmspID0+IFtFdm1OZXR3b3JrVG9DaGFpbklkLmdldChuZXR3b3JrKSwgbmV0d29ya10pXG4pO1xuXG4vLyBzcmMvc2hhcmVkL25ldHdvcmsudHNcbmZ1bmN0aW9uIGdldE5ldHdvcmtJZChuZXR3b3JrKSB7XG4gIGlmIChFdm1OZXR3b3JrVG9DaGFpbklkLmhhcyhuZXR3b3JrKSkge1xuICAgIHJldHVybiBFdm1OZXR3b3JrVG9DaGFpbklkLmdldChuZXR3b3JrKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG5ldHdvcms6ICR7bmV0d29ya31gKTtcbn1cblxuLy8gc3JjL3R5cGVzL3ZlcmlmeS94NDAyU3BlY3MudHNcbnZhciBpbXBvcnRfem9kMyA9IHJlcXVpcmUoXCJ6b2RcIik7XG52YXIgRXZtTWF4QXRvbWljVW5pdHMgPSAxODtcbnZhciBFdm1BZGRyZXNzUmVnZXggPSAvXjB4WzAtOWEtZkEtRl17NDB9JC87XG52YXIgTWl4ZWRBZGRyZXNzUmVnZXggPSAvXjB4W2EtZkEtRjAtOV17NDB9fFtBLVphLXowLTldW0EtWmEtejAtOS1dezAsMzR9W0EtWmEtejAtOV0kLztcbnZhciBIZXhFbmNvZGVkNjRCeXRlUmVnZXggPSAvXjB4WzAtOWEtZkEtRl17NjR9JC87XG52YXIgRXZtU2lnbmF0dXJlUmVnZXggPSAvXjB4WzAtOWEtZkEtRl17MTMwfSQvO1xudmFyIHNjaGVtZXMgPSBbXCJleGFjdFwiXTtcbnZhciB4NDAyVmVyc2lvbnMgPSBbMV07XG52YXIgRXJyb3JSZWFzb25zID0gW1xuICBcImluc3VmZmljaWVudF9mdW5kc1wiLFxuICBcImludmFsaWRfZXhhY3RfZXZtX3BheWxvYWRfYXV0aG9yaXphdGlvbl92YWxpZF9hZnRlclwiLFxuICBcImludmFsaWRfZXhhY3RfZXZtX3BheWxvYWRfYXV0aG9yaXphdGlvbl92YWxpZF9iZWZvcmVcIixcbiAgXCJpbnZhbGlkX2V4YWN0X2V2bV9wYXlsb2FkX2F1dGhvcml6YXRpb25fdmFsdWVcIixcbiAgXCJpbnZhbGlkX2V4YWN0X2V2bV9wYXlsb2FkX3NpZ25hdHVyZVwiLFxuICBcImludmFsaWRfZXhhY3RfZXZtX3BheWxvYWRfcmVjaXBpZW50X21pc21hdGNoXCIsXG4gIFwiaW52YWxpZF9uZXR3b3JrXCIsXG4gIFwiaW52YWxpZF9wYXlsb2FkXCIsXG4gIFwiaW52YWxpZF9wYXltZW50X3JlcXVpcmVtZW50c1wiLFxuICBcImludmFsaWRfc2NoZW1lXCIsXG4gIFwidW5zdXBwb3J0ZWRfc2NoZW1lXCIsXG4gIFwiaW52YWxpZF94NDAyX3ZlcnNpb25cIixcbiAgXCJpbnZhbGlkX3RyYW5zYWN0aW9uX3N0YXRlXCIsXG4gIFwidW5leHBlY3RlZF92ZXJpZnlfZXJyb3JcIixcbiAgXCJ1bmV4cGVjdGVkX3NldHRsZV9lcnJvclwiXG5dO1xudmFyIGlzSW50ZWdlciA9ICh2YWx1ZSkgPT4gTnVtYmVyLmlzSW50ZWdlcihOdW1iZXIodmFsdWUpKSAmJiBOdW1iZXIodmFsdWUpID49IDA7XG52YXIgaGFzTWF4TGVuZ3RoID0gKG1heExlbmd0aCkgPT4gKHZhbHVlKSA9PiB2YWx1ZS5sZW5ndGggPD0gbWF4TGVuZ3RoO1xudmFyIFBheW1lbnRSZXF1aXJlbWVudHNTY2hlbWEgPSBpbXBvcnRfem9kMy56Lm9iamVjdCh7XG4gIHNjaGVtZTogaW1wb3J0X3pvZDMuei5lbnVtKHNjaGVtZXMpLFxuICBuZXR3b3JrOiBOZXR3b3JrU2NoZW1hLFxuICBtYXhBbW91bnRSZXF1aXJlZDogaW1wb3J0X3pvZDMuei5zdHJpbmcoKS5yZWZpbmUoaXNJbnRlZ2VyKSxcbiAgcmVzb3VyY2U6IGltcG9ydF96b2QzLnouc3RyaW5nKCkudXJsKCksXG4gIGRlc2NyaXB0aW9uOiBpbXBvcnRfem9kMy56LnN0cmluZygpLFxuICBtaW1lVHlwZTogaW1wb3J0X3pvZDMuei5zdHJpbmcoKSxcbiAgb3V0cHV0U2NoZW1hOiBpbXBvcnRfem9kMy56LnJlY29yZChpbXBvcnRfem9kMy56LmFueSgpKS5vcHRpb25hbCgpLFxuICBwYXlUbzogaW1wb3J0X3pvZDMuei5zdHJpbmcoKS5yZWdleChNaXhlZEFkZHJlc3NSZWdleCksXG4gIG1heFRpbWVvdXRTZWNvbmRzOiBpbXBvcnRfem9kMy56Lm51bWJlcigpLmludCgpLFxuICBhc3NldDogaW1wb3J0X3pvZDMuei5zdHJpbmcoKS5yZWdleChNaXhlZEFkZHJlc3NSZWdleCksXG4gIGV4dHJhOiBpbXBvcnRfem9kMy56LnJlY29yZChpbXBvcnRfem9kMy56LmFueSgpKS5vcHRpb25hbCgpXG59KTtcbnZhciBFeGFjdEV2bVBheWxvYWRBdXRob3JpemF0aW9uU2NoZW1hID0gaW1wb3J0X3pvZDMuei5vYmplY3Qoe1xuICBmcm9tOiBpbXBvcnRfem9kMy56LnN0cmluZygpLnJlZ2V4KEV2bUFkZHJlc3NSZWdleCksXG4gIHRvOiBpbXBvcnRfem9kMy56LnN0cmluZygpLnJlZ2V4KEV2bUFkZHJlc3NSZWdleCksXG4gIHZhbHVlOiBpbXBvcnRfem9kMy56LnN0cmluZygpLnJlZmluZShpc0ludGVnZXIpLnJlZmluZShoYXNNYXhMZW5ndGgoRXZtTWF4QXRvbWljVW5pdHMpKSxcbiAgdmFsaWRBZnRlcjogaW1wb3J0X3pvZDMuei5zdHJpbmcoKS5yZWZpbmUoaXNJbnRlZ2VyKSxcbiAgdmFsaWRCZWZvcmU6IGltcG9ydF96b2QzLnouc3RyaW5nKCkucmVmaW5lKGlzSW50ZWdlciksXG4gIG5vbmNlOiBpbXBvcnRfem9kMy56LnN0cmluZygpLnJlZ2V4KEhleEVuY29kZWQ2NEJ5dGVSZWdleClcbn0pO1xudmFyIEV4YWN0RXZtUGF5bG9hZFNjaGVtYSA9IGltcG9ydF96b2QzLnoub2JqZWN0KHtcbiAgc2lnbmF0dXJlOiBpbXBvcnRfem9kMy56LnN0cmluZygpLnJlZ2V4KEV2bVNpZ25hdHVyZVJlZ2V4KSxcbiAgYXV0aG9yaXphdGlvbjogRXhhY3RFdm1QYXlsb2FkQXV0aG9yaXphdGlvblNjaGVtYVxufSk7XG52YXIgUGF5bWVudFBheWxvYWRTY2hlbWEgPSBpbXBvcnRfem9kMy56Lm9iamVjdCh7XG4gIHg0MDJWZXJzaW9uOiBpbXBvcnRfem9kMy56Lm51bWJlcigpLnJlZmluZSgodmFsKSA9PiB4NDAyVmVyc2lvbnMuaW5jbHVkZXModmFsKSksXG4gIHNjaGVtZTogaW1wb3J0X3pvZDMuei5lbnVtKHNjaGVtZXMpLFxuICBuZXR3b3JrOiBOZXR3b3JrU2NoZW1hLFxuICBwYXlsb2FkOiBFeGFjdEV2bVBheWxvYWRTY2hlbWFcbn0pO1xudmFyIFZlcmlmeVJlc3BvbnNlU2NoZW1hID0gaW1wb3J0X3pvZDMuei5vYmplY3Qoe1xuICBpc1ZhbGlkOiBpbXBvcnRfem9kMy56LmJvb2xlYW4oKSxcbiAgaW52YWxpZFJlYXNvbjogaW1wb3J0X3pvZDMuei5lbnVtKEVycm9yUmVhc29ucykub3B0aW9uYWwoKSxcbiAgcGF5ZXI6IGltcG9ydF96b2QzLnouc3RyaW5nKCkucmVnZXgoTWl4ZWRBZGRyZXNzUmVnZXgpLm9wdGlvbmFsKClcbn0pO1xudmFyIFNldHRsZVJlc3BvbnNlU2NoZW1hID0gaW1wb3J0X3pvZDMuei5vYmplY3Qoe1xuICBzdWNjZXNzOiBpbXBvcnRfem9kMy56LmJvb2xlYW4oKSxcbiAgZXJyb3JSZWFzb246IGltcG9ydF96b2QzLnouZW51bShFcnJvclJlYXNvbnMpLm9wdGlvbmFsKCksXG4gIHBheWVyOiBpbXBvcnRfem9kMy56LnN0cmluZygpLnJlZ2V4KE1peGVkQWRkcmVzc1JlZ2V4KS5vcHRpb25hbCgpLFxuICB0cmFuc2FjdGlvbjogaW1wb3J0X3pvZDMuei5zdHJpbmcoKS5yZWdleChNaXhlZEFkZHJlc3NSZWdleCksXG4gIG5ldHdvcms6IE5ldHdvcmtTY2hlbWFcbn0pO1xudmFyIFN1cHBvcnRlZFBheW1lbnRLaW5kU2NoZW1hID0gaW1wb3J0X3pvZDMuei5vYmplY3Qoe1xuICB4NDAyVmVyc2lvbjogaW1wb3J0X3pvZDMuei5udW1iZXIoKS5yZWZpbmUoKHZhbCkgPT4geDQwMlZlcnNpb25zLmluY2x1ZGVzKHZhbCkpLFxuICBzY2hlbWU6IGltcG9ydF96b2QzLnouZW51bShzY2hlbWVzKSxcbiAgbmV0d29yazogTmV0d29ya1NjaGVtYVxufSk7XG52YXIgU3VwcG9ydGVkUGF5bWVudEtpbmRzUmVzcG9uc2VTY2hlbWEgPSBpbXBvcnRfem9kMy56Lm9iamVjdCh7XG4gIGtpbmRzOiBpbXBvcnRfem9kMy56LmFycmF5KFN1cHBvcnRlZFBheW1lbnRLaW5kU2NoZW1hKVxufSk7XG5cbi8vIHNyYy90eXBlcy92ZXJpZnkvZmFjaWxpdGF0b3IudHNcbnZhciBpbXBvcnRfem9kNCA9IHJlcXVpcmUoXCJ6b2RcIik7XG52YXIgZmFjaWxpdGF0b3JSZXF1ZXN0U2NoZW1hID0gaW1wb3J0X3pvZDQuei5vYmplY3Qoe1xuICBwYXltZW50SGVhZGVyOiBpbXBvcnRfem9kNC56LnN0cmluZygpLFxuICBwYXltZW50UmVxdWlyZW1lbnRzOiBQYXltZW50UmVxdWlyZW1lbnRzU2NoZW1hXG59KTtcblxuLy8gc3JjL3NoYXJlZC9ldm0vdXNkYy50c1xuZnVuY3Rpb24gZ2V0VXNkY0FkZHJlc3NGb3JDaGFpbihjaGFpbklkKSB7XG4gIHJldHVybiBjb25maWdbY2hhaW5JZC50b1N0cmluZygpXS51c2RjQWRkcmVzcztcbn1cblxuLy8gc3JjL3NjaGVtZXMvZXhhY3QvZXZtL3NpZ24udHNcbmFzeW5jIGZ1bmN0aW9uIHNpZ25BdXRob3JpemF0aW9uKHdhbGxldENsaWVudCwgeyBmcm9tLCB0bywgdmFsdWUsIHZhbGlkQWZ0ZXIsIHZhbGlkQmVmb3JlLCBub25jZSB9LCB7IGFzc2V0LCBuZXR3b3JrLCBleHRyYSB9KSB7XG4gIGNvbnN0IGNoYWluSWQgPSBnZXROZXR3b3JrSWQobmV0d29yayk7XG4gIGNvbnN0IG5hbWUgPSBleHRyYT8ubmFtZTtcbiAgY29uc3QgdmVyc2lvbiA9IGV4dHJhPy52ZXJzaW9uO1xuICBjb25zdCBhY2NvdW50ID0gaXNTaWduZXJXYWxsZXQod2FsbGV0Q2xpZW50KSA/IHdhbGxldENsaWVudC5hY2NvdW50IDogd2FsbGV0Q2xpZW50O1xuICBjb25zdCBkYXRhID0ge1xuICAgIGFjY291bnQsXG4gICAgdHlwZXM6IGF1dGhvcml6YXRpb25UeXBlcyxcbiAgICBkb21haW46IHtcbiAgICAgIG5hbWUsXG4gICAgICB2ZXJzaW9uLFxuICAgICAgY2hhaW5JZCxcbiAgICAgIHZlcmlmeWluZ0NvbnRyYWN0OiBhc3NldFxuICAgIH0sXG4gICAgcHJpbWFyeVR5cGU6IFwiVHJhbnNmZXJXaXRoQXV0aG9yaXphdGlvblwiLFxuICAgIG1lc3NhZ2U6IHtcbiAgICAgIGZyb20sXG4gICAgICB0byxcbiAgICAgIHZhbHVlLFxuICAgICAgdmFsaWRBZnRlcixcbiAgICAgIHZhbGlkQmVmb3JlLFxuICAgICAgbm9uY2VcbiAgICB9XG4gIH07XG4gIGlmIChpc1NpZ25lcldhbGxldCh3YWxsZXRDbGllbnQpKSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgd2FsbGV0Q2xpZW50LnNpZ25UeXBlZERhdGEoZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNpZ25hdHVyZVxuICAgIH07XG4gIH0gZWxzZSBpZiAoaXNBY2NvdW50KHdhbGxldENsaWVudCkgJiYgd2FsbGV0Q2xpZW50LnNpZ25UeXBlZERhdGEpIHtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB3YWxsZXRDbGllbnQuc2lnblR5cGVkRGF0YShkYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgc2lnbmF0dXJlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHdhbGxldCBjbGllbnQgcHJvdmlkZWQgZG9lcyBub3Qgc3VwcG9ydCBzaWduVHlwZWREYXRhXCIpO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVOb25jZSgpIHtcbiAgY29uc3QgY3J5cHRvT2JqID0gdHlwZW9mIGdsb2JhbFRoaXMuY3J5cHRvICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBnbG9iYWxUaGlzLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IGdsb2JhbFRoaXMuY3J5cHRvIDogKFxuICAgIC8vIER5bmFtaWMgcmVxdWlyZSBpcyBuZWVkZWQgdG8gc3VwcG9ydCBub2RlLmpzXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgICByZXF1aXJlKFwiY3J5cHRvXCIpLndlYmNyeXB0b1xuICApO1xuICByZXR1cm4gKDAsIGltcG9ydF92aWVtMi50b0hleCkoY3J5cHRvT2JqLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSgzMikpKTtcbn1cblxuLy8gc3JjL3NjaGVtZXMvZXhhY3QvZXZtL3V0aWxzL3BheW1lbnRVdGlscy50c1xuZnVuY3Rpb24gZW5jb2RlUGF5bWVudChwYXltZW50KSB7XG4gIGNvbnN0IHNhZmUgPSB7XG4gICAgLi4ucGF5bWVudCxcbiAgICBwYXlsb2FkOiB7XG4gICAgICAuLi5wYXltZW50LnBheWxvYWQsXG4gICAgICBhdXRob3JpemF0aW9uOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHBheW1lbnQucGF5bG9hZC5hdXRob3JpemF0aW9uKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gW1xuICAgICAgICAgIGtleSxcbiAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIgPyB2YWx1ZS50b1N0cmluZygpIDogdmFsdWVcbiAgICAgICAgXSlcbiAgICAgIClcbiAgICB9XG4gIH07XG4gIHJldHVybiBzYWZlQmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KHNhZmUpKTtcbn1cblxuLy8gc3JjL3NjaGVtZXMvZXhhY3QvZXZtL2NsaWVudC50c1xuZnVuY3Rpb24gcHJlcGFyZVBheW1lbnRIZWFkZXIoZnJvbSwgeDQwMlZlcnNpb24sIHBheW1lbnRSZXF1aXJlbWVudHMpIHtcbiAgY29uc3Qgbm9uY2UgPSBjcmVhdGVOb25jZSgpO1xuICBjb25zdCB2YWxpZEFmdGVyID0gQmlnSW50KFxuICAgIE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMykgLSA2MDBcbiAgICAvLyAxMCBtaW51dGVzIGJlZm9yZVxuICApLnRvU3RyaW5nKCk7XG4gIGNvbnN0IHZhbGlkQmVmb3JlID0gQmlnSW50KFxuICAgIE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMyArIHBheW1lbnRSZXF1aXJlbWVudHMubWF4VGltZW91dFNlY29uZHMpXG4gICkudG9TdHJpbmcoKTtcbiAgcmV0dXJuIHtcbiAgICB4NDAyVmVyc2lvbixcbiAgICBzY2hlbWU6IHBheW1lbnRSZXF1aXJlbWVudHMuc2NoZW1lLFxuICAgIG5ldHdvcms6IHBheW1lbnRSZXF1aXJlbWVudHMubmV0d29yayxcbiAgICBwYXlsb2FkOiB7XG4gICAgICBzaWduYXR1cmU6IHZvaWQgMCxcbiAgICAgIGF1dGhvcml6YXRpb246IHtcbiAgICAgICAgZnJvbSxcbiAgICAgICAgdG86IHBheW1lbnRSZXF1aXJlbWVudHMucGF5VG8sXG4gICAgICAgIHZhbHVlOiBwYXltZW50UmVxdWlyZW1lbnRzLm1heEFtb3VudFJlcXVpcmVkLFxuICAgICAgICB2YWxpZEFmdGVyOiB2YWxpZEFmdGVyLnRvU3RyaW5nKCksXG4gICAgICAgIHZhbGlkQmVmb3JlOiB2YWxpZEJlZm9yZS50b1N0cmluZygpLFxuICAgICAgICBub25jZVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNpZ25QYXltZW50SGVhZGVyKGNsaWVudCwgcGF5bWVudFJlcXVpcmVtZW50cywgdW5zaWduZWRQYXltZW50SGVhZGVyKSB7XG4gIGNvbnN0IHsgc2lnbmF0dXJlIH0gPSBhd2FpdCBzaWduQXV0aG9yaXphdGlvbihcbiAgICBjbGllbnQsXG4gICAgdW5zaWduZWRQYXltZW50SGVhZGVyLnBheWxvYWQuYXV0aG9yaXphdGlvbixcbiAgICBwYXltZW50UmVxdWlyZW1lbnRzXG4gICk7XG4gIHJldHVybiB7XG4gICAgLi4udW5zaWduZWRQYXltZW50SGVhZGVyLFxuICAgIHBheWxvYWQ6IHtcbiAgICAgIC4uLnVuc2lnbmVkUGF5bWVudEhlYWRlci5wYXlsb2FkLFxuICAgICAgc2lnbmF0dXJlXG4gICAgfVxuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlUGF5bWVudChjbGllbnQsIHg0MDJWZXJzaW9uLCBwYXltZW50UmVxdWlyZW1lbnRzKSB7XG4gIGNvbnN0IGZyb20gPSBpc1NpZ25lcldhbGxldChjbGllbnQpID8gY2xpZW50LmFjY291bnQuYWRkcmVzcyA6IGNsaWVudC5hZGRyZXNzO1xuICBjb25zdCB1bnNpZ25lZFBheW1lbnRIZWFkZXIgPSBwcmVwYXJlUGF5bWVudEhlYWRlcihmcm9tLCB4NDAyVmVyc2lvbiwgcGF5bWVudFJlcXVpcmVtZW50cyk7XG4gIHJldHVybiBzaWduUGF5bWVudEhlYWRlcihjbGllbnQsIHBheW1lbnRSZXF1aXJlbWVudHMsIHVuc2lnbmVkUGF5bWVudEhlYWRlcik7XG59XG5hc3luYyBmdW5jdGlvbiBjcmVhdGVQYXltZW50SGVhZGVyKGNsaWVudCwgeDQwMlZlcnNpb24sIHBheW1lbnRSZXF1aXJlbWVudHMpIHtcbiAgY29uc3QgcGF5bWVudCA9IGF3YWl0IGNyZWF0ZVBheW1lbnQoY2xpZW50LCB4NDAyVmVyc2lvbiwgcGF5bWVudFJlcXVpcmVtZW50cyk7XG4gIHJldHVybiBlbmNvZGVQYXltZW50KHBheW1lbnQpO1xufVxuXG4vLyBzcmMvY2xpZW50L2NyZWF0ZVBheW1lbnRIZWFkZXIudHNcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVBheW1lbnRIZWFkZXIyKGNsaWVudCwgeDQwMlZlcnNpb24sIHBheW1lbnRSZXF1aXJlbWVudHMpIHtcbiAgaWYgKHBheW1lbnRSZXF1aXJlbWVudHMuc2NoZW1lID09PSBcImV4YWN0XCIgJiYgU3VwcG9ydGVkRVZNTmV0d29ya3MuaW5jbHVkZXMocGF5bWVudFJlcXVpcmVtZW50cy5uZXR3b3JrKSkge1xuICAgIHJldHVybiBhd2FpdCBjcmVhdGVQYXltZW50SGVhZGVyKGNsaWVudCwgeDQwMlZlcnNpb24sIHBheW1lbnRSZXF1aXJlbWVudHMpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHNjaGVtZVwiKTtcbn1cblxuLy8gc3JjL2NsaWVudC9wcmVwYXJlUGF5bWVudEhlYWRlci50c1xuZnVuY3Rpb24gcHJlcGFyZVBheW1lbnRIZWFkZXIyKGZyb20sIHg0MDJWZXJzaW9uLCBwYXltZW50UmVxdWlyZW1lbnRzKSB7XG4gIGlmIChwYXltZW50UmVxdWlyZW1lbnRzLnNjaGVtZSA9PT0gXCJleGFjdFwiICYmIFN1cHBvcnRlZEVWTU5ldHdvcmtzLmluY2x1ZGVzKHBheW1lbnRSZXF1aXJlbWVudHMubmV0d29yaykpIHtcbiAgICByZXR1cm4gcHJlcGFyZVBheW1lbnRIZWFkZXIoZnJvbSwgeDQwMlZlcnNpb24sIHBheW1lbnRSZXF1aXJlbWVudHMpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHNjaGVtZVwiKTtcbn1cblxuLy8gc3JjL2NsaWVudC9zZWxlY3RQYXltZW50UmVxdWlyZW1lbnRzLnRzXG5mdW5jdGlvbiBzZWxlY3RQYXltZW50UmVxdWlyZW1lbnRzKHBheW1lbnRSZXF1aXJlbWVudHMsIG5ldHdvcmssIHNjaGVtZSkge1xuICBwYXltZW50UmVxdWlyZW1lbnRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICBpZiAoYS5uZXR3b3JrID09PSBcImJhc2VcIiAmJiBiLm5ldHdvcmsgIT09IFwiYmFzZVwiKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChhLm5ldHdvcmsgIT09IFwiYmFzZVwiICYmIGIubmV0d29yayA9PT0gXCJiYXNlXCIpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSk7XG4gIGNvbnN0IGJyb2FkbHlBY2NlcHRlZFBheW1lbnRSZXF1aXJlbWVudHMgPSBwYXltZW50UmVxdWlyZW1lbnRzLmZpbHRlcigocmVxdWlyZW1lbnQpID0+IHtcbiAgICBjb25zdCBpc0V4cGVjdGVkU2NoZW1lID0gIXNjaGVtZSB8fCByZXF1aXJlbWVudC5zY2hlbWUgPT09IHNjaGVtZTtcbiAgICBjb25zdCBpc0V4cGVjdGVkQ2hhaW4gPSAhbmV0d29yayB8fCBuZXR3b3JrID09IHJlcXVpcmVtZW50Lm5ldHdvcms7XG4gICAgcmV0dXJuIGlzRXhwZWN0ZWRTY2hlbWUgJiYgaXNFeHBlY3RlZENoYWluO1xuICB9KTtcbiAgY29uc3QgdXNkY1JlcXVpcmVtZW50cyA9IGJyb2FkbHlBY2NlcHRlZFBheW1lbnRSZXF1aXJlbWVudHMuZmlsdGVyKChyZXF1aXJlbWVudCkgPT4ge1xuICAgIHJldHVybiByZXF1aXJlbWVudC5hc3NldCA9PT0gZ2V0VXNkY0FkZHJlc3NGb3JDaGFpbihnZXROZXR3b3JrSWQocmVxdWlyZW1lbnQubmV0d29yaykpO1xuICB9KTtcbiAgaWYgKHVzZGNSZXF1aXJlbWVudHMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiB1c2RjUmVxdWlyZW1lbnRzWzBdO1xuICB9XG4gIGlmIChicm9hZGx5QWNjZXB0ZWRQYXltZW50UmVxdWlyZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gYnJvYWRseUFjY2VwdGVkUGF5bWVudFJlcXVpcmVtZW50c1swXTtcbiAgfVxuICByZXR1cm4gcGF5bWVudFJlcXVpcmVtZW50c1swXTtcbn1cblxuLy8gc3JjL2NsaWVudC9zaWduUGF5bWVudEhlYWRlci50c1xuYXN5bmMgZnVuY3Rpb24gc2lnblBheW1lbnRIZWFkZXIyKGNsaWVudCwgcGF5bWVudFJlcXVpcmVtZW50cywgdW5zaWduZWRQYXltZW50SGVhZGVyKSB7XG4gIGlmIChwYXltZW50UmVxdWlyZW1lbnRzLnNjaGVtZSA9PT0gXCJleGFjdFwiICYmIFN1cHBvcnRlZEVWTU5ldHdvcmtzLmluY2x1ZGVzKHBheW1lbnRSZXF1aXJlbWVudHMubmV0d29yaykpIHtcbiAgICBjb25zdCBzaWduZWRQYXltZW50SGVhZGVyID0gYXdhaXQgc2lnblBheW1lbnRIZWFkZXIoY2xpZW50LCBwYXltZW50UmVxdWlyZW1lbnRzLCB1bnNpZ25lZFBheW1lbnRIZWFkZXIpO1xuICAgIHJldHVybiBlbmNvZGVQYXltZW50KHNpZ25lZFBheW1lbnRIZWFkZXIpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHNjaGVtZVwiKTtcbn1cbi8vIEFubm90YXRlIHRoZSBDb21tb25KUyBleHBvcnQgbmFtZXMgZm9yIEVTTSBpbXBvcnQgaW4gbm9kZTpcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGVQYXltZW50SGVhZGVyLFxuICBwcmVwYXJlUGF5bWVudEhlYWRlcixcbiAgc2VsZWN0UGF5bWVudFJlcXVpcmVtZW50cyxcbiAgc2lnblBheW1lbnRIZWFkZXJcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/x402-axios/node_modules/x402/dist/cjs/client/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/x402-axios/node_modules/x402/dist/cjs/shared/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/x402-axios/node_modules/x402/dist/cjs/shared/index.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/shared/index.ts\nvar shared_exports = {};\n__export(shared_exports, {\n  computeRoutePatterns: () => computeRoutePatterns,\n  decodeXPaymentResponse: () => decodeXPaymentResponse,\n  findMatchingPaymentRequirements: () => findMatchingPaymentRequirements,\n  findMatchingRoute: () => findMatchingRoute,\n  getDefaultAsset: () => getDefaultAsset,\n  getNetworkId: () => getNetworkId,\n  getPaywallHtml: () => getPaywallHtml,\n  processPriceToAtomicAmount: () => processPriceToAtomicAmount,\n  safeBase64Decode: () => safeBase64Decode,\n  safeBase64Encode: () => safeBase64Encode,\n  toJsonSafe: () => toJsonSafe\n});\nmodule.exports = __toCommonJS(shared_exports);\n\n// src/shared/json.ts\nfunction toJsonSafe(data) {\n  if (typeof data !== \"object\") {\n    throw new Error(\"Data is not an object\");\n  }\n  function convert(value) {\n    if (value !== null && typeof value === \"object\" && !Array.isArray(value)) {\n      return Object.fromEntries(Object.entries(value).map(([key, val]) => [key, convert(val)]));\n    }\n    if (Array.isArray(value)) {\n      return value.map(convert);\n    }\n    if (typeof value === \"bigint\") {\n      return value.toString();\n    }\n    return value;\n  }\n  return convert(data);\n}\n\n// src/paywall/gen/template.ts\nvar PAYWALL_TEMPLATE = '<!DOCTYPE html><html lang=\"en\"><head>\\n        <meta charset=\"UTF-8\">\\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\\n    <title>Payment Required</title><style>/* src/paywall/styles.css */\\n*,\\n*::before,\\n*::after {\\n  box-sizing: border-box;\\n  margin: 0;\\n  padding: 0;\\n}\\nbody {\\n  line-height: 1.5;\\n  -webkit-font-smoothing: antialiased;\\n}\\nimg,\\npicture,\\nvideo,\\ncanvas,\\nsvg {\\n  display: block;\\n  max-width: 100%;\\n}\\ninput,\\nbutton,\\ntextarea,\\nselect {\\n  font: inherit;\\n}\\np,\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6 {\\n  overflow-wrap: break-word;\\n}\\n:root {\\n  --background-color: #f9fafb;\\n  --container-background-color: white;\\n  --text-color: #111827;\\n  --subtitle-text-color: #4b5563;\\n  --instructions-text-color: #4b5563;\\n  --details-background-color: #f9fafb;\\n  --details-text-color: #111827;\\n  --button-primary-color: #2563eb;\\n  --button-primary-hover-color: #1d4ed8;\\n  --button-secondary-color: #059669;\\n  --button-secondary-hover-color: #047857;\\n}\\nbody {\\n  min-height: 100vh;\\n  background-color: var(--background-color);\\n  font-family:\\n    system-ui,\\n    -apple-system,\\n    sans-serif;\\n}\\n.container {\\n  max-width: 32rem;\\n  margin: 4rem auto;\\n  padding: 1.5rem;\\n  background-color: var(--container-background-color);\\n  border-radius: 0.75rem;\\n  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);\\n}\\n.header {\\n  display: flex;\\n  flex-direction: column;\\n  gap: 1rem;\\n  margin-bottom: 2rem;\\n  align-items: center;\\n  text-align: center;\\n}\\n.title {\\n  font-size: 1.5rem;\\n  font-weight: 700;\\n  color: var(--text-color);\\n  margin-bottom: 0.5rem;\\n}\\n.subtitle {\\n  color: var(--subtitle-text-color);\\n}\\n.instructions {\\n  font-size: 0.9rem;\\n  color: var(--instructions-text-color);\\n  font-style: italic;\\n}\\n.content {\\n  display: flex;\\n  flex-direction: column;\\n  gap: 1rem;\\n}\\n.button {\\n  width: 100%;\\n  padding: 0.5rem 1rem;\\n  border-radius: 0.5rem;\\n  font-weight: 600;\\n  border: none;\\n  cursor: pointer;\\n  transition: background-color 150ms;\\n}\\n.button:focus {\\n  outline: none;\\n}\\n.button-primary {\\n  background-color: var(--button-primary-color);\\n  color: white;\\n}\\n.button-primary:hover {\\n  background-color: var(--button-primary-hover-color);\\n}\\n.button-primary.connected,\\n.button-primary.connected:hover {\\n  opacity: 0.3;\\n  cursor: default;\\n}\\n.button-secondary {\\n  background-color: var(--button-secondary-color);\\n  color: white;\\n}\\n.button-secondary:hover {\\n  background-color: var(--button-secondary-hover-color);\\n}\\n.payment-details {\\n  padding: 1rem;\\n  margin-bottom: 1rem;\\n  background-color: var(--details-background-color);\\n  border-radius: 0.5rem;\\n}\\n.payment-row {\\n  display: flex;\\n  justify-content: space-between;\\n  font-size: 0.875rem;\\n  margin-bottom: 0.5rem;\\n}\\n.payment-row:last-child {\\n  margin-bottom: 0;\\n}\\n.payment-label {\\n  color: var(--details-text-color);\\n}\\n.payment-value {\\n  font-weight: 500;\\n}\\n.hidden {\\n  display: none;\\n}\\n.status {\\n  text-align: center;\\n  font-size: 0.875rem;\\n}\\n</style></head>\\n    <body>\\n        <div class=\"container\">\\n          <div class=\"header\">\\n            <h1 class=\"title\">Payment Required</h1>\\n            <p class=\"subtitle\" id=\"payment-description\">Loading payment details...</p>\\n            <p class=\"instructions\" id=\"instructions\" style=\"display: none;\">Need Base Sepolia USDC? <a href=\"https://faucet.circle.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Get some here.</a></p>\\n          </div>\\n\\n          <div class=\"content\">\\n            <div id=\"connect-section\">\\n              <button id=\"connect-wallet\" class=\"button button-primary\">\\n                  Connect wallet\\n              </button>\\n            </div>\\n\\n            <div id=\"payment-section\" class=\"hidden\">\\n              <div class=\"payment-details\">\\n                <div class=\"payment-row\">\\n                  <span class=\"payment-label\">Wallet:</span>\\n                  <span class=\"payment-value\" id=\"payment-account\">Loading...</span>\\n                </div>\\n                <div class=\"payment-row\">\\n                  <span class=\"payment-label\">Amount:</span>\\n                  <span class=\"payment-value\" id=\"payment-amount\">Loading...</span>\\n                </div>\\n                <div class=\"payment-row\">\\n                  <span class=\"payment-label\">Network:</span>\\n                  <span class=\"payment-value\" id=\"payment-network\">Loading...</span>\\n                </div>\\n              </div>\\n\\n              <button id=\"pay-button\" class=\"button button-secondary\">\\n                  Pay Now\\n              </button>\\n            </div>\\n            <div id=\"status\" class=\"status\"></div>\\n          </div>\\n        </div>\\n    \\n    \\n  <script type=\"module\">\"use strict\";\\n(() => {\\n  var __defProp = Object.defineProperty;\\n  var __getOwnPropNames = Object.getOwnPropertyNames;\\n  var __require = /* @__PURE__ */ ((x) => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\\n    get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\\n  }) : x)(function(x) {\\n    if (typeof require !== \"undefined\") return require.apply(this, arguments);\\n    throw Error(\\'Dynamic require of \"\\' + x + \\'\" is not supported\\');\\n  });\\n  var __esm = (fn, res) => function __init() {\\n    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\\n  };\\n  var __export = (target, all) => {\\n    for (var name in all)\\n      __defProp(target, name, { get: all[name], enumerable: true });\\n  };\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/version.js\\n  var version;\\n  var init_version = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/version.js\"() {\\n      version = \"1.0.8\";\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/errors.js\\n  var BaseError;\\n  var init_errors = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/errors.js\"() {\\n      init_version();\\n      BaseError = class _BaseError extends Error {\\n        constructor(shortMessage, args = {}) {\\n          const details = args.cause instanceof _BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;\\n          const docsPath8 = args.cause instanceof _BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;\\n          const message = [\\n            shortMessage || \"An error occurred.\",\\n            \"\",\\n            ...args.metaMessages ? [...args.metaMessages, \"\"] : [],\\n            ...docsPath8 ? [`Docs: https://abitype.dev${docsPath8}`] : [],\\n            ...details ? [`Details: ${details}`] : [],\\n            `Version: abitype@${version}`\\n          ].join(\"\\\\n\");\\n          super(message);\\n          Object.defineProperty(this, \"details\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          Object.defineProperty(this, \"docsPath\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          Object.defineProperty(this, \"metaMessages\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          Object.defineProperty(this, \"shortMessage\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          Object.defineProperty(this, \"name\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: \"AbiTypeError\"\\n          });\\n          if (args.cause)\\n            this.cause = args.cause;\\n          this.details = details;\\n          this.docsPath = docsPath8;\\n          this.metaMessages = args.metaMessages;\\n          this.shortMessage = shortMessage;\\n        }\\n      };\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/regex.js\\n  function execTyped(regex, string) {\\n    const match = regex.exec(string);\\n    return match?.groups;\\n  }\\n  var bytesRegex, integerRegex, isTupleRegex;\\n  var init_regex = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/regex.js\"() {\\n      bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\\n      integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\\n      isTupleRegex = /^\\\\(.+?\\\\).*?$/;\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js\\n  function formatAbiParameter(abiParameter) {\\n    let type = abiParameter.type;\\n    if (tupleRegex.test(abiParameter.type) && \"components\" in abiParameter) {\\n      type = \"(\";\\n      const length = abiParameter.components.length;\\n      for (let i = 0; i < length; i++) {\\n        const component = abiParameter.components[i];\\n        type += formatAbiParameter(component);\\n        if (i < length - 1)\\n          type += \", \";\\n      }\\n      const result = execTyped(tupleRegex, abiParameter.type);\\n      type += `)${result?.array ?? \"\"}`;\\n      return formatAbiParameter({\\n        ...abiParameter,\\n        type\\n      });\\n    }\\n    if (\"indexed\" in abiParameter && abiParameter.indexed)\\n      type = `${type} indexed`;\\n    if (abiParameter.name)\\n      return `${type} ${abiParameter.name}`;\\n    return type;\\n  }\\n  var tupleRegex;\\n  var init_formatAbiParameter = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js\"() {\\n      init_regex();\\n      tupleRegex = /^tuple(?<array>(\\\\[(\\\\d*)\\\\])*)$/;\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js\\n  function formatAbiParameters(abiParameters) {\\n    let params = \"\";\\n    const length = abiParameters.length;\\n    for (let i = 0; i < length; i++) {\\n      const abiParameter = abiParameters[i];\\n      params += formatAbiParameter(abiParameter);\\n      if (i !== length - 1)\\n        params += \", \";\\n    }\\n    return params;\\n  }\\n  var init_formatAbiParameters = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js\"() {\\n      init_formatAbiParameter();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/human-readable/formatAbiItem.js\\n  function formatAbiItem(abiItem) {\\n    if (abiItem.type === \"function\")\\n      return `function ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== \"nonpayable\" ? ` ${abiItem.stateMutability}` : \"\"}${abiItem.outputs?.length ? ` returns (${formatAbiParameters(abiItem.outputs)})` : \"\"}`;\\n    if (abiItem.type === \"event\")\\n      return `event ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;\\n    if (abiItem.type === \"error\")\\n      return `error ${abiItem.name}(${formatAbiParameters(abiItem.inputs)})`;\\n    if (abiItem.type === \"constructor\")\\n      return `constructor(${formatAbiParameters(abiItem.inputs)})${abiItem.stateMutability === \"payable\" ? \" payable\" : \"\"}`;\\n    if (abiItem.type === \"fallback\")\\n      return `fallback() external${abiItem.stateMutability === \"payable\" ? \" payable\" : \"\"}`;\\n    return \"receive() external payable\";\\n  }\\n  var init_formatAbiItem = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/human-readable/formatAbiItem.js\"() {\\n      init_formatAbiParameters();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/human-readable/runtime/signatures.js\\n  function isErrorSignature(signature) {\\n    return errorSignatureRegex.test(signature);\\n  }\\n  function execErrorSignature(signature) {\\n    return execTyped(errorSignatureRegex, signature);\\n  }\\n  function isEventSignature(signature) {\\n    return eventSignatureRegex.test(signature);\\n  }\\n  function execEventSignature(signature) {\\n    return execTyped(eventSignatureRegex, signature);\\n  }\\n  function isFunctionSignature(signature) {\\n    return functionSignatureRegex.test(signature);\\n  }\\n  function execFunctionSignature(signature) {\\n    return execTyped(functionSignatureRegex, signature);\\n  }\\n  function isStructSignature(signature) {\\n    return structSignatureRegex.test(signature);\\n  }\\n  function execStructSignature(signature) {\\n    return execTyped(structSignatureRegex, signature);\\n  }\\n  function isConstructorSignature(signature) {\\n    return constructorSignatureRegex.test(signature);\\n  }\\n  function execConstructorSignature(signature) {\\n    return execTyped(constructorSignatureRegex, signature);\\n  }\\n  function isFallbackSignature(signature) {\\n    return fallbackSignatureRegex.test(signature);\\n  }\\n  function execFallbackSignature(signature) {\\n    return execTyped(fallbackSignatureRegex, signature);\\n  }\\n  function isReceiveSignature(signature) {\\n    return receiveSignatureRegex.test(signature);\\n  }\\n  var errorSignatureRegex, eventSignatureRegex, functionSignatureRegex, structSignatureRegex, constructorSignatureRegex, fallbackSignatureRegex, receiveSignatureRegex, eventModifiers, functionModifiers;\\n  var init_signatures = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/human-readable/runtime/signatures.js\"() {\\n      init_regex();\\n      errorSignatureRegex = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\\\((?<parameters>.*?)\\\\)$/;\\n      eventSignatureRegex = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\\\((?<parameters>.*?)\\\\)$/;\\n      functionSignatureRegex = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\\\((?<parameters>.*?)\\\\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\\\\s?\\\\((?<returns>.*?)\\\\))?$/;\\n      structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \\\\{(?<properties>.*?)\\\\}$/;\\n      constructorSignatureRegex = /^constructor\\\\((?<parameters>.*?)\\\\)(?:\\\\s(?<stateMutability>payable{1}))?$/;\\n      fallbackSignatureRegex = /^fallback\\\\(\\\\) external(?:\\\\s(?<stateMutability>payable{1}))?$/;\\n      receiveSignatureRegex = /^receive\\\\(\\\\) external payable$/;\\n      eventModifiers = /* @__PURE__ */ new Set([\"indexed\"]);\\n      functionModifiers = /* @__PURE__ */ new Set([\\n        \"calldata\",\\n        \"memory\",\\n        \"storage\"\\n      ]);\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/human-readable/errors/abiItem.js\\n  var InvalidAbiItemError, UnknownTypeError, UnknownSolidityTypeError;\\n  var init_abiItem = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/human-readable/errors/abiItem.js\"() {\\n      init_errors();\\n      InvalidAbiItemError = class extends BaseError {\\n        constructor({ signature }) {\\n          super(\"Failed to parse ABI item.\", {\\n            details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,\\n            docsPath: \"/api/human#parseabiitem-1\"\\n          });\\n          Object.defineProperty(this, \"name\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: \"InvalidAbiItemError\"\\n          });\\n        }\\n      };\\n      UnknownTypeError = class extends BaseError {\\n        constructor({ type }) {\\n          super(\"Unknown type.\", {\\n            metaMessages: [\\n              `Type \"${type}\" is not a valid ABI type. Perhaps you forgot to include a struct signature?`\\n            ]\\n          });\\n          Object.defineProperty(this, \"name\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: \"UnknownTypeError\"\\n          });\\n        }\\n      };\\n      UnknownSolidityTypeError = class extends BaseError {\\n        constructor({ type }) {\\n          super(\"Unknown type.\", {\\n            metaMessages: [`Type \"${type}\" is not a valid ABI type.`]\\n          });\\n          Object.defineProperty(this, \"name\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: \"UnknownSolidityTypeError\"\\n          });\\n        }\\n      };\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js\\n  var InvalidParameterError, SolidityProtectedKeywordError, InvalidModifierError, InvalidFunctionModifierError, InvalidAbiTypeParameterError;\\n  var init_abiParameter = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js\"() {\\n      init_errors();\\n      InvalidParameterError = class extends BaseError {\\n        constructor({ param }) {\\n          super(\"Invalid ABI parameter.\", {\\n            details: param\\n          });\\n          Object.defineProperty(this, \"name\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: \"InvalidParameterError\"\\n          });\\n        }\\n      };\\n      SolidityProtectedKeywordError = class extends BaseError {\\n        constructor({ param, name }) {\\n          super(\"Invalid ABI parameter.\", {\\n            details: param,\\n            metaMessages: [\\n              `\"${name}\" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`\\n            ]\\n          });\\n          Object.defineProperty(this, \"name\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: \"SolidityProtectedKeywordError\"\\n          });\\n        }\\n      };\\n      InvalidModifierError = class extends BaseError {\\n        constructor({ param, type, modifier }) {\\n          super(\"Invalid ABI parameter.\", {\\n            details: param,\\n            metaMessages: [\\n              `Modifier \"${modifier}\" not allowed${type ? ` in \"${type}\" type` : \"\"}.`\\n            ]\\n          });\\n          Object.defineProperty(this, \"name\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: \"InvalidModifierError\"\\n          });\\n        }\\n      };\\n      InvalidFunctionModifierError = class extends BaseError {\\n        constructor({ param, type, modifier }) {\\n          super(\"Invalid ABI parameter.\", {\\n            details: param,\\n            metaMessages: [\\n              `Modifier \"${modifier}\" not allowed${type ? ` in \"${type}\" type` : \"\"}.`,\\n              `Data location can only be specified for array, struct, or mapping types, but \"${modifier}\" was given.`\\n            ]\\n          });\\n          Object.defineProperty(this, \"name\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: \"InvalidFunctionModifierError\"\\n          });\\n        }\\n      };\\n      InvalidAbiTypeParameterError = class extends BaseError {\\n        constructor({ abiParameter }) {\\n          super(\"Invalid ABI parameter.\", {\\n            details: JSON.stringify(abiParameter, null, 2),\\n            metaMessages: [\"ABI parameter type is invalid.\"]\\n          });\\n          Object.defineProperty(this, \"name\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: \"InvalidAbiTypeParameterError\"\\n          });\\n        }\\n      };\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/human-readable/errors/signature.js\\n  var InvalidSignatureError, UnknownSignatureError, InvalidStructSignatureError;\\n  var init_signature = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/human-readable/errors/signature.js\"() {\\n      init_errors();\\n      InvalidSignatureError = class extends BaseError {\\n        constructor({ signature, type }) {\\n          super(`Invalid ${type} signature.`, {\\n            details: signature\\n          });\\n          Object.defineProperty(this, \"name\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: \"InvalidSignatureError\"\\n          });\\n        }\\n      };\\n      UnknownSignatureError = class extends BaseError {\\n        constructor({ signature }) {\\n          super(\"Unknown signature.\", {\\n            details: signature\\n          });\\n          Object.defineProperty(this, \"name\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: \"UnknownSignatureError\"\\n          });\\n        }\\n      };\\n      InvalidStructSignatureError = class extends BaseError {\\n        constructor({ signature }) {\\n          super(\"Invalid struct signature.\", {\\n            details: signature,\\n            metaMessages: [\"No properties exist.\"]\\n          });\\n          Object.defineProperty(this, \"name\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: \"InvalidStructSignatureError\"\\n          });\\n        }\\n      };\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/human-readable/errors/struct.js\\n  var CircularReferenceError;\\n  var init_struct = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/human-readable/errors/struct.js\"() {\\n      init_errors();\\n      CircularReferenceError = class extends BaseError {\\n        constructor({ type }) {\\n          super(\"Circular reference detected.\", {\\n            metaMessages: [`Struct \"${type}\" is a circular reference.`]\\n          });\\n          Object.defineProperty(this, \"name\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: \"CircularReferenceError\"\\n          });\\n        }\\n      };\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/human-readable/errors/splitParameters.js\\n  var InvalidParenthesisError;\\n  var init_splitParameters = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/human-readable/errors/splitParameters.js\"() {\\n      init_errors();\\n      InvalidParenthesisError = class extends BaseError {\\n        constructor({ current, depth }) {\\n          super(\"Unbalanced parentheses.\", {\\n            metaMessages: [\\n              `\"${current.trim()}\" has too many ${depth > 0 ? \"opening\" : \"closing\"} parentheses.`\\n            ],\\n            details: `Depth \"${depth}\"`\\n          });\\n          Object.defineProperty(this, \"name\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: \"InvalidParenthesisError\"\\n          });\\n        }\\n      };\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/human-readable/runtime/cache.js\\n  function getParameterCacheKey(param, type, structs) {\\n    let structKey = \"\";\\n    if (structs)\\n      for (const struct of Object.entries(structs)) {\\n        if (!struct)\\n          continue;\\n        let propertyKey = \"\";\\n        for (const property of struct[1]) {\\n          propertyKey += `[${property.type}${property.name ? `:${property.name}` : \"\"}]`;\\n        }\\n        structKey += `(${struct[0]}{${propertyKey}})`;\\n      }\\n    if (type)\\n      return `${type}:${param}${structKey}`;\\n    return param;\\n  }\\n  var parameterCache;\\n  var init_cache = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/human-readable/runtime/cache.js\"() {\\n      parameterCache = /* @__PURE__ */ new Map([\\n        // Unnamed\\n        [\"address\", { type: \"address\" }],\\n        [\"bool\", { type: \"bool\" }],\\n        [\"bytes\", { type: \"bytes\" }],\\n        [\"bytes32\", { type: \"bytes32\" }],\\n        [\"int\", { type: \"int256\" }],\\n        [\"int256\", { type: \"int256\" }],\\n        [\"string\", { type: \"string\" }],\\n        [\"uint\", { type: \"uint256\" }],\\n        [\"uint8\", { type: \"uint8\" }],\\n        [\"uint16\", { type: \"uint16\" }],\\n        [\"uint24\", { type: \"uint24\" }],\\n        [\"uint32\", { type: \"uint32\" }],\\n        [\"uint64\", { type: \"uint64\" }],\\n        [\"uint96\", { type: \"uint96\" }],\\n        [\"uint112\", { type: \"uint112\" }],\\n        [\"uint160\", { type: \"uint160\" }],\\n        [\"uint192\", { type: \"uint192\" }],\\n        [\"uint256\", { type: \"uint256\" }],\\n        // Named\\n        [\"address owner\", { type: \"address\", name: \"owner\" }],\\n        [\"address to\", { type: \"address\", name: \"to\" }],\\n        [\"bool approved\", { type: \"bool\", name: \"approved\" }],\\n        [\"bytes _data\", { type: \"bytes\", name: \"_data\" }],\\n        [\"bytes data\", { type: \"bytes\", name: \"data\" }],\\n        [\"bytes signature\", { type: \"bytes\", name: \"signature\" }],\\n        [\"bytes32 hash\", { type: \"bytes32\", name: \"hash\" }],\\n        [\"bytes32 r\", { type: \"bytes32\", name: \"r\" }],\\n        [\"bytes32 root\", { type: \"bytes32\", name: \"root\" }],\\n        [\"bytes32 s\", { type: \"bytes32\", name: \"s\" }],\\n        [\"string name\", { type: \"string\", name: \"name\" }],\\n        [\"string symbol\", { type: \"string\", name: \"symbol\" }],\\n        [\"string tokenURI\", { type: \"string\", name: \"tokenURI\" }],\\n        [\"uint tokenId\", { type: \"uint256\", name: \"tokenId\" }],\\n        [\"uint8 v\", { type: \"uint8\", name: \"v\" }],\\n        [\"uint256 balance\", { type: \"uint256\", name: \"balance\" }],\\n        [\"uint256 tokenId\", { type: \"uint256\", name: \"tokenId\" }],\\n        [\"uint256 value\", { type: \"uint256\", name: \"value\" }],\\n        // Indexed\\n        [\\n          \"event:address indexed from\",\\n          { type: \"address\", name: \"from\", indexed: true }\\n        ],\\n        [\"event:address indexed to\", { type: \"address\", name: \"to\", indexed: true }],\\n        [\\n          \"event:uint indexed tokenId\",\\n          { type: \"uint256\", name: \"tokenId\", indexed: true }\\n        ],\\n        [\\n          \"event:uint256 indexed tokenId\",\\n          { type: \"uint256\", name: \"tokenId\", indexed: true }\\n        ]\\n      ]);\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/human-readable/runtime/utils.js\\n  function parseSignature(signature, structs = {}) {\\n    if (isFunctionSignature(signature))\\n      return parseFunctionSignature(signature, structs);\\n    if (isEventSignature(signature))\\n      return parseEventSignature(signature, structs);\\n    if (isErrorSignature(signature))\\n      return parseErrorSignature(signature, structs);\\n    if (isConstructorSignature(signature))\\n      return parseConstructorSignature(signature, structs);\\n    if (isFallbackSignature(signature))\\n      return parseFallbackSignature(signature);\\n    if (isReceiveSignature(signature))\\n      return {\\n        type: \"receive\",\\n        stateMutability: \"payable\"\\n      };\\n    throw new UnknownSignatureError({ signature });\\n  }\\n  function parseFunctionSignature(signature, structs = {}) {\\n    const match = execFunctionSignature(signature);\\n    if (!match)\\n      throw new InvalidSignatureError({ signature, type: \"function\" });\\n    const inputParams = splitParameters(match.parameters);\\n    const inputs = [];\\n    const inputLength = inputParams.length;\\n    for (let i = 0; i < inputLength; i++) {\\n      inputs.push(parseAbiParameter(inputParams[i], {\\n        modifiers: functionModifiers,\\n        structs,\\n        type: \"function\"\\n      }));\\n    }\\n    const outputs = [];\\n    if (match.returns) {\\n      const outputParams = splitParameters(match.returns);\\n      const outputLength = outputParams.length;\\n      for (let i = 0; i < outputLength; i++) {\\n        outputs.push(parseAbiParameter(outputParams[i], {\\n          modifiers: functionModifiers,\\n          structs,\\n          type: \"function\"\\n        }));\\n      }\\n    }\\n    return {\\n      name: match.name,\\n      type: \"function\",\\n      stateMutability: match.stateMutability ?? \"nonpayable\",\\n      inputs,\\n      outputs\\n    };\\n  }\\n  function parseEventSignature(signature, structs = {}) {\\n    const match = execEventSignature(signature);\\n    if (!match)\\n      throw new InvalidSignatureError({ signature, type: \"event\" });\\n    const params = splitParameters(match.parameters);\\n    const abiParameters = [];\\n    const length = params.length;\\n    for (let i = 0; i < length; i++)\\n      abiParameters.push(parseAbiParameter(params[i], {\\n        modifiers: eventModifiers,\\n        structs,\\n        type: \"event\"\\n      }));\\n    return { name: match.name, type: \"event\", inputs: abiParameters };\\n  }\\n  function parseErrorSignature(signature, structs = {}) {\\n    const match = execErrorSignature(signature);\\n    if (!match)\\n      throw new InvalidSignatureError({ signature, type: \"error\" });\\n    const params = splitParameters(match.parameters);\\n    const abiParameters = [];\\n    const length = params.length;\\n    for (let i = 0; i < length; i++)\\n      abiParameters.push(parseAbiParameter(params[i], { structs, type: \"error\" }));\\n    return { name: match.name, type: \"error\", inputs: abiParameters };\\n  }\\n  function parseConstructorSignature(signature, structs = {}) {\\n    const match = execConstructorSignature(signature);\\n    if (!match)\\n      throw new InvalidSignatureError({ signature, type: \"constructor\" });\\n    const params = splitParameters(match.parameters);\\n    const abiParameters = [];\\n    const length = params.length;\\n    for (let i = 0; i < length; i++)\\n      abiParameters.push(parseAbiParameter(params[i], { structs, type: \"constructor\" }));\\n    return {\\n      type: \"constructor\",\\n      stateMutability: match.stateMutability ?? \"nonpayable\",\\n      inputs: abiParameters\\n    };\\n  }\\n  function parseFallbackSignature(signature) {\\n    const match = execFallbackSignature(signature);\\n    if (!match)\\n      throw new InvalidSignatureError({ signature, type: \"fallback\" });\\n    return {\\n      type: \"fallback\",\\n      stateMutability: match.stateMutability ?? \"nonpayable\"\\n    };\\n  }\\n  function parseAbiParameter(param, options) {\\n    const parameterCacheKey = getParameterCacheKey(param, options?.type, options?.structs);\\n    if (parameterCache.has(parameterCacheKey))\\n      return parameterCache.get(parameterCacheKey);\\n    const isTuple = isTupleRegex.test(param);\\n    const match = execTyped(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);\\n    if (!match)\\n      throw new InvalidParameterError({ param });\\n    if (match.name && isSolidityKeyword(match.name))\\n      throw new SolidityProtectedKeywordError({ param, name: match.name });\\n    const name = match.name ? { name: match.name } : {};\\n    const indexed = match.modifier === \"indexed\" ? { indexed: true } : {};\\n    const structs = options?.structs ?? {};\\n    let type;\\n    let components = {};\\n    if (isTuple) {\\n      type = \"tuple\";\\n      const params = splitParameters(match.type);\\n      const components_ = [];\\n      const length = params.length;\\n      for (let i = 0; i < length; i++) {\\n        components_.push(parseAbiParameter(params[i], { structs }));\\n      }\\n      components = { components: components_ };\\n    } else if (match.type in structs) {\\n      type = \"tuple\";\\n      components = { components: structs[match.type] };\\n    } else if (dynamicIntegerRegex.test(match.type)) {\\n      type = `${match.type}256`;\\n    } else {\\n      type = match.type;\\n      if (!(options?.type === \"struct\") && !isSolidityType(type))\\n        throw new UnknownSolidityTypeError({ type });\\n    }\\n    if (match.modifier) {\\n      if (!options?.modifiers?.has?.(match.modifier))\\n        throw new InvalidModifierError({\\n          param,\\n          type: options?.type,\\n          modifier: match.modifier\\n        });\\n      if (functionModifiers.has(match.modifier) && !isValidDataLocation(type, !!match.array))\\n        throw new InvalidFunctionModifierError({\\n          param,\\n          type: options?.type,\\n          modifier: match.modifier\\n        });\\n    }\\n    const abiParameter = {\\n      type: `${type}${match.array ?? \"\"}`,\\n      ...name,\\n      ...indexed,\\n      ...components\\n    };\\n    parameterCache.set(parameterCacheKey, abiParameter);\\n    return abiParameter;\\n  }\\n  function splitParameters(params, result = [], current = \"\", depth = 0) {\\n    const length = params.trim().length;\\n    for (let i = 0; i < length; i++) {\\n      const char = params[i];\\n      const tail = params.slice(i + 1);\\n      switch (char) {\\n        case \",\":\\n          return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, `${current}${char}`, depth);\\n        case \"(\":\\n          return splitParameters(tail, result, `${current}${char}`, depth + 1);\\n        case \")\":\\n          return splitParameters(tail, result, `${current}${char}`, depth - 1);\\n        default:\\n          return splitParameters(tail, result, `${current}${char}`, depth);\\n      }\\n    }\\n    if (current === \"\")\\n      return result;\\n    if (depth !== 0)\\n      throw new InvalidParenthesisError({ current, depth });\\n    result.push(current.trim());\\n    return result;\\n  }\\n  function isSolidityType(type) {\\n    return type === \"address\" || type === \"bool\" || type === \"function\" || type === \"string\" || bytesRegex.test(type) || integerRegex.test(type);\\n  }\\n  function isSolidityKeyword(name) {\\n    return name === \"address\" || name === \"bool\" || name === \"function\" || name === \"string\" || name === \"tuple\" || bytesRegex.test(name) || integerRegex.test(name) || protectedKeywordsRegex.test(name);\\n  }\\n  function isValidDataLocation(type, isArray) {\\n    return isArray || type === \"bytes\" || type === \"string\" || type === \"tuple\";\\n  }\\n  var abiParameterWithoutTupleRegex, abiParameterWithTupleRegex, dynamicIntegerRegex, protectedKeywordsRegex;\\n  var init_utils = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/human-readable/runtime/utils.js\"() {\\n      init_regex();\\n      init_abiItem();\\n      init_abiParameter();\\n      init_signature();\\n      init_splitParameters();\\n      init_cache();\\n      init_signatures();\\n      abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\\\[\\\\d*?\\\\])+?)?(?:\\\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;\\n      abiParameterWithTupleRegex = /^\\\\((?<type>.+?)\\\\)(?<array>(?:\\\\[\\\\d*?\\\\])+?)?(?:\\\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;\\n      dynamicIntegerRegex = /^u?int$/;\\n      protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/human-readable/runtime/structs.js\\n  function parseStructs(signatures) {\\n    const shallowStructs = {};\\n    const signaturesLength = signatures.length;\\n    for (let i = 0; i < signaturesLength; i++) {\\n      const signature = signatures[i];\\n      if (!isStructSignature(signature))\\n        continue;\\n      const match = execStructSignature(signature);\\n      if (!match)\\n        throw new InvalidSignatureError({ signature, type: \"struct\" });\\n      const properties = match.properties.split(\";\");\\n      const components = [];\\n      const propertiesLength = properties.length;\\n      for (let k = 0; k < propertiesLength; k++) {\\n        const property = properties[k];\\n        const trimmed = property.trim();\\n        if (!trimmed)\\n          continue;\\n        const abiParameter = parseAbiParameter(trimmed, {\\n          type: \"struct\"\\n        });\\n        components.push(abiParameter);\\n      }\\n      if (!components.length)\\n        throw new InvalidStructSignatureError({ signature });\\n      shallowStructs[match.name] = components;\\n    }\\n    const resolvedStructs = {};\\n    const entries = Object.entries(shallowStructs);\\n    const entriesLength = entries.length;\\n    for (let i = 0; i < entriesLength; i++) {\\n      const [name, parameters] = entries[i];\\n      resolvedStructs[name] = resolveStructs(parameters, shallowStructs);\\n    }\\n    return resolvedStructs;\\n  }\\n  function resolveStructs(abiParameters, structs, ancestors = /* @__PURE__ */ new Set()) {\\n    const components = [];\\n    const length = abiParameters.length;\\n    for (let i = 0; i < length; i++) {\\n      const abiParameter = abiParameters[i];\\n      const isTuple = isTupleRegex.test(abiParameter.type);\\n      if (isTuple)\\n        components.push(abiParameter);\\n      else {\\n        const match = execTyped(typeWithoutTupleRegex, abiParameter.type);\\n        if (!match?.type)\\n          throw new InvalidAbiTypeParameterError({ abiParameter });\\n        const { array, type } = match;\\n        if (type in structs) {\\n          if (ancestors.has(type))\\n            throw new CircularReferenceError({ type });\\n          components.push({\\n            ...abiParameter,\\n            type: `tuple${array ?? \"\"}`,\\n            components: resolveStructs(structs[type] ?? [], structs, /* @__PURE__ */ new Set([...ancestors, type]))\\n          });\\n        } else {\\n          if (isSolidityType(type))\\n            components.push(abiParameter);\\n          else\\n            throw new UnknownTypeError({ type });\\n        }\\n      }\\n    }\\n    return components;\\n  }\\n  var typeWithoutTupleRegex;\\n  var init_structs = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/human-readable/runtime/structs.js\"() {\\n      init_regex();\\n      init_abiItem();\\n      init_abiParameter();\\n      init_signature();\\n      init_struct();\\n      init_signatures();\\n      init_utils();\\n      typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\\\[\\\\d*?\\\\])+?)?$/;\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/human-readable/parseAbi.js\\n  function parseAbi(signatures) {\\n    const structs = parseStructs(signatures);\\n    const abi2 = [];\\n    const length = signatures.length;\\n    for (let i = 0; i < length; i++) {\\n      const signature = signatures[i];\\n      if (isStructSignature(signature))\\n        continue;\\n      abi2.push(parseSignature(signature, structs));\\n    }\\n    return abi2;\\n  }\\n  var init_parseAbi = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/human-readable/parseAbi.js\"() {\\n      init_signatures();\\n      init_structs();\\n      init_utils();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/human-readable/parseAbiItem.js\\n  function parseAbiItem(signature) {\\n    let abiItem;\\n    if (typeof signature === \"string\")\\n      abiItem = parseSignature(signature);\\n    else {\\n      const structs = parseStructs(signature);\\n      const length = signature.length;\\n      for (let i = 0; i < length; i++) {\\n        const signature_ = signature[i];\\n        if (isStructSignature(signature_))\\n          continue;\\n        abiItem = parseSignature(signature_, structs);\\n        break;\\n      }\\n    }\\n    if (!abiItem)\\n      throw new InvalidAbiItemError({ signature });\\n    return abiItem;\\n  }\\n  var init_parseAbiItem = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/human-readable/parseAbiItem.js\"() {\\n      init_abiItem();\\n      init_signatures();\\n      init_structs();\\n      init_utils();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/exports/index.js\\n  var init_exports = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/abitype@1.0.8_typescript@5.8.3_zod@3.24.3/node_modules/abitype/dist/esm/exports/index.js\"() {\\n      init_formatAbiItem();\\n      init_parseAbi();\\n      init_parseAbiItem();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/abi/formatAbiItem.js\\n  function formatAbiItem2(abiItem, { includeName = false } = {}) {\\n    if (abiItem.type !== \"function\" && abiItem.type !== \"event\" && abiItem.type !== \"error\")\\n      throw new InvalidDefinitionTypeError(abiItem.type);\\n    return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`;\\n  }\\n  function formatAbiParams(params, { includeName = false } = {}) {\\n    if (!params)\\n      return \"\";\\n    return params.map((param) => formatAbiParam(param, { includeName })).join(includeName ? \", \" : \",\");\\n  }\\n  function formatAbiParam(param, { includeName }) {\\n    if (param.type.startsWith(\"tuple\")) {\\n      return `(${formatAbiParams(param.components, { includeName })})${param.type.slice(\"tuple\".length)}`;\\n    }\\n    return param.type + (includeName && param.name ? ` ${param.name}` : \"\");\\n  }\\n  var init_formatAbiItem2 = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/abi/formatAbiItem.js\"() {\\n      init_abi();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/data/isHex.js\\n  function isHex(value, { strict = true } = {}) {\\n    if (!value)\\n      return false;\\n    if (typeof value !== \"string\")\\n      return false;\\n    return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith(\"0x\");\\n  }\\n  var init_isHex = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/data/isHex.js\"() {\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/data/size.js\\n  function size(value) {\\n    if (isHex(value, { strict: false }))\\n      return Math.ceil((value.length - 2) / 2);\\n    return value.length;\\n  }\\n  var init_size = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/data/size.js\"() {\\n      init_isHex();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/version.js\\n  var version2;\\n  var init_version2 = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/version.js\"() {\\n      version2 = \"2.27.2\";\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/base.js\\n  function walk(err, fn) {\\n    if (fn?.(err))\\n      return err;\\n    if (err && typeof err === \"object\" && \"cause\" in err && err.cause !== void 0)\\n      return walk(err.cause, fn);\\n    return fn ? null : err;\\n  }\\n  var errorConfig, BaseError2;\\n  var init_base = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/base.js\"() {\\n      init_version2();\\n      errorConfig = {\\n        getDocsUrl: ({ docsBaseUrl, docsPath: docsPath8 = \"\", docsSlug }) => docsPath8 ? `${docsBaseUrl ?? \"https://viem.sh\"}${docsPath8}${docsSlug ? `#${docsSlug}` : \"\"}` : void 0,\\n        version: `viem@${version2}`\\n      };\\n      BaseError2 = class _BaseError extends Error {\\n        constructor(shortMessage, args = {}) {\\n          const details = (() => {\\n            if (args.cause instanceof _BaseError)\\n              return args.cause.details;\\n            if (args.cause?.message)\\n              return args.cause.message;\\n            return args.details;\\n          })();\\n          const docsPath8 = (() => {\\n            if (args.cause instanceof _BaseError)\\n              return args.cause.docsPath || args.docsPath;\\n            return args.docsPath;\\n          })();\\n          const docsUrl = errorConfig.getDocsUrl?.({ ...args, docsPath: docsPath8 });\\n          const message = [\\n            shortMessage || \"An error occurred.\",\\n            \"\",\\n            ...args.metaMessages ? [...args.metaMessages, \"\"] : [],\\n            ...docsUrl ? [`Docs: ${docsUrl}`] : [],\\n            ...details ? [`Details: ${details}`] : [],\\n            ...errorConfig.version ? [`Version: ${errorConfig.version}`] : []\\n          ].join(\"\\\\n\");\\n          super(message, args.cause ? { cause: args.cause } : void 0);\\n          Object.defineProperty(this, \"details\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          Object.defineProperty(this, \"docsPath\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          Object.defineProperty(this, \"metaMessages\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          Object.defineProperty(this, \"shortMessage\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          Object.defineProperty(this, \"version\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          Object.defineProperty(this, \"name\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: \"BaseError\"\\n          });\\n          this.details = details;\\n          this.docsPath = docsPath8;\\n          this.metaMessages = args.metaMessages;\\n          this.name = args.name ?? this.name;\\n          this.shortMessage = shortMessage;\\n          this.version = version2;\\n        }\\n        walk(fn) {\\n          return walk(this, fn);\\n        }\\n      };\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/abi.js\\n  var AbiConstructorNotFoundError, AbiConstructorParamsNotFoundError, AbiDecodingDataSizeTooSmallError, AbiDecodingZeroDataError, AbiEncodingArrayLengthMismatchError, AbiEncodingBytesSizeMismatchError, AbiEncodingLengthMismatchError, AbiErrorInputsNotFoundError, AbiErrorNotFoundError, AbiErrorSignatureNotFoundError, AbiEventSignatureEmptyTopicsError, AbiEventSignatureNotFoundError, AbiEventNotFoundError, AbiFunctionNotFoundError, AbiFunctionOutputsNotFoundError, AbiFunctionSignatureNotFoundError, AbiItemAmbiguityError, BytesSizeMismatchError, DecodeLogDataMismatch, DecodeLogTopicsMismatch, InvalidAbiEncodingTypeError, InvalidAbiDecodingTypeError, InvalidArrayError, InvalidDefinitionTypeError;\\n  var init_abi = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/abi.js\"() {\\n      init_formatAbiItem2();\\n      init_size();\\n      init_base();\\n      AbiConstructorNotFoundError = class extends BaseError2 {\\n        constructor({ docsPath: docsPath8 }) {\\n          super([\\n            \"A constructor was not found on the ABI.\",\\n            \"Make sure you are using the correct ABI and that the constructor exists on it.\"\\n          ].join(\"\\\\n\"), {\\n            docsPath: docsPath8,\\n            name: \"AbiConstructorNotFoundError\"\\n          });\\n        }\\n      };\\n      AbiConstructorParamsNotFoundError = class extends BaseError2 {\\n        constructor({ docsPath: docsPath8 }) {\\n          super([\\n            \"Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.\",\\n            \"Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.\"\\n          ].join(\"\\\\n\"), {\\n            docsPath: docsPath8,\\n            name: \"AbiConstructorParamsNotFoundError\"\\n          });\\n        }\\n      };\\n      AbiDecodingDataSizeTooSmallError = class extends BaseError2 {\\n        constructor({ data, params, size: size5 }) {\\n          super([`Data size of ${size5} bytes is too small for given parameters.`].join(\"\\\\n\"), {\\n            metaMessages: [\\n              `Params: (${formatAbiParams(params, { includeName: true })})`,\\n              `Data:   ${data} (${size5} bytes)`\\n            ],\\n            name: \"AbiDecodingDataSizeTooSmallError\"\\n          });\\n          Object.defineProperty(this, \"data\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          Object.defineProperty(this, \"params\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          Object.defineProperty(this, \"size\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          this.data = data;\\n          this.params = params;\\n          this.size = size5;\\n        }\\n      };\\n      AbiDecodingZeroDataError = class extends BaseError2 {\\n        constructor() {\\n          super(\\'Cannot decode zero data (\"0x\") with ABI parameters.\\', {\\n            name: \"AbiDecodingZeroDataError\"\\n          });\\n        }\\n      };\\n      AbiEncodingArrayLengthMismatchError = class extends BaseError2 {\\n        constructor({ expectedLength, givenLength, type }) {\\n          super([\\n            `ABI encoding array length mismatch for type ${type}.`,\\n            `Expected length: ${expectedLength}`,\\n            `Given length: ${givenLength}`\\n          ].join(\"\\\\n\"), { name: \"AbiEncodingArrayLengthMismatchError\" });\\n        }\\n      };\\n      AbiEncodingBytesSizeMismatchError = class extends BaseError2 {\\n        constructor({ expectedSize, value }) {\\n          super(`Size of bytes \"${value}\" (bytes${size(value)}) does not match expected size (bytes${expectedSize}).`, { name: \"AbiEncodingBytesSizeMismatchError\" });\\n        }\\n      };\\n      AbiEncodingLengthMismatchError = class extends BaseError2 {\\n        constructor({ expectedLength, givenLength }) {\\n          super([\\n            \"ABI encoding params/values length mismatch.\",\\n            `Expected length (params): ${expectedLength}`,\\n            `Given length (values): ${givenLength}`\\n          ].join(\"\\\\n\"), { name: \"AbiEncodingLengthMismatchError\" });\\n        }\\n      };\\n      AbiErrorInputsNotFoundError = class extends BaseError2 {\\n        constructor(errorName, { docsPath: docsPath8 }) {\\n          super([\\n            `Arguments (\\\\`args\\\\`) were provided to \"${errorName}\", but \"${errorName}\" on the ABI does not contain any parameters (\\\\`inputs\\\\`).`,\\n            \"Cannot encode error result without knowing what the parameter types are.\",\\n            \"Make sure you are using the correct ABI and that the inputs exist on it.\"\\n          ].join(\"\\\\n\"), {\\n            docsPath: docsPath8,\\n            name: \"AbiErrorInputsNotFoundError\"\\n          });\\n        }\\n      };\\n      AbiErrorNotFoundError = class extends BaseError2 {\\n        constructor(errorName, { docsPath: docsPath8 } = {}) {\\n          super([\\n            `Error ${errorName ? `\"${errorName}\" ` : \"\"}not found on ABI.`,\\n            \"Make sure you are using the correct ABI and that the error exists on it.\"\\n          ].join(\"\\\\n\"), {\\n            docsPath: docsPath8,\\n            name: \"AbiErrorNotFoundError\"\\n          });\\n        }\\n      };\\n      AbiErrorSignatureNotFoundError = class extends BaseError2 {\\n        constructor(signature, { docsPath: docsPath8 }) {\\n          super([\\n            `Encoded error signature \"${signature}\" not found on ABI.`,\\n            \"Make sure you are using the correct ABI and that the error exists on it.\",\\n            `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`\\n          ].join(\"\\\\n\"), {\\n            docsPath: docsPath8,\\n            name: \"AbiErrorSignatureNotFoundError\"\\n          });\\n          Object.defineProperty(this, \"signature\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          this.signature = signature;\\n        }\\n      };\\n      AbiEventSignatureEmptyTopicsError = class extends BaseError2 {\\n        constructor({ docsPath: docsPath8 }) {\\n          super(\"Cannot extract event signature from empty topics.\", {\\n            docsPath: docsPath8,\\n            name: \"AbiEventSignatureEmptyTopicsError\"\\n          });\\n        }\\n      };\\n      AbiEventSignatureNotFoundError = class extends BaseError2 {\\n        constructor(signature, { docsPath: docsPath8 }) {\\n          super([\\n            `Encoded event signature \"${signature}\" not found on ABI.`,\\n            \"Make sure you are using the correct ABI and that the event exists on it.\",\\n            `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`\\n          ].join(\"\\\\n\"), {\\n            docsPath: docsPath8,\\n            name: \"AbiEventSignatureNotFoundError\"\\n          });\\n        }\\n      };\\n      AbiEventNotFoundError = class extends BaseError2 {\\n        constructor(eventName, { docsPath: docsPath8 } = {}) {\\n          super([\\n            `Event ${eventName ? `\"${eventName}\" ` : \"\"}not found on ABI.`,\\n            \"Make sure you are using the correct ABI and that the event exists on it.\"\\n          ].join(\"\\\\n\"), {\\n            docsPath: docsPath8,\\n            name: \"AbiEventNotFoundError\"\\n          });\\n        }\\n      };\\n      AbiFunctionNotFoundError = class extends BaseError2 {\\n        constructor(functionName, { docsPath: docsPath8 } = {}) {\\n          super([\\n            `Function ${functionName ? `\"${functionName}\" ` : \"\"}not found on ABI.`,\\n            \"Make sure you are using the correct ABI and that the function exists on it.\"\\n          ].join(\"\\\\n\"), {\\n            docsPath: docsPath8,\\n            name: \"AbiFunctionNotFoundError\"\\n          });\\n        }\\n      };\\n      AbiFunctionOutputsNotFoundError = class extends BaseError2 {\\n        constructor(functionName, { docsPath: docsPath8 }) {\\n          super([\\n            `Function \"${functionName}\" does not contain any \\\\`outputs\\\\` on ABI.`,\\n            \"Cannot decode function result without knowing what the parameter types are.\",\\n            \"Make sure you are using the correct ABI and that the function exists on it.\"\\n          ].join(\"\\\\n\"), {\\n            docsPath: docsPath8,\\n            name: \"AbiFunctionOutputsNotFoundError\"\\n          });\\n        }\\n      };\\n      AbiFunctionSignatureNotFoundError = class extends BaseError2 {\\n        constructor(signature, { docsPath: docsPath8 }) {\\n          super([\\n            `Encoded function signature \"${signature}\" not found on ABI.`,\\n            \"Make sure you are using the correct ABI and that the function exists on it.\",\\n            `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`\\n          ].join(\"\\\\n\"), {\\n            docsPath: docsPath8,\\n            name: \"AbiFunctionSignatureNotFoundError\"\\n          });\\n        }\\n      };\\n      AbiItemAmbiguityError = class extends BaseError2 {\\n        constructor(x, y) {\\n          super(\"Found ambiguous types in overloaded ABI items.\", {\\n            metaMessages: [\\n              `\\\\`${x.type}\\\\` in \\\\`${formatAbiItem2(x.abiItem)}\\\\`, and`,\\n              `\\\\`${y.type}\\\\` in \\\\`${formatAbiItem2(y.abiItem)}\\\\``,\\n              \"\",\\n              \"These types encode differently and cannot be distinguished at runtime.\",\\n              \"Remove one of the ambiguous items in the ABI.\"\\n            ],\\n            name: \"AbiItemAmbiguityError\"\\n          });\\n        }\\n      };\\n      BytesSizeMismatchError = class extends BaseError2 {\\n        constructor({ expectedSize, givenSize }) {\\n          super(`Expected bytes${expectedSize}, got bytes${givenSize}.`, {\\n            name: \"BytesSizeMismatchError\"\\n          });\\n        }\\n      };\\n      DecodeLogDataMismatch = class extends BaseError2 {\\n        constructor({ abiItem, data, params, size: size5 }) {\\n          super([\\n            `Data size of ${size5} bytes is too small for non-indexed event parameters.`\\n          ].join(\"\\\\n\"), {\\n            metaMessages: [\\n              `Params: (${formatAbiParams(params, { includeName: true })})`,\\n              `Data:   ${data} (${size5} bytes)`\\n            ],\\n            name: \"DecodeLogDataMismatch\"\\n          });\\n          Object.defineProperty(this, \"abiItem\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          Object.defineProperty(this, \"data\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          Object.defineProperty(this, \"params\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          Object.defineProperty(this, \"size\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          this.abiItem = abiItem;\\n          this.data = data;\\n          this.params = params;\\n          this.size = size5;\\n        }\\n      };\\n      DecodeLogTopicsMismatch = class extends BaseError2 {\\n        constructor({ abiItem, param }) {\\n          super([\\n            `Expected a topic for indexed event parameter${param.name ? ` \"${param.name}\"` : \"\"} on event \"${formatAbiItem2(abiItem, { includeName: true })}\".`\\n          ].join(\"\\\\n\"), { name: \"DecodeLogTopicsMismatch\" });\\n          Object.defineProperty(this, \"abiItem\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          this.abiItem = abiItem;\\n        }\\n      };\\n      InvalidAbiEncodingTypeError = class extends BaseError2 {\\n        constructor(type, { docsPath: docsPath8 }) {\\n          super([\\n            `Type \"${type}\" is not a valid encoding type.`,\\n            \"Please provide a valid ABI type.\"\\n          ].join(\"\\\\n\"), { docsPath: docsPath8, name: \"InvalidAbiEncodingType\" });\\n        }\\n      };\\n      InvalidAbiDecodingTypeError = class extends BaseError2 {\\n        constructor(type, { docsPath: docsPath8 }) {\\n          super([\\n            `Type \"${type}\" is not a valid decoding type.`,\\n            \"Please provide a valid ABI type.\"\\n          ].join(\"\\\\n\"), { docsPath: docsPath8, name: \"InvalidAbiDecodingType\" });\\n        }\\n      };\\n      InvalidArrayError = class extends BaseError2 {\\n        constructor(value) {\\n          super([`Value \"${value}\" is not a valid array.`].join(\"\\\\n\"), {\\n            name: \"InvalidArrayError\"\\n          });\\n        }\\n      };\\n      InvalidDefinitionTypeError = class extends BaseError2 {\\n        constructor(type) {\\n          super([\\n            `\"${type}\" is not a valid definition type.`,\\n            \\'Valid types: \"function\", \"event\", \"error\"\\'\\n          ].join(\"\\\\n\"), { name: \"InvalidDefinitionTypeError\" });\\n        }\\n      };\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/data.js\\n  var SliceOffsetOutOfBoundsError, SizeExceedsPaddingSizeError, InvalidBytesLengthError;\\n  var init_data = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/data.js\"() {\\n      init_base();\\n      SliceOffsetOutOfBoundsError = class extends BaseError2 {\\n        constructor({ offset, position, size: size5 }) {\\n          super(`Slice ${position === \"start\" ? \"starting\" : \"ending\"} at offset \"${offset}\" is out-of-bounds (size: ${size5}).`, { name: \"SliceOffsetOutOfBoundsError\" });\\n        }\\n      };\\n      SizeExceedsPaddingSizeError = class extends BaseError2 {\\n        constructor({ size: size5, targetSize, type }) {\\n          super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size5}) exceeds padding size (${targetSize}).`, { name: \"SizeExceedsPaddingSizeError\" });\\n        }\\n      };\\n      InvalidBytesLengthError = class extends BaseError2 {\\n        constructor({ size: size5, targetSize, type }) {\\n          super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} is expected to be ${targetSize} ${type} long, but is ${size5} ${type} long.`, { name: \"InvalidBytesLengthError\" });\\n        }\\n      };\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/data/pad.js\\n  function pad(hexOrBytes, { dir, size: size5 = 32 } = {}) {\\n    if (typeof hexOrBytes === \"string\")\\n      return padHex(hexOrBytes, { dir, size: size5 });\\n    return padBytes(hexOrBytes, { dir, size: size5 });\\n  }\\n  function padHex(hex_, { dir, size: size5 = 32 } = {}) {\\n    if (size5 === null)\\n      return hex_;\\n    const hex = hex_.replace(\"0x\", \"\");\\n    if (hex.length > size5 * 2)\\n      throw new SizeExceedsPaddingSizeError({\\n        size: Math.ceil(hex.length / 2),\\n        targetSize: size5,\\n        type: \"hex\"\\n      });\\n    return `0x${hex[dir === \"right\" ? \"padEnd\" : \"padStart\"](size5 * 2, \"0\")}`;\\n  }\\n  function padBytes(bytes, { dir, size: size5 = 32 } = {}) {\\n    if (size5 === null)\\n      return bytes;\\n    if (bytes.length > size5)\\n      throw new SizeExceedsPaddingSizeError({\\n        size: bytes.length,\\n        targetSize: size5,\\n        type: \"bytes\"\\n      });\\n    const paddedBytes = new Uint8Array(size5);\\n    for (let i = 0; i < size5; i++) {\\n      const padEnd = dir === \"right\";\\n      paddedBytes[padEnd ? i : size5 - i - 1] = bytes[padEnd ? i : bytes.length - i - 1];\\n    }\\n    return paddedBytes;\\n  }\\n  var init_pad = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/data/pad.js\"() {\\n      init_data();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/encoding.js\\n  var IntegerOutOfRangeError, InvalidBytesBooleanError, InvalidHexBooleanError, SizeOverflowError;\\n  var init_encoding = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/encoding.js\"() {\\n      init_base();\\n      IntegerOutOfRangeError = class extends BaseError2 {\\n        constructor({ max, min, signed, size: size5, value }) {\\n          super(`Number \"${value}\" is not in safe ${size5 ? `${size5 * 8}-bit ${signed ? \"signed\" : \"unsigned\"} ` : \"\"}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`, { name: \"IntegerOutOfRangeError\" });\\n        }\\n      };\\n      InvalidBytesBooleanError = class extends BaseError2 {\\n        constructor(bytes) {\\n          super(`Bytes value \"${bytes}\" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`, {\\n            name: \"InvalidBytesBooleanError\"\\n          });\\n        }\\n      };\\n      InvalidHexBooleanError = class extends BaseError2 {\\n        constructor(hex) {\\n          super(`Hex value \"${hex}\" is not a valid boolean. The hex value must be \"0x0\" (false) or \"0x1\" (true).`, { name: \"InvalidHexBooleanError\" });\\n        }\\n      };\\n      SizeOverflowError = class extends BaseError2 {\\n        constructor({ givenSize, maxSize }) {\\n          super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`, { name: \"SizeOverflowError\" });\\n        }\\n      };\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/data/trim.js\\n  function trim(hexOrBytes, { dir = \"left\" } = {}) {\\n    let data = typeof hexOrBytes === \"string\" ? hexOrBytes.replace(\"0x\", \"\") : hexOrBytes;\\n    let sliceLength = 0;\\n    for (let i = 0; i < data.length - 1; i++) {\\n      if (data[dir === \"left\" ? i : data.length - i - 1].toString() === \"0\")\\n        sliceLength++;\\n      else\\n        break;\\n    }\\n    data = dir === \"left\" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);\\n    if (typeof hexOrBytes === \"string\") {\\n      if (data.length === 1 && dir === \"right\")\\n        data = `${data}0`;\\n      return `0x${data.length % 2 === 1 ? `0${data}` : data}`;\\n    }\\n    return data;\\n  }\\n  var init_trim = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/data/trim.js\"() {\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/encoding/fromHex.js\\n  function assertSize(hexOrBytes, { size: size5 }) {\\n    if (size(hexOrBytes) > size5)\\n      throw new SizeOverflowError({\\n        givenSize: size(hexOrBytes),\\n        maxSize: size5\\n      });\\n  }\\n  function hexToBigInt(hex, opts = {}) {\\n    const { signed } = opts;\\n    if (opts.size)\\n      assertSize(hex, { size: opts.size });\\n    const value = BigInt(hex);\\n    if (!signed)\\n      return value;\\n    const size5 = (hex.length - 2) / 2;\\n    const max = (1n << BigInt(size5) * 8n - 1n) - 1n;\\n    if (value <= max)\\n      return value;\\n    return value - BigInt(`0x${\"f\".padStart(size5 * 2, \"f\")}`) - 1n;\\n  }\\n  function hexToBool(hex_, opts = {}) {\\n    let hex = hex_;\\n    if (opts.size) {\\n      assertSize(hex, { size: opts.size });\\n      hex = trim(hex);\\n    }\\n    if (trim(hex) === \"0x00\")\\n      return false;\\n    if (trim(hex) === \"0x01\")\\n      return true;\\n    throw new InvalidHexBooleanError(hex);\\n  }\\n  function hexToNumber(hex, opts = {}) {\\n    return Number(hexToBigInt(hex, opts));\\n  }\\n  var init_fromHex = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/encoding/fromHex.js\"() {\\n      init_encoding();\\n      init_size();\\n      init_trim();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/encoding/toHex.js\\n  function toHex(value, opts = {}) {\\n    if (typeof value === \"number\" || typeof value === \"bigint\")\\n      return numberToHex(value, opts);\\n    if (typeof value === \"string\") {\\n      return stringToHex(value, opts);\\n    }\\n    if (typeof value === \"boolean\")\\n      return boolToHex(value, opts);\\n    return bytesToHex(value, opts);\\n  }\\n  function boolToHex(value, opts = {}) {\\n    const hex = `0x${Number(value)}`;\\n    if (typeof opts.size === \"number\") {\\n      assertSize(hex, { size: opts.size });\\n      return pad(hex, { size: opts.size });\\n    }\\n    return hex;\\n  }\\n  function bytesToHex(value, opts = {}) {\\n    let string = \"\";\\n    for (let i = 0; i < value.length; i++) {\\n      string += hexes[value[i]];\\n    }\\n    const hex = `0x${string}`;\\n    if (typeof opts.size === \"number\") {\\n      assertSize(hex, { size: opts.size });\\n      return pad(hex, { dir: \"right\", size: opts.size });\\n    }\\n    return hex;\\n  }\\n  function numberToHex(value_, opts = {}) {\\n    const { signed, size: size5 } = opts;\\n    const value = BigInt(value_);\\n    let maxValue;\\n    if (size5) {\\n      if (signed)\\n        maxValue = (1n << BigInt(size5) * 8n - 1n) - 1n;\\n      else\\n        maxValue = 2n ** (BigInt(size5) * 8n) - 1n;\\n    } else if (typeof value_ === \"number\") {\\n      maxValue = BigInt(Number.MAX_SAFE_INTEGER);\\n    }\\n    const minValue = typeof maxValue === \"bigint\" && signed ? -maxValue - 1n : 0;\\n    if (maxValue && value > maxValue || value < minValue) {\\n      const suffix = typeof value_ === \"bigint\" ? \"n\" : \"\";\\n      throw new IntegerOutOfRangeError({\\n        max: maxValue ? `${maxValue}${suffix}` : void 0,\\n        min: `${minValue}${suffix}`,\\n        signed,\\n        size: size5,\\n        value: `${value_}${suffix}`\\n      });\\n    }\\n    const hex = `0x${(signed && value < 0 ? (1n << BigInt(size5 * 8)) + BigInt(value) : value).toString(16)}`;\\n    if (size5)\\n      return pad(hex, { size: size5 });\\n    return hex;\\n  }\\n  function stringToHex(value_, opts = {}) {\\n    const value = encoder.encode(value_);\\n    return bytesToHex(value, opts);\\n  }\\n  var hexes, encoder;\\n  var init_toHex = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/encoding/toHex.js\"() {\\n      init_encoding();\\n      init_pad();\\n      init_fromHex();\\n      hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, \"0\"));\\n      encoder = /* @__PURE__ */ new TextEncoder();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/encoding/toBytes.js\\n  function toBytes(value, opts = {}) {\\n    if (typeof value === \"number\" || typeof value === \"bigint\")\\n      return numberToBytes(value, opts);\\n    if (typeof value === \"boolean\")\\n      return boolToBytes(value, opts);\\n    if (isHex(value))\\n      return hexToBytes(value, opts);\\n    return stringToBytes(value, opts);\\n  }\\n  function boolToBytes(value, opts = {}) {\\n    const bytes = new Uint8Array(1);\\n    bytes[0] = Number(value);\\n    if (typeof opts.size === \"number\") {\\n      assertSize(bytes, { size: opts.size });\\n      return pad(bytes, { size: opts.size });\\n    }\\n    return bytes;\\n  }\\n  function charCodeToBase16(char) {\\n    if (char >= charCodeMap.zero && char <= charCodeMap.nine)\\n      return char - charCodeMap.zero;\\n    if (char >= charCodeMap.A && char <= charCodeMap.F)\\n      return char - (charCodeMap.A - 10);\\n    if (char >= charCodeMap.a && char <= charCodeMap.f)\\n      return char - (charCodeMap.a - 10);\\n    return void 0;\\n  }\\n  function hexToBytes(hex_, opts = {}) {\\n    let hex = hex_;\\n    if (opts.size) {\\n      assertSize(hex, { size: opts.size });\\n      hex = pad(hex, { dir: \"right\", size: opts.size });\\n    }\\n    let hexString = hex.slice(2);\\n    if (hexString.length % 2)\\n      hexString = `0${hexString}`;\\n    const length = hexString.length / 2;\\n    const bytes = new Uint8Array(length);\\n    for (let index2 = 0, j = 0; index2 < length; index2++) {\\n      const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));\\n      const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));\\n      if (nibbleLeft === void 0 || nibbleRight === void 0) {\\n        throw new BaseError2(`Invalid byte sequence (\"${hexString[j - 2]}${hexString[j - 1]}\" in \"${hexString}\").`);\\n      }\\n      bytes[index2] = nibbleLeft * 16 + nibbleRight;\\n    }\\n    return bytes;\\n  }\\n  function numberToBytes(value, opts) {\\n    const hex = numberToHex(value, opts);\\n    return hexToBytes(hex);\\n  }\\n  function stringToBytes(value, opts = {}) {\\n    const bytes = encoder2.encode(value);\\n    if (typeof opts.size === \"number\") {\\n      assertSize(bytes, { size: opts.size });\\n      return pad(bytes, { dir: \"right\", size: opts.size });\\n    }\\n    return bytes;\\n  }\\n  var encoder2, charCodeMap;\\n  var init_toBytes = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/encoding/toBytes.js\"() {\\n      init_base();\\n      init_isHex();\\n      init_pad();\\n      init_fromHex();\\n      init_toHex();\\n      encoder2 = /* @__PURE__ */ new TextEncoder();\\n      charCodeMap = {\\n        zero: 48,\\n        nine: 57,\\n        A: 65,\\n        F: 70,\\n        a: 97,\\n        f: 102\\n      };\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/@noble+hashes@1.7.1/node_modules/@noble/hashes/esm/_assert.js\\n  function anumber(n) {\\n    if (!Number.isSafeInteger(n) || n < 0)\\n      throw new Error(\"positive integer expected, got \" + n);\\n  }\\n  function isBytes(a) {\\n    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === \"Uint8Array\";\\n  }\\n  function abytes(b, ...lengths) {\\n    if (!isBytes(b))\\n      throw new Error(\"Uint8Array expected\");\\n    if (lengths.length > 0 && !lengths.includes(b.length))\\n      throw new Error(\"Uint8Array expected of length \" + lengths + \", got length=\" + b.length);\\n  }\\n  function ahash(h) {\\n    if (typeof h !== \"function\" || typeof h.create !== \"function\")\\n      throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\\n    anumber(h.outputLen);\\n    anumber(h.blockLen);\\n  }\\n  function aexists(instance, checkFinished = true) {\\n    if (instance.destroyed)\\n      throw new Error(\"Hash instance has been destroyed\");\\n    if (checkFinished && instance.finished)\\n      throw new Error(\"Hash#digest() has already been called\");\\n  }\\n  function aoutput(out, instance) {\\n    abytes(out);\\n    const min = instance.outputLen;\\n    if (out.length < min) {\\n      throw new Error(\"digestInto() expects output buffer of length at least \" + min);\\n    }\\n  }\\n  var init_assert = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/@noble+hashes@1.7.1/node_modules/@noble/hashes/esm/_assert.js\"() {\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/@noble+hashes@1.7.1/node_modules/@noble/hashes/esm/_u64.js\\n  function fromBig(n, le = false) {\\n    if (le)\\n      return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };\\n    return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\\n  }\\n  function split(lst, le = false) {\\n    let Ah = new Uint32Array(lst.length);\\n    let Al = new Uint32Array(lst.length);\\n    for (let i = 0; i < lst.length; i++) {\\n      const { h, l } = fromBig(lst[i], le);\\n      [Ah[i], Al[i]] = [h, l];\\n    }\\n    return [Ah, Al];\\n  }\\n  var U32_MASK64, _32n, rotlSH, rotlSL, rotlBH, rotlBL;\\n  var init_u64 = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/@noble+hashes@1.7.1/node_modules/@noble/hashes/esm/_u64.js\"() {\\n      U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\\n      _32n = /* @__PURE__ */ BigInt(32);\\n      rotlSH = (h, l, s) => h << s | l >>> 32 - s;\\n      rotlSL = (h, l, s) => l << s | h >>> 32 - s;\\n      rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;\\n      rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/@noble+hashes@1.7.1/node_modules/@noble/hashes/esm/crypto.js\\n  var crypto2;\\n  var init_crypto = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/@noble+hashes@1.7.1/node_modules/@noble/hashes/esm/crypto.js\"() {\\n      crypto2 = typeof globalThis === \"object\" && \"crypto\" in globalThis ? globalThis.crypto : void 0;\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/@noble+hashes@1.7.1/node_modules/@noble/hashes/esm/utils.js\\n  function u32(arr) {\\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\\n  }\\n  function createView(arr) {\\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\\n  }\\n  function rotr(word, shift) {\\n    return word << 32 - shift | word >>> shift;\\n  }\\n  function byteSwap(word) {\\n    return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;\\n  }\\n  function byteSwap32(arr) {\\n    for (let i = 0; i < arr.length; i++) {\\n      arr[i] = byteSwap(arr[i]);\\n    }\\n  }\\n  function utf8ToBytes(str) {\\n    if (typeof str !== \"string\")\\n      throw new Error(\"utf8ToBytes expected string, got \" + typeof str);\\n    return new Uint8Array(new TextEncoder().encode(str));\\n  }\\n  function toBytes2(data) {\\n    if (typeof data === \"string\")\\n      data = utf8ToBytes(data);\\n    abytes(data);\\n    return data;\\n  }\\n  function concatBytes(...arrays) {\\n    let sum = 0;\\n    for (let i = 0; i < arrays.length; i++) {\\n      const a = arrays[i];\\n      abytes(a);\\n      sum += a.length;\\n    }\\n    const res = new Uint8Array(sum);\\n    for (let i = 0, pad4 = 0; i < arrays.length; i++) {\\n      const a = arrays[i];\\n      res.set(a, pad4);\\n      pad4 += a.length;\\n    }\\n    return res;\\n  }\\n  function wrapConstructor(hashCons) {\\n    const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();\\n    const tmp = hashCons();\\n    hashC.outputLen = tmp.outputLen;\\n    hashC.blockLen = tmp.blockLen;\\n    hashC.create = () => hashCons();\\n    return hashC;\\n  }\\n  function wrapXOFConstructorWithOpts(hashCons) {\\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();\\n    const tmp = hashCons({});\\n    hashC.outputLen = tmp.outputLen;\\n    hashC.blockLen = tmp.blockLen;\\n    hashC.create = (opts) => hashCons(opts);\\n    return hashC;\\n  }\\n  function randomBytes(bytesLength = 32) {\\n    if (crypto2 && typeof crypto2.getRandomValues === \"function\") {\\n      return crypto2.getRandomValues(new Uint8Array(bytesLength));\\n    }\\n    if (crypto2 && typeof crypto2.randomBytes === \"function\") {\\n      return crypto2.randomBytes(bytesLength);\\n    }\\n    throw new Error(\"crypto.getRandomValues must be defined\");\\n  }\\n  var isLE, Hash;\\n  var init_utils2 = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/@noble+hashes@1.7.1/node_modules/@noble/hashes/esm/utils.js\"() {\\n      init_crypto();\\n      init_assert();\\n      isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();\\n      Hash = class {\\n        // Safe version that clones internal state\\n        clone() {\\n          return this._cloneInto();\\n        }\\n      };\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/@noble+hashes@1.7.1/node_modules/@noble/hashes/esm/sha3.js\\n  function keccakP(s, rounds = 24) {\\n    const B = new Uint32Array(5 * 2);\\n    for (let round = 24 - rounds; round < 24; round++) {\\n      for (let x = 0; x < 10; x++)\\n        B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\\n      for (let x = 0; x < 10; x += 2) {\\n        const idx1 = (x + 8) % 10;\\n        const idx0 = (x + 2) % 10;\\n        const B0 = B[idx0];\\n        const B1 = B[idx0 + 1];\\n        const Th = rotlH(B0, B1, 1) ^ B[idx1];\\n        const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\\n        for (let y = 0; y < 50; y += 10) {\\n          s[x + y] ^= Th;\\n          s[x + y + 1] ^= Tl;\\n        }\\n      }\\n      let curH = s[2];\\n      let curL = s[3];\\n      for (let t = 0; t < 24; t++) {\\n        const shift = SHA3_ROTL[t];\\n        const Th = rotlH(curH, curL, shift);\\n        const Tl = rotlL(curH, curL, shift);\\n        const PI = SHA3_PI[t];\\n        curH = s[PI];\\n        curL = s[PI + 1];\\n        s[PI] = Th;\\n        s[PI + 1] = Tl;\\n      }\\n      for (let y = 0; y < 50; y += 10) {\\n        for (let x = 0; x < 10; x++)\\n          B[x] = s[y + x];\\n        for (let x = 0; x < 10; x++)\\n          s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\\n      }\\n      s[0] ^= SHA3_IOTA_H[round];\\n      s[1] ^= SHA3_IOTA_L[round];\\n    }\\n    B.fill(0);\\n  }\\n  var SHA3_PI, SHA3_ROTL, _SHA3_IOTA, _0n, _1n, _2n, _7n, _256n, _0x71n, SHA3_IOTA_H, SHA3_IOTA_L, rotlH, rotlL, Keccak, gen, sha3_224, sha3_256, sha3_384, sha3_512, keccak_224, keccak_256, keccak_384, keccak_512, genShake, shake128, shake256;\\n  var init_sha3 = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/@noble+hashes@1.7.1/node_modules/@noble/hashes/esm/sha3.js\"() {\\n      init_assert();\\n      init_u64();\\n      init_utils2();\\n      SHA3_PI = [];\\n      SHA3_ROTL = [];\\n      _SHA3_IOTA = [];\\n      _0n = /* @__PURE__ */ BigInt(0);\\n      _1n = /* @__PURE__ */ BigInt(1);\\n      _2n = /* @__PURE__ */ BigInt(2);\\n      _7n = /* @__PURE__ */ BigInt(7);\\n      _256n = /* @__PURE__ */ BigInt(256);\\n      _0x71n = /* @__PURE__ */ BigInt(113);\\n      for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\\n        [x, y] = [y, (2 * x + 3 * y) % 5];\\n        SHA3_PI.push(2 * (5 * y + x));\\n        SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);\\n        let t = _0n;\\n        for (let j = 0; j < 7; j++) {\\n          R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;\\n          if (R & _2n)\\n            t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;\\n        }\\n        _SHA3_IOTA.push(t);\\n      }\\n      [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);\\n      rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);\\n      rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);\\n      Keccak = class _Keccak extends Hash {\\n        // NOTE: we accept arguments in bytes instead of bits here.\\n        constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\\n          super();\\n          this.blockLen = blockLen;\\n          this.suffix = suffix;\\n          this.outputLen = outputLen;\\n          this.enableXOF = enableXOF;\\n          this.rounds = rounds;\\n          this.pos = 0;\\n          this.posOut = 0;\\n          this.finished = false;\\n          this.destroyed = false;\\n          anumber(outputLen);\\n          if (0 >= this.blockLen || this.blockLen >= 200)\\n            throw new Error(\"Sha3 supports only keccak-f1600 function\");\\n          this.state = new Uint8Array(200);\\n          this.state32 = u32(this.state);\\n        }\\n        keccak() {\\n          if (!isLE)\\n            byteSwap32(this.state32);\\n          keccakP(this.state32, this.rounds);\\n          if (!isLE)\\n            byteSwap32(this.state32);\\n          this.posOut = 0;\\n          this.pos = 0;\\n        }\\n        update(data) {\\n          aexists(this);\\n          const { blockLen, state } = this;\\n          data = toBytes2(data);\\n          const len = data.length;\\n          for (let pos = 0; pos < len; ) {\\n            const take = Math.min(blockLen - this.pos, len - pos);\\n            for (let i = 0; i < take; i++)\\n              state[this.pos++] ^= data[pos++];\\n            if (this.pos === blockLen)\\n              this.keccak();\\n          }\\n          return this;\\n        }\\n        finish() {\\n          if (this.finished)\\n            return;\\n          this.finished = true;\\n          const { state, suffix, pos, blockLen } = this;\\n          state[pos] ^= suffix;\\n          if ((suffix & 128) !== 0 && pos === blockLen - 1)\\n            this.keccak();\\n          state[blockLen - 1] ^= 128;\\n          this.keccak();\\n        }\\n        writeInto(out) {\\n          aexists(this, false);\\n          abytes(out);\\n          this.finish();\\n          const bufferOut = this.state;\\n          const { blockLen } = this;\\n          for (let pos = 0, len = out.length; pos < len; ) {\\n            if (this.posOut >= blockLen)\\n              this.keccak();\\n            const take = Math.min(blockLen - this.posOut, len - pos);\\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\\n            this.posOut += take;\\n            pos += take;\\n          }\\n          return out;\\n        }\\n        xofInto(out) {\\n          if (!this.enableXOF)\\n            throw new Error(\"XOF is not possible for this instance\");\\n          return this.writeInto(out);\\n        }\\n        xof(bytes) {\\n          anumber(bytes);\\n          return this.xofInto(new Uint8Array(bytes));\\n        }\\n        digestInto(out) {\\n          aoutput(out, this);\\n          if (this.finished)\\n            throw new Error(\"digest() was already called\");\\n          this.writeInto(out);\\n          this.destroy();\\n          return out;\\n        }\\n        digest() {\\n          return this.digestInto(new Uint8Array(this.outputLen));\\n        }\\n        destroy() {\\n          this.destroyed = true;\\n          this.state.fill(0);\\n        }\\n        _cloneInto(to) {\\n          const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\\n          to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\\n          to.state32.set(this.state32);\\n          to.pos = this.pos;\\n          to.posOut = this.posOut;\\n          to.finished = this.finished;\\n          to.rounds = rounds;\\n          to.suffix = suffix;\\n          to.outputLen = outputLen;\\n          to.enableXOF = enableXOF;\\n          to.destroyed = this.destroyed;\\n          return to;\\n        }\\n      };\\n      gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\\n      sha3_224 = /* @__PURE__ */ gen(6, 144, 224 / 8);\\n      sha3_256 = /* @__PURE__ */ gen(6, 136, 256 / 8);\\n      sha3_384 = /* @__PURE__ */ gen(6, 104, 384 / 8);\\n      sha3_512 = /* @__PURE__ */ gen(6, 72, 512 / 8);\\n      keccak_224 = /* @__PURE__ */ gen(1, 144, 224 / 8);\\n      keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);\\n      keccak_384 = /* @__PURE__ */ gen(1, 104, 384 / 8);\\n      keccak_512 = /* @__PURE__ */ gen(1, 72, 512 / 8);\\n      genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));\\n      shake128 = /* @__PURE__ */ genShake(31, 168, 128 / 8);\\n      shake256 = /* @__PURE__ */ genShake(31, 136, 256 / 8);\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/hash/keccak256.js\\n  function keccak256(value, to_) {\\n    const to = to_ || \"hex\";\\n    const bytes = keccak_256(isHex(value, { strict: false }) ? toBytes(value) : value);\\n    if (to === \"bytes\")\\n      return bytes;\\n    return toHex(bytes);\\n  }\\n  var init_keccak256 = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/hash/keccak256.js\"() {\\n      init_sha3();\\n      init_isHex();\\n      init_toBytes();\\n      init_toHex();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/hash/hashSignature.js\\n  function hashSignature(sig) {\\n    return hash(sig);\\n  }\\n  var hash;\\n  var init_hashSignature = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/hash/hashSignature.js\"() {\\n      init_toBytes();\\n      init_keccak256();\\n      hash = (value) => keccak256(toBytes(value));\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/hash/normalizeSignature.js\\n  function normalizeSignature(signature) {\\n    let active = true;\\n    let current = \"\";\\n    let level = 0;\\n    let result = \"\";\\n    let valid = false;\\n    for (let i = 0; i < signature.length; i++) {\\n      const char = signature[i];\\n      if ([\"(\", \")\", \",\"].includes(char))\\n        active = true;\\n      if (char === \"(\")\\n        level++;\\n      if (char === \")\")\\n        level--;\\n      if (!active)\\n        continue;\\n      if (level === 0) {\\n        if (char === \" \" && [\"event\", \"function\", \"\"].includes(result))\\n          result = \"\";\\n        else {\\n          result += char;\\n          if (char === \")\") {\\n            valid = true;\\n            break;\\n          }\\n        }\\n        continue;\\n      }\\n      if (char === \" \") {\\n        if (signature[i - 1] !== \",\" && current !== \",\" && current !== \",(\") {\\n          current = \"\";\\n          active = false;\\n        }\\n        continue;\\n      }\\n      result += char;\\n      current += char;\\n    }\\n    if (!valid)\\n      throw new BaseError2(\"Unable to normalize signature.\");\\n    return result;\\n  }\\n  var init_normalizeSignature = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/hash/normalizeSignature.js\"() {\\n      init_base();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/hash/toSignature.js\\n  var toSignature;\\n  var init_toSignature = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/hash/toSignature.js\"() {\\n      init_exports();\\n      init_normalizeSignature();\\n      toSignature = (def) => {\\n        const def_ = (() => {\\n          if (typeof def === \"string\")\\n            return def;\\n          return formatAbiItem(def);\\n        })();\\n        return normalizeSignature(def_);\\n      };\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/hash/toSignatureHash.js\\n  function toSignatureHash(fn) {\\n    return hashSignature(toSignature(fn));\\n  }\\n  var init_toSignatureHash = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/hash/toSignatureHash.js\"() {\\n      init_hashSignature();\\n      init_toSignature();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/hash/toEventSelector.js\\n  var toEventSelector;\\n  var init_toEventSelector = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/hash/toEventSelector.js\"() {\\n      init_toSignatureHash();\\n      toEventSelector = toSignatureHash;\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/address.js\\n  var InvalidAddressError;\\n  var init_address = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/address.js\"() {\\n      init_base();\\n      InvalidAddressError = class extends BaseError2 {\\n        constructor({ address }) {\\n          super(`Address \"${address}\" is invalid.`, {\\n            metaMessages: [\\n              \"- Address must be a hex value of 20 bytes (40 hex characters).\",\\n              \"- Address must match its checksum counterpart.\"\\n            ],\\n            name: \"InvalidAddressError\"\\n          });\\n        }\\n      };\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/lru.js\\n  var LruMap;\\n  var init_lru = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/lru.js\"() {\\n      LruMap = class extends Map {\\n        constructor(size5) {\\n          super();\\n          Object.defineProperty(this, \"maxSize\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          this.maxSize = size5;\\n        }\\n        get(key) {\\n          const value = super.get(key);\\n          if (super.has(key) && value !== void 0) {\\n            this.delete(key);\\n            super.set(key, value);\\n          }\\n          return value;\\n        }\\n        set(key, value) {\\n          super.set(key, value);\\n          if (this.maxSize && this.size > this.maxSize) {\\n            const firstKey = this.keys().next().value;\\n            if (firstKey)\\n              this.delete(firstKey);\\n          }\\n          return this;\\n        }\\n      };\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/address/getAddress.js\\n  function checksumAddress(address_, chainId) {\\n    if (checksumAddressCache.has(`${address_}.${chainId}`))\\n      return checksumAddressCache.get(`${address_}.${chainId}`);\\n    const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();\\n    const hash2 = keccak256(stringToBytes(hexAddress), \"bytes\");\\n    const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split(\"\");\\n    for (let i = 0; i < 40; i += 2) {\\n      if (hash2[i >> 1] >> 4 >= 8 && address[i]) {\\n        address[i] = address[i].toUpperCase();\\n      }\\n      if ((hash2[i >> 1] & 15) >= 8 && address[i + 1]) {\\n        address[i + 1] = address[i + 1].toUpperCase();\\n      }\\n    }\\n    const result = `0x${address.join(\"\")}`;\\n    checksumAddressCache.set(`${address_}.${chainId}`, result);\\n    return result;\\n  }\\n  function getAddress(address, chainId) {\\n    if (!isAddress(address, { strict: false }))\\n      throw new InvalidAddressError({ address });\\n    return checksumAddress(address, chainId);\\n  }\\n  var checksumAddressCache;\\n  var init_getAddress = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/address/getAddress.js\"() {\\n      init_address();\\n      init_toBytes();\\n      init_keccak256();\\n      init_lru();\\n      init_isAddress();\\n      checksumAddressCache = /* @__PURE__ */ new LruMap(8192);\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/address/isAddress.js\\n  function isAddress(address, options) {\\n    const { strict = true } = options ?? {};\\n    const cacheKey2 = `${address}.${strict}`;\\n    if (isAddressCache.has(cacheKey2))\\n      return isAddressCache.get(cacheKey2);\\n    const result = (() => {\\n      if (!addressRegex.test(address))\\n        return false;\\n      if (address.toLowerCase() === address)\\n        return true;\\n      if (strict)\\n        return checksumAddress(address) === address;\\n      return true;\\n    })();\\n    isAddressCache.set(cacheKey2, result);\\n    return result;\\n  }\\n  var addressRegex, isAddressCache;\\n  var init_isAddress = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/address/isAddress.js\"() {\\n      init_lru();\\n      init_getAddress();\\n      addressRegex = /^0x[a-fA-F0-9]{40}$/;\\n      isAddressCache = /* @__PURE__ */ new LruMap(8192);\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/data/concat.js\\n  function concat(values) {\\n    if (typeof values[0] === \"string\")\\n      return concatHex(values);\\n    return concatBytes2(values);\\n  }\\n  function concatBytes2(values) {\\n    let length = 0;\\n    for (const arr of values) {\\n      length += arr.length;\\n    }\\n    const result = new Uint8Array(length);\\n    let offset = 0;\\n    for (const arr of values) {\\n      result.set(arr, offset);\\n      offset += arr.length;\\n    }\\n    return result;\\n  }\\n  function concatHex(values) {\\n    return `0x${values.reduce((acc, x) => acc + x.replace(\"0x\", \"\"), \"\")}`;\\n  }\\n  var init_concat = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/data/concat.js\"() {\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/data/slice.js\\n  function slice(value, start, end, { strict } = {}) {\\n    if (isHex(value, { strict: false }))\\n      return sliceHex(value, start, end, {\\n        strict\\n      });\\n    return sliceBytes(value, start, end, {\\n      strict\\n    });\\n  }\\n  function assertStartOffset(value, start) {\\n    if (typeof start === \"number\" && start > 0 && start > size(value) - 1)\\n      throw new SliceOffsetOutOfBoundsError({\\n        offset: start,\\n        position: \"start\",\\n        size: size(value)\\n      });\\n  }\\n  function assertEndOffset(value, start, end) {\\n    if (typeof start === \"number\" && typeof end === \"number\" && size(value) !== end - start) {\\n      throw new SliceOffsetOutOfBoundsError({\\n        offset: end,\\n        position: \"end\",\\n        size: size(value)\\n      });\\n    }\\n  }\\n  function sliceBytes(value_, start, end, { strict } = {}) {\\n    assertStartOffset(value_, start);\\n    const value = value_.slice(start, end);\\n    if (strict)\\n      assertEndOffset(value, start, end);\\n    return value;\\n  }\\n  function sliceHex(value_, start, end, { strict } = {}) {\\n    assertStartOffset(value_, start);\\n    const value = `0x${value_.replace(\"0x\", \"\").slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;\\n    if (strict)\\n      assertEndOffset(value, start, end);\\n    return value;\\n  }\\n  var init_slice = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/data/slice.js\"() {\\n      init_data();\\n      init_isHex();\\n      init_size();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/regex.js\\n  var bytesRegex2, integerRegex2;\\n  var init_regex2 = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/regex.js\"() {\\n      bytesRegex2 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\\n      integerRegex2 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/abi/encodeAbiParameters.js\\n  function encodeAbiParameters(params, values) {\\n    if (params.length !== values.length)\\n      throw new AbiEncodingLengthMismatchError({\\n        expectedLength: params.length,\\n        givenLength: values.length\\n      });\\n    const preparedParams = prepareParams({\\n      params,\\n      values\\n    });\\n    const data = encodeParams(preparedParams);\\n    if (data.length === 0)\\n      return \"0x\";\\n    return data;\\n  }\\n  function prepareParams({ params, values }) {\\n    const preparedParams = [];\\n    for (let i = 0; i < params.length; i++) {\\n      preparedParams.push(prepareParam({ param: params[i], value: values[i] }));\\n    }\\n    return preparedParams;\\n  }\\n  function prepareParam({ param, value }) {\\n    const arrayComponents = getArrayComponents(param.type);\\n    if (arrayComponents) {\\n      const [length, type] = arrayComponents;\\n      return encodeArray(value, { length, param: { ...param, type } });\\n    }\\n    if (param.type === \"tuple\") {\\n      return encodeTuple(value, {\\n        param\\n      });\\n    }\\n    if (param.type === \"address\") {\\n      return encodeAddress(value);\\n    }\\n    if (param.type === \"bool\") {\\n      return encodeBool(value);\\n    }\\n    if (param.type.startsWith(\"uint\") || param.type.startsWith(\"int\")) {\\n      const signed = param.type.startsWith(\"int\");\\n      const [, , size5 = \"256\"] = integerRegex2.exec(param.type) ?? [];\\n      return encodeNumber(value, {\\n        signed,\\n        size: Number(size5)\\n      });\\n    }\\n    if (param.type.startsWith(\"bytes\")) {\\n      return encodeBytes(value, { param });\\n    }\\n    if (param.type === \"string\") {\\n      return encodeString(value);\\n    }\\n    throw new InvalidAbiEncodingTypeError(param.type, {\\n      docsPath: \"/docs/contract/encodeAbiParameters\"\\n    });\\n  }\\n  function encodeParams(preparedParams) {\\n    let staticSize = 0;\\n    for (let i = 0; i < preparedParams.length; i++) {\\n      const { dynamic, encoded } = preparedParams[i];\\n      if (dynamic)\\n        staticSize += 32;\\n      else\\n        staticSize += size(encoded);\\n    }\\n    const staticParams = [];\\n    const dynamicParams = [];\\n    let dynamicSize = 0;\\n    for (let i = 0; i < preparedParams.length; i++) {\\n      const { dynamic, encoded } = preparedParams[i];\\n      if (dynamic) {\\n        staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));\\n        dynamicParams.push(encoded);\\n        dynamicSize += size(encoded);\\n      } else {\\n        staticParams.push(encoded);\\n      }\\n    }\\n    return concat([...staticParams, ...dynamicParams]);\\n  }\\n  function encodeAddress(value) {\\n    if (!isAddress(value))\\n      throw new InvalidAddressError({ address: value });\\n    return { dynamic: false, encoded: padHex(value.toLowerCase()) };\\n  }\\n  function encodeArray(value, { length, param }) {\\n    const dynamic = length === null;\\n    if (!Array.isArray(value))\\n      throw new InvalidArrayError(value);\\n    if (!dynamic && value.length !== length)\\n      throw new AbiEncodingArrayLengthMismatchError({\\n        expectedLength: length,\\n        givenLength: value.length,\\n        type: `${param.type}[${length}]`\\n      });\\n    let dynamicChild = false;\\n    const preparedParams = [];\\n    for (let i = 0; i < value.length; i++) {\\n      const preparedParam = prepareParam({ param, value: value[i] });\\n      if (preparedParam.dynamic)\\n        dynamicChild = true;\\n      preparedParams.push(preparedParam);\\n    }\\n    if (dynamic || dynamicChild) {\\n      const data = encodeParams(preparedParams);\\n      if (dynamic) {\\n        const length2 = numberToHex(preparedParams.length, { size: 32 });\\n        return {\\n          dynamic: true,\\n          encoded: preparedParams.length > 0 ? concat([length2, data]) : length2\\n        };\\n      }\\n      if (dynamicChild)\\n        return { dynamic: true, encoded: data };\\n    }\\n    return {\\n      dynamic: false,\\n      encoded: concat(preparedParams.map(({ encoded }) => encoded))\\n    };\\n  }\\n  function encodeBytes(value, { param }) {\\n    const [, paramSize] = param.type.split(\"bytes\");\\n    const bytesSize = size(value);\\n    if (!paramSize) {\\n      let value_ = value;\\n      if (bytesSize % 32 !== 0)\\n        value_ = padHex(value_, {\\n          dir: \"right\",\\n          size: Math.ceil((value.length - 2) / 2 / 32) * 32\\n        });\\n      return {\\n        dynamic: true,\\n        encoded: concat([padHex(numberToHex(bytesSize, { size: 32 })), value_])\\n      };\\n    }\\n    if (bytesSize !== Number.parseInt(paramSize))\\n      throw new AbiEncodingBytesSizeMismatchError({\\n        expectedSize: Number.parseInt(paramSize),\\n        value\\n      });\\n    return { dynamic: false, encoded: padHex(value, { dir: \"right\" }) };\\n  }\\n  function encodeBool(value) {\\n    if (typeof value !== \"boolean\")\\n      throw new BaseError2(`Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\\\`true\\\\` or \\\\`false\\\\`.`);\\n    return { dynamic: false, encoded: padHex(boolToHex(value)) };\\n  }\\n  function encodeNumber(value, { signed, size: size5 = 256 }) {\\n    if (typeof size5 === \"number\") {\\n      const max = 2n ** (BigInt(size5) - (signed ? 1n : 0n)) - 1n;\\n      const min = signed ? -max - 1n : 0n;\\n      if (value > max || value < min)\\n        throw new IntegerOutOfRangeError({\\n          max: max.toString(),\\n          min: min.toString(),\\n          signed,\\n          size: size5 / 8,\\n          value: value.toString()\\n        });\\n    }\\n    return {\\n      dynamic: false,\\n      encoded: numberToHex(value, {\\n        size: 32,\\n        signed\\n      })\\n    };\\n  }\\n  function encodeString(value) {\\n    const hexValue = stringToHex(value);\\n    const partsLength = Math.ceil(size(hexValue) / 32);\\n    const parts = [];\\n    for (let i = 0; i < partsLength; i++) {\\n      parts.push(padHex(slice(hexValue, i * 32, (i + 1) * 32), {\\n        dir: \"right\"\\n      }));\\n    }\\n    return {\\n      dynamic: true,\\n      encoded: concat([\\n        padHex(numberToHex(size(hexValue), { size: 32 })),\\n        ...parts\\n      ])\\n    };\\n  }\\n  function encodeTuple(value, { param }) {\\n    let dynamic = false;\\n    const preparedParams = [];\\n    for (let i = 0; i < param.components.length; i++) {\\n      const param_ = param.components[i];\\n      const index2 = Array.isArray(value) ? i : param_.name;\\n      const preparedParam = prepareParam({\\n        param: param_,\\n        value: value[index2]\\n      });\\n      preparedParams.push(preparedParam);\\n      if (preparedParam.dynamic)\\n        dynamic = true;\\n    }\\n    return {\\n      dynamic,\\n      encoded: dynamic ? encodeParams(preparedParams) : concat(preparedParams.map(({ encoded }) => encoded))\\n    };\\n  }\\n  function getArrayComponents(type) {\\n    const matches = type.match(/^(.*)\\\\[(\\\\d+)?\\\\]$/);\\n    return matches ? (\\n      // Return `null` if the array is dynamic.\\n      [matches[2] ? Number(matches[2]) : null, matches[1]]\\n    ) : void 0;\\n  }\\n  var init_encodeAbiParameters = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/abi/encodeAbiParameters.js\"() {\\n      init_abi();\\n      init_address();\\n      init_base();\\n      init_encoding();\\n      init_isAddress();\\n      init_concat();\\n      init_pad();\\n      init_size();\\n      init_slice();\\n      init_toHex();\\n      init_regex2();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/hash/toFunctionSelector.js\\n  var toFunctionSelector;\\n  var init_toFunctionSelector = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/hash/toFunctionSelector.js\"() {\\n      init_slice();\\n      init_toSignatureHash();\\n      toFunctionSelector = (fn) => slice(toSignatureHash(fn), 0, 4);\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/abi/getAbiItem.js\\n  function getAbiItem(parameters) {\\n    const { abi: abi2, args = [], name } = parameters;\\n    const isSelector = isHex(name, { strict: false });\\n    const abiItems = abi2.filter((abiItem) => {\\n      if (isSelector) {\\n        if (abiItem.type === \"function\")\\n          return toFunctionSelector(abiItem) === name;\\n        if (abiItem.type === \"event\")\\n          return toEventSelector(abiItem) === name;\\n        return false;\\n      }\\n      return \"name\" in abiItem && abiItem.name === name;\\n    });\\n    if (abiItems.length === 0)\\n      return void 0;\\n    if (abiItems.length === 1)\\n      return abiItems[0];\\n    let matchedAbiItem = void 0;\\n    for (const abiItem of abiItems) {\\n      if (!(\"inputs\" in abiItem))\\n        continue;\\n      if (!args || args.length === 0) {\\n        if (!abiItem.inputs || abiItem.inputs.length === 0)\\n          return abiItem;\\n        continue;\\n      }\\n      if (!abiItem.inputs)\\n        continue;\\n      if (abiItem.inputs.length === 0)\\n        continue;\\n      if (abiItem.inputs.length !== args.length)\\n        continue;\\n      const matched = args.every((arg, index2) => {\\n        const abiParameter = \"inputs\" in abiItem && abiItem.inputs[index2];\\n        if (!abiParameter)\\n          return false;\\n        return isArgOfType(arg, abiParameter);\\n      });\\n      if (matched) {\\n        if (matchedAbiItem && \"inputs\" in matchedAbiItem && matchedAbiItem.inputs) {\\n          const ambiguousTypes = getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);\\n          if (ambiguousTypes)\\n            throw new AbiItemAmbiguityError({\\n              abiItem,\\n              type: ambiguousTypes[0]\\n            }, {\\n              abiItem: matchedAbiItem,\\n              type: ambiguousTypes[1]\\n            });\\n        }\\n        matchedAbiItem = abiItem;\\n      }\\n    }\\n    if (matchedAbiItem)\\n      return matchedAbiItem;\\n    return abiItems[0];\\n  }\\n  function isArgOfType(arg, abiParameter) {\\n    const argType = typeof arg;\\n    const abiParameterType = abiParameter.type;\\n    switch (abiParameterType) {\\n      case \"address\":\\n        return isAddress(arg, { strict: false });\\n      case \"bool\":\\n        return argType === \"boolean\";\\n      case \"function\":\\n        return argType === \"string\";\\n      case \"string\":\\n        return argType === \"string\";\\n      default: {\\n        if (abiParameterType === \"tuple\" && \"components\" in abiParameter)\\n          return Object.values(abiParameter.components).every((component, index2) => {\\n            return isArgOfType(Object.values(arg)[index2], component);\\n          });\\n        if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))\\n          return argType === \"number\" || argType === \"bigint\";\\n        if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\\n          return argType === \"string\" || arg instanceof Uint8Array;\\n        if (/[a-z]+[1-9]{0,3}(\\\\[[0-9]{0,}\\\\])+$/.test(abiParameterType)) {\\n          return Array.isArray(arg) && arg.every((x) => isArgOfType(x, {\\n            ...abiParameter,\\n            // Pop off `[]` or `[M]` from end of type\\n            type: abiParameterType.replace(/(\\\\[[0-9]{0,}\\\\])$/, \"\")\\n          }));\\n        }\\n        return false;\\n      }\\n    }\\n  }\\n  function getAmbiguousTypes(sourceParameters, targetParameters, args) {\\n    for (const parameterIndex in sourceParameters) {\\n      const sourceParameter = sourceParameters[parameterIndex];\\n      const targetParameter = targetParameters[parameterIndex];\\n      if (sourceParameter.type === \"tuple\" && targetParameter.type === \"tuple\" && \"components\" in sourceParameter && \"components\" in targetParameter)\\n        return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);\\n      const types = [sourceParameter.type, targetParameter.type];\\n      const ambiguous = (() => {\\n        if (types.includes(\"address\") && types.includes(\"bytes20\"))\\n          return true;\\n        if (types.includes(\"address\") && types.includes(\"string\"))\\n          return isAddress(args[parameterIndex], { strict: false });\\n        if (types.includes(\"address\") && types.includes(\"bytes\"))\\n          return isAddress(args[parameterIndex], { strict: false });\\n        return false;\\n      })();\\n      if (ambiguous)\\n        return types;\\n    }\\n    return;\\n  }\\n  var init_getAbiItem = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/abi/getAbiItem.js\"() {\\n      init_abi();\\n      init_isHex();\\n      init_isAddress();\\n      init_toEventSelector();\\n      init_toFunctionSelector();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/accounts/utils/parseAccount.js\\n  function parseAccount(account) {\\n    if (typeof account === \"string\")\\n      return { address: account, type: \"json-rpc\" };\\n    return account;\\n  }\\n  var init_parseAccount = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/accounts/utils/parseAccount.js\"() {\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/abi/prepareEncodeFunctionData.js\\n  function prepareEncodeFunctionData(parameters) {\\n    const { abi: abi2, args, functionName } = parameters;\\n    let abiItem = abi2[0];\\n    if (functionName) {\\n      const item = getAbiItem({\\n        abi: abi2,\\n        args,\\n        name: functionName\\n      });\\n      if (!item)\\n        throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath2 });\\n      abiItem = item;\\n    }\\n    if (abiItem.type !== \"function\")\\n      throw new AbiFunctionNotFoundError(void 0, { docsPath: docsPath2 });\\n    return {\\n      abi: [abiItem],\\n      functionName: toFunctionSelector(formatAbiItem2(abiItem))\\n    };\\n  }\\n  var docsPath2;\\n  var init_prepareEncodeFunctionData = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/abi/prepareEncodeFunctionData.js\"() {\\n      init_abi();\\n      init_toFunctionSelector();\\n      init_formatAbiItem2();\\n      init_getAbiItem();\\n      docsPath2 = \"/docs/contract/encodeFunctionData\";\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/abi/encodeFunctionData.js\\n  function encodeFunctionData(parameters) {\\n    const { args } = parameters;\\n    const { abi: abi2, functionName } = (() => {\\n      if (parameters.abi.length === 1 && parameters.functionName?.startsWith(\"0x\"))\\n        return parameters;\\n      return prepareEncodeFunctionData(parameters);\\n    })();\\n    const abiItem = abi2[0];\\n    const signature = functionName;\\n    const data = \"inputs\" in abiItem && abiItem.inputs ? encodeAbiParameters(abiItem.inputs, args ?? []) : void 0;\\n    return concatHex([signature, data ?? \"0x\"]);\\n  }\\n  var init_encodeFunctionData = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/abi/encodeFunctionData.js\"() {\\n      init_concat();\\n      init_encodeAbiParameters();\\n      init_prepareEncodeFunctionData();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/constants/solidity.js\\n  var panicReasons, solidityError, solidityPanic;\\n  var init_solidity = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/constants/solidity.js\"() {\\n      panicReasons = {\\n        1: \"An `assert` condition failed.\",\\n        17: \"Arithmetic operation resulted in underflow or overflow.\",\\n        18: \"Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).\",\\n        33: \"Attempted to convert to an invalid type.\",\\n        34: \"Attempted to access a storage byte array that is incorrectly encoded.\",\\n        49: \"Performed `.pop()` on an empty array\",\\n        50: \"Array index is out of bounds.\",\\n        65: \"Allocated too much memory or created an array which is too large.\",\\n        81: \"Attempted to call a zero-initialized variable of internal function type.\"\\n      };\\n      solidityError = {\\n        inputs: [\\n          {\\n            name: \"message\",\\n            type: \"string\"\\n          }\\n        ],\\n        name: \"Error\",\\n        type: \"error\"\\n      };\\n      solidityPanic = {\\n        inputs: [\\n          {\\n            name: \"reason\",\\n            type: \"uint256\"\\n          }\\n        ],\\n        name: \"Panic\",\\n        type: \"error\"\\n      };\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/cursor.js\\n  var NegativeOffsetError, PositionOutOfBoundsError, RecursiveReadLimitExceededError;\\n  var init_cursor = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/cursor.js\"() {\\n      init_base();\\n      NegativeOffsetError = class extends BaseError2 {\\n        constructor({ offset }) {\\n          super(`Offset \\\\`${offset}\\\\` cannot be negative.`, {\\n            name: \"NegativeOffsetError\"\\n          });\\n        }\\n      };\\n      PositionOutOfBoundsError = class extends BaseError2 {\\n        constructor({ length, position }) {\\n          super(`Position \\\\`${position}\\\\` is out of bounds (\\\\`0 < position < ${length}\\\\`).`, { name: \"PositionOutOfBoundsError\" });\\n        }\\n      };\\n      RecursiveReadLimitExceededError = class extends BaseError2 {\\n        constructor({ count, limit }) {\\n          super(`Recursive read limit of \\\\`${limit}\\\\` exceeded (recursive read count: \\\\`${count}\\\\`).`, { name: \"RecursiveReadLimitExceededError\" });\\n        }\\n      };\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/cursor.js\\n  function createCursor(bytes, { recursiveReadLimit = 8192 } = {}) {\\n    const cursor = Object.create(staticCursor);\\n    cursor.bytes = bytes;\\n    cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\\n    cursor.positionReadCount = /* @__PURE__ */ new Map();\\n    cursor.recursiveReadLimit = recursiveReadLimit;\\n    return cursor;\\n  }\\n  var staticCursor;\\n  var init_cursor2 = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/cursor.js\"() {\\n      init_cursor();\\n      staticCursor = {\\n        bytes: new Uint8Array(),\\n        dataView: new DataView(new ArrayBuffer(0)),\\n        position: 0,\\n        positionReadCount: /* @__PURE__ */ new Map(),\\n        recursiveReadCount: 0,\\n        recursiveReadLimit: Number.POSITIVE_INFINITY,\\n        assertReadLimit() {\\n          if (this.recursiveReadCount >= this.recursiveReadLimit)\\n            throw new RecursiveReadLimitExceededError({\\n              count: this.recursiveReadCount + 1,\\n              limit: this.recursiveReadLimit\\n            });\\n        },\\n        assertPosition(position) {\\n          if (position < 0 || position > this.bytes.length - 1)\\n            throw new PositionOutOfBoundsError({\\n              length: this.bytes.length,\\n              position\\n            });\\n        },\\n        decrementPosition(offset) {\\n          if (offset < 0)\\n            throw new NegativeOffsetError({ offset });\\n          const position = this.position - offset;\\n          this.assertPosition(position);\\n          this.position = position;\\n        },\\n        getReadCount(position) {\\n          return this.positionReadCount.get(position || this.position) || 0;\\n        },\\n        incrementPosition(offset) {\\n          if (offset < 0)\\n            throw new NegativeOffsetError({ offset });\\n          const position = this.position + offset;\\n          this.assertPosition(position);\\n          this.position = position;\\n        },\\n        inspectByte(position_) {\\n          const position = position_ ?? this.position;\\n          this.assertPosition(position);\\n          return this.bytes[position];\\n        },\\n        inspectBytes(length, position_) {\\n          const position = position_ ?? this.position;\\n          this.assertPosition(position + length - 1);\\n          return this.bytes.subarray(position, position + length);\\n        },\\n        inspectUint8(position_) {\\n          const position = position_ ?? this.position;\\n          this.assertPosition(position);\\n          return this.bytes[position];\\n        },\\n        inspectUint16(position_) {\\n          const position = position_ ?? this.position;\\n          this.assertPosition(position + 1);\\n          return this.dataView.getUint16(position);\\n        },\\n        inspectUint24(position_) {\\n          const position = position_ ?? this.position;\\n          this.assertPosition(position + 2);\\n          return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);\\n        },\\n        inspectUint32(position_) {\\n          const position = position_ ?? this.position;\\n          this.assertPosition(position + 3);\\n          return this.dataView.getUint32(position);\\n        },\\n        pushByte(byte) {\\n          this.assertPosition(this.position);\\n          this.bytes[this.position] = byte;\\n          this.position++;\\n        },\\n        pushBytes(bytes) {\\n          this.assertPosition(this.position + bytes.length - 1);\\n          this.bytes.set(bytes, this.position);\\n          this.position += bytes.length;\\n        },\\n        pushUint8(value) {\\n          this.assertPosition(this.position);\\n          this.bytes[this.position] = value;\\n          this.position++;\\n        },\\n        pushUint16(value) {\\n          this.assertPosition(this.position + 1);\\n          this.dataView.setUint16(this.position, value);\\n          this.position += 2;\\n        },\\n        pushUint24(value) {\\n          this.assertPosition(this.position + 2);\\n          this.dataView.setUint16(this.position, value >> 8);\\n          this.dataView.setUint8(this.position + 2, value & ~4294967040);\\n          this.position += 3;\\n        },\\n        pushUint32(value) {\\n          this.assertPosition(this.position + 3);\\n          this.dataView.setUint32(this.position, value);\\n          this.position += 4;\\n        },\\n        readByte() {\\n          this.assertReadLimit();\\n          this._touch();\\n          const value = this.inspectByte();\\n          this.position++;\\n          return value;\\n        },\\n        readBytes(length, size5) {\\n          this.assertReadLimit();\\n          this._touch();\\n          const value = this.inspectBytes(length);\\n          this.position += size5 ?? length;\\n          return value;\\n        },\\n        readUint8() {\\n          this.assertReadLimit();\\n          this._touch();\\n          const value = this.inspectUint8();\\n          this.position += 1;\\n          return value;\\n        },\\n        readUint16() {\\n          this.assertReadLimit();\\n          this._touch();\\n          const value = this.inspectUint16();\\n          this.position += 2;\\n          return value;\\n        },\\n        readUint24() {\\n          this.assertReadLimit();\\n          this._touch();\\n          const value = this.inspectUint24();\\n          this.position += 3;\\n          return value;\\n        },\\n        readUint32() {\\n          this.assertReadLimit();\\n          this._touch();\\n          const value = this.inspectUint32();\\n          this.position += 4;\\n          return value;\\n        },\\n        get remaining() {\\n          return this.bytes.length - this.position;\\n        },\\n        setPosition(position) {\\n          const oldPosition = this.position;\\n          this.assertPosition(position);\\n          this.position = position;\\n          return () => this.position = oldPosition;\\n        },\\n        _touch() {\\n          if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)\\n            return;\\n          const count = this.getReadCount();\\n          this.positionReadCount.set(this.position, count + 1);\\n          if (count > 0)\\n            this.recursiveReadCount++;\\n        }\\n      };\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/encoding/fromBytes.js\\n  function bytesToBigInt(bytes, opts = {}) {\\n    if (typeof opts.size !== \"undefined\")\\n      assertSize(bytes, { size: opts.size });\\n    const hex = bytesToHex(bytes, opts);\\n    return hexToBigInt(hex, opts);\\n  }\\n  function bytesToBool(bytes_, opts = {}) {\\n    let bytes = bytes_;\\n    if (typeof opts.size !== \"undefined\") {\\n      assertSize(bytes, { size: opts.size });\\n      bytes = trim(bytes);\\n    }\\n    if (bytes.length > 1 || bytes[0] > 1)\\n      throw new InvalidBytesBooleanError(bytes);\\n    return Boolean(bytes[0]);\\n  }\\n  function bytesToNumber(bytes, opts = {}) {\\n    if (typeof opts.size !== \"undefined\")\\n      assertSize(bytes, { size: opts.size });\\n    const hex = bytesToHex(bytes, opts);\\n    return hexToNumber(hex, opts);\\n  }\\n  function bytesToString(bytes_, opts = {}) {\\n    let bytes = bytes_;\\n    if (typeof opts.size !== \"undefined\") {\\n      assertSize(bytes, { size: opts.size });\\n      bytes = trim(bytes, { dir: \"right\" });\\n    }\\n    return new TextDecoder().decode(bytes);\\n  }\\n  var init_fromBytes = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/encoding/fromBytes.js\"() {\\n      init_encoding();\\n      init_trim();\\n      init_fromHex();\\n      init_toHex();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/abi/decodeAbiParameters.js\\n  function decodeAbiParameters(params, data) {\\n    const bytes = typeof data === \"string\" ? hexToBytes(data) : data;\\n    const cursor = createCursor(bytes);\\n    if (size(bytes) === 0 && params.length > 0)\\n      throw new AbiDecodingZeroDataError();\\n    if (size(data) && size(data) < 32)\\n      throw new AbiDecodingDataSizeTooSmallError({\\n        data: typeof data === \"string\" ? data : bytesToHex(data),\\n        params,\\n        size: size(data)\\n      });\\n    let consumed = 0;\\n    const values = [];\\n    for (let i = 0; i < params.length; ++i) {\\n      const param = params[i];\\n      cursor.setPosition(consumed);\\n      const [data2, consumed_] = decodeParameter(cursor, param, {\\n        staticPosition: 0\\n      });\\n      consumed += consumed_;\\n      values.push(data2);\\n    }\\n    return values;\\n  }\\n  function decodeParameter(cursor, param, { staticPosition }) {\\n    const arrayComponents = getArrayComponents(param.type);\\n    if (arrayComponents) {\\n      const [length, type] = arrayComponents;\\n      return decodeArray(cursor, { ...param, type }, { length, staticPosition });\\n    }\\n    if (param.type === \"tuple\")\\n      return decodeTuple(cursor, param, { staticPosition });\\n    if (param.type === \"address\")\\n      return decodeAddress(cursor);\\n    if (param.type === \"bool\")\\n      return decodeBool(cursor);\\n    if (param.type.startsWith(\"bytes\"))\\n      return decodeBytes(cursor, param, { staticPosition });\\n    if (param.type.startsWith(\"uint\") || param.type.startsWith(\"int\"))\\n      return decodeNumber(cursor, param);\\n    if (param.type === \"string\")\\n      return decodeString(cursor, { staticPosition });\\n    throw new InvalidAbiDecodingTypeError(param.type, {\\n      docsPath: \"/docs/contract/decodeAbiParameters\"\\n    });\\n  }\\n  function decodeAddress(cursor) {\\n    const value = cursor.readBytes(32);\\n    return [checksumAddress(bytesToHex(sliceBytes(value, -20))), 32];\\n  }\\n  function decodeArray(cursor, param, { length, staticPosition }) {\\n    if (!length) {\\n      const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));\\n      const start = staticPosition + offset;\\n      const startOfData = start + sizeOfLength;\\n      cursor.setPosition(start);\\n      const length2 = bytesToNumber(cursor.readBytes(sizeOfLength));\\n      const dynamicChild = hasDynamicChild(param);\\n      let consumed2 = 0;\\n      const value2 = [];\\n      for (let i = 0; i < length2; ++i) {\\n        cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed2));\\n        const [data, consumed_] = decodeParameter(cursor, param, {\\n          staticPosition: startOfData\\n        });\\n        consumed2 += consumed_;\\n        value2.push(data);\\n      }\\n      cursor.setPosition(staticPosition + 32);\\n      return [value2, 32];\\n    }\\n    if (hasDynamicChild(param)) {\\n      const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));\\n      const start = staticPosition + offset;\\n      const value2 = [];\\n      for (let i = 0; i < length; ++i) {\\n        cursor.setPosition(start + i * 32);\\n        const [data] = decodeParameter(cursor, param, {\\n          staticPosition: start\\n        });\\n        value2.push(data);\\n      }\\n      cursor.setPosition(staticPosition + 32);\\n      return [value2, 32];\\n    }\\n    let consumed = 0;\\n    const value = [];\\n    for (let i = 0; i < length; ++i) {\\n      const [data, consumed_] = decodeParameter(cursor, param, {\\n        staticPosition: staticPosition + consumed\\n      });\\n      consumed += consumed_;\\n      value.push(data);\\n    }\\n    return [value, consumed];\\n  }\\n  function decodeBool(cursor) {\\n    return [bytesToBool(cursor.readBytes(32), { size: 32 }), 32];\\n  }\\n  function decodeBytes(cursor, param, { staticPosition }) {\\n    const [_, size5] = param.type.split(\"bytes\");\\n    if (!size5) {\\n      const offset = bytesToNumber(cursor.readBytes(32));\\n      cursor.setPosition(staticPosition + offset);\\n      const length = bytesToNumber(cursor.readBytes(32));\\n      if (length === 0) {\\n        cursor.setPosition(staticPosition + 32);\\n        return [\"0x\", 32];\\n      }\\n      const data = cursor.readBytes(length);\\n      cursor.setPosition(staticPosition + 32);\\n      return [bytesToHex(data), 32];\\n    }\\n    const value = bytesToHex(cursor.readBytes(Number.parseInt(size5), 32));\\n    return [value, 32];\\n  }\\n  function decodeNumber(cursor, param) {\\n    const signed = param.type.startsWith(\"int\");\\n    const size5 = Number.parseInt(param.type.split(\"int\")[1] || \"256\");\\n    const value = cursor.readBytes(32);\\n    return [\\n      size5 > 48 ? bytesToBigInt(value, { signed }) : bytesToNumber(value, { signed }),\\n      32\\n    ];\\n  }\\n  function decodeTuple(cursor, param, { staticPosition }) {\\n    const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);\\n    const value = hasUnnamedChild ? [] : {};\\n    let consumed = 0;\\n    if (hasDynamicChild(param)) {\\n      const offset = bytesToNumber(cursor.readBytes(sizeOfOffset));\\n      const start = staticPosition + offset;\\n      for (let i = 0; i < param.components.length; ++i) {\\n        const component = param.components[i];\\n        cursor.setPosition(start + consumed);\\n        const [data, consumed_] = decodeParameter(cursor, component, {\\n          staticPosition: start\\n        });\\n        consumed += consumed_;\\n        value[hasUnnamedChild ? i : component?.name] = data;\\n      }\\n      cursor.setPosition(staticPosition + 32);\\n      return [value, 32];\\n    }\\n    for (let i = 0; i < param.components.length; ++i) {\\n      const component = param.components[i];\\n      const [data, consumed_] = decodeParameter(cursor, component, {\\n        staticPosition\\n      });\\n      value[hasUnnamedChild ? i : component?.name] = data;\\n      consumed += consumed_;\\n    }\\n    return [value, consumed];\\n  }\\n  function decodeString(cursor, { staticPosition }) {\\n    const offset = bytesToNumber(cursor.readBytes(32));\\n    const start = staticPosition + offset;\\n    cursor.setPosition(start);\\n    const length = bytesToNumber(cursor.readBytes(32));\\n    if (length === 0) {\\n      cursor.setPosition(staticPosition + 32);\\n      return [\"\", 32];\\n    }\\n    const data = cursor.readBytes(length, 32);\\n    const value = bytesToString(trim(data));\\n    cursor.setPosition(staticPosition + 32);\\n    return [value, 32];\\n  }\\n  function hasDynamicChild(param) {\\n    const { type } = param;\\n    if (type === \"string\")\\n      return true;\\n    if (type === \"bytes\")\\n      return true;\\n    if (type.endsWith(\"[]\"))\\n      return true;\\n    if (type === \"tuple\")\\n      return param.components?.some(hasDynamicChild);\\n    const arrayComponents = getArrayComponents(param.type);\\n    if (arrayComponents && hasDynamicChild({ ...param, type: arrayComponents[1] }))\\n      return true;\\n    return false;\\n  }\\n  var sizeOfLength, sizeOfOffset;\\n  var init_decodeAbiParameters = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/abi/decodeAbiParameters.js\"() {\\n      init_abi();\\n      init_getAddress();\\n      init_cursor2();\\n      init_size();\\n      init_slice();\\n      init_trim();\\n      init_fromBytes();\\n      init_toBytes();\\n      init_toHex();\\n      init_encodeAbiParameters();\\n      sizeOfLength = 32;\\n      sizeOfOffset = 32;\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/abi/decodeErrorResult.js\\n  function decodeErrorResult(parameters) {\\n    const { abi: abi2, data } = parameters;\\n    const signature = slice(data, 0, 4);\\n    if (signature === \"0x\")\\n      throw new AbiDecodingZeroDataError();\\n    const abi_ = [...abi2 || [], solidityError, solidityPanic];\\n    const abiItem = abi_.find((x) => x.type === \"error\" && signature === toFunctionSelector(formatAbiItem2(x)));\\n    if (!abiItem)\\n      throw new AbiErrorSignatureNotFoundError(signature, {\\n        docsPath: \"/docs/contract/decodeErrorResult\"\\n      });\\n    return {\\n      abiItem,\\n      args: \"inputs\" in abiItem && abiItem.inputs && abiItem.inputs.length > 0 ? decodeAbiParameters(abiItem.inputs, slice(data, 4)) : void 0,\\n      errorName: abiItem.name\\n    };\\n  }\\n  var init_decodeErrorResult = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/abi/decodeErrorResult.js\"() {\\n      init_solidity();\\n      init_abi();\\n      init_slice();\\n      init_toFunctionSelector();\\n      init_decodeAbiParameters();\\n      init_formatAbiItem2();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/stringify.js\\n  var stringify;\\n  var init_stringify = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/stringify.js\"() {\\n      stringify = (value, replacer, space) => JSON.stringify(value, (key, value_) => {\\n        const value2 = typeof value_ === \"bigint\" ? value_.toString() : value_;\\n        return typeof replacer === \"function\" ? replacer(key, value2) : value2;\\n      }, space);\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/abi/formatAbiItemWithArgs.js\\n  function formatAbiItemWithArgs({ abiItem, args, includeFunctionName = true, includeName = false }) {\\n    if (!(\"name\" in abiItem))\\n      return;\\n    if (!(\"inputs\" in abiItem))\\n      return;\\n    if (!abiItem.inputs)\\n      return;\\n    return `${includeFunctionName ? abiItem.name : \"\"}(${abiItem.inputs.map((input, i) => `${includeName && input.name ? `${input.name}: ` : \"\"}${typeof args[i] === \"object\" ? stringify(args[i]) : args[i]}`).join(\", \")})`;\\n  }\\n  var init_formatAbiItemWithArgs = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/abi/formatAbiItemWithArgs.js\"() {\\n      init_stringify();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/constants/unit.js\\n  var etherUnits, gweiUnits;\\n  var init_unit = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/constants/unit.js\"() {\\n      etherUnits = {\\n        gwei: 9,\\n        wei: 18\\n      };\\n      gweiUnits = {\\n        ether: -9,\\n        wei: 9\\n      };\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/unit/formatUnits.js\\n  function formatUnits(value, decimals) {\\n    let display = value.toString();\\n    const negative = display.startsWith(\"-\");\\n    if (negative)\\n      display = display.slice(1);\\n    display = display.padStart(decimals, \"0\");\\n    let [integer, fraction] = [\\n      display.slice(0, display.length - decimals),\\n      display.slice(display.length - decimals)\\n    ];\\n    fraction = fraction.replace(/(0+)$/, \"\");\\n    return `${negative ? \"-\" : \"\"}${integer || \"0\"}${fraction ? `.${fraction}` : \"\"}`;\\n  }\\n  var init_formatUnits = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/unit/formatUnits.js\"() {\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/unit/formatEther.js\\n  function formatEther(wei, unit = \"wei\") {\\n    return formatUnits(wei, etherUnits[unit]);\\n  }\\n  var init_formatEther = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/unit/formatEther.js\"() {\\n      init_unit();\\n      init_formatUnits();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/unit/formatGwei.js\\n  function formatGwei(wei, unit = \"wei\") {\\n    return formatUnits(wei, gweiUnits[unit]);\\n  }\\n  var init_formatGwei = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/unit/formatGwei.js\"() {\\n      init_unit();\\n      init_formatUnits();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/stateOverride.js\\n  function prettyStateMapping(stateMapping) {\\n    return stateMapping.reduce((pretty, { slot, value }) => {\\n      return `${pretty}        ${slot}: ${value}\\n`;\\n    }, \"\");\\n  }\\n  function prettyStateOverride(stateOverride) {\\n    return stateOverride.reduce((pretty, { address, ...state }) => {\\n      let val = `${pretty}    ${address}:\\n`;\\n      if (state.nonce)\\n        val += `      nonce: ${state.nonce}\\n`;\\n      if (state.balance)\\n        val += `      balance: ${state.balance}\\n`;\\n      if (state.code)\\n        val += `      code: ${state.code}\\n`;\\n      if (state.state) {\\n        val += \"      state:\\\\n\";\\n        val += prettyStateMapping(state.state);\\n      }\\n      if (state.stateDiff) {\\n        val += \"      stateDiff:\\\\n\";\\n        val += prettyStateMapping(state.stateDiff);\\n      }\\n      return val;\\n    }, \"  State Override:\\\\n\").slice(0, -1);\\n  }\\n  var AccountStateConflictError, StateAssignmentConflictError;\\n  var init_stateOverride = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/stateOverride.js\"() {\\n      init_base();\\n      AccountStateConflictError = class extends BaseError2 {\\n        constructor({ address }) {\\n          super(`State for account \"${address}\" is set multiple times.`, {\\n            name: \"AccountStateConflictError\"\\n          });\\n        }\\n      };\\n      StateAssignmentConflictError = class extends BaseError2 {\\n        constructor() {\\n          super(\"state and stateDiff are set on the same account.\", {\\n            name: \"StateAssignmentConflictError\"\\n          });\\n        }\\n      };\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/transaction.js\\n  function prettyPrint(args) {\\n    const entries = Object.entries(args).map(([key, value]) => {\\n      if (value === void 0 || value === false)\\n        return null;\\n      return [key, value];\\n    }).filter(Boolean);\\n    const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);\\n    return entries.map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`).join(\"\\\\n\");\\n  }\\n  var FeeConflictError, InvalidLegacyVError, InvalidSerializableTransactionError, InvalidStorageKeySizeError, TransactionExecutionError, TransactionNotFoundError, TransactionReceiptNotFoundError, WaitForTransactionReceiptTimeoutError;\\n  var init_transaction = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/transaction.js\"() {\\n      init_formatEther();\\n      init_formatGwei();\\n      init_base();\\n      FeeConflictError = class extends BaseError2 {\\n        constructor() {\\n          super([\\n            \"Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.\",\\n            \"Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others.\"\\n          ].join(\"\\\\n\"), { name: \"FeeConflictError\" });\\n        }\\n      };\\n      InvalidLegacyVError = class extends BaseError2 {\\n        constructor({ v }) {\\n          super(`Invalid \\\\`v\\\\` value \"${v}\". Expected 27 or 28.`, {\\n            name: \"InvalidLegacyVError\"\\n          });\\n        }\\n      };\\n      InvalidSerializableTransactionError = class extends BaseError2 {\\n        constructor({ transaction }) {\\n          super(\"Cannot infer a transaction type from provided transaction.\", {\\n            metaMessages: [\\n              \"Provided Transaction:\",\\n              \"{\",\\n              prettyPrint(transaction),\\n              \"}\",\\n              \"\",\\n              \"To infer the type, either provide:\",\\n              \"- a `type` to the Transaction, or\",\\n              \"- an EIP-1559 Transaction with `maxFeePerGas`, or\",\\n              \"- an EIP-2930 Transaction with `gasPrice` & `accessList`, or\",\\n              \"- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or\",\\n              \"- an EIP-7702 Transaction with `authorizationList`, or\",\\n              \"- a Legacy Transaction with `gasPrice`\"\\n            ],\\n            name: \"InvalidSerializableTransactionError\"\\n          });\\n        }\\n      };\\n      InvalidStorageKeySizeError = class extends BaseError2 {\\n        constructor({ storageKey }) {\\n          super(`Size for storage key \"${storageKey}\" is invalid. Expected 32 bytes. Got ${Math.floor((storageKey.length - 2) / 2)} bytes.`, { name: \"InvalidStorageKeySizeError\" });\\n        }\\n      };\\n      TransactionExecutionError = class extends BaseError2 {\\n        constructor(cause, { account, docsPath: docsPath8, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {\\n          const prettyArgs = prettyPrint({\\n            chain: chain && `${chain?.name} (id: ${chain?.id})`,\\n            from: account?.address,\\n            to,\\n            value: typeof value !== \"undefined\" && `${formatEther(value)} ${chain?.nativeCurrency?.symbol || \"ETH\"}`,\\n            data,\\n            gas,\\n            gasPrice: typeof gasPrice !== \"undefined\" && `${formatGwei(gasPrice)} gwei`,\\n            maxFeePerGas: typeof maxFeePerGas !== \"undefined\" && `${formatGwei(maxFeePerGas)} gwei`,\\n            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== \"undefined\" && `${formatGwei(maxPriorityFeePerGas)} gwei`,\\n            nonce\\n          });\\n          super(cause.shortMessage, {\\n            cause,\\n            docsPath: docsPath8,\\n            metaMessages: [\\n              ...cause.metaMessages ? [...cause.metaMessages, \" \"] : [],\\n              \"Request Arguments:\",\\n              prettyArgs\\n            ].filter(Boolean),\\n            name: \"TransactionExecutionError\"\\n          });\\n          Object.defineProperty(this, \"cause\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          this.cause = cause;\\n        }\\n      };\\n      TransactionNotFoundError = class extends BaseError2 {\\n        constructor({ blockHash, blockNumber, blockTag, hash: hash2, index: index2 }) {\\n          let identifier = \"Transaction\";\\n          if (blockTag && index2 !== void 0)\\n            identifier = `Transaction at block time \"${blockTag}\" at index \"${index2}\"`;\\n          if (blockHash && index2 !== void 0)\\n            identifier = `Transaction at block hash \"${blockHash}\" at index \"${index2}\"`;\\n          if (blockNumber && index2 !== void 0)\\n            identifier = `Transaction at block number \"${blockNumber}\" at index \"${index2}\"`;\\n          if (hash2)\\n            identifier = `Transaction with hash \"${hash2}\"`;\\n          super(`${identifier} could not be found.`, {\\n            name: \"TransactionNotFoundError\"\\n          });\\n        }\\n      };\\n      TransactionReceiptNotFoundError = class extends BaseError2 {\\n        constructor({ hash: hash2 }) {\\n          super(`Transaction receipt with hash \"${hash2}\" could not be found. The Transaction may not be processed on a block yet.`, {\\n            name: \"TransactionReceiptNotFoundError\"\\n          });\\n        }\\n      };\\n      WaitForTransactionReceiptTimeoutError = class extends BaseError2 {\\n        constructor({ hash: hash2 }) {\\n          super(`Timed out while waiting for transaction with hash \"${hash2}\" to be confirmed.`, { name: \"WaitForTransactionReceiptTimeoutError\" });\\n        }\\n      };\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/utils.js\\n  var getContractAddress, getUrl;\\n  var init_utils3 = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/utils.js\"() {\\n      getContractAddress = (address) => address;\\n      getUrl = (url) => url;\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/contract.js\\n  var CallExecutionError, ContractFunctionExecutionError, ContractFunctionRevertedError, ContractFunctionZeroDataError, CounterfactualDeploymentFailedError, RawContractError;\\n  var init_contract = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/contract.js\"() {\\n      init_parseAccount();\\n      init_solidity();\\n      init_decodeErrorResult();\\n      init_formatAbiItem2();\\n      init_formatAbiItemWithArgs();\\n      init_getAbiItem();\\n      init_formatEther();\\n      init_formatGwei();\\n      init_abi();\\n      init_base();\\n      init_stateOverride();\\n      init_transaction();\\n      init_utils3();\\n      CallExecutionError = class extends BaseError2 {\\n        constructor(cause, { account: account_, docsPath: docsPath8, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride }) {\\n          const account = account_ ? parseAccount(account_) : void 0;\\n          let prettyArgs = prettyPrint({\\n            from: account?.address,\\n            to,\\n            value: typeof value !== \"undefined\" && `${formatEther(value)} ${chain?.nativeCurrency?.symbol || \"ETH\"}`,\\n            data,\\n            gas,\\n            gasPrice: typeof gasPrice !== \"undefined\" && `${formatGwei(gasPrice)} gwei`,\\n            maxFeePerGas: typeof maxFeePerGas !== \"undefined\" && `${formatGwei(maxFeePerGas)} gwei`,\\n            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== \"undefined\" && `${formatGwei(maxPriorityFeePerGas)} gwei`,\\n            nonce\\n          });\\n          if (stateOverride) {\\n            prettyArgs += `\\n${prettyStateOverride(stateOverride)}`;\\n          }\\n          super(cause.shortMessage, {\\n            cause,\\n            docsPath: docsPath8,\\n            metaMessages: [\\n              ...cause.metaMessages ? [...cause.metaMessages, \" \"] : [],\\n              \"Raw Call Arguments:\",\\n              prettyArgs\\n            ].filter(Boolean),\\n            name: \"CallExecutionError\"\\n          });\\n          Object.defineProperty(this, \"cause\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          this.cause = cause;\\n        }\\n      };\\n      ContractFunctionExecutionError = class extends BaseError2 {\\n        constructor(cause, { abi: abi2, args, contractAddress, docsPath: docsPath8, functionName, sender }) {\\n          const abiItem = getAbiItem({ abi: abi2, args, name: functionName });\\n          const formattedArgs = abiItem ? formatAbiItemWithArgs({\\n            abiItem,\\n            args,\\n            includeFunctionName: false,\\n            includeName: false\\n          }) : void 0;\\n          const functionWithParams = abiItem ? formatAbiItem2(abiItem, { includeName: true }) : void 0;\\n          const prettyArgs = prettyPrint({\\n            address: contractAddress && getContractAddress(contractAddress),\\n            function: functionWithParams,\\n            args: formattedArgs && formattedArgs !== \"()\" && `${[...Array(functionName?.length ?? 0).keys()].map(() => \" \").join(\"\")}${formattedArgs}`,\\n            sender\\n          });\\n          super(cause.shortMessage || `An unknown error occurred while executing the contract function \"${functionName}\".`, {\\n            cause,\\n            docsPath: docsPath8,\\n            metaMessages: [\\n              ...cause.metaMessages ? [...cause.metaMessages, \" \"] : [],\\n              prettyArgs && \"Contract Call:\",\\n              prettyArgs\\n            ].filter(Boolean),\\n            name: \"ContractFunctionExecutionError\"\\n          });\\n          Object.defineProperty(this, \"abi\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          Object.defineProperty(this, \"args\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          Object.defineProperty(this, \"cause\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          Object.defineProperty(this, \"contractAddress\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          Object.defineProperty(this, \"formattedArgs\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          Object.defineProperty(this, \"functionName\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          Object.defineProperty(this, \"sender\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          this.abi = abi2;\\n          this.args = args;\\n          this.cause = cause;\\n          this.contractAddress = contractAddress;\\n          this.functionName = functionName;\\n          this.sender = sender;\\n        }\\n      };\\n      ContractFunctionRevertedError = class extends BaseError2 {\\n        constructor({ abi: abi2, data, functionName, message }) {\\n          let cause;\\n          let decodedData = void 0;\\n          let metaMessages;\\n          let reason;\\n          if (data && data !== \"0x\") {\\n            try {\\n              decodedData = decodeErrorResult({ abi: abi2, data });\\n              const { abiItem, errorName, args: errorArgs } = decodedData;\\n              if (errorName === \"Error\") {\\n                reason = errorArgs[0];\\n              } else if (errorName === \"Panic\") {\\n                const [firstArg] = errorArgs;\\n                reason = panicReasons[firstArg];\\n              } else {\\n                const errorWithParams = abiItem ? formatAbiItem2(abiItem, { includeName: true }) : void 0;\\n                const formattedArgs = abiItem && errorArgs ? formatAbiItemWithArgs({\\n                  abiItem,\\n                  args: errorArgs,\\n                  includeFunctionName: false,\\n                  includeName: false\\n                }) : void 0;\\n                metaMessages = [\\n                  errorWithParams ? `Error: ${errorWithParams}` : \"\",\\n                  formattedArgs && formattedArgs !== \"()\" ? `       ${[...Array(errorName?.length ?? 0).keys()].map(() => \" \").join(\"\")}${formattedArgs}` : \"\"\\n                ];\\n              }\\n            } catch (err) {\\n              cause = err;\\n            }\\n          } else if (message)\\n            reason = message;\\n          let signature;\\n          if (cause instanceof AbiErrorSignatureNotFoundError) {\\n            signature = cause.signature;\\n            metaMessages = [\\n              `Unable to decode signature \"${signature}\" as it was not found on the provided ABI.`,\\n              \"Make sure you are using the correct ABI and that the error exists on it.\",\\n              `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`\\n            ];\\n          }\\n          super(reason && reason !== \"execution reverted\" || signature ? [\\n            `The contract function \"${functionName}\" reverted with the following ${signature ? \"signature\" : \"reason\"}:`,\\n            reason || signature\\n          ].join(\"\\\\n\") : `The contract function \"${functionName}\" reverted.`, {\\n            cause,\\n            metaMessages,\\n            name: \"ContractFunctionRevertedError\"\\n          });\\n          Object.defineProperty(this, \"data\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          Object.defineProperty(this, \"raw\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          Object.defineProperty(this, \"reason\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          Object.defineProperty(this, \"signature\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          this.data = decodedData;\\n          this.raw = data;\\n          this.reason = reason;\\n          this.signature = signature;\\n        }\\n      };\\n      ContractFunctionZeroDataError = class extends BaseError2 {\\n        constructor({ functionName }) {\\n          super(`The contract function \"${functionName}\" returned no data (\"0x\").`, {\\n            metaMessages: [\\n              \"This could be due to any of the following:\",\\n              `  - The contract does not have the function \"${functionName}\",`,\\n              \"  - The parameters passed to the contract function may be invalid, or\",\\n              \"  - The address is not a contract.\"\\n            ],\\n            name: \"ContractFunctionZeroDataError\"\\n          });\\n        }\\n      };\\n      CounterfactualDeploymentFailedError = class extends BaseError2 {\\n        constructor({ factory }) {\\n          super(`Deployment for counterfactual contract call failed${factory ? ` for factory \"${factory}\".` : \"\"}`, {\\n            metaMessages: [\\n              \"Please ensure:\",\\n              \"- The `factory` is a valid contract deployment factory (ie. Create2 Factory, ERC-4337 Factory, etc).\",\\n              \"- The `factoryData` is a valid encoded function call for contract deployment function on the factory.\"\\n            ],\\n            name: \"CounterfactualDeploymentFailedError\"\\n          });\\n        }\\n      };\\n      RawContractError = class extends BaseError2 {\\n        constructor({ data, message }) {\\n          super(message || \"\", { name: \"RawContractError\" });\\n          Object.defineProperty(this, \"code\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: 3\\n          });\\n          Object.defineProperty(this, \"data\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          this.data = data;\\n        }\\n      };\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/request.js\\n  var HttpRequestError, RpcRequestError, TimeoutError;\\n  var init_request = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/request.js\"() {\\n      init_stringify();\\n      init_base();\\n      init_utils3();\\n      HttpRequestError = class extends BaseError2 {\\n        constructor({ body, cause, details, headers, status, url }) {\\n          super(\"HTTP request failed.\", {\\n            cause,\\n            details,\\n            metaMessages: [\\n              status && `Status: ${status}`,\\n              `URL: ${getUrl(url)}`,\\n              body && `Request body: ${stringify(body)}`\\n            ].filter(Boolean),\\n            name: \"HttpRequestError\"\\n          });\\n          Object.defineProperty(this, \"body\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          Object.defineProperty(this, \"headers\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          Object.defineProperty(this, \"status\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          Object.defineProperty(this, \"url\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          this.body = body;\\n          this.headers = headers;\\n          this.status = status;\\n          this.url = url;\\n        }\\n      };\\n      RpcRequestError = class extends BaseError2 {\\n        constructor({ body, error, url }) {\\n          super(\"RPC Request failed.\", {\\n            cause: error,\\n            details: error.message,\\n            metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],\\n            name: \"RpcRequestError\"\\n          });\\n          Object.defineProperty(this, \"code\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          Object.defineProperty(this, \"data\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          this.code = error.code;\\n          this.data = error.data;\\n        }\\n      };\\n      TimeoutError = class extends BaseError2 {\\n        constructor({ body, url }) {\\n          super(\"The request took too long to respond.\", {\\n            details: \"The request timed out.\",\\n            metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],\\n            name: \"TimeoutError\"\\n          });\\n        }\\n      };\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/rpc.js\\n  var unknownErrorCode, RpcError, ProviderRpcError, ParseRpcError, InvalidRequestRpcError, MethodNotFoundRpcError, InvalidParamsRpcError, InternalRpcError, InvalidInputRpcError, ResourceNotFoundRpcError, ResourceUnavailableRpcError, TransactionRejectedRpcError, MethodNotSupportedRpcError, LimitExceededRpcError, JsonRpcVersionUnsupportedError, UserRejectedRequestError, UnauthorizedProviderError, UnsupportedProviderMethodError, ProviderDisconnectedError, ChainDisconnectedError, SwitchChainError, UnsupportedNonOptionalCapabilityError, UnsupportedChainIdError, DuplicateIdError, UnknownBundleIdError, BundleTooLargeError, AtomicReadyWalletRejectedUpgradeError, AtomicityNotSupportedError, UnknownRpcError;\\n  var init_rpc = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/rpc.js\"() {\\n      init_base();\\n      init_request();\\n      unknownErrorCode = -1;\\n      RpcError = class extends BaseError2 {\\n        constructor(cause, { code, docsPath: docsPath8, metaMessages, name, shortMessage }) {\\n          super(shortMessage, {\\n            cause,\\n            docsPath: docsPath8,\\n            metaMessages: metaMessages || cause?.metaMessages,\\n            name: name || \"RpcError\"\\n          });\\n          Object.defineProperty(this, \"code\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          this.name = name || cause.name;\\n          this.code = cause instanceof RpcRequestError ? cause.code : code ?? unknownErrorCode;\\n        }\\n      };\\n      ProviderRpcError = class extends RpcError {\\n        constructor(cause, options) {\\n          super(cause, options);\\n          Object.defineProperty(this, \"data\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: void 0\\n          });\\n          this.data = options.data;\\n        }\\n      };\\n      ParseRpcError = class _ParseRpcError extends RpcError {\\n        constructor(cause) {\\n          super(cause, {\\n            code: _ParseRpcError.code,\\n            name: \"ParseRpcError\",\\n            shortMessage: \"Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.\"\\n          });\\n        }\\n      };\\n      Object.defineProperty(ParseRpcError, \"code\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: -32700\\n      });\\n      InvalidRequestRpcError = class _InvalidRequestRpcError extends RpcError {\\n        constructor(cause) {\\n          super(cause, {\\n            code: _InvalidRequestRpcError.code,\\n            name: \"InvalidRequestRpcError\",\\n            shortMessage: \"JSON is not a valid request object.\"\\n          });\\n        }\\n      };\\n      Object.defineProperty(InvalidRequestRpcError, \"code\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: -32600\\n      });\\n      MethodNotFoundRpcError = class _MethodNotFoundRpcError extends RpcError {\\n        constructor(cause, { method } = {}) {\\n          super(cause, {\\n            code: _MethodNotFoundRpcError.code,\\n            name: \"MethodNotFoundRpcError\",\\n            shortMessage: `The method${method ? ` \"${method}\"` : \"\"} does not exist / is not available.`\\n          });\\n        }\\n      };\\n      Object.defineProperty(MethodNotFoundRpcError, \"code\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: -32601\\n      });\\n      InvalidParamsRpcError = class _InvalidParamsRpcError extends RpcError {\\n        constructor(cause) {\\n          super(cause, {\\n            code: _InvalidParamsRpcError.code,\\n            name: \"InvalidParamsRpcError\",\\n            shortMessage: [\\n              \"Invalid parameters were provided to the RPC method.\",\\n              \"Double check you have provided the correct parameters.\"\\n            ].join(\"\\\\n\")\\n          });\\n        }\\n      };\\n      Object.defineProperty(InvalidParamsRpcError, \"code\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: -32602\\n      });\\n      InternalRpcError = class _InternalRpcError extends RpcError {\\n        constructor(cause) {\\n          super(cause, {\\n            code: _InternalRpcError.code,\\n            name: \"InternalRpcError\",\\n            shortMessage: \"An internal error was received.\"\\n          });\\n        }\\n      };\\n      Object.defineProperty(InternalRpcError, \"code\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: -32603\\n      });\\n      InvalidInputRpcError = class _InvalidInputRpcError extends RpcError {\\n        constructor(cause) {\\n          super(cause, {\\n            code: _InvalidInputRpcError.code,\\n            name: \"InvalidInputRpcError\",\\n            shortMessage: [\\n              \"Missing or invalid parameters.\",\\n              \"Double check you have provided the correct parameters.\"\\n            ].join(\"\\\\n\")\\n          });\\n        }\\n      };\\n      Object.defineProperty(InvalidInputRpcError, \"code\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: -32e3\\n      });\\n      ResourceNotFoundRpcError = class _ResourceNotFoundRpcError extends RpcError {\\n        constructor(cause) {\\n          super(cause, {\\n            code: _ResourceNotFoundRpcError.code,\\n            name: \"ResourceNotFoundRpcError\",\\n            shortMessage: \"Requested resource not found.\"\\n          });\\n          Object.defineProperty(this, \"name\", {\\n            enumerable: true,\\n            configurable: true,\\n            writable: true,\\n            value: \"ResourceNotFoundRpcError\"\\n          });\\n        }\\n      };\\n      Object.defineProperty(ResourceNotFoundRpcError, \"code\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: -32001\\n      });\\n      ResourceUnavailableRpcError = class _ResourceUnavailableRpcError extends RpcError {\\n        constructor(cause) {\\n          super(cause, {\\n            code: _ResourceUnavailableRpcError.code,\\n            name: \"ResourceUnavailableRpcError\",\\n            shortMessage: \"Requested resource not available.\"\\n          });\\n        }\\n      };\\n      Object.defineProperty(ResourceUnavailableRpcError, \"code\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: -32002\\n      });\\n      TransactionRejectedRpcError = class _TransactionRejectedRpcError extends RpcError {\\n        constructor(cause) {\\n          super(cause, {\\n            code: _TransactionRejectedRpcError.code,\\n            name: \"TransactionRejectedRpcError\",\\n            shortMessage: \"Transaction creation failed.\"\\n          });\\n        }\\n      };\\n      Object.defineProperty(TransactionRejectedRpcError, \"code\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: -32003\\n      });\\n      MethodNotSupportedRpcError = class _MethodNotSupportedRpcError extends RpcError {\\n        constructor(cause, { method } = {}) {\\n          super(cause, {\\n            code: _MethodNotSupportedRpcError.code,\\n            name: \"MethodNotSupportedRpcError\",\\n            shortMessage: `Method${method ? ` \"${method}\"` : \"\"} is not supported.`\\n          });\\n        }\\n      };\\n      Object.defineProperty(MethodNotSupportedRpcError, \"code\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: -32004\\n      });\\n      LimitExceededRpcError = class _LimitExceededRpcError extends RpcError {\\n        constructor(cause) {\\n          super(cause, {\\n            code: _LimitExceededRpcError.code,\\n            name: \"LimitExceededRpcError\",\\n            shortMessage: \"Request exceeds defined limit.\"\\n          });\\n        }\\n      };\\n      Object.defineProperty(LimitExceededRpcError, \"code\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: -32005\\n      });\\n      JsonRpcVersionUnsupportedError = class _JsonRpcVersionUnsupportedError extends RpcError {\\n        constructor(cause) {\\n          super(cause, {\\n            code: _JsonRpcVersionUnsupportedError.code,\\n            name: \"JsonRpcVersionUnsupportedError\",\\n            shortMessage: \"Version of JSON-RPC protocol is not supported.\"\\n          });\\n        }\\n      };\\n      Object.defineProperty(JsonRpcVersionUnsupportedError, \"code\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: -32006\\n      });\\n      UserRejectedRequestError = class _UserRejectedRequestError extends ProviderRpcError {\\n        constructor(cause) {\\n          super(cause, {\\n            code: _UserRejectedRequestError.code,\\n            name: \"UserRejectedRequestError\",\\n            shortMessage: \"User rejected the request.\"\\n          });\\n        }\\n      };\\n      Object.defineProperty(UserRejectedRequestError, \"code\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: 4001\\n      });\\n      UnauthorizedProviderError = class _UnauthorizedProviderError extends ProviderRpcError {\\n        constructor(cause) {\\n          super(cause, {\\n            code: _UnauthorizedProviderError.code,\\n            name: \"UnauthorizedProviderError\",\\n            shortMessage: \"The requested method and/or account has not been authorized by the user.\"\\n          });\\n        }\\n      };\\n      Object.defineProperty(UnauthorizedProviderError, \"code\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: 4100\\n      });\\n      UnsupportedProviderMethodError = class _UnsupportedProviderMethodError extends ProviderRpcError {\\n        constructor(cause, { method } = {}) {\\n          super(cause, {\\n            code: _UnsupportedProviderMethodError.code,\\n            name: \"UnsupportedProviderMethodError\",\\n            shortMessage: `The Provider does not support the requested method${method ? ` \" ${method}\"` : \"\"}.`\\n          });\\n        }\\n      };\\n      Object.defineProperty(UnsupportedProviderMethodError, \"code\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: 4200\\n      });\\n      ProviderDisconnectedError = class _ProviderDisconnectedError extends ProviderRpcError {\\n        constructor(cause) {\\n          super(cause, {\\n            code: _ProviderDisconnectedError.code,\\n            name: \"ProviderDisconnectedError\",\\n            shortMessage: \"The Provider is disconnected from all chains.\"\\n          });\\n        }\\n      };\\n      Object.defineProperty(ProviderDisconnectedError, \"code\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: 4900\\n      });\\n      ChainDisconnectedError = class _ChainDisconnectedError extends ProviderRpcError {\\n        constructor(cause) {\\n          super(cause, {\\n            code: _ChainDisconnectedError.code,\\n            name: \"ChainDisconnectedError\",\\n            shortMessage: \"The Provider is not connected to the requested chain.\"\\n          });\\n        }\\n      };\\n      Object.defineProperty(ChainDisconnectedError, \"code\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: 4901\\n      });\\n      SwitchChainError = class _SwitchChainError extends ProviderRpcError {\\n        constructor(cause) {\\n          super(cause, {\\n            code: _SwitchChainError.code,\\n            name: \"SwitchChainError\",\\n            shortMessage: \"An error occurred when attempting to switch chain.\"\\n          });\\n        }\\n      };\\n      Object.defineProperty(SwitchChainError, \"code\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: 4902\\n      });\\n      UnsupportedNonOptionalCapabilityError = class _UnsupportedNonOptionalCapabilityError extends ProviderRpcError {\\n        constructor(cause) {\\n          super(cause, {\\n            code: _UnsupportedNonOptionalCapabilityError.code,\\n            name: \"UnsupportedNonOptionalCapabilityError\",\\n            shortMessage: \"This Wallet does not support a capability that was not marked as optional.\"\\n          });\\n        }\\n      };\\n      Object.defineProperty(UnsupportedNonOptionalCapabilityError, \"code\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: 5700\\n      });\\n      UnsupportedChainIdError = class _UnsupportedChainIdError extends ProviderRpcError {\\n        constructor(cause) {\\n          super(cause, {\\n            code: _UnsupportedChainIdError.code,\\n            name: \"UnsupportedChainIdError\",\\n            shortMessage: \"This Wallet does not support the requested chain ID.\"\\n          });\\n        }\\n      };\\n      Object.defineProperty(UnsupportedChainIdError, \"code\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: 5710\\n      });\\n      DuplicateIdError = class _DuplicateIdError extends ProviderRpcError {\\n        constructor(cause) {\\n          super(cause, {\\n            code: _DuplicateIdError.code,\\n            name: \"DuplicateIdError\",\\n            shortMessage: \"There is already a bundle submitted with this ID.\"\\n          });\\n        }\\n      };\\n      Object.defineProperty(DuplicateIdError, \"code\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: 5720\\n      });\\n      UnknownBundleIdError = class _UnknownBundleIdError extends ProviderRpcError {\\n        constructor(cause) {\\n          super(cause, {\\n            code: _UnknownBundleIdError.code,\\n            name: \"UnknownBundleIdError\",\\n            shortMessage: \"This bundle id is unknown / has not been submitted\"\\n          });\\n        }\\n      };\\n      Object.defineProperty(UnknownBundleIdError, \"code\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: 5730\\n      });\\n      BundleTooLargeError = class _BundleTooLargeError extends ProviderRpcError {\\n        constructor(cause) {\\n          super(cause, {\\n            code: _BundleTooLargeError.code,\\n            name: \"BundleTooLargeError\",\\n            shortMessage: \"The call bundle is too large for the Wallet to process.\"\\n          });\\n        }\\n      };\\n      Object.defineProperty(BundleTooLargeError, \"code\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: 5740\\n      });\\n      AtomicReadyWalletRejectedUpgradeError = class _AtomicReadyWalletRejectedUpgradeError extends ProviderRpcError {\\n        constructor(cause) {\\n          super(cause, {\\n            code: _AtomicReadyWalletRejectedUpgradeError.code,\\n            name: \"AtomicReadyWalletRejectedUpgradeError\",\\n            shortMessage: \"The Wallet can support atomicity after an upgrade, but the user rejected the upgrade.\"\\n          });\\n        }\\n      };\\n      Object.defineProperty(AtomicReadyWalletRejectedUpgradeError, \"code\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: 5750\\n      });\\n      AtomicityNotSupportedError = class _AtomicityNotSupportedError extends ProviderRpcError {\\n        constructor(cause) {\\n          super(cause, {\\n            code: _AtomicityNotSupportedError.code,\\n            name: \"AtomicityNotSupportedError\",\\n            shortMessage: \"The wallet does not support atomic execution but the request requires it.\"\\n          });\\n        }\\n      };\\n      Object.defineProperty(AtomicityNotSupportedError, \"code\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: 5760\\n      });\\n      UnknownRpcError = class extends RpcError {\\n        constructor(cause) {\\n          super(cause, {\\n            name: \"UnknownRpcError\",\\n            shortMessage: \"An unknown RPC error occurred.\"\\n          });\\n        }\\n      };\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/@noble+hashes@1.7.1/node_modules/@noble/hashes/esm/_md.js\\n  function setBigUint64(view, byteOffset, value, isLE3) {\\n    if (typeof view.setBigUint64 === \"function\")\\n      return view.setBigUint64(byteOffset, value, isLE3);\\n    const _32n3 = BigInt(32);\\n    const _u32_max = BigInt(4294967295);\\n    const wh = Number(value >> _32n3 & _u32_max);\\n    const wl = Number(value & _u32_max);\\n    const h = isLE3 ? 4 : 0;\\n    const l = isLE3 ? 0 : 4;\\n    view.setUint32(byteOffset + h, wh, isLE3);\\n    view.setUint32(byteOffset + l, wl, isLE3);\\n  }\\n  function Chi(a, b, c) {\\n    return a & b ^ ~a & c;\\n  }\\n  function Maj(a, b, c) {\\n    return a & b ^ a & c ^ b & c;\\n  }\\n  var HashMD;\\n  var init_md = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/@noble+hashes@1.7.1/node_modules/@noble/hashes/esm/_md.js\"() {\\n      init_assert();\\n      init_utils2();\\n      HashMD = class extends Hash {\\n        constructor(blockLen, outputLen, padOffset, isLE3) {\\n          super();\\n          this.blockLen = blockLen;\\n          this.outputLen = outputLen;\\n          this.padOffset = padOffset;\\n          this.isLE = isLE3;\\n          this.finished = false;\\n          this.length = 0;\\n          this.pos = 0;\\n          this.destroyed = false;\\n          this.buffer = new Uint8Array(blockLen);\\n          this.view = createView(this.buffer);\\n        }\\n        update(data) {\\n          aexists(this);\\n          const { view, buffer: buffer2, blockLen } = this;\\n          data = toBytes2(data);\\n          const len = data.length;\\n          for (let pos = 0; pos < len; ) {\\n            const take = Math.min(blockLen - this.pos, len - pos);\\n            if (take === blockLen) {\\n              const dataView = createView(data);\\n              for (; blockLen <= len - pos; pos += blockLen)\\n                this.process(dataView, pos);\\n              continue;\\n            }\\n            buffer2.set(data.subarray(pos, pos + take), this.pos);\\n            this.pos += take;\\n            pos += take;\\n            if (this.pos === blockLen) {\\n              this.process(view, 0);\\n              this.pos = 0;\\n            }\\n          }\\n          this.length += data.length;\\n          this.roundClean();\\n          return this;\\n        }\\n        digestInto(out) {\\n          aexists(this);\\n          aoutput(out, this);\\n          this.finished = true;\\n          const { buffer: buffer2, view, blockLen, isLE: isLE3 } = this;\\n          let { pos } = this;\\n          buffer2[pos++] = 128;\\n          this.buffer.subarray(pos).fill(0);\\n          if (this.padOffset > blockLen - pos) {\\n            this.process(view, 0);\\n            pos = 0;\\n          }\\n          for (let i = pos; i < blockLen; i++)\\n            buffer2[i] = 0;\\n          setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE3);\\n          this.process(view, 0);\\n          const oview = createView(out);\\n          const len = this.outputLen;\\n          if (len % 4)\\n            throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\\n          const outLen = len / 4;\\n          const state = this.get();\\n          if (outLen > state.length)\\n            throw new Error(\"_sha2: outputLen bigger than state\");\\n          for (let i = 0; i < outLen; i++)\\n            oview.setUint32(4 * i, state[i], isLE3);\\n        }\\n        digest() {\\n          const { buffer: buffer2, outputLen } = this;\\n          this.digestInto(buffer2);\\n          const res = buffer2.slice(0, outputLen);\\n          this.destroy();\\n          return res;\\n        }\\n        _cloneInto(to) {\\n          to || (to = new this.constructor());\\n          to.set(...this.get());\\n          const { blockLen, buffer: buffer2, length, finished, destroyed, pos } = this;\\n          to.length = length;\\n          to.pos = pos;\\n          to.finished = finished;\\n          to.destroyed = destroyed;\\n          if (length % blockLen)\\n            to.buffer.set(buffer2);\\n          return to;\\n        }\\n      };\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/@noble+hashes@1.7.1/node_modules/@noble/hashes/esm/sha256.js\\n  var SHA256_K, SHA256_IV, SHA256_W, SHA256, sha256;\\n  var init_sha256 = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/@noble+hashes@1.7.1/node_modules/@noble/hashes/esm/sha256.js\"() {\\n      init_md();\\n      init_utils2();\\n      SHA256_K = /* @__PURE__ */ new Uint32Array([\\n        1116352408,\\n        1899447441,\\n        3049323471,\\n        3921009573,\\n        961987163,\\n        1508970993,\\n        2453635748,\\n        2870763221,\\n        3624381080,\\n        310598401,\\n        607225278,\\n        1426881987,\\n        1925078388,\\n        2162078206,\\n        2614888103,\\n        3248222580,\\n        3835390401,\\n        4022224774,\\n        264347078,\\n        604807628,\\n        770255983,\\n        1249150122,\\n        1555081692,\\n        1996064986,\\n        2554220882,\\n        2821834349,\\n        2952996808,\\n        3210313671,\\n        3336571891,\\n        3584528711,\\n        113926993,\\n        338241895,\\n        666307205,\\n        773529912,\\n        1294757372,\\n        1396182291,\\n        1695183700,\\n        1986661051,\\n        2177026350,\\n        2456956037,\\n        2730485921,\\n        2820302411,\\n        3259730800,\\n        3345764771,\\n        3516065817,\\n        3600352804,\\n        4094571909,\\n        275423344,\\n        430227734,\\n        506948616,\\n        659060556,\\n        883997877,\\n        958139571,\\n        1322822218,\\n        1537002063,\\n        1747873779,\\n        1955562222,\\n        2024104815,\\n        2227730452,\\n        2361852424,\\n        2428436474,\\n        2756734187,\\n        3204031479,\\n        3329325298\\n      ]);\\n      SHA256_IV = /* @__PURE__ */ new Uint32Array([\\n        1779033703,\\n        3144134277,\\n        1013904242,\\n        2773480762,\\n        1359893119,\\n        2600822924,\\n        528734635,\\n        1541459225\\n      ]);\\n      SHA256_W = /* @__PURE__ */ new Uint32Array(64);\\n      SHA256 = class extends HashMD {\\n        constructor() {\\n          super(64, 32, 8, false);\\n          this.A = SHA256_IV[0] | 0;\\n          this.B = SHA256_IV[1] | 0;\\n          this.C = SHA256_IV[2] | 0;\\n          this.D = SHA256_IV[3] | 0;\\n          this.E = SHA256_IV[4] | 0;\\n          this.F = SHA256_IV[5] | 0;\\n          this.G = SHA256_IV[6] | 0;\\n          this.H = SHA256_IV[7] | 0;\\n        }\\n        get() {\\n          const { A, B, C, D, E, F, G, H } = this;\\n          return [A, B, C, D, E, F, G, H];\\n        }\\n        // prettier-ignore\\n        set(A, B, C, D, E, F, G, H) {\\n          this.A = A | 0;\\n          this.B = B | 0;\\n          this.C = C | 0;\\n          this.D = D | 0;\\n          this.E = E | 0;\\n          this.F = F | 0;\\n          this.G = G | 0;\\n          this.H = H | 0;\\n        }\\n        process(view, offset) {\\n          for (let i = 0; i < 16; i++, offset += 4)\\n            SHA256_W[i] = view.getUint32(offset, false);\\n          for (let i = 16; i < 64; i++) {\\n            const W15 = SHA256_W[i - 15];\\n            const W2 = SHA256_W[i - 2];\\n            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;\\n            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;\\n            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;\\n          }\\n          let { A, B, C, D, E, F, G, H } = this;\\n          for (let i = 0; i < 64; i++) {\\n            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\\n            const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;\\n            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\\n            const T2 = sigma0 + Maj(A, B, C) | 0;\\n            H = G;\\n            G = F;\\n            F = E;\\n            E = D + T1 | 0;\\n            D = C;\\n            C = B;\\n            B = A;\\n            A = T1 + T2 | 0;\\n          }\\n          A = A + this.A | 0;\\n          B = B + this.B | 0;\\n          C = C + this.C | 0;\\n          D = D + this.D | 0;\\n          E = E + this.E | 0;\\n          F = F + this.F | 0;\\n          G = G + this.G | 0;\\n          H = H + this.H | 0;\\n          this.set(A, B, C, D, E, F, G, H);\\n        }\\n        roundClean() {\\n          SHA256_W.fill(0);\\n        }\\n        destroy() {\\n          this.set(0, 0, 0, 0, 0, 0, 0, 0);\\n          this.buffer.fill(0);\\n        }\\n      };\\n      sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/@noble+hashes@1.7.1/node_modules/@noble/hashes/esm/hmac.js\\n  var HMAC, hmac;\\n  var init_hmac = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/@noble+hashes@1.7.1/node_modules/@noble/hashes/esm/hmac.js\"() {\\n      init_assert();\\n      init_utils2();\\n      HMAC = class extends Hash {\\n        constructor(hash2, _key) {\\n          super();\\n          this.finished = false;\\n          this.destroyed = false;\\n          ahash(hash2);\\n          const key = toBytes2(_key);\\n          this.iHash = hash2.create();\\n          if (typeof this.iHash.update !== \"function\")\\n            throw new Error(\"Expected instance of class which extends utils.Hash\");\\n          this.blockLen = this.iHash.blockLen;\\n          this.outputLen = this.iHash.outputLen;\\n          const blockLen = this.blockLen;\\n          const pad4 = new Uint8Array(blockLen);\\n          pad4.set(key.length > blockLen ? hash2.create().update(key).digest() : key);\\n          for (let i = 0; i < pad4.length; i++)\\n            pad4[i] ^= 54;\\n          this.iHash.update(pad4);\\n          this.oHash = hash2.create();\\n          for (let i = 0; i < pad4.length; i++)\\n            pad4[i] ^= 54 ^ 92;\\n          this.oHash.update(pad4);\\n          pad4.fill(0);\\n        }\\n        update(buf) {\\n          aexists(this);\\n          this.iHash.update(buf);\\n          return this;\\n        }\\n        digestInto(out) {\\n          aexists(this);\\n          abytes(out, this.outputLen);\\n          this.finished = true;\\n          this.iHash.digestInto(out);\\n          this.oHash.update(out);\\n          this.oHash.digestInto(out);\\n          this.destroy();\\n        }\\n        digest() {\\n          const out = new Uint8Array(this.oHash.outputLen);\\n          this.digestInto(out);\\n          return out;\\n        }\\n        _cloneInto(to) {\\n          to || (to = Object.create(Object.getPrototypeOf(this), {}));\\n          const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\\n          to = to;\\n          to.finished = finished;\\n          to.destroyed = destroyed;\\n          to.blockLen = blockLen;\\n          to.outputLen = outputLen;\\n          to.oHash = oHash._cloneInto(to.oHash);\\n          to.iHash = iHash._cloneInto(to.iHash);\\n          return to;\\n        }\\n        destroy() {\\n          this.destroyed = true;\\n          this.oHash.destroy();\\n          this.iHash.destroy();\\n        }\\n      };\\n      hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();\\n      hmac.create = (hash2, key) => new HMAC(hash2, key);\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/@noble+curves@1.8.1/node_modules/@noble/curves/esm/abstract/utils.js\\n  var utils_exports = {};\\n  __export(utils_exports, {\\n    aInRange: () => aInRange,\\n    abool: () => abool,\\n    abytes: () => abytes2,\\n    bitGet: () => bitGet,\\n    bitLen: () => bitLen,\\n    bitMask: () => bitMask,\\n    bitSet: () => bitSet,\\n    bytesToHex: () => bytesToHex2,\\n    bytesToNumberBE: () => bytesToNumberBE,\\n    bytesToNumberLE: () => bytesToNumberLE,\\n    concatBytes: () => concatBytes3,\\n    createHmacDrbg: () => createHmacDrbg,\\n    ensureBytes: () => ensureBytes,\\n    equalBytes: () => equalBytes,\\n    hexToBytes: () => hexToBytes2,\\n    hexToNumber: () => hexToNumber2,\\n    inRange: () => inRange,\\n    isBytes: () => isBytes2,\\n    memoized: () => memoized,\\n    notImplemented: () => notImplemented,\\n    numberToBytesBE: () => numberToBytesBE,\\n    numberToBytesLE: () => numberToBytesLE,\\n    numberToHexUnpadded: () => numberToHexUnpadded,\\n    numberToVarBytesBE: () => numberToVarBytesBE,\\n    utf8ToBytes: () => utf8ToBytes2,\\n    validateObject: () => validateObject\\n  });\\n  function isBytes2(a) {\\n    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === \"Uint8Array\";\\n  }\\n  function abytes2(item) {\\n    if (!isBytes2(item))\\n      throw new Error(\"Uint8Array expected\");\\n  }\\n  function abool(title, value) {\\n    if (typeof value !== \"boolean\")\\n      throw new Error(title + \" boolean expected, got \" + value);\\n  }\\n  function bytesToHex2(bytes) {\\n    abytes2(bytes);\\n    let hex = \"\";\\n    for (let i = 0; i < bytes.length; i++) {\\n      hex += hexes2[bytes[i]];\\n    }\\n    return hex;\\n  }\\n  function numberToHexUnpadded(num2) {\\n    const hex = num2.toString(16);\\n    return hex.length & 1 ? \"0\" + hex : hex;\\n  }\\n  function hexToNumber2(hex) {\\n    if (typeof hex !== \"string\")\\n      throw new Error(\"hex string expected, got \" + typeof hex);\\n    return hex === \"\" ? _0n2 : BigInt(\"0x\" + hex);\\n  }\\n  function asciiToBase16(ch) {\\n    if (ch >= asciis._0 && ch <= asciis._9)\\n      return ch - asciis._0;\\n    if (ch >= asciis.A && ch <= asciis.F)\\n      return ch - (asciis.A - 10);\\n    if (ch >= asciis.a && ch <= asciis.f)\\n      return ch - (asciis.a - 10);\\n    return;\\n  }\\n  function hexToBytes2(hex) {\\n    if (typeof hex !== \"string\")\\n      throw new Error(\"hex string expected, got \" + typeof hex);\\n    const hl = hex.length;\\n    const al = hl / 2;\\n    if (hl % 2)\\n      throw new Error(\"hex string expected, got unpadded hex of length \" + hl);\\n    const array = new Uint8Array(al);\\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\\n      const n1 = asciiToBase16(hex.charCodeAt(hi));\\n      const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\\n      if (n1 === void 0 || n2 === void 0) {\\n        const char = hex[hi] + hex[hi + 1];\\n        throw new Error(\\'hex string expected, got non-hex character \"\\' + char + \\'\" at index \\' + hi);\\n      }\\n      array[ai] = n1 * 16 + n2;\\n    }\\n    return array;\\n  }\\n  function bytesToNumberBE(bytes) {\\n    return hexToNumber2(bytesToHex2(bytes));\\n  }\\n  function bytesToNumberLE(bytes) {\\n    abytes2(bytes);\\n    return hexToNumber2(bytesToHex2(Uint8Array.from(bytes).reverse()));\\n  }\\n  function numberToBytesBE(n, len) {\\n    return hexToBytes2(n.toString(16).padStart(len * 2, \"0\"));\\n  }\\n  function numberToBytesLE(n, len) {\\n    return numberToBytesBE(n, len).reverse();\\n  }\\n  function numberToVarBytesBE(n) {\\n    return hexToBytes2(numberToHexUnpadded(n));\\n  }\\n  function ensureBytes(title, hex, expectedLength) {\\n    let res;\\n    if (typeof hex === \"string\") {\\n      try {\\n        res = hexToBytes2(hex);\\n      } catch (e) {\\n        throw new Error(title + \" must be hex string or Uint8Array, cause: \" + e);\\n      }\\n    } else if (isBytes2(hex)) {\\n      res = Uint8Array.from(hex);\\n    } else {\\n      throw new Error(title + \" must be hex string or Uint8Array\");\\n    }\\n    const len = res.length;\\n    if (typeof expectedLength === \"number\" && len !== expectedLength)\\n      throw new Error(title + \" of length \" + expectedLength + \" expected, got \" + len);\\n    return res;\\n  }\\n  function concatBytes3(...arrays) {\\n    let sum = 0;\\n    for (let i = 0; i < arrays.length; i++) {\\n      const a = arrays[i];\\n      abytes2(a);\\n      sum += a.length;\\n    }\\n    const res = new Uint8Array(sum);\\n    for (let i = 0, pad4 = 0; i < arrays.length; i++) {\\n      const a = arrays[i];\\n      res.set(a, pad4);\\n      pad4 += a.length;\\n    }\\n    return res;\\n  }\\n  function equalBytes(a, b) {\\n    if (a.length !== b.length)\\n      return false;\\n    let diff = 0;\\n    for (let i = 0; i < a.length; i++)\\n      diff |= a[i] ^ b[i];\\n    return diff === 0;\\n  }\\n  function utf8ToBytes2(str) {\\n    if (typeof str !== \"string\")\\n      throw new Error(\"string expected\");\\n    return new Uint8Array(new TextEncoder().encode(str));\\n  }\\n  function inRange(n, min, max) {\\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\\n  }\\n  function aInRange(title, n, min, max) {\\n    if (!inRange(n, min, max))\\n      throw new Error(\"expected valid \" + title + \": \" + min + \" <= n < \" + max + \", got \" + n);\\n  }\\n  function bitLen(n) {\\n    let len;\\n    for (len = 0; n > _0n2; n >>= _1n2, len += 1)\\n      ;\\n    return len;\\n  }\\n  function bitGet(n, pos) {\\n    return n >> BigInt(pos) & _1n2;\\n  }\\n  function bitSet(n, pos, value) {\\n    return n | (value ? _1n2 : _0n2) << BigInt(pos);\\n  }\\n  function createHmacDrbg(hashLen, qByteLen, hmacFn) {\\n    if (typeof hashLen !== \"number\" || hashLen < 2)\\n      throw new Error(\"hashLen must be a number\");\\n    if (typeof qByteLen !== \"number\" || qByteLen < 2)\\n      throw new Error(\"qByteLen must be a number\");\\n    if (typeof hmacFn !== \"function\")\\n      throw new Error(\"hmacFn must be a function\");\\n    let v = u8n(hashLen);\\n    let k = u8n(hashLen);\\n    let i = 0;\\n    const reset = () => {\\n      v.fill(1);\\n      k.fill(0);\\n      i = 0;\\n    };\\n    const h = (...b) => hmacFn(k, v, ...b);\\n    const reseed = (seed = u8n()) => {\\n      k = h(u8fr([0]), seed);\\n      v = h();\\n      if (seed.length === 0)\\n        return;\\n      k = h(u8fr([1]), seed);\\n      v = h();\\n    };\\n    const gen3 = () => {\\n      if (i++ >= 1e3)\\n        throw new Error(\"drbg: tried 1000 values\");\\n      let len = 0;\\n      const out = [];\\n      while (len < qByteLen) {\\n        v = h();\\n        const sl = v.slice();\\n        out.push(sl);\\n        len += v.length;\\n      }\\n      return concatBytes3(...out);\\n    };\\n    const genUntil = (seed, pred) => {\\n      reset();\\n      reseed(seed);\\n      let res = void 0;\\n      while (!(res = pred(gen3())))\\n        reseed();\\n      reset();\\n      return res;\\n    };\\n    return genUntil;\\n  }\\n  function validateObject(object, validators, optValidators = {}) {\\n    const checkField = (fieldName, type, isOptional) => {\\n      const checkVal = validatorFns[type];\\n      if (typeof checkVal !== \"function\")\\n        throw new Error(\"invalid validator function\");\\n      const val = object[fieldName];\\n      if (isOptional && val === void 0)\\n        return;\\n      if (!checkVal(val, object)) {\\n        throw new Error(\"param \" + String(fieldName) + \" is invalid. Expected \" + type + \", got \" + val);\\n      }\\n    };\\n    for (const [fieldName, type] of Object.entries(validators))\\n      checkField(fieldName, type, false);\\n    for (const [fieldName, type] of Object.entries(optValidators))\\n      checkField(fieldName, type, true);\\n    return object;\\n  }\\n  function memoized(fn) {\\n    const map = /* @__PURE__ */ new WeakMap();\\n    return (arg, ...args) => {\\n      const val = map.get(arg);\\n      if (val !== void 0)\\n        return val;\\n      const computed = fn(arg, ...args);\\n      map.set(arg, computed);\\n      return computed;\\n    };\\n  }\\n  var _0n2, _1n2, _2n2, hexes2, asciis, isPosBig, bitMask, u8n, u8fr, validatorFns, notImplemented;\\n  var init_utils4 = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/@noble+curves@1.8.1/node_modules/@noble/curves/esm/abstract/utils.js\"() {\\n      _0n2 = /* @__PURE__ */ BigInt(0);\\n      _1n2 = /* @__PURE__ */ BigInt(1);\\n      _2n2 = /* @__PURE__ */ BigInt(2);\\n      hexes2 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, \"0\"));\\n      asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\\n      isPosBig = (n) => typeof n === \"bigint\" && _0n2 <= n;\\n      bitMask = (n) => (_2n2 << BigInt(n - 1)) - _1n2;\\n      u8n = (data) => new Uint8Array(data);\\n      u8fr = (arr) => Uint8Array.from(arr);\\n      validatorFns = {\\n        bigint: (val) => typeof val === \"bigint\",\\n        function: (val) => typeof val === \"function\",\\n        boolean: (val) => typeof val === \"boolean\",\\n        string: (val) => typeof val === \"string\",\\n        stringOrUint8Array: (val) => typeof val === \"string\" || isBytes2(val),\\n        isSafeInteger: (val) => Number.isSafeInteger(val),\\n        array: (val) => Array.isArray(val),\\n        field: (val, object) => object.Fp.isValid(val),\\n        hash: (val) => typeof val === \"function\" && Number.isSafeInteger(val.outputLen)\\n      };\\n      notImplemented = () => {\\n        throw new Error(\"not implemented\");\\n      };\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/@noble+curves@1.8.1/node_modules/@noble/curves/esm/abstract/modular.js\\n  function mod(a, b) {\\n    const result = a % b;\\n    return result >= _0n3 ? result : b + result;\\n  }\\n  function pow(num2, power, modulo) {\\n    if (power < _0n3)\\n      throw new Error(\"invalid exponent, negatives unsupported\");\\n    if (modulo <= _0n3)\\n      throw new Error(\"invalid modulus\");\\n    if (modulo === _1n3)\\n      return _0n3;\\n    let res = _1n3;\\n    while (power > _0n3) {\\n      if (power & _1n3)\\n        res = res * num2 % modulo;\\n      num2 = num2 * num2 % modulo;\\n      power >>= _1n3;\\n    }\\n    return res;\\n  }\\n  function pow2(x, power, modulo) {\\n    let res = x;\\n    while (power-- > _0n3) {\\n      res *= res;\\n      res %= modulo;\\n    }\\n    return res;\\n  }\\n  function invert(number, modulo) {\\n    if (number === _0n3)\\n      throw new Error(\"invert: expected non-zero number\");\\n    if (modulo <= _0n3)\\n      throw new Error(\"invert: expected positive modulus, got \" + modulo);\\n    let a = mod(number, modulo);\\n    let b = modulo;\\n    let x = _0n3, y = _1n3, u = _1n3, v = _0n3;\\n    while (a !== _0n3) {\\n      const q = b / a;\\n      const r = b % a;\\n      const m = x - u * q;\\n      const n = y - v * q;\\n      b = a, a = r, x = u, y = v, u = m, v = n;\\n    }\\n    const gcd = b;\\n    if (gcd !== _1n3)\\n      throw new Error(\"invert: does not exist\");\\n    return mod(x, modulo);\\n  }\\n  function tonelliShanks(P) {\\n    const legendreC = (P - _1n3) / _2n3;\\n    let Q, S, Z;\\n    for (Q = P - _1n3, S = 0; Q % _2n3 === _0n3; Q /= _2n3, S++)\\n      ;\\n    for (Z = _2n3; Z < P && pow(Z, legendreC, P) !== P - _1n3; Z++) {\\n      if (Z > 1e3)\\n        throw new Error(\"Cannot find square root: likely non-prime P\");\\n    }\\n    if (S === 1) {\\n      const p1div4 = (P + _1n3) / _4n;\\n      return function tonelliFast(Fp, n) {\\n        const root = Fp.pow(n, p1div4);\\n        if (!Fp.eql(Fp.sqr(root), n))\\n          throw new Error(\"Cannot find square root\");\\n        return root;\\n      };\\n    }\\n    const Q1div2 = (Q + _1n3) / _2n3;\\n    return function tonelliSlow(Fp, n) {\\n      if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\\n        throw new Error(\"Cannot find square root\");\\n      let r = S;\\n      let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);\\n      let x = Fp.pow(n, Q1div2);\\n      let b = Fp.pow(n, Q);\\n      while (!Fp.eql(b, Fp.ONE)) {\\n        if (Fp.eql(b, Fp.ZERO))\\n          return Fp.ZERO;\\n        let m = 1;\\n        for (let t2 = Fp.sqr(b); m < r; m++) {\\n          if (Fp.eql(t2, Fp.ONE))\\n            break;\\n          t2 = Fp.sqr(t2);\\n        }\\n        const ge = Fp.pow(g, _1n3 << BigInt(r - m - 1));\\n        g = Fp.sqr(ge);\\n        x = Fp.mul(x, ge);\\n        b = Fp.mul(b, g);\\n        r = m;\\n      }\\n      return x;\\n    };\\n  }\\n  function FpSqrt(P) {\\n    if (P % _4n === _3n) {\\n      const p1div4 = (P + _1n3) / _4n;\\n      return function sqrt3mod4(Fp, n) {\\n        const root = Fp.pow(n, p1div4);\\n        if (!Fp.eql(Fp.sqr(root), n))\\n          throw new Error(\"Cannot find square root\");\\n        return root;\\n      };\\n    }\\n    if (P % _8n === _5n) {\\n      const c1 = (P - _5n) / _8n;\\n      return function sqrt5mod8(Fp, n) {\\n        const n2 = Fp.mul(n, _2n3);\\n        const v = Fp.pow(n2, c1);\\n        const nv = Fp.mul(n, v);\\n        const i = Fp.mul(Fp.mul(nv, _2n3), v);\\n        const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\\n        if (!Fp.eql(Fp.sqr(root), n))\\n          throw new Error(\"Cannot find square root\");\\n        return root;\\n      };\\n    }\\n    if (P % _16n === _9n) {\\n    }\\n    return tonelliShanks(P);\\n  }\\n  function validateField(field) {\\n    const initial = {\\n      ORDER: \"bigint\",\\n      MASK: \"bigint\",\\n      BYTES: \"isSafeInteger\",\\n      BITS: \"isSafeInteger\"\\n    };\\n    const opts = FIELD_FIELDS.reduce((map, val) => {\\n      map[val] = \"function\";\\n      return map;\\n    }, initial);\\n    return validateObject(field, opts);\\n  }\\n  function FpPow(f, num2, power) {\\n    if (power < _0n3)\\n      throw new Error(\"invalid exponent, negatives unsupported\");\\n    if (power === _0n3)\\n      return f.ONE;\\n    if (power === _1n3)\\n      return num2;\\n    let p = f.ONE;\\n    let d = num2;\\n    while (power > _0n3) {\\n      if (power & _1n3)\\n        p = f.mul(p, d);\\n      d = f.sqr(d);\\n      power >>= _1n3;\\n    }\\n    return p;\\n  }\\n  function FpInvertBatch(f, nums) {\\n    const tmp = new Array(nums.length);\\n    const lastMultiplied = nums.reduce((acc, num2, i) => {\\n      if (f.is0(num2))\\n        return acc;\\n      tmp[i] = acc;\\n      return f.mul(acc, num2);\\n    }, f.ONE);\\n    const inverted = f.inv(lastMultiplied);\\n    nums.reduceRight((acc, num2, i) => {\\n      if (f.is0(num2))\\n        return acc;\\n      tmp[i] = f.mul(acc, tmp[i]);\\n      return f.mul(acc, num2);\\n    }, inverted);\\n    return tmp;\\n  }\\n  function nLength(n, nBitLength) {\\n    const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;\\n    const nByteLength = Math.ceil(_nBitLength / 8);\\n    return { nBitLength: _nBitLength, nByteLength };\\n  }\\n  function Field(ORDER, bitLen2, isLE3 = false, redef = {}) {\\n    if (ORDER <= _0n3)\\n      throw new Error(\"invalid field: expected ORDER > 0, got \" + ORDER);\\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);\\n    if (BYTES > 2048)\\n      throw new Error(\"invalid field: expected ORDER of <= 2048 bytes\");\\n    let sqrtP;\\n    const f = Object.freeze({\\n      ORDER,\\n      isLE: isLE3,\\n      BITS,\\n      BYTES,\\n      MASK: bitMask(BITS),\\n      ZERO: _0n3,\\n      ONE: _1n3,\\n      create: (num2) => mod(num2, ORDER),\\n      isValid: (num2) => {\\n        if (typeof num2 !== \"bigint\")\\n          throw new Error(\"invalid field element: expected bigint, got \" + typeof num2);\\n        return _0n3 <= num2 && num2 < ORDER;\\n      },\\n      is0: (num2) => num2 === _0n3,\\n      isOdd: (num2) => (num2 & _1n3) === _1n3,\\n      neg: (num2) => mod(-num2, ORDER),\\n      eql: (lhs, rhs) => lhs === rhs,\\n      sqr: (num2) => mod(num2 * num2, ORDER),\\n      add: (lhs, rhs) => mod(lhs + rhs, ORDER),\\n      sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\\n      mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\\n      pow: (num2, power) => FpPow(f, num2, power),\\n      div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\\n      // Same as above, but doesn\\'t normalize\\n      sqrN: (num2) => num2 * num2,\\n      addN: (lhs, rhs) => lhs + rhs,\\n      subN: (lhs, rhs) => lhs - rhs,\\n      mulN: (lhs, rhs) => lhs * rhs,\\n      inv: (num2) => invert(num2, ORDER),\\n      sqrt: redef.sqrt || ((n) => {\\n        if (!sqrtP)\\n          sqrtP = FpSqrt(ORDER);\\n        return sqrtP(f, n);\\n      }),\\n      invertBatch: (lst) => FpInvertBatch(f, lst),\\n      // TODO: do we really need constant cmov?\\n      // We don\\'t have const-time bigints anyway, so probably will be not very useful\\n      cmov: (a, b, c) => c ? b : a,\\n      toBytes: (num2) => isLE3 ? numberToBytesLE(num2, BYTES) : numberToBytesBE(num2, BYTES),\\n      fromBytes: (bytes) => {\\n        if (bytes.length !== BYTES)\\n          throw new Error(\"Field.fromBytes: expected \" + BYTES + \" bytes, got \" + bytes.length);\\n        return isLE3 ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\\n      }\\n    });\\n    return Object.freeze(f);\\n  }\\n  function getFieldBytesLength(fieldOrder) {\\n    if (typeof fieldOrder !== \"bigint\")\\n      throw new Error(\"field order must be bigint\");\\n    const bitLength = fieldOrder.toString(2).length;\\n    return Math.ceil(bitLength / 8);\\n  }\\n  function getMinHashLength(fieldOrder) {\\n    const length = getFieldBytesLength(fieldOrder);\\n    return length + Math.ceil(length / 2);\\n  }\\n  function mapHashToField(key, fieldOrder, isLE3 = false) {\\n    const len = key.length;\\n    const fieldLen = getFieldBytesLength(fieldOrder);\\n    const minLen = getMinHashLength(fieldOrder);\\n    if (len < 16 || len < minLen || len > 1024)\\n      throw new Error(\"expected \" + minLen + \"-1024 bytes of input, got \" + len);\\n    const num2 = isLE3 ? bytesToNumberLE(key) : bytesToNumberBE(key);\\n    const reduced = mod(num2, fieldOrder - _1n3) + _1n3;\\n    return isLE3 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\\n  }\\n  var _0n3, _1n3, _2n3, _3n, _4n, _5n, _8n, _9n, _16n, FIELD_FIELDS;\\n  var init_modular = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/@noble+curves@1.8.1/node_modules/@noble/curves/esm/abstract/modular.js\"() {\\n      init_utils4();\\n      _0n3 = BigInt(0);\\n      _1n3 = BigInt(1);\\n      _2n3 = /* @__PURE__ */ BigInt(2);\\n      _3n = /* @__PURE__ */ BigInt(3);\\n      _4n = /* @__PURE__ */ BigInt(4);\\n      _5n = /* @__PURE__ */ BigInt(5);\\n      _8n = /* @__PURE__ */ BigInt(8);\\n      _9n = /* @__PURE__ */ BigInt(9);\\n      _16n = /* @__PURE__ */ BigInt(16);\\n      FIELD_FIELDS = [\\n        \"create\",\\n        \"isValid\",\\n        \"is0\",\\n        \"neg\",\\n        \"inv\",\\n        \"sqrt\",\\n        \"sqr\",\\n        \"eql\",\\n        \"add\",\\n        \"sub\",\\n        \"mul\",\\n        \"pow\",\\n        \"div\",\\n        \"addN\",\\n        \"subN\",\\n        \"mulN\",\\n        \"sqrN\"\\n      ];\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/@noble+curves@1.8.1/node_modules/@noble/curves/esm/abstract/curve.js\\n  function constTimeNegate(condition, item) {\\n    const neg = item.negate();\\n    return condition ? neg : item;\\n  }\\n  function validateW(W, bits) {\\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\\n      throw new Error(\"invalid window size, expected [1..\" + bits + \"], got W=\" + W);\\n  }\\n  function calcWOpts(W, bits) {\\n    validateW(W, bits);\\n    const windows = Math.ceil(bits / W) + 1;\\n    const windowSize = 2 ** (W - 1);\\n    return { windows, windowSize };\\n  }\\n  function validateMSMPoints(points, c) {\\n    if (!Array.isArray(points))\\n      throw new Error(\"array expected\");\\n    points.forEach((p, i) => {\\n      if (!(p instanceof c))\\n        throw new Error(\"invalid point at index \" + i);\\n    });\\n  }\\n  function validateMSMScalars(scalars, field) {\\n    if (!Array.isArray(scalars))\\n      throw new Error(\"array of scalars expected\");\\n    scalars.forEach((s, i) => {\\n      if (!field.isValid(s))\\n        throw new Error(\"invalid scalar at index \" + i);\\n    });\\n  }\\n  function getW(P) {\\n    return pointWindowSizes.get(P) || 1;\\n  }\\n  function wNAF(c, bits) {\\n    return {\\n      constTimeNegate,\\n      hasPrecomputes(elm) {\\n        return getW(elm) !== 1;\\n      },\\n      // non-const time multiplication ladder\\n      unsafeLadder(elm, n, p = c.ZERO) {\\n        let d = elm;\\n        while (n > _0n4) {\\n          if (n & _1n4)\\n            p = p.add(d);\\n          d = d.double();\\n          n >>= _1n4;\\n        }\\n        return p;\\n      },\\n      /**\\n       * Creates a wNAF precomputation window. Used for caching.\\n       * Default window size is set by `utils.precompute()` and is equal to 8.\\n       * Number of precomputed points depends on the curve size:\\n       * 2^(\\u{1D44A}\\u22121) * (Math.ceil(\\u{1D45B} / \\u{1D44A}) + 1), where:\\n       * - \\u{1D44A} is the window size\\n       * - \\u{1D45B} is the bitlength of the curve order.\\n       * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\\n       * @param elm Point instance\\n       * @param W window size\\n       * @returns precomputed point tables flattened to a single array\\n       */\\n      precomputeWindow(elm, W) {\\n        const { windows, windowSize } = calcWOpts(W, bits);\\n        const points = [];\\n        let p = elm;\\n        let base2 = p;\\n        for (let window2 = 0; window2 < windows; window2++) {\\n          base2 = p;\\n          points.push(base2);\\n          for (let i = 1; i < windowSize; i++) {\\n            base2 = base2.add(p);\\n            points.push(base2);\\n          }\\n          p = base2.double();\\n        }\\n        return points;\\n      },\\n      /**\\n       * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\\n       * @param W window size\\n       * @param precomputes precomputed tables\\n       * @param n scalar (we don\\'t check here, but should be less than curve order)\\n       * @returns real and fake (for const-time) points\\n       */\\n      wNAF(W, precomputes, n) {\\n        const { windows, windowSize } = calcWOpts(W, bits);\\n        let p = c.ZERO;\\n        let f = c.BASE;\\n        const mask = BigInt(2 ** W - 1);\\n        const maxNumber = 2 ** W;\\n        const shiftBy = BigInt(W);\\n        for (let window2 = 0; window2 < windows; window2++) {\\n          const offset = window2 * windowSize;\\n          let wbits = Number(n & mask);\\n          n >>= shiftBy;\\n          if (wbits > windowSize) {\\n            wbits -= maxNumber;\\n            n += _1n4;\\n          }\\n          const offset1 = offset;\\n          const offset2 = offset + Math.abs(wbits) - 1;\\n          const cond1 = window2 % 2 !== 0;\\n          const cond2 = wbits < 0;\\n          if (wbits === 0) {\\n            f = f.add(constTimeNegate(cond1, precomputes[offset1]));\\n          } else {\\n            p = p.add(constTimeNegate(cond2, precomputes[offset2]));\\n          }\\n        }\\n        return { p, f };\\n      },\\n      /**\\n       * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\\n       * @param W window size\\n       * @param precomputes precomputed tables\\n       * @param n scalar (we don\\'t check here, but should be less than curve order)\\n       * @param acc accumulator point to add result of multiplication\\n       * @returns point\\n       */\\n      wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {\\n        const { windows, windowSize } = calcWOpts(W, bits);\\n        const mask = BigInt(2 ** W - 1);\\n        const maxNumber = 2 ** W;\\n        const shiftBy = BigInt(W);\\n        for (let window2 = 0; window2 < windows; window2++) {\\n          const offset = window2 * windowSize;\\n          if (n === _0n4)\\n            break;\\n          let wbits = Number(n & mask);\\n          n >>= shiftBy;\\n          if (wbits > windowSize) {\\n            wbits -= maxNumber;\\n            n += _1n4;\\n          }\\n          if (wbits === 0)\\n            continue;\\n          let curr = precomputes[offset + Math.abs(wbits) - 1];\\n          if (wbits < 0)\\n            curr = curr.negate();\\n          acc = acc.add(curr);\\n        }\\n        return acc;\\n      },\\n      getPrecomputes(W, P, transform) {\\n        let comp = pointPrecomputes.get(P);\\n        if (!comp) {\\n          comp = this.precomputeWindow(P, W);\\n          if (W !== 1)\\n            pointPrecomputes.set(P, transform(comp));\\n        }\\n        return comp;\\n      },\\n      wNAFCached(P, n, transform) {\\n        const W = getW(P);\\n        return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\\n      },\\n      wNAFCachedUnsafe(P, n, transform, prev) {\\n        const W = getW(P);\\n        if (W === 1)\\n          return this.unsafeLadder(P, n, prev);\\n        return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\\n      },\\n      // We calculate precomputes for elliptic curve point multiplication\\n      // using windowed method. This specifies window size and\\n      // stores precomputed values. Usually only base point would be precomputed.\\n      setWindowSize(P, W) {\\n        validateW(W, bits);\\n        pointWindowSizes.set(P, W);\\n        pointPrecomputes.delete(P);\\n      }\\n    };\\n  }\\n  function pippenger(c, fieldN, points, scalars) {\\n    validateMSMPoints(points, c);\\n    validateMSMScalars(scalars, fieldN);\\n    if (points.length !== scalars.length)\\n      throw new Error(\"arrays of points and scalars must have equal length\");\\n    const zero = c.ZERO;\\n    const wbits = bitLen(BigInt(points.length));\\n    const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1;\\n    const MASK = (1 << windowSize) - 1;\\n    const buckets = new Array(MASK + 1).fill(zero);\\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\\n    let sum = zero;\\n    for (let i = lastBits; i >= 0; i -= windowSize) {\\n      buckets.fill(zero);\\n      for (let j = 0; j < scalars.length; j++) {\\n        const scalar = scalars[j];\\n        const wbits2 = Number(scalar >> BigInt(i) & BigInt(MASK));\\n        buckets[wbits2] = buckets[wbits2].add(points[j]);\\n      }\\n      let resI = zero;\\n      for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\\n        sumI = sumI.add(buckets[j]);\\n        resI = resI.add(sumI);\\n      }\\n      sum = sum.add(resI);\\n      if (i !== 0)\\n        for (let j = 0; j < windowSize; j++)\\n          sum = sum.double();\\n    }\\n    return sum;\\n  }\\n  function validateBasic(curve) {\\n    validateField(curve.Fp);\\n    validateObject(curve, {\\n      n: \"bigint\",\\n      h: \"bigint\",\\n      Gx: \"field\",\\n      Gy: \"field\"\\n    }, {\\n      nBitLength: \"isSafeInteger\",\\n      nByteLength: \"isSafeInteger\"\\n    });\\n    return Object.freeze({\\n      ...nLength(curve.n, curve.nBitLength),\\n      ...curve,\\n      ...{ p: curve.Fp.ORDER }\\n    });\\n  }\\n  var _0n4, _1n4, pointPrecomputes, pointWindowSizes;\\n  var init_curve = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/@noble+curves@1.8.1/node_modules/@noble/curves/esm/abstract/curve.js\"() {\\n      init_modular();\\n      init_utils4();\\n      _0n4 = BigInt(0);\\n      _1n4 = BigInt(1);\\n      pointPrecomputes = /* @__PURE__ */ new WeakMap();\\n      pointWindowSizes = /* @__PURE__ */ new WeakMap();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/@noble+curves@1.8.1/node_modules/@noble/curves/esm/abstract/weierstrass.js\\n  function validateSigVerOpts(opts) {\\n    if (opts.lowS !== void 0)\\n      abool(\"lowS\", opts.lowS);\\n    if (opts.prehash !== void 0)\\n      abool(\"prehash\", opts.prehash);\\n  }\\n  function validatePointOpts(curve) {\\n    const opts = validateBasic(curve);\\n    validateObject(opts, {\\n      a: \"field\",\\n      b: \"field\"\\n    }, {\\n      allowedPrivateKeyLengths: \"array\",\\n      wrapPrivateKey: \"boolean\",\\n      isTorsionFree: \"function\",\\n      clearCofactor: \"function\",\\n      allowInfinityPoint: \"boolean\",\\n      fromBytes: \"function\",\\n      toBytes: \"function\"\\n    });\\n    const { endo, Fp, a } = opts;\\n    if (endo) {\\n      if (!Fp.eql(a, Fp.ZERO)) {\\n        throw new Error(\"invalid endomorphism, can only be defined for Koblitz curves that have a=0\");\\n      }\\n      if (typeof endo !== \"object\" || typeof endo.beta !== \"bigint\" || typeof endo.splitScalar !== \"function\") {\\n        throw new Error(\"invalid endomorphism, expected beta: bigint and splitScalar: function\");\\n      }\\n    }\\n    return Object.freeze({ ...opts });\\n  }\\n  function weierstrassPoints(opts) {\\n    const CURVE = validatePointOpts(opts);\\n    const { Fp } = CURVE;\\n    const Fn = Field(CURVE.n, CURVE.nBitLength);\\n    const toBytes4 = CURVE.toBytes || ((_c, point, _isCompressed) => {\\n      const a = point.toAffine();\\n      return concatBytes3(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y));\\n    });\\n    const fromBytes2 = CURVE.fromBytes || ((bytes) => {\\n      const tail = bytes.subarray(1);\\n      const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\\n      const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\\n      return { x, y };\\n    });\\n    function weierstrassEquation(x) {\\n      const { a, b } = CURVE;\\n      const x2 = Fp.sqr(x);\\n      const x3 = Fp.mul(x2, x);\\n      return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);\\n    }\\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\\n      throw new Error(\"bad generator point: equation left != right\");\\n    function isWithinCurveOrder(num2) {\\n      return inRange(num2, _1n5, CURVE.n);\\n    }\\n    function normPrivateKeyToScalar(key) {\\n      const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;\\n      if (lengths && typeof key !== \"bigint\") {\\n        if (isBytes2(key))\\n          key = bytesToHex2(key);\\n        if (typeof key !== \"string\" || !lengths.includes(key.length))\\n          throw new Error(\"invalid private key\");\\n        key = key.padStart(nByteLength * 2, \"0\");\\n      }\\n      let num2;\\n      try {\\n        num2 = typeof key === \"bigint\" ? key : bytesToNumberBE(ensureBytes(\"private key\", key, nByteLength));\\n      } catch (error) {\\n        throw new Error(\"invalid private key, expected hex or \" + nByteLength + \" bytes, got \" + typeof key);\\n      }\\n      if (wrapPrivateKey)\\n        num2 = mod(num2, N);\\n      aInRange(\"private key\", num2, _1n5, N);\\n      return num2;\\n    }\\n    function assertPrjPoint(other) {\\n      if (!(other instanceof Point2))\\n        throw new Error(\"ProjectivePoint expected\");\\n    }\\n    const toAffineMemo = memoized((p, iz) => {\\n      const { px: x, py: y, pz: z2 } = p;\\n      if (Fp.eql(z2, Fp.ONE))\\n        return { x, y };\\n      const is0 = p.is0();\\n      if (iz == null)\\n        iz = is0 ? Fp.ONE : Fp.inv(z2);\\n      const ax = Fp.mul(x, iz);\\n      const ay = Fp.mul(y, iz);\\n      const zz = Fp.mul(z2, iz);\\n      if (is0)\\n        return { x: Fp.ZERO, y: Fp.ZERO };\\n      if (!Fp.eql(zz, Fp.ONE))\\n        throw new Error(\"invZ was invalid\");\\n      return { x: ax, y: ay };\\n    });\\n    const assertValidMemo = memoized((p) => {\\n      if (p.is0()) {\\n        if (CURVE.allowInfinityPoint && !Fp.is0(p.py))\\n          return;\\n        throw new Error(\"bad point: ZERO\");\\n      }\\n      const { x, y } = p.toAffine();\\n      if (!Fp.isValid(x) || !Fp.isValid(y))\\n        throw new Error(\"bad point: x or y not FE\");\\n      const left = Fp.sqr(y);\\n      const right = weierstrassEquation(x);\\n      if (!Fp.eql(left, right))\\n        throw new Error(\"bad point: equation left != right\");\\n      if (!p.isTorsionFree())\\n        throw new Error(\"bad point: not in prime-order subgroup\");\\n      return true;\\n    });\\n    class Point2 {\\n      constructor(px, py, pz) {\\n        this.px = px;\\n        this.py = py;\\n        this.pz = pz;\\n        if (px == null || !Fp.isValid(px))\\n          throw new Error(\"x required\");\\n        if (py == null || !Fp.isValid(py))\\n          throw new Error(\"y required\");\\n        if (pz == null || !Fp.isValid(pz))\\n          throw new Error(\"z required\");\\n        Object.freeze(this);\\n      }\\n      // Does not validate if the point is on-curve.\\n      // Use fromHex instead, or call assertValidity() later.\\n      static fromAffine(p) {\\n        const { x, y } = p || {};\\n        if (!p || !Fp.isValid(x) || !Fp.isValid(y))\\n          throw new Error(\"invalid affine point\");\\n        if (p instanceof Point2)\\n          throw new Error(\"projective point not allowed\");\\n        const is0 = (i) => Fp.eql(i, Fp.ZERO);\\n        if (is0(x) && is0(y))\\n          return Point2.ZERO;\\n        return new Point2(x, y, Fp.ONE);\\n      }\\n      get x() {\\n        return this.toAffine().x;\\n      }\\n      get y() {\\n        return this.toAffine().y;\\n      }\\n      /**\\n       * Takes a bunch of Projective Points but executes only one\\n       * inversion on all of them. Inversion is very slow operation,\\n       * so this improves performance massively.\\n       * Optimization: converts a list of projective points to a list of identical points with Z=1.\\n       */\\n      static normalizeZ(points) {\\n        const toInv = Fp.invertBatch(points.map((p) => p.pz));\\n        return points.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);\\n      }\\n      /**\\n       * Converts hash string or Uint8Array to Point.\\n       * @param hex short/long ECDSA hex\\n       */\\n      static fromHex(hex) {\\n        const P = Point2.fromAffine(fromBytes2(ensureBytes(\"pointHex\", hex)));\\n        P.assertValidity();\\n        return P;\\n      }\\n      // Multiplies generator point by privateKey.\\n      static fromPrivateKey(privateKey) {\\n        return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));\\n      }\\n      // Multiscalar Multiplication\\n      static msm(points, scalars) {\\n        return pippenger(Point2, Fn, points, scalars);\\n      }\\n      // \"Private method\", don\\'t use it directly\\n      _setWindowSize(windowSize) {\\n        wnaf.setWindowSize(this, windowSize);\\n      }\\n      // A point on curve is valid if it conforms to equation.\\n      assertValidity() {\\n        assertValidMemo(this);\\n      }\\n      hasEvenY() {\\n        const { y } = this.toAffine();\\n        if (Fp.isOdd)\\n          return !Fp.isOdd(y);\\n        throw new Error(\"Field doesn\\'t support isOdd\");\\n      }\\n      /**\\n       * Compare one point to another.\\n       */\\n      equals(other) {\\n        assertPrjPoint(other);\\n        const { px: X1, py: Y1, pz: Z1 } = this;\\n        const { px: X2, py: Y2, pz: Z2 } = other;\\n        const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\\n        const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\\n        return U1 && U2;\\n      }\\n      /**\\n       * Flips point to one corresponding to (x, -y) in Affine coordinates.\\n       */\\n      negate() {\\n        return new Point2(this.px, Fp.neg(this.py), this.pz);\\n      }\\n      // Renes-Costello-Batina exception-free doubling formula.\\n      // There is 30% faster Jacobian formula, but it is not complete.\\n      // https://eprint.iacr.org/2015/1060, algorithm 3\\n      // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\\n      double() {\\n        const { a, b } = CURVE;\\n        const b3 = Fp.mul(b, _3n2);\\n        const { px: X1, py: Y1, pz: Z1 } = this;\\n        let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;\\n        let t0 = Fp.mul(X1, X1);\\n        let t1 = Fp.mul(Y1, Y1);\\n        let t2 = Fp.mul(Z1, Z1);\\n        let t3 = Fp.mul(X1, Y1);\\n        t3 = Fp.add(t3, t3);\\n        Z3 = Fp.mul(X1, Z1);\\n        Z3 = Fp.add(Z3, Z3);\\n        X3 = Fp.mul(a, Z3);\\n        Y3 = Fp.mul(b3, t2);\\n        Y3 = Fp.add(X3, Y3);\\n        X3 = Fp.sub(t1, Y3);\\n        Y3 = Fp.add(t1, Y3);\\n        Y3 = Fp.mul(X3, Y3);\\n        X3 = Fp.mul(t3, X3);\\n        Z3 = Fp.mul(b3, Z3);\\n        t2 = Fp.mul(a, t2);\\n        t3 = Fp.sub(t0, t2);\\n        t3 = Fp.mul(a, t3);\\n        t3 = Fp.add(t3, Z3);\\n        Z3 = Fp.add(t0, t0);\\n        t0 = Fp.add(Z3, t0);\\n        t0 = Fp.add(t0, t2);\\n        t0 = Fp.mul(t0, t3);\\n        Y3 = Fp.add(Y3, t0);\\n        t2 = Fp.mul(Y1, Z1);\\n        t2 = Fp.add(t2, t2);\\n        t0 = Fp.mul(t2, t3);\\n        X3 = Fp.sub(X3, t0);\\n        Z3 = Fp.mul(t2, t1);\\n        Z3 = Fp.add(Z3, Z3);\\n        Z3 = Fp.add(Z3, Z3);\\n        return new Point2(X3, Y3, Z3);\\n      }\\n      // Renes-Costello-Batina exception-free addition formula.\\n      // There is 30% faster Jacobian formula, but it is not complete.\\n      // https://eprint.iacr.org/2015/1060, algorithm 1\\n      // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\\n      add(other) {\\n        assertPrjPoint(other);\\n        const { px: X1, py: Y1, pz: Z1 } = this;\\n        const { px: X2, py: Y2, pz: Z2 } = other;\\n        let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;\\n        const a = CURVE.a;\\n        const b3 = Fp.mul(CURVE.b, _3n2);\\n        let t0 = Fp.mul(X1, X2);\\n        let t1 = Fp.mul(Y1, Y2);\\n        let t2 = Fp.mul(Z1, Z2);\\n        let t3 = Fp.add(X1, Y1);\\n        let t4 = Fp.add(X2, Y2);\\n        t3 = Fp.mul(t3, t4);\\n        t4 = Fp.add(t0, t1);\\n        t3 = Fp.sub(t3, t4);\\n        t4 = Fp.add(X1, Z1);\\n        let t5 = Fp.add(X2, Z2);\\n        t4 = Fp.mul(t4, t5);\\n        t5 = Fp.add(t0, t2);\\n        t4 = Fp.sub(t4, t5);\\n        t5 = Fp.add(Y1, Z1);\\n        X3 = Fp.add(Y2, Z2);\\n        t5 = Fp.mul(t5, X3);\\n        X3 = Fp.add(t1, t2);\\n        t5 = Fp.sub(t5, X3);\\n        Z3 = Fp.mul(a, t4);\\n        X3 = Fp.mul(b3, t2);\\n        Z3 = Fp.add(X3, Z3);\\n        X3 = Fp.sub(t1, Z3);\\n        Z3 = Fp.add(t1, Z3);\\n        Y3 = Fp.mul(X3, Z3);\\n        t1 = Fp.add(t0, t0);\\n        t1 = Fp.add(t1, t0);\\n        t2 = Fp.mul(a, t2);\\n        t4 = Fp.mul(b3, t4);\\n        t1 = Fp.add(t1, t2);\\n        t2 = Fp.sub(t0, t2);\\n        t2 = Fp.mul(a, t2);\\n        t4 = Fp.add(t4, t2);\\n        t0 = Fp.mul(t1, t4);\\n        Y3 = Fp.add(Y3, t0);\\n        t0 = Fp.mul(t5, t4);\\n        X3 = Fp.mul(t3, X3);\\n        X3 = Fp.sub(X3, t0);\\n        t0 = Fp.mul(t3, t1);\\n        Z3 = Fp.mul(t5, Z3);\\n        Z3 = Fp.add(Z3, t0);\\n        return new Point2(X3, Y3, Z3);\\n      }\\n      subtract(other) {\\n        return this.add(other.negate());\\n      }\\n      is0() {\\n        return this.equals(Point2.ZERO);\\n      }\\n      wNAF(n) {\\n        return wnaf.wNAFCached(this, n, Point2.normalizeZ);\\n      }\\n      /**\\n       * Non-constant-time multiplication. Uses double-and-add algorithm.\\n       * It\\'s faster, but should only be used when you don\\'t care about\\n       * an exposed private key e.g. sig verification, which works over *public* keys.\\n       */\\n      multiplyUnsafe(sc) {\\n        const { endo, n: N } = CURVE;\\n        aInRange(\"scalar\", sc, _0n5, N);\\n        const I = Point2.ZERO;\\n        if (sc === _0n5)\\n          return I;\\n        if (this.is0() || sc === _1n5)\\n          return this;\\n        if (!endo || wnaf.hasPrecomputes(this))\\n          return wnaf.wNAFCachedUnsafe(this, sc, Point2.normalizeZ);\\n        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);\\n        let k1p = I;\\n        let k2p = I;\\n        let d = this;\\n        while (k1 > _0n5 || k2 > _0n5) {\\n          if (k1 & _1n5)\\n            k1p = k1p.add(d);\\n          if (k2 & _1n5)\\n            k2p = k2p.add(d);\\n          d = d.double();\\n          k1 >>= _1n5;\\n          k2 >>= _1n5;\\n        }\\n        if (k1neg)\\n          k1p = k1p.negate();\\n        if (k2neg)\\n          k2p = k2p.negate();\\n        k2p = new Point2(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\\n        return k1p.add(k2p);\\n      }\\n      /**\\n       * Constant time multiplication.\\n       * Uses wNAF method. Windowed method may be 10% faster,\\n       * but takes 2x longer to generate and consumes 2x memory.\\n       * Uses precomputes when available.\\n       * Uses endomorphism for Koblitz curves.\\n       * @param scalar by which the point would be multiplied\\n       * @returns New point\\n       */\\n      multiply(scalar) {\\n        const { endo, n: N } = CURVE;\\n        aInRange(\"scalar\", scalar, _1n5, N);\\n        let point, fake;\\n        if (endo) {\\n          const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);\\n          let { p: k1p, f: f1p } = this.wNAF(k1);\\n          let { p: k2p, f: f2p } = this.wNAF(k2);\\n          k1p = wnaf.constTimeNegate(k1neg, k1p);\\n          k2p = wnaf.constTimeNegate(k2neg, k2p);\\n          k2p = new Point2(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\\n          point = k1p.add(k2p);\\n          fake = f1p.add(f2p);\\n        } else {\\n          const { p, f } = this.wNAF(scalar);\\n          point = p;\\n          fake = f;\\n        }\\n        return Point2.normalizeZ([point, fake])[0];\\n      }\\n      /**\\n       * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\\n       * Not using Strauss-Shamir trick: precomputation tables are faster.\\n       * The trick could be useful if both P and Q are not G (not in our case).\\n       * @returns non-zero affine point\\n       */\\n      multiplyAndAddUnsafe(Q, a, b) {\\n        const G = Point2.BASE;\\n        const mul = (P, a2) => a2 === _0n5 || a2 === _1n5 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);\\n        const sum = mul(this, a).add(mul(Q, b));\\n        return sum.is0() ? void 0 : sum;\\n      }\\n      // Converts Projective point to affine (x, y) coordinates.\\n      // Can accept precomputed Z^-1 - for example, from invertBatch.\\n      // (x, y, z) \\u220B (x=x/z, y=y/z)\\n      toAffine(iz) {\\n        return toAffineMemo(this, iz);\\n      }\\n      isTorsionFree() {\\n        const { h: cofactor, isTorsionFree } = CURVE;\\n        if (cofactor === _1n5)\\n          return true;\\n        if (isTorsionFree)\\n          return isTorsionFree(Point2, this);\\n        throw new Error(\"isTorsionFree() has not been declared for the elliptic curve\");\\n      }\\n      clearCofactor() {\\n        const { h: cofactor, clearCofactor } = CURVE;\\n        if (cofactor === _1n5)\\n          return this;\\n        if (clearCofactor)\\n          return clearCofactor(Point2, this);\\n        return this.multiplyUnsafe(CURVE.h);\\n      }\\n      toRawBytes(isCompressed = true) {\\n        abool(\"isCompressed\", isCompressed);\\n        this.assertValidity();\\n        return toBytes4(Point2, this, isCompressed);\\n      }\\n      toHex(isCompressed = true) {\\n        abool(\"isCompressed\", isCompressed);\\n        return bytesToHex2(this.toRawBytes(isCompressed));\\n      }\\n    }\\n    Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp.ONE);\\n    Point2.ZERO = new Point2(Fp.ZERO, Fp.ONE, Fp.ZERO);\\n    const _bits = CURVE.nBitLength;\\n    const wnaf = wNAF(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\\n    return {\\n      CURVE,\\n      ProjectivePoint: Point2,\\n      normPrivateKeyToScalar,\\n      weierstrassEquation,\\n      isWithinCurveOrder\\n    };\\n  }\\n  function validateOpts(curve) {\\n    const opts = validateBasic(curve);\\n    validateObject(opts, {\\n      hash: \"hash\",\\n      hmac: \"function\",\\n      randomBytes: \"function\"\\n    }, {\\n      bits2int: \"function\",\\n      bits2int_modN: \"function\",\\n      lowS: \"boolean\"\\n    });\\n    return Object.freeze({ lowS: true, ...opts });\\n  }\\n  function weierstrass(curveDef) {\\n    const CURVE = validateOpts(curveDef);\\n    const { Fp, n: CURVE_ORDER } = CURVE;\\n    const compressedLen = Fp.BYTES + 1;\\n    const uncompressedLen = 2 * Fp.BYTES + 1;\\n    function modN2(a) {\\n      return mod(a, CURVE_ORDER);\\n    }\\n    function invN(a) {\\n      return invert(a, CURVE_ORDER);\\n    }\\n    const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({\\n      ...CURVE,\\n      toBytes(_c, point, isCompressed) {\\n        const a = point.toAffine();\\n        const x = Fp.toBytes(a.x);\\n        const cat = concatBytes3;\\n        abool(\"isCompressed\", isCompressed);\\n        if (isCompressed) {\\n          return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);\\n        } else {\\n          return cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));\\n        }\\n      },\\n      fromBytes(bytes) {\\n        const len = bytes.length;\\n        const head = bytes[0];\\n        const tail = bytes.subarray(1);\\n        if (len === compressedLen && (head === 2 || head === 3)) {\\n          const x = bytesToNumberBE(tail);\\n          if (!inRange(x, _1n5, Fp.ORDER))\\n            throw new Error(\"Point is not on curve\");\\n          const y2 = weierstrassEquation(x);\\n          let y;\\n          try {\\n            y = Fp.sqrt(y2);\\n          } catch (sqrtError) {\\n            const suffix = sqrtError instanceof Error ? \": \" + sqrtError.message : \"\";\\n            throw new Error(\"Point is not on curve\" + suffix);\\n          }\\n          const isYOdd = (y & _1n5) === _1n5;\\n          const isHeadOdd = (head & 1) === 1;\\n          if (isHeadOdd !== isYOdd)\\n            y = Fp.neg(y);\\n          return { x, y };\\n        } else if (len === uncompressedLen && head === 4) {\\n          const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\\n          const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\\n          return { x, y };\\n        } else {\\n          const cl = compressedLen;\\n          const ul = uncompressedLen;\\n          throw new Error(\"invalid Point, expected length of \" + cl + \", or uncompressed \" + ul + \", got \" + len);\\n        }\\n      }\\n    });\\n    const numToNByteStr = (num2) => bytesToHex2(numberToBytesBE(num2, CURVE.nByteLength));\\n    function isBiggerThanHalfOrder(number) {\\n      const HALF = CURVE_ORDER >> _1n5;\\n      return number > HALF;\\n    }\\n    function normalizeS(s) {\\n      return isBiggerThanHalfOrder(s) ? modN2(-s) : s;\\n    }\\n    const slcNum = (b, from5, to) => bytesToNumberBE(b.slice(from5, to));\\n    class Signature {\\n      constructor(r, s, recovery) {\\n        this.r = r;\\n        this.s = s;\\n        this.recovery = recovery;\\n        this.assertValidity();\\n      }\\n      // pair (bytes of r, bytes of s)\\n      static fromCompact(hex) {\\n        const l = CURVE.nByteLength;\\n        hex = ensureBytes(\"compactSignature\", hex, l * 2);\\n        return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\\n      }\\n      // DER encoded ECDSA signature\\n      // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\\n      static fromDER(hex) {\\n        const { r, s } = DER.toSig(ensureBytes(\"DER\", hex));\\n        return new Signature(r, s);\\n      }\\n      assertValidity() {\\n        aInRange(\"r\", this.r, _1n5, CURVE_ORDER);\\n        aInRange(\"s\", this.s, _1n5, CURVE_ORDER);\\n      }\\n      addRecoveryBit(recovery) {\\n        return new Signature(this.r, this.s, recovery);\\n      }\\n      recoverPublicKey(msgHash) {\\n        const { r, s, recovery: rec } = this;\\n        const h = bits2int_modN(ensureBytes(\"msgHash\", msgHash));\\n        if (rec == null || ![0, 1, 2, 3].includes(rec))\\n          throw new Error(\"recovery id invalid\");\\n        const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\\n        if (radj >= Fp.ORDER)\\n          throw new Error(\"recovery id 2 or 3 invalid\");\\n        const prefix = (rec & 1) === 0 ? \"02\" : \"03\";\\n        const R = Point2.fromHex(prefix + numToNByteStr(radj));\\n        const ir = invN(radj);\\n        const u1 = modN2(-h * ir);\\n        const u2 = modN2(s * ir);\\n        const Q = Point2.BASE.multiplyAndAddUnsafe(R, u1, u2);\\n        if (!Q)\\n          throw new Error(\"point at infinify\");\\n        Q.assertValidity();\\n        return Q;\\n      }\\n      // Signatures should be low-s, to prevent malleability.\\n      hasHighS() {\\n        return isBiggerThanHalfOrder(this.s);\\n      }\\n      normalizeS() {\\n        return this.hasHighS() ? new Signature(this.r, modN2(-this.s), this.recovery) : this;\\n      }\\n      // DER-encoded\\n      toDERRawBytes() {\\n        return hexToBytes2(this.toDERHex());\\n      }\\n      toDERHex() {\\n        return DER.hexFromSig({ r: this.r, s: this.s });\\n      }\\n      // padded bytes of r, then padded bytes of s\\n      toCompactRawBytes() {\\n        return hexToBytes2(this.toCompactHex());\\n      }\\n      toCompactHex() {\\n        return numToNByteStr(this.r) + numToNByteStr(this.s);\\n      }\\n    }\\n    const utils = {\\n      isValidPrivateKey(privateKey) {\\n        try {\\n          normPrivateKeyToScalar(privateKey);\\n          return true;\\n        } catch (error) {\\n          return false;\\n        }\\n      },\\n      normPrivateKeyToScalar,\\n      /**\\n       * Produces cryptographically secure private key from random of size\\n       * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\\n       */\\n      randomPrivateKey: () => {\\n        const length = getMinHashLength(CURVE.n);\\n        return mapHashToField(CURVE.randomBytes(length), CURVE.n);\\n      },\\n      /**\\n       * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\\n       * Allows to massively speed-up `point.multiply(scalar)`.\\n       * @returns cached point\\n       * @example\\n       * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\\n       * fast.multiply(privKey); // much faster ECDH now\\n       */\\n      precompute(windowSize = 8, point = Point2.BASE) {\\n        point._setWindowSize(windowSize);\\n        point.multiply(BigInt(3));\\n        return point;\\n      }\\n    };\\n    function getPublicKey(privateKey, isCompressed = true) {\\n      return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);\\n    }\\n    function isProbPub(item) {\\n      const arr = isBytes2(item);\\n      const str = typeof item === \"string\";\\n      const len = (arr || str) && item.length;\\n      if (arr)\\n        return len === compressedLen || len === uncompressedLen;\\n      if (str)\\n        return len === 2 * compressedLen || len === 2 * uncompressedLen;\\n      if (item instanceof Point2)\\n        return true;\\n      return false;\\n    }\\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\\n      if (isProbPub(privateA))\\n        throw new Error(\"first arg must be private key\");\\n      if (!isProbPub(publicB))\\n        throw new Error(\"second arg must be public key\");\\n      const b = Point2.fromHex(publicB);\\n      return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\\n    }\\n    const bits2int = CURVE.bits2int || function(bytes) {\\n      if (bytes.length > 8192)\\n        throw new Error(\"input is too large\");\\n      const num2 = bytesToNumberBE(bytes);\\n      const delta = bytes.length * 8 - CURVE.nBitLength;\\n      return delta > 0 ? num2 >> BigInt(delta) : num2;\\n    };\\n    const bits2int_modN = CURVE.bits2int_modN || function(bytes) {\\n      return modN2(bits2int(bytes));\\n    };\\n    const ORDER_MASK = bitMask(CURVE.nBitLength);\\n    function int2octets(num2) {\\n      aInRange(\"num < 2^\" + CURVE.nBitLength, num2, _0n5, ORDER_MASK);\\n      return numberToBytesBE(num2, CURVE.nByteLength);\\n    }\\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\\n      if ([\"recovered\", \"canonical\"].some((k) => k in opts))\\n        throw new Error(\"sign() legacy options not supported\");\\n      const { hash: hash2, randomBytes: randomBytes2 } = CURVE;\\n      let { lowS, prehash, extraEntropy: ent } = opts;\\n      if (lowS == null)\\n        lowS = true;\\n      msgHash = ensureBytes(\"msgHash\", msgHash);\\n      validateSigVerOpts(opts);\\n      if (prehash)\\n        msgHash = ensureBytes(\"prehashed msgHash\", hash2(msgHash));\\n      const h1int = bits2int_modN(msgHash);\\n      const d = normPrivateKeyToScalar(privateKey);\\n      const seedArgs = [int2octets(d), int2octets(h1int)];\\n      if (ent != null && ent !== false) {\\n        const e = ent === true ? randomBytes2(Fp.BYTES) : ent;\\n        seedArgs.push(ensureBytes(\"extraEntropy\", e));\\n      }\\n      const seed = concatBytes3(...seedArgs);\\n      const m = h1int;\\n      function k2sig(kBytes) {\\n        const k = bits2int(kBytes);\\n        if (!isWithinCurveOrder(k))\\n          return;\\n        const ik = invN(k);\\n        const q = Point2.BASE.multiply(k).toAffine();\\n        const r = modN2(q.x);\\n        if (r === _0n5)\\n          return;\\n        const s = modN2(ik * modN2(m + r * d));\\n        if (s === _0n5)\\n          return;\\n        let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n5);\\n        let normS = s;\\n        if (lowS && isBiggerThanHalfOrder(s)) {\\n          normS = normalizeS(s);\\n          recovery ^= 1;\\n        }\\n        return new Signature(r, normS, recovery);\\n      }\\n      return { seed, k2sig };\\n    }\\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\\n      const { seed, k2sig } = prepSig(msgHash, privKey, opts);\\n      const C = CURVE;\\n      const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\\n      return drbg(seed, k2sig);\\n    }\\n    Point2.BASE._setWindowSize(8);\\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\\n      const sg = signature;\\n      msgHash = ensureBytes(\"msgHash\", msgHash);\\n      publicKey = ensureBytes(\"publicKey\", publicKey);\\n      const { lowS, prehash, format } = opts;\\n      validateSigVerOpts(opts);\\n      if (\"strict\" in opts)\\n        throw new Error(\"options.strict was renamed to lowS\");\\n      if (format !== void 0 && format !== \"compact\" && format !== \"der\")\\n        throw new Error(\"format must be compact or der\");\\n      const isHex2 = typeof sg === \"string\" || isBytes2(sg);\\n      const isObj = !isHex2 && !format && typeof sg === \"object\" && sg !== null && typeof sg.r === \"bigint\" && typeof sg.s === \"bigint\";\\n      if (!isHex2 && !isObj)\\n        throw new Error(\"invalid signature, expected Uint8Array, hex string or Signature instance\");\\n      let _sig = void 0;\\n      let P;\\n      try {\\n        if (isObj)\\n          _sig = new Signature(sg.r, sg.s);\\n        if (isHex2) {\\n          try {\\n            if (format !== \"compact\")\\n              _sig = Signature.fromDER(sg);\\n          } catch (derError) {\\n            if (!(derError instanceof DER.Err))\\n              throw derError;\\n          }\\n          if (!_sig && format !== \"der\")\\n            _sig = Signature.fromCompact(sg);\\n        }\\n        P = Point2.fromHex(publicKey);\\n      } catch (error) {\\n        return false;\\n      }\\n      if (!_sig)\\n        return false;\\n      if (lowS && _sig.hasHighS())\\n        return false;\\n      if (prehash)\\n        msgHash = CURVE.hash(msgHash);\\n      const { r, s } = _sig;\\n      const h = bits2int_modN(msgHash);\\n      const is = invN(s);\\n      const u1 = modN2(h * is);\\n      const u2 = modN2(r * is);\\n      const R = Point2.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();\\n      if (!R)\\n        return false;\\n      const v = modN2(R.x);\\n      return v === r;\\n    }\\n    return {\\n      CURVE,\\n      getPublicKey,\\n      getSharedSecret,\\n      sign,\\n      verify,\\n      ProjectivePoint: Point2,\\n      Signature,\\n      utils\\n    };\\n  }\\n  function SWUFpSqrtRatio(Fp, Z) {\\n    const q = Fp.ORDER;\\n    let l = _0n5;\\n    for (let o = q - _1n5; o % _2n4 === _0n5; o /= _2n4)\\n      l += _1n5;\\n    const c1 = l;\\n    const _2n_pow_c1_1 = _2n4 << c1 - _1n5 - _1n5;\\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n4;\\n    const c2 = (q - _1n5) / _2n_pow_c1;\\n    const c3 = (c2 - _1n5) / _2n4;\\n    const c4 = _2n_pow_c1 - _1n5;\\n    const c5 = _2n_pow_c1_1;\\n    const c6 = Fp.pow(Z, c2);\\n    const c7 = Fp.pow(Z, (c2 + _1n5) / _2n4);\\n    let sqrtRatio = (u, v) => {\\n      let tv1 = c6;\\n      let tv2 = Fp.pow(v, c4);\\n      let tv3 = Fp.sqr(tv2);\\n      tv3 = Fp.mul(tv3, v);\\n      let tv5 = Fp.mul(u, tv3);\\n      tv5 = Fp.pow(tv5, c3);\\n      tv5 = Fp.mul(tv5, tv2);\\n      tv2 = Fp.mul(tv5, v);\\n      tv3 = Fp.mul(tv5, u);\\n      let tv4 = Fp.mul(tv3, tv2);\\n      tv5 = Fp.pow(tv4, c5);\\n      let isQR = Fp.eql(tv5, Fp.ONE);\\n      tv2 = Fp.mul(tv3, c7);\\n      tv5 = Fp.mul(tv4, tv1);\\n      tv3 = Fp.cmov(tv2, tv3, isQR);\\n      tv4 = Fp.cmov(tv5, tv4, isQR);\\n      for (let i = c1; i > _1n5; i--) {\\n        let tv52 = i - _2n4;\\n        tv52 = _2n4 << tv52 - _1n5;\\n        let tvv5 = Fp.pow(tv4, tv52);\\n        const e1 = Fp.eql(tvv5, Fp.ONE);\\n        tv2 = Fp.mul(tv3, tv1);\\n        tv1 = Fp.mul(tv1, tv1);\\n        tvv5 = Fp.mul(tv4, tv1);\\n        tv3 = Fp.cmov(tv2, tv3, e1);\\n        tv4 = Fp.cmov(tvv5, tv4, e1);\\n      }\\n      return { isValid: isQR, value: tv3 };\\n    };\\n    if (Fp.ORDER % _4n2 === _3n2) {\\n      const c12 = (Fp.ORDER - _3n2) / _4n2;\\n      const c22 = Fp.sqrt(Fp.neg(Z));\\n      sqrtRatio = (u, v) => {\\n        let tv1 = Fp.sqr(v);\\n        const tv2 = Fp.mul(u, v);\\n        tv1 = Fp.mul(tv1, tv2);\\n        let y1 = Fp.pow(tv1, c12);\\n        y1 = Fp.mul(y1, tv2);\\n        const y2 = Fp.mul(y1, c22);\\n        const tv3 = Fp.mul(Fp.sqr(y1), v);\\n        const isQR = Fp.eql(tv3, u);\\n        let y = Fp.cmov(y2, y1, isQR);\\n        return { isValid: isQR, value: y };\\n      };\\n    }\\n    return sqrtRatio;\\n  }\\n  function mapToCurveSimpleSWU(Fp, opts) {\\n    validateField(Fp);\\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\\n      throw new Error(\"mapToCurveSimpleSWU: invalid opts\");\\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\\n    if (!Fp.isOdd)\\n      throw new Error(\"Fp.isOdd is not implemented!\");\\n    return (u) => {\\n      let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\\n      tv1 = Fp.sqr(u);\\n      tv1 = Fp.mul(tv1, opts.Z);\\n      tv2 = Fp.sqr(tv1);\\n      tv2 = Fp.add(tv2, tv1);\\n      tv3 = Fp.add(tv2, Fp.ONE);\\n      tv3 = Fp.mul(tv3, opts.B);\\n      tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));\\n      tv4 = Fp.mul(tv4, opts.A);\\n      tv2 = Fp.sqr(tv3);\\n      tv6 = Fp.sqr(tv4);\\n      tv5 = Fp.mul(tv6, opts.A);\\n      tv2 = Fp.add(tv2, tv5);\\n      tv2 = Fp.mul(tv2, tv3);\\n      tv6 = Fp.mul(tv6, tv4);\\n      tv5 = Fp.mul(tv6, opts.B);\\n      tv2 = Fp.add(tv2, tv5);\\n      x = Fp.mul(tv1, tv3);\\n      const { isValid: isValid2, value } = sqrtRatio(tv2, tv6);\\n      y = Fp.mul(tv1, u);\\n      y = Fp.mul(y, value);\\n      x = Fp.cmov(x, tv3, isValid2);\\n      y = Fp.cmov(y, value, isValid2);\\n      const e1 = Fp.isOdd(u) === Fp.isOdd(y);\\n      y = Fp.cmov(Fp.neg(y), y, e1);\\n      x = Fp.div(x, tv4);\\n      return { x, y };\\n    };\\n  }\\n  var b2n, h2b, DERErr, DER, _0n5, _1n5, _2n4, _3n2, _4n2;\\n  var init_weierstrass = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/@noble+curves@1.8.1/node_modules/@noble/curves/esm/abstract/weierstrass.js\"() {\\n      init_curve();\\n      init_modular();\\n      init_utils4();\\n      init_utils4();\\n      ({ bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports);\\n      DERErr = class extends Error {\\n        constructor(m = \"\") {\\n          super(m);\\n        }\\n      };\\n      DER = {\\n        // asn.1 DER encoding utils\\n        Err: DERErr,\\n        // Basic building block is TLV (Tag-Length-Value)\\n        _tlv: {\\n          encode: (tag, data) => {\\n            const { Err: E } = DER;\\n            if (tag < 0 || tag > 256)\\n              throw new E(\"tlv.encode: wrong tag\");\\n            if (data.length & 1)\\n              throw new E(\"tlv.encode: unpadded data\");\\n            const dataLen = data.length / 2;\\n            const len = numberToHexUnpadded(dataLen);\\n            if (len.length / 2 & 128)\\n              throw new E(\"tlv.encode: long form length too big\");\\n            const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : \"\";\\n            const t = numberToHexUnpadded(tag);\\n            return t + lenLen + len + data;\\n          },\\n          // v - value, l - left bytes (unparsed)\\n          decode(tag, data) {\\n            const { Err: E } = DER;\\n            let pos = 0;\\n            if (tag < 0 || tag > 256)\\n              throw new E(\"tlv.encode: wrong tag\");\\n            if (data.length < 2 || data[pos++] !== tag)\\n              throw new E(\"tlv.decode: wrong tlv\");\\n            const first = data[pos++];\\n            const isLong = !!(first & 128);\\n            let length = 0;\\n            if (!isLong)\\n              length = first;\\n            else {\\n              const lenLen = first & 127;\\n              if (!lenLen)\\n                throw new E(\"tlv.decode(long): indefinite length not supported\");\\n              if (lenLen > 4)\\n                throw new E(\"tlv.decode(long): byte length is too big\");\\n              const lengthBytes = data.subarray(pos, pos + lenLen);\\n              if (lengthBytes.length !== lenLen)\\n                throw new E(\"tlv.decode: length bytes not complete\");\\n              if (lengthBytes[0] === 0)\\n                throw new E(\"tlv.decode(long): zero leftmost byte\");\\n              for (const b of lengthBytes)\\n                length = length << 8 | b;\\n              pos += lenLen;\\n              if (length < 128)\\n                throw new E(\"tlv.decode(long): not minimal encoding\");\\n            }\\n            const v = data.subarray(pos, pos + length);\\n            if (v.length !== length)\\n              throw new E(\"tlv.decode: wrong value length\");\\n            return { v, l: data.subarray(pos + length) };\\n          }\\n        },\\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is \\'negative\\' flag,\\n        // since we always use positive integers here. It must always be empty:\\n        // - add zero byte if exists\\n        // - if next byte doesn\\'t have a flag, leading zero is not allowed (minimal encoding)\\n        _int: {\\n          encode(num2) {\\n            const { Err: E } = DER;\\n            if (num2 < _0n5)\\n              throw new E(\"integer: negative integers are not allowed\");\\n            let hex = numberToHexUnpadded(num2);\\n            if (Number.parseInt(hex[0], 16) & 8)\\n              hex = \"00\" + hex;\\n            if (hex.length & 1)\\n              throw new E(\"unexpected DER parsing assertion: unpadded hex\");\\n            return hex;\\n          },\\n          decode(data) {\\n            const { Err: E } = DER;\\n            if (data[0] & 128)\\n              throw new E(\"invalid signature integer: negative\");\\n            if (data[0] === 0 && !(data[1] & 128))\\n              throw new E(\"invalid signature integer: unnecessary leading zero\");\\n            return b2n(data);\\n          }\\n        },\\n        toSig(hex) {\\n          const { Err: E, _int: int, _tlv: tlv } = DER;\\n          const data = typeof hex === \"string\" ? h2b(hex) : hex;\\n          abytes2(data);\\n          const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);\\n          if (seqLeftBytes.length)\\n            throw new E(\"invalid signature: left bytes after parsing\");\\n          const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);\\n          const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);\\n          if (sLeftBytes.length)\\n            throw new E(\"invalid signature: left bytes after parsing\");\\n          return { r: int.decode(rBytes), s: int.decode(sBytes) };\\n        },\\n        hexFromSig(sig) {\\n          const { _tlv: tlv, _int: int } = DER;\\n          const rs = tlv.encode(2, int.encode(sig.r));\\n          const ss = tlv.encode(2, int.encode(sig.s));\\n          const seq = rs + ss;\\n          return tlv.encode(48, seq);\\n        }\\n      };\\n      _0n5 = BigInt(0);\\n      _1n5 = BigInt(1);\\n      _2n4 = BigInt(2);\\n      _3n2 = BigInt(3);\\n      _4n2 = BigInt(4);\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/@noble+curves@1.8.1/node_modules/@noble/curves/esm/_shortw_utils.js\\n  function getHash(hash2) {\\n    return {\\n      hash: hash2,\\n      hmac: (key, ...msgs) => hmac(hash2, key, concatBytes(...msgs)),\\n      randomBytes\\n    };\\n  }\\n  function createCurve(curveDef, defHash) {\\n    const create = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });\\n    return { ...create(defHash), create };\\n  }\\n  var init_shortw_utils = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/@noble+curves@1.8.1/node_modules/@noble/curves/esm/_shortw_utils.js\"() {\\n      init_hmac();\\n      init_utils2();\\n      init_weierstrass();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/@noble+curves@1.8.1/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\\n  function i2osp(value, length) {\\n    anum(value);\\n    anum(length);\\n    if (value < 0 || value >= 1 << 8 * length)\\n      throw new Error(\"invalid I2OSP input: \" + value);\\n    const res = Array.from({ length }).fill(0);\\n    for (let i = length - 1; i >= 0; i--) {\\n      res[i] = value & 255;\\n      value >>>= 8;\\n    }\\n    return new Uint8Array(res);\\n  }\\n  function strxor(a, b) {\\n    const arr = new Uint8Array(a.length);\\n    for (let i = 0; i < a.length; i++) {\\n      arr[i] = a[i] ^ b[i];\\n    }\\n    return arr;\\n  }\\n  function anum(item) {\\n    if (!Number.isSafeInteger(item))\\n      throw new Error(\"number expected\");\\n  }\\n  function expand_message_xmd(msg, DST, lenInBytes, H) {\\n    abytes2(msg);\\n    abytes2(DST);\\n    anum(lenInBytes);\\n    if (DST.length > 255)\\n      DST = H(concatBytes3(utf8ToBytes2(\"H2C-OVERSIZE-DST-\"), DST));\\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\\n    if (lenInBytes > 65535 || ell > 255)\\n      throw new Error(\"expand_message_xmd: invalid lenInBytes\");\\n    const DST_prime = concatBytes3(DST, i2osp(DST.length, 1));\\n    const Z_pad = i2osp(0, r_in_bytes);\\n    const l_i_b_str = i2osp(lenInBytes, 2);\\n    const b = new Array(ell);\\n    const b_0 = H(concatBytes3(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\\n    b[0] = H(concatBytes3(b_0, i2osp(1, 1), DST_prime));\\n    for (let i = 1; i <= ell; i++) {\\n      const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\\n      b[i] = H(concatBytes3(...args));\\n    }\\n    const pseudo_random_bytes = concatBytes3(...b);\\n    return pseudo_random_bytes.slice(0, lenInBytes);\\n  }\\n  function expand_message_xof(msg, DST, lenInBytes, k, H) {\\n    abytes2(msg);\\n    abytes2(DST);\\n    anum(lenInBytes);\\n    if (DST.length > 255) {\\n      const dkLen = Math.ceil(2 * k / 8);\\n      DST = H.create({ dkLen }).update(utf8ToBytes2(\"H2C-OVERSIZE-DST-\")).update(DST).digest();\\n    }\\n    if (lenInBytes > 65535 || DST.length > 255)\\n      throw new Error(\"expand_message_xof: invalid lenInBytes\");\\n    return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();\\n  }\\n  function hash_to_field(msg, count, options) {\\n    validateObject(options, {\\n      DST: \"stringOrUint8Array\",\\n      p: \"bigint\",\\n      m: \"isSafeInteger\",\\n      k: \"isSafeInteger\",\\n      hash: \"hash\"\\n    });\\n    const { p, k, m, hash: hash2, expand, DST: _DST } = options;\\n    abytes2(msg);\\n    anum(count);\\n    const DST = typeof _DST === \"string\" ? utf8ToBytes2(_DST) : _DST;\\n    const log2p = p.toString(2).length;\\n    const L = Math.ceil((log2p + k) / 8);\\n    const len_in_bytes = count * m * L;\\n    let prb;\\n    if (expand === \"xmd\") {\\n      prb = expand_message_xmd(msg, DST, len_in_bytes, hash2);\\n    } else if (expand === \"xof\") {\\n      prb = expand_message_xof(msg, DST, len_in_bytes, k, hash2);\\n    } else if (expand === \"_internal_pass\") {\\n      prb = msg;\\n    } else {\\n      throw new Error(\\'expand must be \"xmd\" or \"xof\"\\');\\n    }\\n    const u = new Array(count);\\n    for (let i = 0; i < count; i++) {\\n      const e = new Array(m);\\n      for (let j = 0; j < m; j++) {\\n        const elm_offset = L * (j + i * m);\\n        const tv = prb.subarray(elm_offset, elm_offset + L);\\n        e[j] = mod(os2ip(tv), p);\\n      }\\n      u[i] = e;\\n    }\\n    return u;\\n  }\\n  function isogenyMap(field, map) {\\n    const COEFF = map.map((i) => Array.from(i).reverse());\\n    return (x, y) => {\\n      const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\\n      x = field.div(xNum, xDen);\\n      y = field.mul(y, field.div(yNum, yDen));\\n      return { x, y };\\n    };\\n  }\\n  function createHasher(Point2, mapToCurve, def) {\\n    if (typeof mapToCurve !== \"function\")\\n      throw new Error(\"mapToCurve() must be defined\");\\n    return {\\n      // Encodes byte string to elliptic curve.\\n      // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\\n      hashToCurve(msg, options) {\\n        const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\\n        const u0 = Point2.fromAffine(mapToCurve(u[0]));\\n        const u1 = Point2.fromAffine(mapToCurve(u[1]));\\n        const P = u0.add(u1).clearCofactor();\\n        P.assertValidity();\\n        return P;\\n      },\\n      // Encodes byte string to elliptic curve.\\n      // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\\n      encodeToCurve(msg, options) {\\n        const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\\n        const P = Point2.fromAffine(mapToCurve(u[0])).clearCofactor();\\n        P.assertValidity();\\n        return P;\\n      },\\n      // Same as encodeToCurve, but without hash\\n      mapToCurve(scalars) {\\n        if (!Array.isArray(scalars))\\n          throw new Error(\"mapToCurve: expected array of bigints\");\\n        for (const i of scalars)\\n          if (typeof i !== \"bigint\")\\n            throw new Error(\"mapToCurve: expected array of bigints\");\\n        const P = Point2.fromAffine(mapToCurve(scalars)).clearCofactor();\\n        P.assertValidity();\\n        return P;\\n      }\\n    };\\n  }\\n  var os2ip;\\n  var init_hash_to_curve = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/@noble+curves@1.8.1/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\"() {\\n      init_modular();\\n      init_utils4();\\n      os2ip = bytesToNumberBE;\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/@noble+curves@1.8.1/node_modules/@noble/curves/esm/secp256k1.js\\n  var secp256k1_exports = {};\\n  __export(secp256k1_exports, {\\n    encodeToCurve: () => encodeToCurve,\\n    hashToCurve: () => hashToCurve,\\n    schnorr: () => schnorr,\\n    secp256k1: () => secp256k1\\n  });\\n  function sqrtMod(y) {\\n    const P = secp256k1P;\\n    const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\\n    const b2 = y * y * y % P;\\n    const b3 = b2 * b2 * y % P;\\n    const b6 = pow2(b3, _3n3, P) * b3 % P;\\n    const b9 = pow2(b6, _3n3, P) * b3 % P;\\n    const b11 = pow2(b9, _2n5, P) * b2 % P;\\n    const b22 = pow2(b11, _11n, P) * b11 % P;\\n    const b44 = pow2(b22, _22n, P) * b22 % P;\\n    const b88 = pow2(b44, _44n, P) * b44 % P;\\n    const b176 = pow2(b88, _88n, P) * b88 % P;\\n    const b220 = pow2(b176, _44n, P) * b44 % P;\\n    const b223 = pow2(b220, _3n3, P) * b3 % P;\\n    const t1 = pow2(b223, _23n, P) * b22 % P;\\n    const t2 = pow2(t1, _6n, P) * b2 % P;\\n    const root = pow2(t2, _2n5, P);\\n    if (!Fpk1.eql(Fpk1.sqr(root), y))\\n      throw new Error(\"Cannot find square root\");\\n    return root;\\n  }\\n  function taggedHash(tag, ...messages) {\\n    let tagP = TAGGED_HASH_PREFIXES[tag];\\n    if (tagP === void 0) {\\n      const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\\n      tagP = concatBytes3(tagH, tagH);\\n      TAGGED_HASH_PREFIXES[tag] = tagP;\\n    }\\n    return sha256(concatBytes3(tagP, ...messages));\\n  }\\n  function schnorrGetExtPubKey(priv) {\\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv);\\n    let p = Point.fromPrivateKey(d_);\\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\\n    return { scalar, bytes: pointToBytes(p) };\\n  }\\n  function lift_x(x) {\\n    aInRange(\"x\", x, _1n6, secp256k1P);\\n    const xx = modP(x * x);\\n    const c = modP(xx * x + BigInt(7));\\n    let y = sqrtMod(c);\\n    if (y % _2n5 !== _0n6)\\n      y = modP(-y);\\n    const p = new Point(x, y, _1n6);\\n    p.assertValidity();\\n    return p;\\n  }\\n  function challenge(...args) {\\n    return modN(num(taggedHash(\"BIP0340/challenge\", ...args)));\\n  }\\n  function schnorrGetPublicKey(privateKey) {\\n    return schnorrGetExtPubKey(privateKey).bytes;\\n  }\\n  function schnorrSign(message, privateKey, auxRand = randomBytes(32)) {\\n    const m = ensureBytes(\"message\", message);\\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);\\n    const a = ensureBytes(\"auxRand\", auxRand, 32);\\n    const t = numTo32b(d ^ num(taggedHash(\"BIP0340/aux\", a)));\\n    const rand = taggedHash(\"BIP0340/nonce\", t, px, m);\\n    const k_ = modN(num(rand));\\n    if (k_ === _0n6)\\n      throw new Error(\"sign failed: k is zero\");\\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);\\n    const e = challenge(rx, px, m);\\n    const sig = new Uint8Array(64);\\n    sig.set(rx, 0);\\n    sig.set(numTo32b(modN(k + e * d)), 32);\\n    if (!schnorrVerify(sig, m, px))\\n      throw new Error(\"sign: Invalid signature produced\");\\n    return sig;\\n  }\\n  function schnorrVerify(signature, message, publicKey) {\\n    const sig = ensureBytes(\"signature\", signature, 64);\\n    const m = ensureBytes(\"message\", message);\\n    const pub = ensureBytes(\"publicKey\", publicKey, 32);\\n    try {\\n      const P = lift_x(num(pub));\\n      const r = num(sig.subarray(0, 32));\\n      if (!inRange(r, _1n6, secp256k1P))\\n        return false;\\n      const s = num(sig.subarray(32, 64));\\n      if (!inRange(s, _1n6, secp256k1N))\\n        return false;\\n      const e = challenge(numTo32b(r), pointToBytes(P), m);\\n      const R = GmulAdd(P, s, modN(-e));\\n      if (!R || !R.hasEvenY() || R.toAffine().x !== r)\\n        return false;\\n      return true;\\n    } catch (error) {\\n      return false;\\n    }\\n  }\\n  var secp256k1P, secp256k1N, _1n6, _2n5, divNearest, Fpk1, secp256k1, _0n6, TAGGED_HASH_PREFIXES, pointToBytes, numTo32b, modP, modN, Point, GmulAdd, num, schnorr, isoMap, mapSWU, htf, hashToCurve, encodeToCurve;\\n  var init_secp256k1 = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/@noble+curves@1.8.1/node_modules/@noble/curves/esm/secp256k1.js\"() {\\n      init_sha256();\\n      init_utils2();\\n      init_shortw_utils();\\n      init_hash_to_curve();\\n      init_modular();\\n      init_utils4();\\n      init_weierstrass();\\n      secp256k1P = BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\");\\n      secp256k1N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\\n      _1n6 = BigInt(1);\\n      _2n5 = BigInt(2);\\n      divNearest = (a, b) => (a + b / _2n5) / b;\\n      Fpk1 = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });\\n      secp256k1 = createCurve({\\n        a: BigInt(0),\\n        // equation params: a, b\\n        b: BigInt(7),\\n        Fp: Fpk1,\\n        // Field\\'s prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n\\n        n: secp256k1N,\\n        // Curve order, total count of valid points in the field\\n        // Base point (x, y) aka generator point\\n        Gx: BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),\\n        Gy: BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),\\n        h: BigInt(1),\\n        // Cofactor\\n        lowS: true,\\n        // Allow only low-S signatures by default in sign() and verify()\\n        endo: {\\n          // Endomorphism, see above\\n          beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\\n          splitScalar: (k) => {\\n            const n = secp256k1N;\\n            const a1 = BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\");\\n            const b1 = -_1n6 * BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\");\\n            const a2 = BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\");\\n            const b2 = a1;\\n            const POW_2_128 = BigInt(\"0x100000000000000000000000000000000\");\\n            const c1 = divNearest(b2 * k, n);\\n            const c2 = divNearest(-b1 * k, n);\\n            let k1 = mod(k - c1 * a1 - c2 * a2, n);\\n            let k2 = mod(-c1 * b1 - c2 * b2, n);\\n            const k1neg = k1 > POW_2_128;\\n            const k2neg = k2 > POW_2_128;\\n            if (k1neg)\\n              k1 = n - k1;\\n            if (k2neg)\\n              k2 = n - k2;\\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\\n              throw new Error(\"splitScalar: Endomorphism failed, k=\" + k);\\n            }\\n            return { k1neg, k1, k2neg, k2 };\\n          }\\n        }\\n      }, sha256);\\n      _0n6 = BigInt(0);\\n      TAGGED_HASH_PREFIXES = {};\\n      pointToBytes = (point) => point.toRawBytes(true).slice(1);\\n      numTo32b = (n) => numberToBytesBE(n, 32);\\n      modP = (x) => mod(x, secp256k1P);\\n      modN = (x) => mod(x, secp256k1N);\\n      Point = secp256k1.ProjectivePoint;\\n      GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\\n      num = bytesToNumberBE;\\n      schnorr = /* @__PURE__ */ (() => ({\\n        getPublicKey: schnorrGetPublicKey,\\n        sign: schnorrSign,\\n        verify: schnorrVerify,\\n        utils: {\\n          randomPrivateKey: secp256k1.utils.randomPrivateKey,\\n          lift_x,\\n          pointToBytes,\\n          numberToBytesBE,\\n          bytesToNumberBE,\\n          taggedHash,\\n          mod\\n        }\\n      }))();\\n      isoMap = /* @__PURE__ */ (() => isogenyMap(Fpk1, [\\n        // xNum\\n        [\\n          \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7\",\\n          \"0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581\",\\n          \"0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262\",\\n          \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c\"\\n        ],\\n        // xDen\\n        [\\n          \"0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b\",\\n          \"0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14\",\\n          \"0x0000000000000000000000000000000000000000000000000000000000000001\"\\n          // LAST 1\\n        ],\\n        // yNum\\n        [\\n          \"0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c\",\\n          \"0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3\",\\n          \"0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931\",\\n          \"0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84\"\\n        ],\\n        // yDen\\n        [\\n          \"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b\",\\n          \"0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573\",\\n          \"0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f\",\\n          \"0x0000000000000000000000000000000000000000000000000000000000000001\"\\n          // LAST 1\\n        ]\\n      ].map((i) => i.map((j) => BigInt(j)))))();\\n      mapSWU = /* @__PURE__ */ (() => mapToCurveSimpleSWU(Fpk1, {\\n        A: BigInt(\"0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533\"),\\n        B: BigInt(\"1771\"),\\n        Z: Fpk1.create(BigInt(\"-11\"))\\n      }))();\\n      htf = /* @__PURE__ */ (() => createHasher(secp256k1.ProjectivePoint, (scalars) => {\\n        const { x, y } = mapSWU(Fpk1.create(scalars[0]));\\n        return isoMap(x, y);\\n      }, {\\n        DST: \"secp256k1_XMD:SHA-256_SSWU_RO_\",\\n        encodeDST: \"secp256k1_XMD:SHA-256_SSWU_NU_\",\\n        p: Fpk1.ORDER,\\n        m: 1,\\n        k: 128,\\n        expand: \"xmd\",\\n        hash: sha256\\n      }))();\\n      hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\\n      encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/node.js\\n  var ExecutionRevertedError, FeeCapTooHighError, FeeCapTooLowError, NonceTooHighError, NonceTooLowError, NonceMaxValueError, InsufficientFundsError, IntrinsicGasTooHighError, IntrinsicGasTooLowError, TransactionTypeNotSupportedError, TipAboveFeeCapError, UnknownNodeError;\\n  var init_node = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/node.js\"() {\\n      init_formatGwei();\\n      init_base();\\n      ExecutionRevertedError = class extends BaseError2 {\\n        constructor({ cause, message } = {}) {\\n          const reason = message?.replace(\"execution reverted: \", \"\")?.replace(\"execution reverted\", \"\");\\n          super(`Execution reverted ${reason ? `with reason: ${reason}` : \"for an unknown reason\"}.`, {\\n            cause,\\n            name: \"ExecutionRevertedError\"\\n          });\\n        }\\n      };\\n      Object.defineProperty(ExecutionRevertedError, \"code\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: 3\\n      });\\n      Object.defineProperty(ExecutionRevertedError, \"nodeMessage\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: /execution reverted/\\n      });\\n      FeeCapTooHighError = class extends BaseError2 {\\n        constructor({ cause, maxFeePerGas } = {}) {\\n          super(`The fee cap (\\\\`maxFeePerGas\\\\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : \"\"}) cannot be higher than the maximum allowed value (2^256-1).`, {\\n            cause,\\n            name: \"FeeCapTooHighError\"\\n          });\\n        }\\n      };\\n      Object.defineProperty(FeeCapTooHighError, \"nodeMessage\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: /max fee per gas higher than 2\\\\^256-1|fee cap higher than 2\\\\^256-1/\\n      });\\n      FeeCapTooLowError = class extends BaseError2 {\\n        constructor({ cause, maxFeePerGas } = {}) {\\n          super(`The fee cap (\\\\`maxFeePerGas\\\\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : \"\"} gwei) cannot be lower than the block base fee.`, {\\n            cause,\\n            name: \"FeeCapTooLowError\"\\n          });\\n        }\\n      };\\n      Object.defineProperty(FeeCapTooLowError, \"nodeMessage\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/\\n      });\\n      NonceTooHighError = class extends BaseError2 {\\n        constructor({ cause, nonce } = {}) {\\n          super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : \"\"}is higher than the next one expected.`, { cause, name: \"NonceTooHighError\" });\\n        }\\n      };\\n      Object.defineProperty(NonceTooHighError, \"nodeMessage\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: /nonce too high/\\n      });\\n      NonceTooLowError = class extends BaseError2 {\\n        constructor({ cause, nonce } = {}) {\\n          super([\\n            `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : \"\"}is lower than the current nonce of the account.`,\\n            \"Try increasing the nonce or find the latest nonce with `getTransactionCount`.\"\\n          ].join(\"\\\\n\"), { cause, name: \"NonceTooLowError\" });\\n        }\\n      };\\n      Object.defineProperty(NonceTooLowError, \"nodeMessage\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: /nonce too low|transaction already imported|already known/\\n      });\\n      NonceMaxValueError = class extends BaseError2 {\\n        constructor({ cause, nonce } = {}) {\\n          super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : \"\"}exceeds the maximum allowed nonce.`, { cause, name: \"NonceMaxValueError\" });\\n        }\\n      };\\n      Object.defineProperty(NonceMaxValueError, \"nodeMessage\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: /nonce has max value/\\n      });\\n      InsufficientFundsError = class extends BaseError2 {\\n        constructor({ cause } = {}) {\\n          super([\\n            \"The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account.\"\\n          ].join(\"\\\\n\"), {\\n            cause,\\n            metaMessages: [\\n              \"This error could arise when the account does not have enough funds to:\",\\n              \" - pay for the total gas fee,\",\\n              \" - pay for the value to send.\",\\n              \" \",\\n              \"The cost of the transaction is calculated as `gas * gas fee + value`, where:\",\\n              \" - `gas` is the amount of gas needed for transaction to execute,\",\\n              \" - `gas fee` is the gas fee,\",\\n              \" - `value` is the amount of ether to send to the recipient.\"\\n            ],\\n            name: \"InsufficientFundsError\"\\n          });\\n        }\\n      };\\n      Object.defineProperty(InsufficientFundsError, \"nodeMessage\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: /insufficient funds|exceeds transaction sender account balance/\\n      });\\n      IntrinsicGasTooHighError = class extends BaseError2 {\\n        constructor({ cause, gas } = {}) {\\n          super(`The amount of gas ${gas ? `(${gas}) ` : \"\"}provided for the transaction exceeds the limit allowed for the block.`, {\\n            cause,\\n            name: \"IntrinsicGasTooHighError\"\\n          });\\n        }\\n      };\\n      Object.defineProperty(IntrinsicGasTooHighError, \"nodeMessage\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: /intrinsic gas too high|gas limit reached/\\n      });\\n      IntrinsicGasTooLowError = class extends BaseError2 {\\n        constructor({ cause, gas } = {}) {\\n          super(`The amount of gas ${gas ? `(${gas}) ` : \"\"}provided for the transaction is too low.`, {\\n            cause,\\n            name: \"IntrinsicGasTooLowError\"\\n          });\\n        }\\n      };\\n      Object.defineProperty(IntrinsicGasTooLowError, \"nodeMessage\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: /intrinsic gas too low/\\n      });\\n      TransactionTypeNotSupportedError = class extends BaseError2 {\\n        constructor({ cause }) {\\n          super(\"The transaction type is not supported for this chain.\", {\\n            cause,\\n            name: \"TransactionTypeNotSupportedError\"\\n          });\\n        }\\n      };\\n      Object.defineProperty(TransactionTypeNotSupportedError, \"nodeMessage\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: /transaction type not valid/\\n      });\\n      TipAboveFeeCapError = class extends BaseError2 {\\n        constructor({ cause, maxPriorityFeePerGas, maxFeePerGas } = {}) {\\n          super([\\n            `The provided tip (\\\\`maxPriorityFeePerGas\\\\`${maxPriorityFeePerGas ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei` : \"\"}) cannot be higher than the fee cap (\\\\`maxFeePerGas\\\\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : \"\"}).`\\n          ].join(\"\\\\n\"), {\\n            cause,\\n            name: \"TipAboveFeeCapError\"\\n          });\\n        }\\n      };\\n      Object.defineProperty(TipAboveFeeCapError, \"nodeMessage\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/\\n      });\\n      UnknownNodeError = class extends BaseError2 {\\n        constructor({ cause }) {\\n          super(`An error occurred while executing: ${cause?.shortMessage}`, {\\n            cause,\\n            name: \"UnknownNodeError\"\\n          });\\n        }\\n      };\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/errors/getNodeError.js\\n  function getNodeError(err, args) {\\n    const message = (err.details || \"\").toLowerCase();\\n    const executionRevertedError = err instanceof BaseError2 ? err.walk((e) => e?.code === ExecutionRevertedError.code) : err;\\n    if (executionRevertedError instanceof BaseError2)\\n      return new ExecutionRevertedError({\\n        cause: err,\\n        message: executionRevertedError.details\\n      });\\n    if (ExecutionRevertedError.nodeMessage.test(message))\\n      return new ExecutionRevertedError({\\n        cause: err,\\n        message: err.details\\n      });\\n    if (FeeCapTooHighError.nodeMessage.test(message))\\n      return new FeeCapTooHighError({\\n        cause: err,\\n        maxFeePerGas: args?.maxFeePerGas\\n      });\\n    if (FeeCapTooLowError.nodeMessage.test(message))\\n      return new FeeCapTooLowError({\\n        cause: err,\\n        maxFeePerGas: args?.maxFeePerGas\\n      });\\n    if (NonceTooHighError.nodeMessage.test(message))\\n      return new NonceTooHighError({ cause: err, nonce: args?.nonce });\\n    if (NonceTooLowError.nodeMessage.test(message))\\n      return new NonceTooLowError({ cause: err, nonce: args?.nonce });\\n    if (NonceMaxValueError.nodeMessage.test(message))\\n      return new NonceMaxValueError({ cause: err, nonce: args?.nonce });\\n    if (InsufficientFundsError.nodeMessage.test(message))\\n      return new InsufficientFundsError({ cause: err });\\n    if (IntrinsicGasTooHighError.nodeMessage.test(message))\\n      return new IntrinsicGasTooHighError({ cause: err, gas: args?.gas });\\n    if (IntrinsicGasTooLowError.nodeMessage.test(message))\\n      return new IntrinsicGasTooLowError({ cause: err, gas: args?.gas });\\n    if (TransactionTypeNotSupportedError.nodeMessage.test(message))\\n      return new TransactionTypeNotSupportedError({ cause: err });\\n    if (TipAboveFeeCapError.nodeMessage.test(message))\\n      return new TipAboveFeeCapError({\\n        cause: err,\\n        maxFeePerGas: args?.maxFeePerGas,\\n        maxPriorityFeePerGas: args?.maxPriorityFeePerGas\\n      });\\n    return new UnknownNodeError({\\n      cause: err\\n    });\\n  }\\n  var init_getNodeError = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/errors/getNodeError.js\"() {\\n      init_base();\\n      init_node();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/formatters/extract.js\\n  function extract(value_, { format }) {\\n    if (!format)\\n      return {};\\n    const value = {};\\n    function extract_(formatted2) {\\n      const keys = Object.keys(formatted2);\\n      for (const key of keys) {\\n        if (key in value_)\\n          value[key] = value_[key];\\n        if (formatted2[key] && typeof formatted2[key] === \"object\" && !Array.isArray(formatted2[key]))\\n          extract_(formatted2[key]);\\n      }\\n    }\\n    const formatted = format(value_ || {});\\n    extract_(formatted);\\n    return value;\\n  }\\n  var init_extract = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/formatters/extract.js\"() {\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/formatters/formatter.js\\n  function defineFormatter(type, format) {\\n    return ({ exclude, format: overrides }) => {\\n      return {\\n        exclude,\\n        format: (args) => {\\n          const formatted = format(args);\\n          if (exclude) {\\n            for (const key of exclude) {\\n              delete formatted[key];\\n            }\\n          }\\n          return {\\n            ...formatted,\\n            ...overrides(args)\\n          };\\n        },\\n        type\\n      };\\n    };\\n  }\\n  var init_formatter = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/formatters/formatter.js\"() {\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/formatters/transactionRequest.js\\n  function formatTransactionRequest(request) {\\n    const rpcRequest = {};\\n    if (typeof request.authorizationList !== \"undefined\")\\n      rpcRequest.authorizationList = formatAuthorizationList(request.authorizationList);\\n    if (typeof request.accessList !== \"undefined\")\\n      rpcRequest.accessList = request.accessList;\\n    if (typeof request.blobVersionedHashes !== \"undefined\")\\n      rpcRequest.blobVersionedHashes = request.blobVersionedHashes;\\n    if (typeof request.blobs !== \"undefined\") {\\n      if (typeof request.blobs[0] !== \"string\")\\n        rpcRequest.blobs = request.blobs.map((x) => bytesToHex(x));\\n      else\\n        rpcRequest.blobs = request.blobs;\\n    }\\n    if (typeof request.data !== \"undefined\")\\n      rpcRequest.data = request.data;\\n    if (typeof request.from !== \"undefined\")\\n      rpcRequest.from = request.from;\\n    if (typeof request.gas !== \"undefined\")\\n      rpcRequest.gas = numberToHex(request.gas);\\n    if (typeof request.gasPrice !== \"undefined\")\\n      rpcRequest.gasPrice = numberToHex(request.gasPrice);\\n    if (typeof request.maxFeePerBlobGas !== \"undefined\")\\n      rpcRequest.maxFeePerBlobGas = numberToHex(request.maxFeePerBlobGas);\\n    if (typeof request.maxFeePerGas !== \"undefined\")\\n      rpcRequest.maxFeePerGas = numberToHex(request.maxFeePerGas);\\n    if (typeof request.maxPriorityFeePerGas !== \"undefined\")\\n      rpcRequest.maxPriorityFeePerGas = numberToHex(request.maxPriorityFeePerGas);\\n    if (typeof request.nonce !== \"undefined\")\\n      rpcRequest.nonce = numberToHex(request.nonce);\\n    if (typeof request.to !== \"undefined\")\\n      rpcRequest.to = request.to;\\n    if (typeof request.type !== \"undefined\")\\n      rpcRequest.type = rpcTransactionType[request.type];\\n    if (typeof request.value !== \"undefined\")\\n      rpcRequest.value = numberToHex(request.value);\\n    return rpcRequest;\\n  }\\n  function formatAuthorizationList(authorizationList) {\\n    return authorizationList.map((authorization) => ({\\n      address: authorization.address,\\n      r: authorization.r ? numberToHex(BigInt(authorization.r)) : authorization.r,\\n      s: authorization.s ? numberToHex(BigInt(authorization.s)) : authorization.s,\\n      chainId: numberToHex(authorization.chainId),\\n      nonce: numberToHex(authorization.nonce),\\n      ...typeof authorization.yParity !== \"undefined\" ? { yParity: numberToHex(authorization.yParity) } : {},\\n      ...typeof authorization.v !== \"undefined\" && typeof authorization.yParity === \"undefined\" ? { v: numberToHex(authorization.v) } : {}\\n    }));\\n  }\\n  var rpcTransactionType;\\n  var init_transactionRequest = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/formatters/transactionRequest.js\"() {\\n      init_toHex();\\n      rpcTransactionType = {\\n        legacy: \"0x0\",\\n        eip2930: \"0x1\",\\n        eip1559: \"0x2\",\\n        eip4844: \"0x3\",\\n        eip7702: \"0x4\"\\n      };\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/stateOverride.js\\n  function serializeStateMapping(stateMapping) {\\n    if (!stateMapping || stateMapping.length === 0)\\n      return void 0;\\n    return stateMapping.reduce((acc, { slot, value }) => {\\n      if (slot.length !== 66)\\n        throw new InvalidBytesLengthError({\\n          size: slot.length,\\n          targetSize: 66,\\n          type: \"hex\"\\n        });\\n      if (value.length !== 66)\\n        throw new InvalidBytesLengthError({\\n          size: value.length,\\n          targetSize: 66,\\n          type: \"hex\"\\n        });\\n      acc[slot] = value;\\n      return acc;\\n    }, {});\\n  }\\n  function serializeAccountStateOverride(parameters) {\\n    const { balance, nonce, state, stateDiff, code } = parameters;\\n    const rpcAccountStateOverride = {};\\n    if (code !== void 0)\\n      rpcAccountStateOverride.code = code;\\n    if (balance !== void 0)\\n      rpcAccountStateOverride.balance = numberToHex(balance);\\n    if (nonce !== void 0)\\n      rpcAccountStateOverride.nonce = numberToHex(nonce);\\n    if (state !== void 0)\\n      rpcAccountStateOverride.state = serializeStateMapping(state);\\n    if (stateDiff !== void 0) {\\n      if (rpcAccountStateOverride.state)\\n        throw new StateAssignmentConflictError();\\n      rpcAccountStateOverride.stateDiff = serializeStateMapping(stateDiff);\\n    }\\n    return rpcAccountStateOverride;\\n  }\\n  function serializeStateOverride(parameters) {\\n    if (!parameters)\\n      return void 0;\\n    const rpcStateOverride = {};\\n    for (const { address, ...accountState } of parameters) {\\n      if (!isAddress(address, { strict: false }))\\n        throw new InvalidAddressError({ address });\\n      if (rpcStateOverride[address])\\n        throw new AccountStateConflictError({ address });\\n      rpcStateOverride[address] = serializeAccountStateOverride(accountState);\\n    }\\n    return rpcStateOverride;\\n  }\\n  var init_stateOverride2 = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/stateOverride.js\"() {\\n      init_address();\\n      init_data();\\n      init_stateOverride();\\n      init_isAddress();\\n      init_toHex();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/constants/number.js\\n  var maxInt8, maxInt16, maxInt24, maxInt32, maxInt40, maxInt48, maxInt56, maxInt64, maxInt72, maxInt80, maxInt88, maxInt96, maxInt104, maxInt112, maxInt120, maxInt128, maxInt136, maxInt144, maxInt152, maxInt160, maxInt168, maxInt176, maxInt184, maxInt192, maxInt200, maxInt208, maxInt216, maxInt224, maxInt232, maxInt240, maxInt248, maxInt256, minInt8, minInt16, minInt24, minInt32, minInt40, minInt48, minInt56, minInt64, minInt72, minInt80, minInt88, minInt96, minInt104, minInt112, minInt120, minInt128, minInt136, minInt144, minInt152, minInt160, minInt168, minInt176, minInt184, minInt192, minInt200, minInt208, minInt216, minInt224, minInt232, minInt240, minInt248, minInt256, maxUint8, maxUint16, maxUint24, maxUint32, maxUint40, maxUint48, maxUint56, maxUint64, maxUint72, maxUint80, maxUint88, maxUint96, maxUint104, maxUint112, maxUint120, maxUint128, maxUint136, maxUint144, maxUint152, maxUint160, maxUint168, maxUint176, maxUint184, maxUint192, maxUint200, maxUint208, maxUint216, maxUint224, maxUint232, maxUint240, maxUint248, maxUint256;\\n  var init_number = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/constants/number.js\"() {\\n      maxInt8 = 2n ** (8n - 1n) - 1n;\\n      maxInt16 = 2n ** (16n - 1n) - 1n;\\n      maxInt24 = 2n ** (24n - 1n) - 1n;\\n      maxInt32 = 2n ** (32n - 1n) - 1n;\\n      maxInt40 = 2n ** (40n - 1n) - 1n;\\n      maxInt48 = 2n ** (48n - 1n) - 1n;\\n      maxInt56 = 2n ** (56n - 1n) - 1n;\\n      maxInt64 = 2n ** (64n - 1n) - 1n;\\n      maxInt72 = 2n ** (72n - 1n) - 1n;\\n      maxInt80 = 2n ** (80n - 1n) - 1n;\\n      maxInt88 = 2n ** (88n - 1n) - 1n;\\n      maxInt96 = 2n ** (96n - 1n) - 1n;\\n      maxInt104 = 2n ** (104n - 1n) - 1n;\\n      maxInt112 = 2n ** (112n - 1n) - 1n;\\n      maxInt120 = 2n ** (120n - 1n) - 1n;\\n      maxInt128 = 2n ** (128n - 1n) - 1n;\\n      maxInt136 = 2n ** (136n - 1n) - 1n;\\n      maxInt144 = 2n ** (144n - 1n) - 1n;\\n      maxInt152 = 2n ** (152n - 1n) - 1n;\\n      maxInt160 = 2n ** (160n - 1n) - 1n;\\n      maxInt168 = 2n ** (168n - 1n) - 1n;\\n      maxInt176 = 2n ** (176n - 1n) - 1n;\\n      maxInt184 = 2n ** (184n - 1n) - 1n;\\n      maxInt192 = 2n ** (192n - 1n) - 1n;\\n      maxInt200 = 2n ** (200n - 1n) - 1n;\\n      maxInt208 = 2n ** (208n - 1n) - 1n;\\n      maxInt216 = 2n ** (216n - 1n) - 1n;\\n      maxInt224 = 2n ** (224n - 1n) - 1n;\\n      maxInt232 = 2n ** (232n - 1n) - 1n;\\n      maxInt240 = 2n ** (240n - 1n) - 1n;\\n      maxInt248 = 2n ** (248n - 1n) - 1n;\\n      maxInt256 = 2n ** (256n - 1n) - 1n;\\n      minInt8 = -(2n ** (8n - 1n));\\n      minInt16 = -(2n ** (16n - 1n));\\n      minInt24 = -(2n ** (24n - 1n));\\n      minInt32 = -(2n ** (32n - 1n));\\n      minInt40 = -(2n ** (40n - 1n));\\n      minInt48 = -(2n ** (48n - 1n));\\n      minInt56 = -(2n ** (56n - 1n));\\n      minInt64 = -(2n ** (64n - 1n));\\n      minInt72 = -(2n ** (72n - 1n));\\n      minInt80 = -(2n ** (80n - 1n));\\n      minInt88 = -(2n ** (88n - 1n));\\n      minInt96 = -(2n ** (96n - 1n));\\n      minInt104 = -(2n ** (104n - 1n));\\n      minInt112 = -(2n ** (112n - 1n));\\n      minInt120 = -(2n ** (120n - 1n));\\n      minInt128 = -(2n ** (128n - 1n));\\n      minInt136 = -(2n ** (136n - 1n));\\n      minInt144 = -(2n ** (144n - 1n));\\n      minInt152 = -(2n ** (152n - 1n));\\n      minInt160 = -(2n ** (160n - 1n));\\n      minInt168 = -(2n ** (168n - 1n));\\n      minInt176 = -(2n ** (176n - 1n));\\n      minInt184 = -(2n ** (184n - 1n));\\n      minInt192 = -(2n ** (192n - 1n));\\n      minInt200 = -(2n ** (200n - 1n));\\n      minInt208 = -(2n ** (208n - 1n));\\n      minInt216 = -(2n ** (216n - 1n));\\n      minInt224 = -(2n ** (224n - 1n));\\n      minInt232 = -(2n ** (232n - 1n));\\n      minInt240 = -(2n ** (240n - 1n));\\n      minInt248 = -(2n ** (248n - 1n));\\n      minInt256 = -(2n ** (256n - 1n));\\n      maxUint8 = 2n ** 8n - 1n;\\n      maxUint16 = 2n ** 16n - 1n;\\n      maxUint24 = 2n ** 24n - 1n;\\n      maxUint32 = 2n ** 32n - 1n;\\n      maxUint40 = 2n ** 40n - 1n;\\n      maxUint48 = 2n ** 48n - 1n;\\n      maxUint56 = 2n ** 56n - 1n;\\n      maxUint64 = 2n ** 64n - 1n;\\n      maxUint72 = 2n ** 72n - 1n;\\n      maxUint80 = 2n ** 80n - 1n;\\n      maxUint88 = 2n ** 88n - 1n;\\n      maxUint96 = 2n ** 96n - 1n;\\n      maxUint104 = 2n ** 104n - 1n;\\n      maxUint112 = 2n ** 112n - 1n;\\n      maxUint120 = 2n ** 120n - 1n;\\n      maxUint128 = 2n ** 128n - 1n;\\n      maxUint136 = 2n ** 136n - 1n;\\n      maxUint144 = 2n ** 144n - 1n;\\n      maxUint152 = 2n ** 152n - 1n;\\n      maxUint160 = 2n ** 160n - 1n;\\n      maxUint168 = 2n ** 168n - 1n;\\n      maxUint176 = 2n ** 176n - 1n;\\n      maxUint184 = 2n ** 184n - 1n;\\n      maxUint192 = 2n ** 192n - 1n;\\n      maxUint200 = 2n ** 200n - 1n;\\n      maxUint208 = 2n ** 208n - 1n;\\n      maxUint216 = 2n ** 216n - 1n;\\n      maxUint224 = 2n ** 224n - 1n;\\n      maxUint232 = 2n ** 232n - 1n;\\n      maxUint240 = 2n ** 240n - 1n;\\n      maxUint248 = 2n ** 248n - 1n;\\n      maxUint256 = 2n ** 256n - 1n;\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/transaction/assertRequest.js\\n  function assertRequest(args) {\\n    const { account: account_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to } = args;\\n    const account = account_ ? parseAccount(account_) : void 0;\\n    if (account && !isAddress(account.address))\\n      throw new InvalidAddressError({ address: account.address });\\n    if (to && !isAddress(to))\\n      throw new InvalidAddressError({ address: to });\\n    if (typeof gasPrice !== \"undefined\" && (typeof maxFeePerGas !== \"undefined\" || typeof maxPriorityFeePerGas !== \"undefined\"))\\n      throw new FeeConflictError();\\n    if (maxFeePerGas && maxFeePerGas > maxUint256)\\n      throw new FeeCapTooHighError({ maxFeePerGas });\\n    if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)\\n      throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });\\n  }\\n  var init_assertRequest = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/transaction/assertRequest.js\"() {\\n      init_parseAccount();\\n      init_number();\\n      init_address();\\n      init_node();\\n      init_transaction();\\n      init_isAddress();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/address/isAddressEqual.js\\n  function isAddressEqual(a, b) {\\n    if (!isAddress(a, { strict: false }))\\n      throw new InvalidAddressError({ address: a });\\n    if (!isAddress(b, { strict: false }))\\n      throw new InvalidAddressError({ address: b });\\n    return a.toLowerCase() === b.toLowerCase();\\n  }\\n  var init_isAddressEqual = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/address/isAddressEqual.js\"() {\\n      init_address();\\n      init_isAddress();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/abi/decodeFunctionResult.js\\n  function decodeFunctionResult(parameters) {\\n    const { abi: abi2, args, functionName, data } = parameters;\\n    let abiItem = abi2[0];\\n    if (functionName) {\\n      const item = getAbiItem({ abi: abi2, args, name: functionName });\\n      if (!item)\\n        throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath4 });\\n      abiItem = item;\\n    }\\n    if (abiItem.type !== \"function\")\\n      throw new AbiFunctionNotFoundError(void 0, { docsPath: docsPath4 });\\n    if (!abiItem.outputs)\\n      throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath: docsPath4 });\\n    const values = decodeAbiParameters(abiItem.outputs, data);\\n    if (values && values.length > 1)\\n      return values;\\n    if (values && values.length === 1)\\n      return values[0];\\n    return void 0;\\n  }\\n  var docsPath4;\\n  var init_decodeFunctionResult = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/abi/decodeFunctionResult.js\"() {\\n      init_abi();\\n      init_decodeAbiParameters();\\n      init_getAbiItem();\\n      docsPath4 = \"/docs/contract/decodeFunctionResult\";\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/constants/abis.js\\n  var multicall3Abi, batchGatewayAbi, universalResolverErrors, universalResolverResolveAbi, universalResolverReverseAbi, textResolverAbi, addressResolverAbi, universalSignatureValidatorAbi;\\n  var init_abis = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/constants/abis.js\"() {\\n      multicall3Abi = [\\n        {\\n          inputs: [\\n            {\\n              components: [\\n                {\\n                  name: \"target\",\\n                  type: \"address\"\\n                },\\n                {\\n                  name: \"allowFailure\",\\n                  type: \"bool\"\\n                },\\n                {\\n                  name: \"callData\",\\n                  type: \"bytes\"\\n                }\\n              ],\\n              name: \"calls\",\\n              type: \"tuple[]\"\\n            }\\n          ],\\n          name: \"aggregate3\",\\n          outputs: [\\n            {\\n              components: [\\n                {\\n                  name: \"success\",\\n                  type: \"bool\"\\n                },\\n                {\\n                  name: \"returnData\",\\n                  type: \"bytes\"\\n                }\\n              ],\\n              name: \"returnData\",\\n              type: \"tuple[]\"\\n            }\\n          ],\\n          stateMutability: \"view\",\\n          type: \"function\"\\n        }\\n      ];\\n      batchGatewayAbi = [\\n        {\\n          name: \"query\",\\n          type: \"function\",\\n          stateMutability: \"view\",\\n          inputs: [\\n            {\\n              type: \"tuple[]\",\\n              name: \"queries\",\\n              components: [\\n                {\\n                  type: \"address\",\\n                  name: \"sender\"\\n                },\\n                {\\n                  type: \"string[]\",\\n                  name: \"urls\"\\n                },\\n                {\\n                  type: \"bytes\",\\n                  name: \"data\"\\n                }\\n              ]\\n            }\\n          ],\\n          outputs: [\\n            {\\n              type: \"bool[]\",\\n              name: \"failures\"\\n            },\\n            {\\n              type: \"bytes[]\",\\n              name: \"responses\"\\n            }\\n          ]\\n        },\\n        {\\n          name: \"HttpError\",\\n          type: \"error\",\\n          inputs: [\\n            {\\n              type: \"uint16\",\\n              name: \"status\"\\n            },\\n            {\\n              type: \"string\",\\n              name: \"message\"\\n            }\\n          ]\\n        }\\n      ];\\n      universalResolverErrors = [\\n        {\\n          inputs: [],\\n          name: \"ResolverNotFound\",\\n          type: \"error\"\\n        },\\n        {\\n          inputs: [],\\n          name: \"ResolverWildcardNotSupported\",\\n          type: \"error\"\\n        },\\n        {\\n          inputs: [],\\n          name: \"ResolverNotContract\",\\n          type: \"error\"\\n        },\\n        {\\n          inputs: [\\n            {\\n              name: \"returnData\",\\n              type: \"bytes\"\\n            }\\n          ],\\n          name: \"ResolverError\",\\n          type: \"error\"\\n        },\\n        {\\n          inputs: [\\n            {\\n              components: [\\n                {\\n                  name: \"status\",\\n                  type: \"uint16\"\\n                },\\n                {\\n                  name: \"message\",\\n                  type: \"string\"\\n                }\\n              ],\\n              name: \"errors\",\\n              type: \"tuple[]\"\\n            }\\n          ],\\n          name: \"HttpError\",\\n          type: \"error\"\\n        }\\n      ];\\n      universalResolverResolveAbi = [\\n        ...universalResolverErrors,\\n        {\\n          name: \"resolve\",\\n          type: \"function\",\\n          stateMutability: \"view\",\\n          inputs: [\\n            { name: \"name\", type: \"bytes\" },\\n            { name: \"data\", type: \"bytes\" }\\n          ],\\n          outputs: [\\n            { name: \"\", type: \"bytes\" },\\n            { name: \"address\", type: \"address\" }\\n          ]\\n        },\\n        {\\n          name: \"resolve\",\\n          type: \"function\",\\n          stateMutability: \"view\",\\n          inputs: [\\n            { name: \"name\", type: \"bytes\" },\\n            { name: \"data\", type: \"bytes\" },\\n            { name: \"gateways\", type: \"string[]\" }\\n          ],\\n          outputs: [\\n            { name: \"\", type: \"bytes\" },\\n            { name: \"address\", type: \"address\" }\\n          ]\\n        }\\n      ];\\n      universalResolverReverseAbi = [\\n        ...universalResolverErrors,\\n        {\\n          name: \"reverse\",\\n          type: \"function\",\\n          stateMutability: \"view\",\\n          inputs: [{ type: \"bytes\", name: \"reverseName\" }],\\n          outputs: [\\n            { type: \"string\", name: \"resolvedName\" },\\n            { type: \"address\", name: \"resolvedAddress\" },\\n            { type: \"address\", name: \"reverseResolver\" },\\n            { type: \"address\", name: \"resolver\" }\\n          ]\\n        },\\n        {\\n          name: \"reverse\",\\n          type: \"function\",\\n          stateMutability: \"view\",\\n          inputs: [\\n            { type: \"bytes\", name: \"reverseName\" },\\n            { type: \"string[]\", name: \"gateways\" }\\n          ],\\n          outputs: [\\n            { type: \"string\", name: \"resolvedName\" },\\n            { type: \"address\", name: \"resolvedAddress\" },\\n            { type: \"address\", name: \"reverseResolver\" },\\n            { type: \"address\", name: \"resolver\" }\\n          ]\\n        }\\n      ];\\n      textResolverAbi = [\\n        {\\n          name: \"text\",\\n          type: \"function\",\\n          stateMutability: \"view\",\\n          inputs: [\\n            { name: \"name\", type: \"bytes32\" },\\n            { name: \"key\", type: \"string\" }\\n          ],\\n          outputs: [{ name: \"\", type: \"string\" }]\\n        }\\n      ];\\n      addressResolverAbi = [\\n        {\\n          name: \"addr\",\\n          type: \"function\",\\n          stateMutability: \"view\",\\n          inputs: [{ name: \"name\", type: \"bytes32\" }],\\n          outputs: [{ name: \"\", type: \"address\" }]\\n        },\\n        {\\n          name: \"addr\",\\n          type: \"function\",\\n          stateMutability: \"view\",\\n          inputs: [\\n            { name: \"name\", type: \"bytes32\" },\\n            { name: \"coinType\", type: \"uint256\" }\\n          ],\\n          outputs: [{ name: \"\", type: \"bytes\" }]\\n        }\\n      ];\\n      universalSignatureValidatorAbi = [\\n        {\\n          inputs: [\\n            {\\n              name: \"_signer\",\\n              type: \"address\"\\n            },\\n            {\\n              name: \"_hash\",\\n              type: \"bytes32\"\\n            },\\n            {\\n              name: \"_signature\",\\n              type: \"bytes\"\\n            }\\n          ],\\n          stateMutability: \"nonpayable\",\\n          type: \"constructor\"\\n        },\\n        {\\n          inputs: [\\n            {\\n              name: \"_signer\",\\n              type: \"address\"\\n            },\\n            {\\n              name: \"_hash\",\\n              type: \"bytes32\"\\n            },\\n            {\\n              name: \"_signature\",\\n              type: \"bytes\"\\n            }\\n          ],\\n          outputs: [\\n            {\\n              type: \"bool\"\\n            }\\n          ],\\n          stateMutability: \"nonpayable\",\\n          type: \"function\",\\n          name: \"isValidSig\"\\n        }\\n      ];\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/constants/contract.js\\n  var aggregate3Signature;\\n  var init_contract2 = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/constants/contract.js\"() {\\n      aggregate3Signature = \"0x82ad56cb\";\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/constants/contracts.js\\n  var deploylessCallViaBytecodeBytecode, deploylessCallViaFactoryBytecode, universalSignatureValidatorByteCode;\\n  var init_contracts = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/constants/contracts.js\"() {\\n      deploylessCallViaBytecodeBytecode = \"0x608060405234801561001057600080fd5b5060405161018e38038061018e83398101604081905261002f91610124565b6000808351602085016000f59050803b61004857600080fd5b6000808351602085016000855af16040513d6000823e81610067573d81fd5b3d81f35b634e487b7160e01b600052604160045260246000fd5b600082601f83011261009257600080fd5b81516001600160401b038111156100ab576100ab61006b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156100d9576100d961006b565b6040528181528382016020018510156100f157600080fd5b60005b82811015610110576020818601810151838301820152016100f4565b506000918101602001919091529392505050565b6000806040838503121561013757600080fd5b82516001600160401b0381111561014d57600080fd5b61015985828601610081565b602085015190935090506001600160401b0381111561017757600080fd5b61018385828601610081565b915050925092905056fe\";\\n      deploylessCallViaFactoryBytecode = \"0x608060405234801561001057600080fd5b506040516102c03803806102c083398101604081905261002f916101e6565b836001600160a01b03163b6000036100e457600080836001600160a01b03168360405161005c9190610270565b6000604051808303816000865af19150503d8060008114610099576040519150601f19603f3d011682016040523d82523d6000602084013e61009e565b606091505b50915091508115806100b857506001600160a01b0386163b155b156100e1578060405163101bb98d60e01b81526004016100d8919061028c565b60405180910390fd5b50505b6000808451602086016000885af16040513d6000823e81610103573d81fd5b3d81f35b80516001600160a01b038116811461011e57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561015457818101518382015260200161013c565b50506000910152565b600082601f83011261016e57600080fd5b81516001600160401b0381111561018757610187610123565b604051601f8201601f19908116603f011681016001600160401b03811182821017156101b5576101b5610123565b6040528181528382016020018510156101cd57600080fd5b6101de826020830160208701610139565b949350505050565b600080600080608085870312156101fc57600080fd5b61020585610107565b60208601519094506001600160401b0381111561022157600080fd5b61022d8782880161015d565b93505061023c60408601610107565b60608601519092506001600160401b0381111561025857600080fd5b6102648782880161015d565b91505092959194509250565b60008251610282818460208701610139565b9190910192915050565b60208152600082518060208401526102ab816040850160208701610139565b601f01601f1916919091016040019291505056fe\";\\n      universalSignatureValidatorByteCode = \"0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572\";\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/chain.js\\n  var ChainDoesNotSupportContract, ChainMismatchError, ChainNotFoundError, ClientChainNotConfiguredError, InvalidChainIdError;\\n  var init_chain = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/chain.js\"() {\\n      init_base();\\n      ChainDoesNotSupportContract = class extends BaseError2 {\\n        constructor({ blockNumber, chain, contract }) {\\n          super(`Chain \"${chain.name}\" does not support contract \"${contract.name}\".`, {\\n            metaMessages: [\\n              \"This could be due to any of the following:\",\\n              ...blockNumber && contract.blockCreated && contract.blockCreated > blockNumber ? [\\n                `- The contract \"${contract.name}\" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`\\n              ] : [\\n                `- The chain does not have the contract \"${contract.name}\" configured.`\\n              ]\\n            ],\\n            name: \"ChainDoesNotSupportContract\"\\n          });\\n        }\\n      };\\n      ChainMismatchError = class extends BaseError2 {\\n        constructor({ chain, currentChainId }) {\\n          super(`The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id} \\\\u2013 ${chain.name}).`, {\\n            metaMessages: [\\n              `Current Chain ID:  ${currentChainId}`,\\n              `Expected Chain ID: ${chain.id} \\\\u2013 ${chain.name}`\\n            ],\\n            name: \"ChainMismatchError\"\\n          });\\n        }\\n      };\\n      ChainNotFoundError = class extends BaseError2 {\\n        constructor() {\\n          super([\\n            \"No chain was provided to the request.\",\\n            \"Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient.\"\\n          ].join(\"\\\\n\"), {\\n            name: \"ChainNotFoundError\"\\n          });\\n        }\\n      };\\n      ClientChainNotConfiguredError = class extends BaseError2 {\\n        constructor() {\\n          super(\"No chain was provided to the Client.\", {\\n            name: \"ClientChainNotConfiguredError\"\\n          });\\n        }\\n      };\\n      InvalidChainIdError = class extends BaseError2 {\\n        constructor({ chainId }) {\\n          super(typeof chainId === \"number\" ? `Chain ID \"${chainId}\" is invalid.` : \"Chain ID is invalid.\", { name: \"InvalidChainIdError\" });\\n        }\\n      };\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/abi/encodeDeployData.js\\n  function encodeDeployData(parameters) {\\n    const { abi: abi2, args, bytecode } = parameters;\\n    if (!args || args.length === 0)\\n      return bytecode;\\n    const description = abi2.find((x) => \"type\" in x && x.type === \"constructor\");\\n    if (!description)\\n      throw new AbiConstructorNotFoundError({ docsPath: docsPath5 });\\n    if (!(\"inputs\" in description))\\n      throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath5 });\\n    if (!description.inputs || description.inputs.length === 0)\\n      throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath5 });\\n    const data = encodeAbiParameters(description.inputs, args);\\n    return concatHex([bytecode, data]);\\n  }\\n  var docsPath5;\\n  var init_encodeDeployData = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/abi/encodeDeployData.js\"() {\\n      init_abi();\\n      init_concat();\\n      init_encodeAbiParameters();\\n      docsPath5 = \"/docs/contract/encodeDeployData\";\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/chain/getChainContractAddress.js\\n  function getChainContractAddress({ blockNumber, chain, contract: name }) {\\n    const contract = chain?.contracts?.[name];\\n    if (!contract)\\n      throw new ChainDoesNotSupportContract({\\n        chain,\\n        contract: { name }\\n      });\\n    if (blockNumber && contract.blockCreated && contract.blockCreated > blockNumber)\\n      throw new ChainDoesNotSupportContract({\\n        blockNumber,\\n        chain,\\n        contract: {\\n          name,\\n          blockCreated: contract.blockCreated\\n        }\\n      });\\n    return contract.address;\\n  }\\n  var init_getChainContractAddress = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/chain/getChainContractAddress.js\"() {\\n      init_chain();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/errors/getCallError.js\\n  function getCallError(err, { docsPath: docsPath8, ...args }) {\\n    const cause = (() => {\\n      const cause2 = getNodeError(err, args);\\n      if (cause2 instanceof UnknownNodeError)\\n        return err;\\n      return cause2;\\n    })();\\n    return new CallExecutionError(cause, {\\n      docsPath: docsPath8,\\n      ...args\\n    });\\n  }\\n  var init_getCallError = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/errors/getCallError.js\"() {\\n      init_contract();\\n      init_node();\\n      init_getNodeError();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/promise/withResolvers.js\\n  function withResolvers() {\\n    let resolve = () => void 0;\\n    let reject = () => void 0;\\n    const promise = new Promise((resolve_, reject_) => {\\n      resolve = resolve_;\\n      reject = reject_;\\n    });\\n    return { promise, resolve, reject };\\n  }\\n  var init_withResolvers = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/promise/withResolvers.js\"() {\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/promise/createBatchScheduler.js\\n  function createBatchScheduler({ fn, id, shouldSplitBatch, wait: wait2 = 0, sort }) {\\n    const exec = async () => {\\n      const scheduler = getScheduler();\\n      flush();\\n      const args = scheduler.map(({ args: args2 }) => args2);\\n      if (args.length === 0)\\n        return;\\n      fn(args).then((data) => {\\n        if (sort && Array.isArray(data))\\n          data.sort(sort);\\n        for (let i = 0; i < scheduler.length; i++) {\\n          const { resolve } = scheduler[i];\\n          resolve?.([data[i], data]);\\n        }\\n      }).catch((err) => {\\n        for (let i = 0; i < scheduler.length; i++) {\\n          const { reject } = scheduler[i];\\n          reject?.(err);\\n        }\\n      });\\n    };\\n    const flush = () => schedulerCache.delete(id);\\n    const getBatchedArgs = () => getScheduler().map(({ args }) => args);\\n    const getScheduler = () => schedulerCache.get(id) || [];\\n    const setScheduler = (item) => schedulerCache.set(id, [...getScheduler(), item]);\\n    return {\\n      flush,\\n      async schedule(args) {\\n        const { promise, resolve, reject } = withResolvers();\\n        const split3 = shouldSplitBatch?.([...getBatchedArgs(), args]);\\n        if (split3)\\n          exec();\\n        const hasActiveScheduler = getScheduler().length > 0;\\n        if (hasActiveScheduler) {\\n          setScheduler({ args, resolve, reject });\\n          return promise;\\n        }\\n        setScheduler({ args, resolve, reject });\\n        setTimeout(exec, wait2);\\n        return promise;\\n      }\\n    };\\n  }\\n  var schedulerCache;\\n  var init_createBatchScheduler = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/promise/createBatchScheduler.js\"() {\\n      init_withResolvers();\\n      schedulerCache = /* @__PURE__ */ new Map();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/ccip.js\\n  var OffchainLookupError, OffchainLookupResponseMalformedError, OffchainLookupSenderMismatchError;\\n  var init_ccip = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/ccip.js\"() {\\n      init_stringify();\\n      init_base();\\n      init_utils3();\\n      OffchainLookupError = class extends BaseError2 {\\n        constructor({ callbackSelector, cause, data, extraData, sender, urls }) {\\n          super(cause.shortMessage || \"An error occurred while fetching for an offchain result.\", {\\n            cause,\\n            metaMessages: [\\n              ...cause.metaMessages || [],\\n              cause.metaMessages?.length ? \"\" : [],\\n              \"Offchain Gateway Call:\",\\n              urls && [\\n                \"  Gateway URL(s):\",\\n                ...urls.map((url) => `    ${getUrl(url)}`)\\n              ],\\n              `  Sender: ${sender}`,\\n              `  Data: ${data}`,\\n              `  Callback selector: ${callbackSelector}`,\\n              `  Extra data: ${extraData}`\\n            ].flat(),\\n            name: \"OffchainLookupError\"\\n          });\\n        }\\n      };\\n      OffchainLookupResponseMalformedError = class extends BaseError2 {\\n        constructor({ result, url }) {\\n          super(\"Offchain gateway response is malformed. Response data must be a hex value.\", {\\n            metaMessages: [\\n              `Gateway URL: ${getUrl(url)}`,\\n              `Response: ${stringify(result)}`\\n            ],\\n            name: \"OffchainLookupResponseMalformedError\"\\n          });\\n        }\\n      };\\n      OffchainLookupSenderMismatchError = class extends BaseError2 {\\n        constructor({ sender, to }) {\\n          super(\"Reverted sender address does not match target contract address (`to`).\", {\\n            metaMessages: [\\n              `Contract address: ${to}`,\\n              `OffchainLookup sender address: ${sender}`\\n            ],\\n            name: \"OffchainLookupSenderMismatchError\"\\n          });\\n        }\\n      };\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/abi/decodeFunctionData.js\\n  function decodeFunctionData(parameters) {\\n    const { abi: abi2, data } = parameters;\\n    const signature = slice(data, 0, 4);\\n    const description = abi2.find((x) => x.type === \"function\" && signature === toFunctionSelector(formatAbiItem2(x)));\\n    if (!description)\\n      throw new AbiFunctionSignatureNotFoundError(signature, {\\n        docsPath: \"/docs/contract/decodeFunctionData\"\\n      });\\n    return {\\n      functionName: description.name,\\n      args: \"inputs\" in description && description.inputs && description.inputs.length > 0 ? decodeAbiParameters(description.inputs, slice(data, 4)) : void 0\\n    };\\n  }\\n  var init_decodeFunctionData = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/abi/decodeFunctionData.js\"() {\\n      init_abi();\\n      init_slice();\\n      init_toFunctionSelector();\\n      init_decodeAbiParameters();\\n      init_formatAbiItem2();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/abi/encodeErrorResult.js\\n  function encodeErrorResult(parameters) {\\n    const { abi: abi2, errorName, args } = parameters;\\n    let abiItem = abi2[0];\\n    if (errorName) {\\n      const item = getAbiItem({ abi: abi2, args, name: errorName });\\n      if (!item)\\n        throw new AbiErrorNotFoundError(errorName, { docsPath: docsPath6 });\\n      abiItem = item;\\n    }\\n    if (abiItem.type !== \"error\")\\n      throw new AbiErrorNotFoundError(void 0, { docsPath: docsPath6 });\\n    const definition = formatAbiItem2(abiItem);\\n    const signature = toFunctionSelector(definition);\\n    let data = \"0x\";\\n    if (args && args.length > 0) {\\n      if (!abiItem.inputs)\\n        throw new AbiErrorInputsNotFoundError(abiItem.name, { docsPath: docsPath6 });\\n      data = encodeAbiParameters(abiItem.inputs, args);\\n    }\\n    return concatHex([signature, data]);\\n  }\\n  var docsPath6;\\n  var init_encodeErrorResult = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/abi/encodeErrorResult.js\"() {\\n      init_abi();\\n      init_concat();\\n      init_toFunctionSelector();\\n      init_encodeAbiParameters();\\n      init_formatAbiItem2();\\n      init_getAbiItem();\\n      docsPath6 = \"/docs/contract/encodeErrorResult\";\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/abi/encodeFunctionResult.js\\n  function encodeFunctionResult(parameters) {\\n    const { abi: abi2, functionName, result } = parameters;\\n    let abiItem = abi2[0];\\n    if (functionName) {\\n      const item = getAbiItem({ abi: abi2, name: functionName });\\n      if (!item)\\n        throw new AbiFunctionNotFoundError(functionName, { docsPath: docsPath7 });\\n      abiItem = item;\\n    }\\n    if (abiItem.type !== \"function\")\\n      throw new AbiFunctionNotFoundError(void 0, { docsPath: docsPath7 });\\n    if (!abiItem.outputs)\\n      throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath: docsPath7 });\\n    const values = (() => {\\n      if (abiItem.outputs.length === 0)\\n        return [];\\n      if (abiItem.outputs.length === 1)\\n        return [result];\\n      if (Array.isArray(result))\\n        return result;\\n      throw new InvalidArrayError(result);\\n    })();\\n    return encodeAbiParameters(abiItem.outputs, values);\\n  }\\n  var docsPath7;\\n  var init_encodeFunctionResult = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/abi/encodeFunctionResult.js\"() {\\n      init_abi();\\n      init_encodeAbiParameters();\\n      init_getAbiItem();\\n      docsPath7 = \"/docs/contract/encodeFunctionResult\";\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/ens/localBatchGatewayRequest.js\\n  async function localBatchGatewayRequest(parameters) {\\n    const { data, ccipRequest: ccipRequest2 } = parameters;\\n    const { args: [queries] } = decodeFunctionData({ abi: batchGatewayAbi, data });\\n    const failures = [];\\n    const responses = [];\\n    await Promise.all(queries.map(async (query, i) => {\\n      try {\\n        responses[i] = await ccipRequest2(query);\\n        failures[i] = false;\\n      } catch (err) {\\n        failures[i] = true;\\n        responses[i] = encodeError(err);\\n      }\\n    }));\\n    return encodeFunctionResult({\\n      abi: batchGatewayAbi,\\n      functionName: \"query\",\\n      result: [failures, responses]\\n    });\\n  }\\n  function encodeError(error) {\\n    if (error.name === \"HttpRequestError\" && error.status)\\n      return encodeErrorResult({\\n        abi: batchGatewayAbi,\\n        errorName: \"HttpError\",\\n        args: [error.status, error.shortMessage]\\n      });\\n    return encodeErrorResult({\\n      abi: [solidityError],\\n      errorName: \"Error\",\\n      args: [\"shortMessage\" in error ? error.shortMessage : error.message]\\n    });\\n  }\\n  var localBatchGatewayUrl;\\n  var init_localBatchGatewayRequest = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/ens/localBatchGatewayRequest.js\"() {\\n      init_abis();\\n      init_solidity();\\n      init_decodeFunctionData();\\n      init_encodeErrorResult();\\n      init_encodeFunctionResult();\\n      localBatchGatewayUrl = \"x-batch-gateway:true\";\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/ccip.js\\n  var ccip_exports = {};\\n  __export(ccip_exports, {\\n    ccipRequest: () => ccipRequest,\\n    offchainLookup: () => offchainLookup,\\n    offchainLookupAbiItem: () => offchainLookupAbiItem,\\n    offchainLookupSignature: () => offchainLookupSignature\\n  });\\n  async function offchainLookup(client, { blockNumber, blockTag, data, to }) {\\n    const { args } = decodeErrorResult({\\n      data,\\n      abi: [offchainLookupAbiItem]\\n    });\\n    const [sender, urls, callData, callbackSelector, extraData] = args;\\n    const { ccipRead } = client;\\n    const ccipRequest_ = ccipRead && typeof ccipRead?.request === \"function\" ? ccipRead.request : ccipRequest;\\n    try {\\n      if (!isAddressEqual(to, sender))\\n        throw new OffchainLookupSenderMismatchError({ sender, to });\\n      const result = urls.includes(localBatchGatewayUrl) ? await localBatchGatewayRequest({\\n        data: callData,\\n        ccipRequest: ccipRequest_\\n      }) : await ccipRequest_({ data: callData, sender, urls });\\n      const { data: data_ } = await call(client, {\\n        blockNumber,\\n        blockTag,\\n        data: concat([\\n          callbackSelector,\\n          encodeAbiParameters([{ type: \"bytes\" }, { type: \"bytes\" }], [result, extraData])\\n        ]),\\n        to\\n      });\\n      return data_;\\n    } catch (err) {\\n      throw new OffchainLookupError({\\n        callbackSelector,\\n        cause: err,\\n        data,\\n        extraData,\\n        sender,\\n        urls\\n      });\\n    }\\n  }\\n  async function ccipRequest({ data, sender, urls }) {\\n    let error = new Error(\"An unknown error occurred.\");\\n    for (let i = 0; i < urls.length; i++) {\\n      const url = urls[i];\\n      const method = url.includes(\"{data}\") ? \"GET\" : \"POST\";\\n      const body = method === \"POST\" ? { data, sender } : void 0;\\n      const headers = method === \"POST\" ? { \"Content-Type\": \"application/json\" } : {};\\n      try {\\n        const response = await fetch(url.replace(\"{sender}\", sender.toLowerCase()).replace(\"{data}\", data), {\\n          body: JSON.stringify(body),\\n          headers,\\n          method\\n        });\\n        let result;\\n        if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\")) {\\n          result = (await response.json()).data;\\n        } else {\\n          result = await response.text();\\n        }\\n        if (!response.ok) {\\n          error = new HttpRequestError({\\n            body,\\n            details: result?.error ? stringify(result.error) : response.statusText,\\n            headers: response.headers,\\n            status: response.status,\\n            url\\n          });\\n          continue;\\n        }\\n        if (!isHex(result)) {\\n          error = new OffchainLookupResponseMalformedError({\\n            result,\\n            url\\n          });\\n          continue;\\n        }\\n        return result;\\n      } catch (err) {\\n        error = new HttpRequestError({\\n          body,\\n          details: err.message,\\n          url\\n        });\\n      }\\n    }\\n    throw error;\\n  }\\n  var offchainLookupSignature, offchainLookupAbiItem;\\n  var init_ccip2 = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/ccip.js\"() {\\n      init_call();\\n      init_ccip();\\n      init_request();\\n      init_decodeErrorResult();\\n      init_encodeAbiParameters();\\n      init_isAddressEqual();\\n      init_concat();\\n      init_isHex();\\n      init_localBatchGatewayRequest();\\n      init_stringify();\\n      offchainLookupSignature = \"0x556f1830\";\\n      offchainLookupAbiItem = {\\n        name: \"OffchainLookup\",\\n        type: \"error\",\\n        inputs: [\\n          {\\n            name: \"sender\",\\n            type: \"address\"\\n          },\\n          {\\n            name: \"urls\",\\n            type: \"string[]\"\\n          },\\n          {\\n            name: \"callData\",\\n            type: \"bytes\"\\n          },\\n          {\\n            name: \"callbackFunction\",\\n            type: \"bytes4\"\\n          },\\n          {\\n            name: \"extraData\",\\n            type: \"bytes\"\\n          }\\n        ]\\n      };\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/call.js\\n  async function call(client, args) {\\n    const { account: account_ = client.account, batch = Boolean(client.batch?.multicall), blockNumber, blockTag = \"latest\", accessList, blobs, code, data: data_, factory, factoryData, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride, ...rest } = args;\\n    const account = account_ ? parseAccount(account_) : void 0;\\n    if (code && (factory || factoryData))\\n      throw new BaseError2(\"Cannot provide both `code` & `factory`/`factoryData` as parameters.\");\\n    if (code && to)\\n      throw new BaseError2(\"Cannot provide both `code` & `to` as parameters.\");\\n    const deploylessCallViaBytecode = code && data_;\\n    const deploylessCallViaFactory = factory && factoryData && to && data_;\\n    const deploylessCall = deploylessCallViaBytecode || deploylessCallViaFactory;\\n    const data = (() => {\\n      if (deploylessCallViaBytecode)\\n        return toDeploylessCallViaBytecodeData({\\n          code,\\n          data: data_\\n        });\\n      if (deploylessCallViaFactory)\\n        return toDeploylessCallViaFactoryData({\\n          data: data_,\\n          factory,\\n          factoryData,\\n          to\\n        });\\n      return data_;\\n    })();\\n    try {\\n      assertRequest(args);\\n      const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;\\n      const block = blockNumberHex || blockTag;\\n      const rpcStateOverride = serializeStateOverride(stateOverride);\\n      const chainFormat = client.chain?.formatters?.transactionRequest?.format;\\n      const format = chainFormat || formatTransactionRequest;\\n      const request = format({\\n        // Pick out extra data that might exist on the chain\\'s transaction request type.\\n        ...extract(rest, { format: chainFormat }),\\n        from: account?.address,\\n        accessList,\\n        blobs,\\n        data,\\n        gas,\\n        gasPrice,\\n        maxFeePerBlobGas,\\n        maxFeePerGas,\\n        maxPriorityFeePerGas,\\n        nonce,\\n        to: deploylessCall ? void 0 : to,\\n        value\\n      });\\n      if (batch && shouldPerformMulticall({ request }) && !rpcStateOverride) {\\n        try {\\n          return await scheduleMulticall(client, {\\n            ...request,\\n            blockNumber,\\n            blockTag\\n          });\\n        } catch (err) {\\n          if (!(err instanceof ClientChainNotConfiguredError) && !(err instanceof ChainDoesNotSupportContract))\\n            throw err;\\n        }\\n      }\\n      const response = await client.request({\\n        method: \"eth_call\",\\n        params: rpcStateOverride ? [\\n          request,\\n          block,\\n          rpcStateOverride\\n        ] : [request, block]\\n      });\\n      if (response === \"0x\")\\n        return { data: void 0 };\\n      return { data: response };\\n    } catch (err) {\\n      const data2 = getRevertErrorData(err);\\n      const { offchainLookup: offchainLookup2, offchainLookupSignature: offchainLookupSignature2 } = await Promise.resolve().then(() => (init_ccip2(), ccip_exports));\\n      if (client.ccipRead !== false && data2?.slice(0, 10) === offchainLookupSignature2 && to)\\n        return { data: await offchainLookup2(client, { data: data2, to }) };\\n      if (deploylessCall && data2?.slice(0, 10) === \"0x101bb98d\")\\n        throw new CounterfactualDeploymentFailedError({ factory });\\n      throw getCallError(err, {\\n        ...args,\\n        account,\\n        chain: client.chain\\n      });\\n    }\\n  }\\n  function shouldPerformMulticall({ request }) {\\n    const { data, to, ...request_ } = request;\\n    if (!data)\\n      return false;\\n    if (data.startsWith(aggregate3Signature))\\n      return false;\\n    if (!to)\\n      return false;\\n    if (Object.values(request_).filter((x) => typeof x !== \"undefined\").length > 0)\\n      return false;\\n    return true;\\n  }\\n  async function scheduleMulticall(client, args) {\\n    const { batchSize = 1024, wait: wait2 = 0 } = typeof client.batch?.multicall === \"object\" ? client.batch.multicall : {};\\n    const { blockNumber, blockTag = \"latest\", data, multicallAddress: multicallAddress_, to } = args;\\n    let multicallAddress = multicallAddress_;\\n    if (!multicallAddress) {\\n      if (!client.chain)\\n        throw new ClientChainNotConfiguredError();\\n      multicallAddress = getChainContractAddress({\\n        blockNumber,\\n        chain: client.chain,\\n        contract: \"multicall3\"\\n      });\\n    }\\n    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;\\n    const block = blockNumberHex || blockTag;\\n    const { schedule } = createBatchScheduler({\\n      id: `${client.uid}.${block}`,\\n      wait: wait2,\\n      shouldSplitBatch(args2) {\\n        const size5 = args2.reduce((size6, { data: data2 }) => size6 + (data2.length - 2), 0);\\n        return size5 > batchSize * 2;\\n      },\\n      fn: async (requests) => {\\n        const calls = requests.map((request) => ({\\n          allowFailure: true,\\n          callData: request.data,\\n          target: request.to\\n        }));\\n        const calldata = encodeFunctionData({\\n          abi: multicall3Abi,\\n          args: [calls],\\n          functionName: \"aggregate3\"\\n        });\\n        const data2 = await client.request({\\n          method: \"eth_call\",\\n          params: [\\n            {\\n              data: calldata,\\n              to: multicallAddress\\n            },\\n            block\\n          ]\\n        });\\n        return decodeFunctionResult({\\n          abi: multicall3Abi,\\n          args: [calls],\\n          functionName: \"aggregate3\",\\n          data: data2 || \"0x\"\\n        });\\n      }\\n    });\\n    const [{ returnData, success }] = await schedule({ data, to });\\n    if (!success)\\n      throw new RawContractError({ data: returnData });\\n    if (returnData === \"0x\")\\n      return { data: void 0 };\\n    return { data: returnData };\\n  }\\n  function toDeploylessCallViaBytecodeData(parameters) {\\n    const { code, data } = parameters;\\n    return encodeDeployData({\\n      abi: parseAbi([\"constructor(bytes, bytes)\"]),\\n      bytecode: deploylessCallViaBytecodeBytecode,\\n      args: [code, data]\\n    });\\n  }\\n  function toDeploylessCallViaFactoryData(parameters) {\\n    const { data, factory, factoryData, to } = parameters;\\n    return encodeDeployData({\\n      abi: parseAbi([\"constructor(address, bytes, address, bytes)\"]),\\n      bytecode: deploylessCallViaFactoryBytecode,\\n      args: [to, data, factory, factoryData]\\n    });\\n  }\\n  function getRevertErrorData(err) {\\n    if (!(err instanceof BaseError2))\\n      return void 0;\\n    const error = err.walk();\\n    return typeof error?.data === \"object\" ? error.data?.data : error.data;\\n  }\\n  var init_call = __esm({\\n    \"../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/call.js\"() {\\n      init_exports();\\n      init_parseAccount();\\n      init_abis();\\n      init_contract2();\\n      init_contracts();\\n      init_base();\\n      init_chain();\\n      init_contract();\\n      init_decodeFunctionResult();\\n      init_encodeDeployData();\\n      init_encodeFunctionData();\\n      init_getChainContractAddress();\\n      init_toHex();\\n      init_getCallError();\\n      init_extract();\\n      init_transactionRequest();\\n      init_createBatchScheduler();\\n      init_stateOverride2();\\n      init_assertRequest();\\n    }\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/getAction.js\\n  function getAction(client, actionFn, name) {\\n    const action_implicit = client[actionFn.name];\\n    if (typeof action_implicit === \"function\")\\n      return action_implicit;\\n    const action_explicit = client[name];\\n    if (typeof action_explicit === \"function\")\\n      return action_explicit;\\n    return (params) => actionFn(client, params);\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/abi/encodeEventTopics.js\\n  init_abi();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/log.js\\n  init_base();\\n  var FilterTypeNotSupportedError = class extends BaseError2 {\\n    constructor(type) {\\n      super(`Filter type \"${type}\" is not supported.`, {\\n        name: \"FilterTypeNotSupportedError\"\\n      });\\n    }\\n  };\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/abi/encodeEventTopics.js\\n  init_toBytes();\\n  init_keccak256();\\n  init_toEventSelector();\\n  init_encodeAbiParameters();\\n  init_formatAbiItem2();\\n  init_getAbiItem();\\n  var docsPath = \"/docs/contract/encodeEventTopics\";\\n  function encodeEventTopics(parameters) {\\n    const { abi: abi2, eventName, args } = parameters;\\n    let abiItem = abi2[0];\\n    if (eventName) {\\n      const item = getAbiItem({ abi: abi2, name: eventName });\\n      if (!item)\\n        throw new AbiEventNotFoundError(eventName, { docsPath });\\n      abiItem = item;\\n    }\\n    if (abiItem.type !== \"event\")\\n      throw new AbiEventNotFoundError(void 0, { docsPath });\\n    const definition = formatAbiItem2(abiItem);\\n    const signature = toEventSelector(definition);\\n    let topics = [];\\n    if (args && \"inputs\" in abiItem) {\\n      const indexedInputs = abiItem.inputs?.filter((param) => \"indexed\" in param && param.indexed);\\n      const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? indexedInputs?.map((x) => args[x.name]) ?? [] : [];\\n      if (args_.length > 0) {\\n        topics = indexedInputs?.map((param, i) => {\\n          if (Array.isArray(args_[i]))\\n            return args_[i].map((_, j) => encodeArg({ param, value: args_[i][j] }));\\n          return typeof args_[i] !== \"undefined\" && args_[i] !== null ? encodeArg({ param, value: args_[i] }) : null;\\n        }) ?? [];\\n      }\\n    }\\n    return [signature, ...topics];\\n  }\\n  function encodeArg({ param, value }) {\\n    if (param.type === \"string\" || param.type === \"bytes\")\\n      return keccak256(toBytes(value));\\n    if (param.type === \"tuple\" || param.type.match(/^(.*)\\\\[(\\\\d+)?\\\\]$/))\\n      throw new FilterTypeNotSupportedError(param.type);\\n    return encodeAbiParameters([param], [value]);\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/createContractEventFilter.js\\n  init_toHex();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/filters/createFilterRequestScope.js\\n  function createFilterRequestScope(client, { method }) {\\n    const requestMap = {};\\n    if (client.transport.type === \"fallback\")\\n      client.transport.onResponse?.(({ method: method_, response: id, status, transport }) => {\\n        if (status === \"success\" && method === method_)\\n          requestMap[id] = transport.request;\\n      });\\n    return (id) => requestMap[id] || client.request;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/createContractEventFilter.js\\n  async function createContractEventFilter(client, parameters) {\\n    const { address, abi: abi2, args, eventName, fromBlock, strict, toBlock } = parameters;\\n    const getRequest = createFilterRequestScope(client, {\\n      method: \"eth_newFilter\"\\n    });\\n    const topics = eventName ? encodeEventTopics({\\n      abi: abi2,\\n      args,\\n      eventName\\n    }) : void 0;\\n    const id = await client.request({\\n      method: \"eth_newFilter\",\\n      params: [\\n        {\\n          address,\\n          fromBlock: typeof fromBlock === \"bigint\" ? numberToHex(fromBlock) : fromBlock,\\n          toBlock: typeof toBlock === \"bigint\" ? numberToHex(toBlock) : toBlock,\\n          topics\\n        }\\n      ]\\n    });\\n    return {\\n      abi: abi2,\\n      args,\\n      eventName,\\n      id,\\n      request: getRequest(id),\\n      strict: Boolean(strict),\\n      type: \"event\"\\n    };\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/estimateContractGas.js\\n  init_parseAccount();\\n  init_encodeFunctionData();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/errors/getContractError.js\\n  init_abi();\\n  init_base();\\n  init_contract();\\n  init_request();\\n  init_rpc();\\n  var EXECUTION_REVERTED_ERROR_CODE = 3;\\n  function getContractError(err, { abi: abi2, address, args, docsPath: docsPath8, functionName, sender }) {\\n    const error = err instanceof RawContractError ? err : err instanceof BaseError2 ? err.walk((err2) => \"data\" in err2) || err.walk() : {};\\n    const { code, data, details, message, shortMessage } = error;\\n    const cause = (() => {\\n      if (err instanceof AbiDecodingZeroDataError)\\n        return new ContractFunctionZeroDataError({ functionName });\\n      if ([EXECUTION_REVERTED_ERROR_CODE, InternalRpcError.code].includes(code) && (data || details || message || shortMessage)) {\\n        return new ContractFunctionRevertedError({\\n          abi: abi2,\\n          data: typeof data === \"object\" ? data.data : data,\\n          functionName,\\n          message: error instanceof RpcRequestError ? details : shortMessage ?? message\\n        });\\n      }\\n      return err;\\n    })();\\n    return new ContractFunctionExecutionError(cause, {\\n      abi: abi2,\\n      args,\\n      contractAddress: address,\\n      docsPath: docsPath8,\\n      functionName,\\n      sender\\n    });\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/estimateGas.js\\n  init_parseAccount();\\n  init_base();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js\\n  init_getAddress();\\n  init_keccak256();\\n  function publicKeyToAddress(publicKey) {\\n    const address = keccak256(`0x${publicKey.substring(4)}`).substring(26);\\n    return checksumAddress(`0x${address}`);\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/signature/recoverPublicKey.js\\n  init_isHex();\\n  init_fromHex();\\n  init_toHex();\\n  async function recoverPublicKey({ hash: hash2, signature }) {\\n    const hashHex = isHex(hash2) ? hash2 : toHex(hash2);\\n    const { secp256k1: secp256k12 } = await Promise.resolve().then(() => (init_secp256k1(), secp256k1_exports));\\n    const signature_ = (() => {\\n      if (typeof signature === \"object\" && \"r\" in signature && \"s\" in signature) {\\n        const { r, s, v, yParity } = signature;\\n        const yParityOrV2 = Number(yParity ?? v);\\n        const recoveryBit2 = toRecoveryBit(yParityOrV2);\\n        return new secp256k12.Signature(hexToBigInt(r), hexToBigInt(s)).addRecoveryBit(recoveryBit2);\\n      }\\n      const signatureHex = isHex(signature) ? signature : toHex(signature);\\n      const yParityOrV = hexToNumber(`0x${signatureHex.slice(130)}`);\\n      const recoveryBit = toRecoveryBit(yParityOrV);\\n      return secp256k12.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);\\n    })();\\n    const publicKey = signature_.recoverPublicKey(hashHex.substring(2)).toHex(false);\\n    return `0x${publicKey}`;\\n  }\\n  function toRecoveryBit(yParityOrV) {\\n    if (yParityOrV === 0 || yParityOrV === 1)\\n      return yParityOrV;\\n    if (yParityOrV === 27)\\n      return 0;\\n    if (yParityOrV === 28)\\n      return 1;\\n    throw new Error(\"Invalid yParityOrV value\");\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/signature/recoverAddress.js\\n  async function recoverAddress({ hash: hash2, signature }) {\\n    return publicKeyToAddress(await recoverPublicKey({ hash: hash2, signature }));\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/authorization/hashAuthorization.js\\n  init_concat();\\n  init_toBytes();\\n  init_toHex();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/encoding/toRlp.js\\n  init_base();\\n  init_cursor2();\\n  init_toBytes();\\n  init_toHex();\\n  function toRlp(bytes, to = \"hex\") {\\n    const encodable = getEncodable(bytes);\\n    const cursor = createCursor(new Uint8Array(encodable.length));\\n    encodable.encode(cursor);\\n    if (to === \"hex\")\\n      return bytesToHex(cursor.bytes);\\n    return cursor.bytes;\\n  }\\n  function getEncodable(bytes) {\\n    if (Array.isArray(bytes))\\n      return getEncodableList(bytes.map((x) => getEncodable(x)));\\n    return getEncodableBytes(bytes);\\n  }\\n  function getEncodableList(list) {\\n    const bodyLength = list.reduce((acc, x) => acc + x.length, 0);\\n    const sizeOfBodyLength = getSizeOfLength(bodyLength);\\n    const length = (() => {\\n      if (bodyLength <= 55)\\n        return 1 + bodyLength;\\n      return 1 + sizeOfBodyLength + bodyLength;\\n    })();\\n    return {\\n      length,\\n      encode(cursor) {\\n        if (bodyLength <= 55) {\\n          cursor.pushByte(192 + bodyLength);\\n        } else {\\n          cursor.pushByte(192 + 55 + sizeOfBodyLength);\\n          if (sizeOfBodyLength === 1)\\n            cursor.pushUint8(bodyLength);\\n          else if (sizeOfBodyLength === 2)\\n            cursor.pushUint16(bodyLength);\\n          else if (sizeOfBodyLength === 3)\\n            cursor.pushUint24(bodyLength);\\n          else\\n            cursor.pushUint32(bodyLength);\\n        }\\n        for (const { encode: encode4 } of list) {\\n          encode4(cursor);\\n        }\\n      }\\n    };\\n  }\\n  function getEncodableBytes(bytesOrHex) {\\n    const bytes = typeof bytesOrHex === \"string\" ? hexToBytes(bytesOrHex) : bytesOrHex;\\n    const sizeOfBytesLength = getSizeOfLength(bytes.length);\\n    const length = (() => {\\n      if (bytes.length === 1 && bytes[0] < 128)\\n        return 1;\\n      if (bytes.length <= 55)\\n        return 1 + bytes.length;\\n      return 1 + sizeOfBytesLength + bytes.length;\\n    })();\\n    return {\\n      length,\\n      encode(cursor) {\\n        if (bytes.length === 1 && bytes[0] < 128) {\\n          cursor.pushBytes(bytes);\\n        } else if (bytes.length <= 55) {\\n          cursor.pushByte(128 + bytes.length);\\n          cursor.pushBytes(bytes);\\n        } else {\\n          cursor.pushByte(128 + 55 + sizeOfBytesLength);\\n          if (sizeOfBytesLength === 1)\\n            cursor.pushUint8(bytes.length);\\n          else if (sizeOfBytesLength === 2)\\n            cursor.pushUint16(bytes.length);\\n          else if (sizeOfBytesLength === 3)\\n            cursor.pushUint24(bytes.length);\\n          else\\n            cursor.pushUint32(bytes.length);\\n          cursor.pushBytes(bytes);\\n        }\\n      }\\n    };\\n  }\\n  function getSizeOfLength(length) {\\n    if (length < 2 ** 8)\\n      return 1;\\n    if (length < 2 ** 16)\\n      return 2;\\n    if (length < 2 ** 24)\\n      return 3;\\n    if (length < 2 ** 32)\\n      return 4;\\n    throw new BaseError2(\"Length is too large.\");\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/authorization/hashAuthorization.js\\n  init_keccak256();\\n  function hashAuthorization(parameters) {\\n    const { chainId, nonce, to } = parameters;\\n    const address = parameters.contractAddress ?? parameters.address;\\n    const hash2 = keccak256(concatHex([\\n      \"0x05\",\\n      toRlp([\\n        chainId ? numberToHex(chainId) : \"0x\",\\n        address,\\n        nonce ? numberToHex(nonce) : \"0x\"\\n      ])\\n    ]));\\n    if (to === \"bytes\")\\n      return hexToBytes(hash2);\\n    return hash2;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/authorization/recoverAuthorizationAddress.js\\n  async function recoverAuthorizationAddress(parameters) {\\n    const { authorization, signature } = parameters;\\n    return recoverAddress({\\n      hash: hashAuthorization(authorization),\\n      signature: signature ?? authorization\\n    });\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/estimateGas.js\\n  init_toHex();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/estimateGas.js\\n  init_formatEther();\\n  init_formatGwei();\\n  init_base();\\n  init_transaction();\\n  var EstimateGasExecutionError = class extends BaseError2 {\\n    constructor(cause, { account, docsPath: docsPath8, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {\\n      const prettyArgs = prettyPrint({\\n        from: account?.address,\\n        to,\\n        value: typeof value !== \"undefined\" && `${formatEther(value)} ${chain?.nativeCurrency?.symbol || \"ETH\"}`,\\n        data,\\n        gas,\\n        gasPrice: typeof gasPrice !== \"undefined\" && `${formatGwei(gasPrice)} gwei`,\\n        maxFeePerGas: typeof maxFeePerGas !== \"undefined\" && `${formatGwei(maxFeePerGas)} gwei`,\\n        maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== \"undefined\" && `${formatGwei(maxPriorityFeePerGas)} gwei`,\\n        nonce\\n      });\\n      super(cause.shortMessage, {\\n        cause,\\n        docsPath: docsPath8,\\n        metaMessages: [\\n          ...cause.metaMessages ? [...cause.metaMessages, \" \"] : [],\\n          \"Estimate Gas Arguments:\",\\n          prettyArgs\\n        ].filter(Boolean),\\n        name: \"EstimateGasExecutionError\"\\n      });\\n      Object.defineProperty(this, \"cause\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: void 0\\n      });\\n      this.cause = cause;\\n    }\\n  };\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/errors/getEstimateGasError.js\\n  init_node();\\n  init_getNodeError();\\n  function getEstimateGasError(err, { docsPath: docsPath8, ...args }) {\\n    const cause = (() => {\\n      const cause2 = getNodeError(err, args);\\n      if (cause2 instanceof UnknownNodeError)\\n        return err;\\n      return cause2;\\n    })();\\n    return new EstimateGasExecutionError(cause, {\\n      docsPath: docsPath8,\\n      ...args\\n    });\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/estimateGas.js\\n  init_extract();\\n  init_transactionRequest();\\n  init_stateOverride2();\\n  init_assertRequest();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/wallet/prepareTransactionRequest.js\\n  init_parseAccount();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/fee.js\\n  init_formatGwei();\\n  init_base();\\n  var BaseFeeScalarError = class extends BaseError2 {\\n    constructor() {\\n      super(\"`baseFeeMultiplier` must be greater than 1.\", {\\n        name: \"BaseFeeScalarError\"\\n      });\\n    }\\n  };\\n  var Eip1559FeesNotSupportedError = class extends BaseError2 {\\n    constructor() {\\n      super(\"Chain does not support EIP-1559 fees.\", {\\n        name: \"Eip1559FeesNotSupportedError\"\\n      });\\n    }\\n  };\\n  var MaxFeePerGasTooLowError = class extends BaseError2 {\\n    constructor({ maxPriorityFeePerGas }) {\\n      super(`\\\\`maxFeePerGas\\\\` cannot be less than the \\\\`maxPriorityFeePerGas\\\\` (${formatGwei(maxPriorityFeePerGas)} gwei).`, { name: \"MaxFeePerGasTooLowError\" });\\n    }\\n  };\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/estimateMaxPriorityFeePerGas.js\\n  init_fromHex();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/block.js\\n  init_base();\\n  var BlockNotFoundError = class extends BaseError2 {\\n    constructor({ blockHash, blockNumber }) {\\n      let identifier = \"Block\";\\n      if (blockHash)\\n        identifier = `Block at hash \"${blockHash}\"`;\\n      if (blockNumber)\\n        identifier = `Block at number \"${blockNumber}\"`;\\n      super(`${identifier} could not be found.`, { name: \"BlockNotFoundError\" });\\n    }\\n  };\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/getBlock.js\\n  init_toHex();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/formatters/block.js\\n  init_formatter();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/formatters/transaction.js\\n  init_fromHex();\\n  init_formatter();\\n  var transactionType = {\\n    \"0x0\": \"legacy\",\\n    \"0x1\": \"eip2930\",\\n    \"0x2\": \"eip1559\",\\n    \"0x3\": \"eip4844\",\\n    \"0x4\": \"eip7702\"\\n  };\\n  function formatTransaction(transaction) {\\n    const transaction_ = {\\n      ...transaction,\\n      blockHash: transaction.blockHash ? transaction.blockHash : null,\\n      blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,\\n      chainId: transaction.chainId ? hexToNumber(transaction.chainId) : void 0,\\n      gas: transaction.gas ? BigInt(transaction.gas) : void 0,\\n      gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,\\n      maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : void 0,\\n      maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,\\n      maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,\\n      nonce: transaction.nonce ? hexToNumber(transaction.nonce) : void 0,\\n      to: transaction.to ? transaction.to : null,\\n      transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,\\n      type: transaction.type ? transactionType[transaction.type] : void 0,\\n      typeHex: transaction.type ? transaction.type : void 0,\\n      value: transaction.value ? BigInt(transaction.value) : void 0,\\n      v: transaction.v ? BigInt(transaction.v) : void 0\\n    };\\n    if (transaction.authorizationList)\\n      transaction_.authorizationList = formatAuthorizationList2(transaction.authorizationList);\\n    transaction_.yParity = (() => {\\n      if (transaction.yParity)\\n        return Number(transaction.yParity);\\n      if (typeof transaction_.v === \"bigint\") {\\n        if (transaction_.v === 0n || transaction_.v === 27n)\\n          return 0;\\n        if (transaction_.v === 1n || transaction_.v === 28n)\\n          return 1;\\n        if (transaction_.v >= 35n)\\n          return transaction_.v % 2n === 0n ? 1 : 0;\\n      }\\n      return void 0;\\n    })();\\n    if (transaction_.type === \"legacy\") {\\n      delete transaction_.accessList;\\n      delete transaction_.maxFeePerBlobGas;\\n      delete transaction_.maxFeePerGas;\\n      delete transaction_.maxPriorityFeePerGas;\\n      delete transaction_.yParity;\\n    }\\n    if (transaction_.type === \"eip2930\") {\\n      delete transaction_.maxFeePerBlobGas;\\n      delete transaction_.maxFeePerGas;\\n      delete transaction_.maxPriorityFeePerGas;\\n    }\\n    if (transaction_.type === \"eip1559\") {\\n      delete transaction_.maxFeePerBlobGas;\\n    }\\n    return transaction_;\\n  }\\n  var defineTransaction = /* @__PURE__ */ defineFormatter(\"transaction\", formatTransaction);\\n  function formatAuthorizationList2(authorizationList) {\\n    return authorizationList.map((authorization) => ({\\n      address: authorization.address,\\n      chainId: Number(authorization.chainId),\\n      nonce: Number(authorization.nonce),\\n      r: authorization.r,\\n      s: authorization.s,\\n      yParity: Number(authorization.yParity)\\n    }));\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/formatters/block.js\\n  function formatBlock(block) {\\n    const transactions = (block.transactions ?? []).map((transaction) => {\\n      if (typeof transaction === \"string\")\\n        return transaction;\\n      return formatTransaction(transaction);\\n    });\\n    return {\\n      ...block,\\n      baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,\\n      blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,\\n      difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,\\n      excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,\\n      gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,\\n      gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,\\n      hash: block.hash ? block.hash : null,\\n      logsBloom: block.logsBloom ? block.logsBloom : null,\\n      nonce: block.nonce ? block.nonce : null,\\n      number: block.number ? BigInt(block.number) : null,\\n      size: block.size ? BigInt(block.size) : void 0,\\n      timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,\\n      transactions,\\n      totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null\\n    };\\n  }\\n  var defineBlock = /* @__PURE__ */ defineFormatter(\"block\", formatBlock);\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/getBlock.js\\n  async function getBlock(client, { blockHash, blockNumber, blockTag: blockTag_, includeTransactions: includeTransactions_ } = {}) {\\n    const blockTag = blockTag_ ?? \"latest\";\\n    const includeTransactions = includeTransactions_ ?? false;\\n    const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;\\n    let block = null;\\n    if (blockHash) {\\n      block = await client.request({\\n        method: \"eth_getBlockByHash\",\\n        params: [blockHash, includeTransactions]\\n      }, { dedupe: true });\\n    } else {\\n      block = await client.request({\\n        method: \"eth_getBlockByNumber\",\\n        params: [blockNumberHex || blockTag, includeTransactions]\\n      }, { dedupe: Boolean(blockNumberHex) });\\n    }\\n    if (!block)\\n      throw new BlockNotFoundError({ blockHash, blockNumber });\\n    const format = client.chain?.formatters?.block?.format || formatBlock;\\n    return format(block);\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/getGasPrice.js\\n  async function getGasPrice(client) {\\n    const gasPrice = await client.request({\\n      method: \"eth_gasPrice\"\\n    });\\n    return BigInt(gasPrice);\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/estimateMaxPriorityFeePerGas.js\\n  async function estimateMaxPriorityFeePerGas(client, args) {\\n    return internal_estimateMaxPriorityFeePerGas(client, args);\\n  }\\n  async function internal_estimateMaxPriorityFeePerGas(client, args) {\\n    const { block: block_, chain = client.chain, request } = args || {};\\n    try {\\n      const maxPriorityFeePerGas = chain?.fees?.maxPriorityFeePerGas ?? chain?.fees?.defaultPriorityFee;\\n      if (typeof maxPriorityFeePerGas === \"function\") {\\n        const block = block_ || await getAction(client, getBlock, \"getBlock\")({});\\n        const maxPriorityFeePerGas_ = await maxPriorityFeePerGas({\\n          block,\\n          client,\\n          request\\n        });\\n        if (maxPriorityFeePerGas_ === null)\\n          throw new Error();\\n        return maxPriorityFeePerGas_;\\n      }\\n      if (typeof maxPriorityFeePerGas !== \"undefined\")\\n        return maxPriorityFeePerGas;\\n      const maxPriorityFeePerGasHex = await client.request({\\n        method: \"eth_maxPriorityFeePerGas\"\\n      });\\n      return hexToBigInt(maxPriorityFeePerGasHex);\\n    } catch {\\n      const [block, gasPrice] = await Promise.all([\\n        block_ ? Promise.resolve(block_) : getAction(client, getBlock, \"getBlock\")({}),\\n        getAction(client, getGasPrice, \"getGasPrice\")({})\\n      ]);\\n      if (typeof block.baseFeePerGas !== \"bigint\")\\n        throw new Eip1559FeesNotSupportedError();\\n      const maxPriorityFeePerGas = gasPrice - block.baseFeePerGas;\\n      if (maxPriorityFeePerGas < 0n)\\n        return 0n;\\n      return maxPriorityFeePerGas;\\n    }\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/estimateFeesPerGas.js\\n  async function estimateFeesPerGas(client, args) {\\n    return internal_estimateFeesPerGas(client, args);\\n  }\\n  async function internal_estimateFeesPerGas(client, args) {\\n    const { block: block_, chain = client.chain, request, type = \"eip1559\" } = args || {};\\n    const baseFeeMultiplier = await (async () => {\\n      if (typeof chain?.fees?.baseFeeMultiplier === \"function\")\\n        return chain.fees.baseFeeMultiplier({\\n          block: block_,\\n          client,\\n          request\\n        });\\n      return chain?.fees?.baseFeeMultiplier ?? 1.2;\\n    })();\\n    if (baseFeeMultiplier < 1)\\n      throw new BaseFeeScalarError();\\n    const decimals = baseFeeMultiplier.toString().split(\".\")[1]?.length ?? 0;\\n    const denominator = 10 ** decimals;\\n    const multiply = (base2) => base2 * BigInt(Math.ceil(baseFeeMultiplier * denominator)) / BigInt(denominator);\\n    const block = block_ ? block_ : await getAction(client, getBlock, \"getBlock\")({});\\n    if (typeof chain?.fees?.estimateFeesPerGas === \"function\") {\\n      const fees = await chain.fees.estimateFeesPerGas({\\n        block: block_,\\n        client,\\n        multiply,\\n        request,\\n        type\\n      });\\n      if (fees !== null)\\n        return fees;\\n    }\\n    if (type === \"eip1559\") {\\n      if (typeof block.baseFeePerGas !== \"bigint\")\\n        throw new Eip1559FeesNotSupportedError();\\n      const maxPriorityFeePerGas = typeof request?.maxPriorityFeePerGas === \"bigint\" ? request.maxPriorityFeePerGas : await internal_estimateMaxPriorityFeePerGas(client, {\\n        block,\\n        chain,\\n        request\\n      });\\n      const baseFeePerGas = multiply(block.baseFeePerGas);\\n      const maxFeePerGas = request?.maxFeePerGas ?? baseFeePerGas + maxPriorityFeePerGas;\\n      return {\\n        maxFeePerGas,\\n        maxPriorityFeePerGas\\n      };\\n    }\\n    const gasPrice = request?.gasPrice ?? multiply(await getAction(client, getGasPrice, \"getGasPrice\")({}));\\n    return {\\n      gasPrice\\n    };\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/getTransactionCount.js\\n  init_fromHex();\\n  init_toHex();\\n  async function getTransactionCount(client, { address, blockTag = \"latest\", blockNumber }) {\\n    const count = await client.request({\\n      method: \"eth_getTransactionCount\",\\n      params: [address, blockNumber ? numberToHex(blockNumber) : blockTag]\\n    }, { dedupe: Boolean(blockNumber) });\\n    return hexToNumber(count);\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/blob/blobsToCommitments.js\\n  init_toBytes();\\n  init_toHex();\\n  function blobsToCommitments(parameters) {\\n    const { kzg } = parameters;\\n    const to = parameters.to ?? (typeof parameters.blobs[0] === \"string\" ? \"hex\" : \"bytes\");\\n    const blobs = typeof parameters.blobs[0] === \"string\" ? parameters.blobs.map((x) => hexToBytes(x)) : parameters.blobs;\\n    const commitments = [];\\n    for (const blob of blobs)\\n      commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)));\\n    return to === \"bytes\" ? commitments : commitments.map((x) => bytesToHex(x));\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/blob/blobsToProofs.js\\n  init_toBytes();\\n  init_toHex();\\n  function blobsToProofs(parameters) {\\n    const { kzg } = parameters;\\n    const to = parameters.to ?? (typeof parameters.blobs[0] === \"string\" ? \"hex\" : \"bytes\");\\n    const blobs = typeof parameters.blobs[0] === \"string\" ? parameters.blobs.map((x) => hexToBytes(x)) : parameters.blobs;\\n    const commitments = typeof parameters.commitments[0] === \"string\" ? parameters.commitments.map((x) => hexToBytes(x)) : parameters.commitments;\\n    const proofs = [];\\n    for (let i = 0; i < blobs.length; i++) {\\n      const blob = blobs[i];\\n      const commitment = commitments[i];\\n      proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));\\n    }\\n    return to === \"bytes\" ? proofs : proofs.map((x) => bytesToHex(x));\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/blob/commitmentToVersionedHash.js\\n  init_toHex();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/hash/sha256.js\\n  init_sha256();\\n  init_isHex();\\n  init_toBytes();\\n  init_toHex();\\n  function sha2562(value, to_) {\\n    const to = to_ || \"hex\";\\n    const bytes = sha256(isHex(value, { strict: false }) ? toBytes(value) : value);\\n    if (to === \"bytes\")\\n      return bytes;\\n    return toHex(bytes);\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/blob/commitmentToVersionedHash.js\\n  function commitmentToVersionedHash(parameters) {\\n    const { commitment, version: version4 = 1 } = parameters;\\n    const to = parameters.to ?? (typeof commitment === \"string\" ? \"hex\" : \"bytes\");\\n    const versionedHash = sha2562(commitment, \"bytes\");\\n    versionedHash.set([version4], 0);\\n    return to === \"bytes\" ? versionedHash : bytesToHex(versionedHash);\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/blob/commitmentsToVersionedHashes.js\\n  function commitmentsToVersionedHashes(parameters) {\\n    const { commitments, version: version4 } = parameters;\\n    const to = parameters.to ?? (typeof commitments[0] === \"string\" ? \"hex\" : \"bytes\");\\n    const hashes = [];\\n    for (const commitment of commitments) {\\n      hashes.push(commitmentToVersionedHash({\\n        commitment,\\n        to,\\n        version: version4\\n      }));\\n    }\\n    return hashes;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/constants/blob.js\\n  var blobsPerTransaction = 6;\\n  var bytesPerFieldElement = 32;\\n  var fieldElementsPerBlob = 4096;\\n  var bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;\\n  var maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - // terminator byte (0x80).\\n  1 - // zero byte (0x00) appended to each field element.\\n  1 * fieldElementsPerBlob * blobsPerTransaction;\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/constants/kzg.js\\n  var versionedHashVersionKzg = 1;\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/blob.js\\n  init_base();\\n  var BlobSizeTooLargeError = class extends BaseError2 {\\n    constructor({ maxSize, size: size5 }) {\\n      super(\"Blob size is too large.\", {\\n        metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size5} bytes`],\\n        name: \"BlobSizeTooLargeError\"\\n      });\\n    }\\n  };\\n  var EmptyBlobError = class extends BaseError2 {\\n    constructor() {\\n      super(\"Blob data must not be empty.\", { name: \"EmptyBlobError\" });\\n    }\\n  };\\n  var InvalidVersionedHashSizeError = class extends BaseError2 {\\n    constructor({ hash: hash2, size: size5 }) {\\n      super(`Versioned hash \"${hash2}\" size is invalid.`, {\\n        metaMessages: [\"Expected: 32\", `Received: ${size5}`],\\n        name: \"InvalidVersionedHashSizeError\"\\n      });\\n    }\\n  };\\n  var InvalidVersionedHashVersionError = class extends BaseError2 {\\n    constructor({ hash: hash2, version: version4 }) {\\n      super(`Versioned hash \"${hash2}\" version is invalid.`, {\\n        metaMessages: [\\n          `Expected: ${versionedHashVersionKzg}`,\\n          `Received: ${version4}`\\n        ],\\n        name: \"InvalidVersionedHashVersionError\"\\n      });\\n    }\\n  };\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/blob/toBlobs.js\\n  init_cursor2();\\n  init_size();\\n  init_toBytes();\\n  init_toHex();\\n  function toBlobs(parameters) {\\n    const to = parameters.to ?? (typeof parameters.data === \"string\" ? \"hex\" : \"bytes\");\\n    const data = typeof parameters.data === \"string\" ? hexToBytes(parameters.data) : parameters.data;\\n    const size_ = size(data);\\n    if (!size_)\\n      throw new EmptyBlobError();\\n    if (size_ > maxBytesPerTransaction)\\n      throw new BlobSizeTooLargeError({\\n        maxSize: maxBytesPerTransaction,\\n        size: size_\\n      });\\n    const blobs = [];\\n    let active = true;\\n    let position = 0;\\n    while (active) {\\n      const blob = createCursor(new Uint8Array(bytesPerBlob));\\n      let size5 = 0;\\n      while (size5 < fieldElementsPerBlob) {\\n        const bytes = data.slice(position, position + (bytesPerFieldElement - 1));\\n        blob.pushByte(0);\\n        blob.pushBytes(bytes);\\n        if (bytes.length < 31) {\\n          blob.pushByte(128);\\n          active = false;\\n          break;\\n        }\\n        size5++;\\n        position += 31;\\n      }\\n      blobs.push(blob);\\n    }\\n    return to === \"bytes\" ? blobs.map((x) => x.bytes) : blobs.map((x) => bytesToHex(x.bytes));\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/blob/toBlobSidecars.js\\n  function toBlobSidecars(parameters) {\\n    const { data, kzg, to } = parameters;\\n    const blobs = parameters.blobs ?? toBlobs({ data, to });\\n    const commitments = parameters.commitments ?? blobsToCommitments({ blobs, kzg, to });\\n    const proofs = parameters.proofs ?? blobsToProofs({ blobs, commitments, kzg, to });\\n    const sidecars = [];\\n    for (let i = 0; i < blobs.length; i++)\\n      sidecars.push({\\n        blob: blobs[i],\\n        commitment: commitments[i],\\n        proof: proofs[i]\\n      });\\n    return sidecars;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/wallet/prepareTransactionRequest.js\\n  init_assertRequest();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/transaction/getTransactionType.js\\n  init_transaction();\\n  function getTransactionType(transaction) {\\n    if (transaction.type)\\n      return transaction.type;\\n    if (typeof transaction.authorizationList !== \"undefined\")\\n      return \"eip7702\";\\n    if (typeof transaction.blobs !== \"undefined\" || typeof transaction.blobVersionedHashes !== \"undefined\" || typeof transaction.maxFeePerBlobGas !== \"undefined\" || typeof transaction.sidecars !== \"undefined\")\\n      return \"eip4844\";\\n    if (typeof transaction.maxFeePerGas !== \"undefined\" || typeof transaction.maxPriorityFeePerGas !== \"undefined\") {\\n      return \"eip1559\";\\n    }\\n    if (typeof transaction.gasPrice !== \"undefined\") {\\n      if (typeof transaction.accessList !== \"undefined\")\\n        return \"eip2930\";\\n      return \"legacy\";\\n    }\\n    throw new InvalidSerializableTransactionError({ transaction });\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/getChainId.js\\n  init_fromHex();\\n  async function getChainId(client) {\\n    const chainIdHex = await client.request({\\n      method: \"eth_chainId\"\\n    }, { dedupe: true });\\n    return hexToNumber(chainIdHex);\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/wallet/prepareTransactionRequest.js\\n  var defaultParameters = [\\n    \"blobVersionedHashes\",\\n    \"chainId\",\\n    \"fees\",\\n    \"gas\",\\n    \"nonce\",\\n    \"type\"\\n  ];\\n  var eip1559NetworkCache = /* @__PURE__ */ new Map();\\n  async function prepareTransactionRequest(client, args) {\\n    const { account: account_ = client.account, blobs, chain, gas, kzg, nonce, nonceManager, parameters = defaultParameters, type } = args;\\n    const account = account_ ? parseAccount(account_) : account_;\\n    const request = { ...args, ...account ? { from: account?.address } : {} };\\n    let block;\\n    async function getBlock2() {\\n      if (block)\\n        return block;\\n      block = await getAction(client, getBlock, \"getBlock\")({ blockTag: \"latest\" });\\n      return block;\\n    }\\n    let chainId;\\n    async function getChainId2() {\\n      if (chainId)\\n        return chainId;\\n      if (chain)\\n        return chain.id;\\n      if (typeof args.chainId !== \"undefined\")\\n        return args.chainId;\\n      const chainId_ = await getAction(client, getChainId, \"getChainId\")({});\\n      chainId = chainId_;\\n      return chainId;\\n    }\\n    if (parameters.includes(\"nonce\") && typeof nonce === \"undefined\" && account) {\\n      if (nonceManager) {\\n        const chainId2 = await getChainId2();\\n        request.nonce = await nonceManager.consume({\\n          address: account.address,\\n          chainId: chainId2,\\n          client\\n        });\\n      } else {\\n        request.nonce = await getAction(client, getTransactionCount, \"getTransactionCount\")({\\n          address: account.address,\\n          blockTag: \"pending\"\\n        });\\n      }\\n    }\\n    if ((parameters.includes(\"blobVersionedHashes\") || parameters.includes(\"sidecars\")) && blobs && kzg) {\\n      const commitments = blobsToCommitments({ blobs, kzg });\\n      if (parameters.includes(\"blobVersionedHashes\")) {\\n        const versionedHashes = commitmentsToVersionedHashes({\\n          commitments,\\n          to: \"hex\"\\n        });\\n        request.blobVersionedHashes = versionedHashes;\\n      }\\n      if (parameters.includes(\"sidecars\")) {\\n        const proofs = blobsToProofs({ blobs, commitments, kzg });\\n        const sidecars = toBlobSidecars({\\n          blobs,\\n          commitments,\\n          proofs,\\n          to: \"hex\"\\n        });\\n        request.sidecars = sidecars;\\n      }\\n    }\\n    if (parameters.includes(\"chainId\"))\\n      request.chainId = await getChainId2();\\n    if ((parameters.includes(\"fees\") || parameters.includes(\"type\")) && typeof type === \"undefined\") {\\n      try {\\n        request.type = getTransactionType(request);\\n      } catch {\\n        let isEip1559Network = eip1559NetworkCache.get(client.uid);\\n        if (typeof isEip1559Network === \"undefined\") {\\n          const block2 = await getBlock2();\\n          isEip1559Network = typeof block2?.baseFeePerGas === \"bigint\";\\n          eip1559NetworkCache.set(client.uid, isEip1559Network);\\n        }\\n        request.type = isEip1559Network ? \"eip1559\" : \"legacy\";\\n      }\\n    }\\n    if (parameters.includes(\"fees\")) {\\n      if (request.type !== \"legacy\" && request.type !== \"eip2930\") {\\n        if (typeof request.maxFeePerGas === \"undefined\" || typeof request.maxPriorityFeePerGas === \"undefined\") {\\n          const block2 = await getBlock2();\\n          const { maxFeePerGas, maxPriorityFeePerGas } = await internal_estimateFeesPerGas(client, {\\n            block: block2,\\n            chain,\\n            request\\n          });\\n          if (typeof args.maxPriorityFeePerGas === \"undefined\" && args.maxFeePerGas && args.maxFeePerGas < maxPriorityFeePerGas)\\n            throw new MaxFeePerGasTooLowError({\\n              maxPriorityFeePerGas\\n            });\\n          request.maxPriorityFeePerGas = maxPriorityFeePerGas;\\n          request.maxFeePerGas = maxFeePerGas;\\n        }\\n      } else {\\n        if (typeof args.maxFeePerGas !== \"undefined\" || typeof args.maxPriorityFeePerGas !== \"undefined\")\\n          throw new Eip1559FeesNotSupportedError();\\n        if (typeof args.gasPrice === \"undefined\") {\\n          const block2 = await getBlock2();\\n          const { gasPrice: gasPrice_ } = await internal_estimateFeesPerGas(client, {\\n            block: block2,\\n            chain,\\n            request,\\n            type: \"legacy\"\\n          });\\n          request.gasPrice = gasPrice_;\\n        }\\n      }\\n    }\\n    if (parameters.includes(\"gas\") && typeof gas === \"undefined\")\\n      request.gas = await getAction(client, estimateGas, \"estimateGas\")({\\n        ...request,\\n        account: account ? { address: account.address, type: \"json-rpc\" } : account\\n      });\\n    assertRequest(request);\\n    delete request.parameters;\\n    return request;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/getBalance.js\\n  init_toHex();\\n  async function getBalance(client, { address, blockNumber, blockTag = \"latest\" }) {\\n    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;\\n    const balance = await client.request({\\n      method: \"eth_getBalance\",\\n      params: [address, blockNumberHex || blockTag]\\n    });\\n    return BigInt(balance);\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/estimateGas.js\\n  async function estimateGas(client, args) {\\n    const { account: account_ = client.account } = args;\\n    const account = account_ ? parseAccount(account_) : void 0;\\n    try {\\n      let estimateGas_rpc = function(parameters) {\\n        const { block: block2, request: request2, rpcStateOverride: rpcStateOverride2 } = parameters;\\n        return client.request({\\n          method: \"eth_estimateGas\",\\n          params: rpcStateOverride2 ? [request2, block2 ?? \"latest\", rpcStateOverride2] : block2 ? [request2, block2] : [request2]\\n        });\\n      };\\n      const { accessList, authorizationList, blobs, blobVersionedHashes, blockNumber, blockTag, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, value, stateOverride, ...rest } = await prepareTransactionRequest(client, {\\n        ...args,\\n        parameters: (\\n          // Some RPC Providers do not compute versioned hashes from blobs. We will need\\n          // to compute them.\\n          account?.type === \"local\" ? void 0 : [\"blobVersionedHashes\"]\\n        )\\n      });\\n      const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;\\n      const block = blockNumberHex || blockTag;\\n      const rpcStateOverride = serializeStateOverride(stateOverride);\\n      const to = await (async () => {\\n        if (rest.to)\\n          return rest.to;\\n        if (authorizationList && authorizationList.length > 0)\\n          return await recoverAuthorizationAddress({\\n            authorization: authorizationList[0]\\n          }).catch(() => {\\n            throw new BaseError2(\"`to` is required. Could not infer from `authorizationList`\");\\n          });\\n        return void 0;\\n      })();\\n      assertRequest(args);\\n      const chainFormat = client.chain?.formatters?.transactionRequest?.format;\\n      const format = chainFormat || formatTransactionRequest;\\n      const request = format({\\n        // Pick out extra data that might exist on the chain\\'s transaction request type.\\n        ...extract(rest, { format: chainFormat }),\\n        from: account?.address,\\n        accessList,\\n        authorizationList,\\n        blobs,\\n        blobVersionedHashes,\\n        data,\\n        gas,\\n        gasPrice,\\n        maxFeePerBlobGas,\\n        maxFeePerGas,\\n        maxPriorityFeePerGas,\\n        nonce,\\n        to,\\n        value\\n      });\\n      let estimate = BigInt(await estimateGas_rpc({ block, request, rpcStateOverride }));\\n      if (authorizationList) {\\n        const value2 = await getBalance(client, { address: request.from });\\n        const estimates = await Promise.all(authorizationList.map(async (authorization) => {\\n          const { address } = authorization;\\n          const estimate2 = await estimateGas_rpc({\\n            block,\\n            request: {\\n              authorizationList: void 0,\\n              data,\\n              from: account?.address,\\n              to: address,\\n              value: numberToHex(value2)\\n            },\\n            rpcStateOverride\\n          }).catch(() => 100000n);\\n          return 2n * BigInt(estimate2);\\n        }));\\n        estimate += estimates.reduce((acc, curr) => acc + curr, 0n);\\n      }\\n      return estimate;\\n    } catch (err) {\\n      throw getEstimateGasError(err, {\\n        ...args,\\n        account,\\n        chain: client.chain\\n      });\\n    }\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/estimateContractGas.js\\n  async function estimateContractGas(client, parameters) {\\n    const { abi: abi2, address, args, functionName, dataSuffix, ...request } = parameters;\\n    const data = encodeFunctionData({\\n      abi: abi2,\\n      args,\\n      functionName\\n    });\\n    try {\\n      const gas = await getAction(client, estimateGas, \"estimateGas\")({\\n        data: `${data}${dataSuffix ? dataSuffix.replace(\"0x\", \"\") : \"\"}`,\\n        to: address,\\n        ...request\\n      });\\n      return gas;\\n    } catch (error) {\\n      const account = request.account ? parseAccount(request.account) : void 0;\\n      throw getContractError(error, {\\n        abi: abi2,\\n        address,\\n        args,\\n        docsPath: \"/docs/contract/estimateContractGas\",\\n        functionName,\\n        sender: account?.address\\n      });\\n    }\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/getContractEvents.js\\n  init_getAbiItem();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/abi/parseEventLogs.js\\n  init_abi();\\n  init_isAddressEqual();\\n  init_toBytes();\\n  init_keccak256();\\n  init_toEventSelector();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/abi/decodeEventLog.js\\n  init_abi();\\n  init_size();\\n  init_toEventSelector();\\n  init_cursor();\\n  init_decodeAbiParameters();\\n  init_formatAbiItem2();\\n  var docsPath3 = \"/docs/contract/decodeEventLog\";\\n  function decodeEventLog(parameters) {\\n    const { abi: abi2, data, strict: strict_, topics } = parameters;\\n    const strict = strict_ ?? true;\\n    const [signature, ...argTopics] = topics;\\n    if (!signature)\\n      throw new AbiEventSignatureEmptyTopicsError({ docsPath: docsPath3 });\\n    const abiItem = (() => {\\n      if (abi2.length === 1)\\n        return abi2[0];\\n      return abi2.find((x) => x.type === \"event\" && signature === toEventSelector(formatAbiItem2(x)));\\n    })();\\n    if (!(abiItem && \"name\" in abiItem) || abiItem.type !== \"event\")\\n      throw new AbiEventSignatureNotFoundError(signature, { docsPath: docsPath3 });\\n    const { name, inputs } = abiItem;\\n    const isUnnamed = inputs?.some((x) => !(\"name\" in x && x.name));\\n    let args = isUnnamed ? [] : {};\\n    const indexedInputs = inputs.filter((x) => \"indexed\" in x && x.indexed);\\n    for (let i = 0; i < indexedInputs.length; i++) {\\n      const param = indexedInputs[i];\\n      const topic = argTopics[i];\\n      if (!topic)\\n        throw new DecodeLogTopicsMismatch({\\n          abiItem,\\n          param\\n        });\\n      args[isUnnamed ? i : param.name || i] = decodeTopic({ param, value: topic });\\n    }\\n    const nonIndexedInputs = inputs.filter((x) => !(\"indexed\" in x && x.indexed));\\n    if (nonIndexedInputs.length > 0) {\\n      if (data && data !== \"0x\") {\\n        try {\\n          const decodedData = decodeAbiParameters(nonIndexedInputs, data);\\n          if (decodedData) {\\n            if (isUnnamed)\\n              args = [...args, ...decodedData];\\n            else {\\n              for (let i = 0; i < nonIndexedInputs.length; i++) {\\n                args[nonIndexedInputs[i].name] = decodedData[i];\\n              }\\n            }\\n          }\\n        } catch (err) {\\n          if (strict) {\\n            if (err instanceof AbiDecodingDataSizeTooSmallError || err instanceof PositionOutOfBoundsError)\\n              throw new DecodeLogDataMismatch({\\n                abiItem,\\n                data,\\n                params: nonIndexedInputs,\\n                size: size(data)\\n              });\\n            throw err;\\n          }\\n        }\\n      } else if (strict) {\\n        throw new DecodeLogDataMismatch({\\n          abiItem,\\n          data: \"0x\",\\n          params: nonIndexedInputs,\\n          size: 0\\n        });\\n      }\\n    }\\n    return {\\n      eventName: name,\\n      args: Object.values(args).length > 0 ? args : void 0\\n    };\\n  }\\n  function decodeTopic({ param, value }) {\\n    if (param.type === \"string\" || param.type === \"bytes\" || param.type === \"tuple\" || param.type.match(/^(.*)\\\\[(\\\\d+)?\\\\]$/))\\n      return value;\\n    const decodedArg = decodeAbiParameters([param], value) || [];\\n    return decodedArg[0];\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/abi/parseEventLogs.js\\n  function parseEventLogs(parameters) {\\n    const { abi: abi2, args, logs, strict = true } = parameters;\\n    const eventName = (() => {\\n      if (!parameters.eventName)\\n        return void 0;\\n      if (Array.isArray(parameters.eventName))\\n        return parameters.eventName;\\n      return [parameters.eventName];\\n    })();\\n    return logs.map((log) => {\\n      try {\\n        const abiItem = abi2.find((abiItem2) => abiItem2.type === \"event\" && log.topics[0] === toEventSelector(abiItem2));\\n        if (!abiItem)\\n          return null;\\n        const event = decodeEventLog({\\n          ...log,\\n          abi: [abiItem],\\n          strict\\n        });\\n        if (eventName && !eventName.includes(event.eventName))\\n          return null;\\n        if (!includesArgs({\\n          args: event.args,\\n          inputs: abiItem.inputs,\\n          matchArgs: args\\n        }))\\n          return null;\\n        return { ...event, ...log };\\n      } catch (err) {\\n        let eventName2;\\n        let isUnnamed;\\n        if (err instanceof AbiEventSignatureNotFoundError)\\n          return null;\\n        if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {\\n          if (strict)\\n            return null;\\n          eventName2 = err.abiItem.name;\\n          isUnnamed = err.abiItem.inputs?.some((x) => !(\"name\" in x && x.name));\\n        }\\n        return { ...log, args: isUnnamed ? [] : {}, eventName: eventName2 };\\n      }\\n    }).filter(Boolean);\\n  }\\n  function includesArgs(parameters) {\\n    const { args, inputs, matchArgs } = parameters;\\n    if (!matchArgs)\\n      return true;\\n    if (!args)\\n      return false;\\n    function isEqual(input, value, arg) {\\n      try {\\n        if (input.type === \"address\")\\n          return isAddressEqual(value, arg);\\n        if (input.type === \"string\" || input.type === \"bytes\")\\n          return keccak256(toBytes(value)) === arg;\\n        return value === arg;\\n      } catch {\\n        return false;\\n      }\\n    }\\n    if (Array.isArray(args) && Array.isArray(matchArgs)) {\\n      return matchArgs.every((value, index2) => {\\n        if (value === null || value === void 0)\\n          return true;\\n        const input = inputs[index2];\\n        if (!input)\\n          return false;\\n        const value_ = Array.isArray(value) ? value : [value];\\n        return value_.some((value2) => isEqual(input, value2, args[index2]));\\n      });\\n    }\\n    if (typeof args === \"object\" && !Array.isArray(args) && typeof matchArgs === \"object\" && !Array.isArray(matchArgs))\\n      return Object.entries(matchArgs).every(([key, value]) => {\\n        if (value === null || value === void 0)\\n          return true;\\n        const input = inputs.find((input2) => input2.name === key);\\n        if (!input)\\n          return false;\\n        const value_ = Array.isArray(value) ? value : [value];\\n        return value_.some((value2) => isEqual(input, value2, args[key]));\\n      });\\n    return false;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/getLogs.js\\n  init_toHex();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/formatters/log.js\\n  function formatLog(log, { args, eventName } = {}) {\\n    return {\\n      ...log,\\n      blockHash: log.blockHash ? log.blockHash : null,\\n      blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,\\n      logIndex: log.logIndex ? Number(log.logIndex) : null,\\n      transactionHash: log.transactionHash ? log.transactionHash : null,\\n      transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,\\n      ...eventName ? { args, eventName } : {}\\n    };\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/getLogs.js\\n  async function getLogs(client, { address, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_ } = {}) {\\n    const strict = strict_ ?? false;\\n    const events = events_ ?? (event ? [event] : void 0);\\n    let topics = [];\\n    if (events) {\\n      const encoded = events.flatMap((event2) => encodeEventTopics({\\n        abi: [event2],\\n        eventName: event2.name,\\n        args: events_ ? void 0 : args\\n      }));\\n      topics = [encoded];\\n      if (event)\\n        topics = topics[0];\\n    }\\n    let logs;\\n    if (blockHash) {\\n      logs = await client.request({\\n        method: \"eth_getLogs\",\\n        params: [{ address, topics, blockHash }]\\n      });\\n    } else {\\n      logs = await client.request({\\n        method: \"eth_getLogs\",\\n        params: [\\n          {\\n            address,\\n            topics,\\n            fromBlock: typeof fromBlock === \"bigint\" ? numberToHex(fromBlock) : fromBlock,\\n            toBlock: typeof toBlock === \"bigint\" ? numberToHex(toBlock) : toBlock\\n          }\\n        ]\\n      });\\n    }\\n    const formattedLogs = logs.map((log) => formatLog(log));\\n    if (!events)\\n      return formattedLogs;\\n    return parseEventLogs({\\n      abi: events,\\n      args,\\n      logs: formattedLogs,\\n      strict\\n    });\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/getContractEvents.js\\n  async function getContractEvents(client, parameters) {\\n    const { abi: abi2, address, args, blockHash, eventName, fromBlock, toBlock, strict } = parameters;\\n    const event = eventName ? getAbiItem({ abi: abi2, name: eventName }) : void 0;\\n    const events = !event ? abi2.filter((x) => x.type === \"event\") : void 0;\\n    return getAction(client, getLogs, \"getLogs\")({\\n      address,\\n      args,\\n      blockHash,\\n      event,\\n      events,\\n      fromBlock,\\n      toBlock,\\n      strict\\n    });\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/readContract.js\\n  init_decodeFunctionResult();\\n  init_encodeFunctionData();\\n  init_call();\\n  async function readContract(client, parameters) {\\n    const { abi: abi2, address, args, functionName, ...rest } = parameters;\\n    const calldata = encodeFunctionData({\\n      abi: abi2,\\n      args,\\n      functionName\\n    });\\n    try {\\n      const { data } = await getAction(client, call, \"call\")({\\n        ...rest,\\n        data: calldata,\\n        to: address\\n      });\\n      return decodeFunctionResult({\\n        abi: abi2,\\n        args,\\n        functionName,\\n        data: data || \"0x\"\\n      });\\n    } catch (error) {\\n      throw getContractError(error, {\\n        abi: abi2,\\n        address,\\n        args,\\n        docsPath: \"/docs/contract/readContract\",\\n        functionName\\n      });\\n    }\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/simulateContract.js\\n  init_parseAccount();\\n  init_decodeFunctionResult();\\n  init_encodeFunctionData();\\n  init_call();\\n  async function simulateContract(client, parameters) {\\n    const { abi: abi2, address, args, dataSuffix, functionName, ...callRequest } = parameters;\\n    const account = callRequest.account ? parseAccount(callRequest.account) : client.account;\\n    const calldata = encodeFunctionData({ abi: abi2, args, functionName });\\n    try {\\n      const { data } = await getAction(client, call, \"call\")({\\n        batch: false,\\n        data: `${calldata}${dataSuffix ? dataSuffix.replace(\"0x\", \"\") : \"\"}`,\\n        to: address,\\n        ...callRequest,\\n        account\\n      });\\n      const result = decodeFunctionResult({\\n        abi: abi2,\\n        args,\\n        functionName,\\n        data: data || \"0x\"\\n      });\\n      const minimizedAbi = abi2.filter((abiItem) => \"name\" in abiItem && abiItem.name === parameters.functionName);\\n      return {\\n        result,\\n        request: {\\n          abi: minimizedAbi,\\n          address,\\n          args,\\n          dataSuffix,\\n          functionName,\\n          ...callRequest,\\n          account\\n        }\\n      };\\n    } catch (error) {\\n      throw getContractError(error, {\\n        abi: abi2,\\n        address,\\n        args,\\n        docsPath: \"/docs/contract/simulateContract\",\\n        functionName,\\n        sender: account?.address\\n      });\\n    }\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/watchContractEvent.js\\n  init_abi();\\n  init_rpc();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/observe.js\\n  var listenersCache = /* @__PURE__ */ new Map();\\n  var cleanupCache = /* @__PURE__ */ new Map();\\n  var callbackCount = 0;\\n  function observe(observerId, callbacks, fn) {\\n    const callbackId = ++callbackCount;\\n    const getListeners = () => listenersCache.get(observerId) || [];\\n    const unsubscribe = () => {\\n      const listeners2 = getListeners();\\n      listenersCache.set(observerId, listeners2.filter((cb) => cb.id !== callbackId));\\n    };\\n    const unwatch = () => {\\n      const listeners2 = getListeners();\\n      if (!listeners2.some((cb) => cb.id === callbackId))\\n        return;\\n      const cleanup2 = cleanupCache.get(observerId);\\n      if (listeners2.length === 1 && cleanup2)\\n        cleanup2();\\n      unsubscribe();\\n    };\\n    const listeners = getListeners();\\n    listenersCache.set(observerId, [\\n      ...listeners,\\n      { id: callbackId, fns: callbacks }\\n    ]);\\n    if (listeners && listeners.length > 0)\\n      return unwatch;\\n    const emit = {};\\n    for (const key in callbacks) {\\n      emit[key] = (...args) => {\\n        const listeners2 = getListeners();\\n        if (listeners2.length === 0)\\n          return;\\n        for (const listener of listeners2)\\n          listener.fns[key]?.(...args);\\n      };\\n    }\\n    const cleanup = fn(emit);\\n    if (typeof cleanup === \"function\")\\n      cleanupCache.set(observerId, cleanup);\\n    return unwatch;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/wait.js\\n  async function wait(time) {\\n    return new Promise((res) => setTimeout(res, time));\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/poll.js\\n  function poll(fn, { emitOnBegin, initialWaitTime, interval }) {\\n    let active = true;\\n    const unwatch = () => active = false;\\n    const watch = async () => {\\n      let data = void 0;\\n      if (emitOnBegin)\\n        data = await fn({ unpoll: unwatch });\\n      const initialWait = await initialWaitTime?.(data) ?? interval;\\n      await wait(initialWait);\\n      const poll2 = async () => {\\n        if (!active)\\n          return;\\n        await fn({ unpoll: unwatch });\\n        await wait(interval);\\n        poll2();\\n      };\\n      poll2();\\n    };\\n    watch();\\n    return unwatch;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/watchContractEvent.js\\n  init_stringify();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/promise/withCache.js\\n  var promiseCache = /* @__PURE__ */ new Map();\\n  var responseCache = /* @__PURE__ */ new Map();\\n  function getCache(cacheKey2) {\\n    const buildCache = (cacheKey3, cache) => ({\\n      clear: () => cache.delete(cacheKey3),\\n      get: () => cache.get(cacheKey3),\\n      set: (data) => cache.set(cacheKey3, data)\\n    });\\n    const promise = buildCache(cacheKey2, promiseCache);\\n    const response = buildCache(cacheKey2, responseCache);\\n    return {\\n      clear: () => {\\n        promise.clear();\\n        response.clear();\\n      },\\n      promise,\\n      response\\n    };\\n  }\\n  async function withCache(fn, { cacheKey: cacheKey2, cacheTime = Number.POSITIVE_INFINITY }) {\\n    const cache = getCache(cacheKey2);\\n    const response = cache.response.get();\\n    if (response && cacheTime > 0) {\\n      const age = (/* @__PURE__ */ new Date()).getTime() - response.created.getTime();\\n      if (age < cacheTime)\\n        return response.data;\\n    }\\n    let promise = cache.promise.get();\\n    if (!promise) {\\n      promise = fn();\\n      cache.promise.set(promise);\\n    }\\n    try {\\n      const data = await promise;\\n      cache.response.set({ created: /* @__PURE__ */ new Date(), data });\\n      return data;\\n    } finally {\\n      cache.promise.clear();\\n    }\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/getBlockNumber.js\\n  var cacheKey = (id) => `blockNumber.${id}`;\\n  async function getBlockNumber(client, { cacheTime = client.cacheTime } = {}) {\\n    const blockNumberHex = await withCache(() => client.request({\\n      method: \"eth_blockNumber\"\\n    }), { cacheKey: cacheKey(client.uid), cacheTime });\\n    return BigInt(blockNumberHex);\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/getFilterChanges.js\\n  async function getFilterChanges(_client, { filter }) {\\n    const strict = \"strict\" in filter && filter.strict;\\n    const logs = await filter.request({\\n      method: \"eth_getFilterChanges\",\\n      params: [filter.id]\\n    });\\n    if (typeof logs[0] === \"string\")\\n      return logs;\\n    const formattedLogs = logs.map((log) => formatLog(log));\\n    if (!(\"abi\" in filter) || !filter.abi)\\n      return formattedLogs;\\n    return parseEventLogs({\\n      abi: filter.abi,\\n      logs: formattedLogs,\\n      strict\\n    });\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/uninstallFilter.js\\n  async function uninstallFilter(_client, { filter }) {\\n    return filter.request({\\n      method: \"eth_uninstallFilter\",\\n      params: [filter.id]\\n    });\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/watchContractEvent.js\\n  function watchContractEvent(client, parameters) {\\n    const { abi: abi2, address, args, batch = true, eventName, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ } = parameters;\\n    const enablePolling = (() => {\\n      if (typeof poll_ !== \"undefined\")\\n        return poll_;\\n      if (typeof fromBlock === \"bigint\")\\n        return true;\\n      if (client.transport.type === \"webSocket\")\\n        return false;\\n      if (client.transport.type === \"fallback\" && client.transport.transports[0].config.type === \"webSocket\")\\n        return false;\\n      return true;\\n    })();\\n    const pollContractEvent = () => {\\n      const strict = strict_ ?? false;\\n      const observerId = stringify([\\n        \"watchContractEvent\",\\n        address,\\n        args,\\n        batch,\\n        client.uid,\\n        eventName,\\n        pollingInterval,\\n        strict,\\n        fromBlock\\n      ]);\\n      return observe(observerId, { onLogs, onError }, (emit) => {\\n        let previousBlockNumber;\\n        if (fromBlock !== void 0)\\n          previousBlockNumber = fromBlock - 1n;\\n        let filter;\\n        let initialized = false;\\n        const unwatch = poll(async () => {\\n          if (!initialized) {\\n            try {\\n              filter = await getAction(client, createContractEventFilter, \"createContractEventFilter\")({\\n                abi: abi2,\\n                address,\\n                args,\\n                eventName,\\n                strict,\\n                fromBlock\\n              });\\n            } catch {\\n            }\\n            initialized = true;\\n            return;\\n          }\\n          try {\\n            let logs;\\n            if (filter) {\\n              logs = await getAction(client, getFilterChanges, \"getFilterChanges\")({ filter });\\n            } else {\\n              const blockNumber = await getAction(client, getBlockNumber, \"getBlockNumber\")({});\\n              if (previousBlockNumber && previousBlockNumber < blockNumber) {\\n                logs = await getAction(client, getContractEvents, \"getContractEvents\")({\\n                  abi: abi2,\\n                  address,\\n                  args,\\n                  eventName,\\n                  fromBlock: previousBlockNumber + 1n,\\n                  toBlock: blockNumber,\\n                  strict\\n                });\\n              } else {\\n                logs = [];\\n              }\\n              previousBlockNumber = blockNumber;\\n            }\\n            if (logs.length === 0)\\n              return;\\n            if (batch)\\n              emit.onLogs(logs);\\n            else\\n              for (const log of logs)\\n                emit.onLogs([log]);\\n          } catch (err) {\\n            if (filter && err instanceof InvalidInputRpcError)\\n              initialized = false;\\n            emit.onError?.(err);\\n          }\\n        }, {\\n          emitOnBegin: true,\\n          interval: pollingInterval\\n        });\\n        return async () => {\\n          if (filter)\\n            await getAction(client, uninstallFilter, \"uninstallFilter\")({ filter });\\n          unwatch();\\n        };\\n      });\\n    };\\n    const subscribeContractEvent = () => {\\n      const strict = strict_ ?? false;\\n      const observerId = stringify([\\n        \"watchContractEvent\",\\n        address,\\n        args,\\n        batch,\\n        client.uid,\\n        eventName,\\n        pollingInterval,\\n        strict\\n      ]);\\n      let active = true;\\n      let unsubscribe = () => active = false;\\n      return observe(observerId, { onLogs, onError }, (emit) => {\\n        ;\\n        (async () => {\\n          try {\\n            const transport = (() => {\\n              if (client.transport.type === \"fallback\") {\\n                const transport2 = client.transport.transports.find((transport3) => transport3.config.type === \"webSocket\");\\n                if (!transport2)\\n                  return client.transport;\\n                return transport2.value;\\n              }\\n              return client.transport;\\n            })();\\n            const topics = eventName ? encodeEventTopics({\\n              abi: abi2,\\n              eventName,\\n              args\\n            }) : [];\\n            const { unsubscribe: unsubscribe_ } = await transport.subscribe({\\n              params: [\"logs\", { address, topics }],\\n              onData(data) {\\n                if (!active)\\n                  return;\\n                const log = data.result;\\n                try {\\n                  const { eventName: eventName2, args: args2 } = decodeEventLog({\\n                    abi: abi2,\\n                    data: log.data,\\n                    topics: log.topics,\\n                    strict: strict_\\n                  });\\n                  const formatted = formatLog(log, {\\n                    args: args2,\\n                    eventName: eventName2\\n                  });\\n                  emit.onLogs([formatted]);\\n                } catch (err) {\\n                  let eventName2;\\n                  let isUnnamed;\\n                  if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {\\n                    if (strict_)\\n                      return;\\n                    eventName2 = err.abiItem.name;\\n                    isUnnamed = err.abiItem.inputs?.some((x) => !(\"name\" in x && x.name));\\n                  }\\n                  const formatted = formatLog(log, {\\n                    args: isUnnamed ? [] : {},\\n                    eventName: eventName2\\n                  });\\n                  emit.onLogs([formatted]);\\n                }\\n              },\\n              onError(error) {\\n                emit.onError?.(error);\\n              }\\n            });\\n            unsubscribe = unsubscribe_;\\n            if (!active)\\n              unsubscribe();\\n          } catch (err) {\\n            onError?.(err);\\n          }\\n        })();\\n        return () => unsubscribe();\\n      });\\n    };\\n    return enablePolling ? pollContractEvent() : subscribeContractEvent();\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/wallet/writeContract.js\\n  init_parseAccount();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/account.js\\n  init_base();\\n  var AccountNotFoundError = class extends BaseError2 {\\n    constructor({ docsPath: docsPath8 } = {}) {\\n      super([\\n        \"Could not find an Account to execute with this Action.\",\\n        \"Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client.\"\\n      ].join(\"\\\\n\"), {\\n        docsPath: docsPath8,\\n        docsSlug: \"account\",\\n        name: \"AccountNotFoundError\"\\n      });\\n    }\\n  };\\n  var AccountTypeNotSupportedError = class extends BaseError2 {\\n    constructor({ docsPath: docsPath8, metaMessages, type }) {\\n      super(`Account type \"${type}\" is not supported.`, {\\n        docsPath: docsPath8,\\n        metaMessages,\\n        name: \"AccountTypeNotSupportedError\"\\n      });\\n    }\\n  };\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/wallet/writeContract.js\\n  init_encodeFunctionData();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/wallet/sendTransaction.js\\n  init_parseAccount();\\n  init_base();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/chain/assertCurrentChain.js\\n  init_chain();\\n  function assertCurrentChain({ chain, currentChainId }) {\\n    if (!chain)\\n      throw new ChainNotFoundError();\\n    if (currentChainId !== chain.id)\\n      throw new ChainMismatchError({ chain, currentChainId });\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/errors/getTransactionError.js\\n  init_node();\\n  init_transaction();\\n  init_getNodeError();\\n  function getTransactionError(err, { docsPath: docsPath8, ...args }) {\\n    const cause = (() => {\\n      const cause2 = getNodeError(err, args);\\n      if (cause2 instanceof UnknownNodeError)\\n        return err;\\n      return cause2;\\n    })();\\n    return new TransactionExecutionError(cause, {\\n      docsPath: docsPath8,\\n      ...args\\n    });\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/wallet/sendTransaction.js\\n  init_extract();\\n  init_transactionRequest();\\n  init_lru();\\n  init_assertRequest();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/wallet/sendRawTransaction.js\\n  async function sendRawTransaction(client, { serializedTransaction }) {\\n    return client.request({\\n      method: \"eth_sendRawTransaction\",\\n      params: [serializedTransaction]\\n    }, { retryCount: 0 });\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/wallet/sendTransaction.js\\n  var supportsWalletNamespace = new LruMap(128);\\n  async function sendTransaction(client, parameters) {\\n    const { account: account_ = client.account, chain = client.chain, accessList, authorizationList, blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, value, ...rest } = parameters;\\n    if (typeof account_ === \"undefined\")\\n      throw new AccountNotFoundError({\\n        docsPath: \"/docs/actions/wallet/sendTransaction\"\\n      });\\n    const account = account_ ? parseAccount(account_) : null;\\n    try {\\n      assertRequest(parameters);\\n      const to = await (async () => {\\n        if (parameters.to)\\n          return parameters.to;\\n        if (parameters.to === null)\\n          return void 0;\\n        if (authorizationList && authorizationList.length > 0)\\n          return await recoverAuthorizationAddress({\\n            authorization: authorizationList[0]\\n          }).catch(() => {\\n            throw new BaseError2(\"`to` is required. Could not infer from `authorizationList`.\");\\n          });\\n        return void 0;\\n      })();\\n      if (account?.type === \"json-rpc\" || account === null) {\\n        let chainId;\\n        if (chain !== null) {\\n          chainId = await getAction(client, getChainId, \"getChainId\")({});\\n          assertCurrentChain({\\n            currentChainId: chainId,\\n            chain\\n          });\\n        }\\n        const chainFormat = client.chain?.formatters?.transactionRequest?.format;\\n        const format = chainFormat || formatTransactionRequest;\\n        const request = format({\\n          // Pick out extra data that might exist on the chain\\'s transaction request type.\\n          ...extract(rest, { format: chainFormat }),\\n          accessList,\\n          authorizationList,\\n          blobs,\\n          chainId,\\n          data,\\n          from: account?.address,\\n          gas,\\n          gasPrice,\\n          maxFeePerBlobGas,\\n          maxFeePerGas,\\n          maxPriorityFeePerGas,\\n          nonce,\\n          to,\\n          value\\n        });\\n        const isWalletNamespaceSupported = supportsWalletNamespace.get(client.uid);\\n        const method = isWalletNamespaceSupported ? \"wallet_sendTransaction\" : \"eth_sendTransaction\";\\n        try {\\n          return await client.request({\\n            method,\\n            params: [request]\\n          }, { retryCount: 0 });\\n        } catch (e) {\\n          if (isWalletNamespaceSupported === false)\\n            throw e;\\n          const error = e;\\n          if (error.name === \"InvalidInputRpcError\" || error.name === \"InvalidParamsRpcError\" || error.name === \"MethodNotFoundRpcError\" || error.name === \"MethodNotSupportedRpcError\") {\\n            return await client.request({\\n              method: \"wallet_sendTransaction\",\\n              params: [request]\\n            }, { retryCount: 0 }).then((hash2) => {\\n              supportsWalletNamespace.set(client.uid, true);\\n              return hash2;\\n            }).catch((e2) => {\\n              const walletNamespaceError = e2;\\n              if (walletNamespaceError.name === \"MethodNotFoundRpcError\" || walletNamespaceError.name === \"MethodNotSupportedRpcError\") {\\n                supportsWalletNamespace.set(client.uid, false);\\n                throw error;\\n              }\\n              throw walletNamespaceError;\\n            });\\n          }\\n          throw error;\\n        }\\n      }\\n      if (account?.type === \"local\") {\\n        const request = await getAction(client, prepareTransactionRequest, \"prepareTransactionRequest\")({\\n          account,\\n          accessList,\\n          authorizationList,\\n          blobs,\\n          chain,\\n          data,\\n          gas,\\n          gasPrice,\\n          maxFeePerBlobGas,\\n          maxFeePerGas,\\n          maxPriorityFeePerGas,\\n          nonce,\\n          nonceManager: account.nonceManager,\\n          parameters: [...defaultParameters, \"sidecars\"],\\n          value,\\n          ...rest,\\n          to\\n        });\\n        const serializer = chain?.serializers?.transaction;\\n        const serializedTransaction = await account.signTransaction(request, {\\n          serializer\\n        });\\n        return await getAction(client, sendRawTransaction, \"sendRawTransaction\")({\\n          serializedTransaction\\n        });\\n      }\\n      if (account?.type === \"smart\")\\n        throw new AccountTypeNotSupportedError({\\n          metaMessages: [\\n            \"Consider using the `sendUserOperation` Action instead.\"\\n          ],\\n          docsPath: \"/docs/actions/bundler/sendUserOperation\",\\n          type: \"smart\"\\n        });\\n      throw new AccountTypeNotSupportedError({\\n        docsPath: \"/docs/actions/wallet/sendTransaction\",\\n        type: account?.type\\n      });\\n    } catch (err) {\\n      if (err instanceof AccountTypeNotSupportedError)\\n        throw err;\\n      throw getTransactionError(err, {\\n        ...parameters,\\n        account,\\n        chain: parameters.chain || void 0\\n      });\\n    }\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/wallet/writeContract.js\\n  async function writeContract(client, parameters) {\\n    const { abi: abi2, account: account_ = client.account, address, args, dataSuffix, functionName, ...request } = parameters;\\n    if (typeof account_ === \"undefined\")\\n      throw new AccountNotFoundError({\\n        docsPath: \"/docs/contract/writeContract\"\\n      });\\n    const account = account_ ? parseAccount(account_) : null;\\n    const data = encodeFunctionData({\\n      abi: abi2,\\n      args,\\n      functionName\\n    });\\n    try {\\n      return await getAction(client, sendTransaction, \"sendTransaction\")({\\n        data: `${data}${dataSuffix ? dataSuffix.replace(\"0x\", \"\") : \"\"}`,\\n        to: address,\\n        account,\\n        ...request\\n      });\\n    } catch (error) {\\n      throw getContractError(error, {\\n        abi: abi2,\\n        address,\\n        args,\\n        docsPath: \"/docs/contract/writeContract\",\\n        functionName,\\n        sender: account?.address\\n      });\\n    }\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/clients/createClient.js\\n  init_parseAccount();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/uid.js\\n  var size2 = 256;\\n  var index = size2;\\n  var buffer;\\n  function uid(length = 11) {\\n    if (!buffer || index + length > size2 * 2) {\\n      buffer = \"\";\\n      index = 0;\\n      for (let i = 0; i < size2; i++) {\\n        buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);\\n      }\\n    }\\n    return buffer.substring(index, index++ + length);\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/clients/createClient.js\\n  function createClient(parameters) {\\n    const { batch, cacheTime = parameters.pollingInterval ?? 4e3, ccipRead, key = \"base\", name = \"Base Client\", pollingInterval = 4e3, type = \"base\" } = parameters;\\n    const chain = parameters.chain;\\n    const account = parameters.account ? parseAccount(parameters.account) : void 0;\\n    const { config: config2, request, value } = parameters.transport({\\n      chain,\\n      pollingInterval\\n    });\\n    const transport = { ...config2, ...value };\\n    const client = {\\n      account,\\n      batch,\\n      cacheTime,\\n      ccipRead,\\n      chain,\\n      key,\\n      name,\\n      pollingInterval,\\n      request,\\n      transport,\\n      type,\\n      uid: uid()\\n    };\\n    function extend(base2) {\\n      return (extendFn) => {\\n        const extended = extendFn(base2);\\n        for (const key2 in client)\\n          delete extended[key2];\\n        const combined = { ...base2, ...extended };\\n        return Object.assign(combined, { extend: extend(combined) });\\n      };\\n    }\\n    return Object.assign(client, { extend: extend(client) });\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/buildRequest.js\\n  init_base();\\n  init_request();\\n  init_rpc();\\n  init_toHex();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/promise/withDedupe.js\\n  init_lru();\\n  var promiseCache2 = /* @__PURE__ */ new LruMap(8192);\\n  function withDedupe(fn, { enabled = true, id }) {\\n    if (!enabled || !id)\\n      return fn();\\n    if (promiseCache2.get(id))\\n      return promiseCache2.get(id);\\n    const promise = fn().finally(() => promiseCache2.delete(id));\\n    promiseCache2.set(id, promise);\\n    return promise;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/promise/withRetry.js\\n  function withRetry(fn, { delay: delay_ = 100, retryCount = 2, shouldRetry: shouldRetry2 = () => true } = {}) {\\n    return new Promise((resolve, reject) => {\\n      const attemptRetry = async ({ count = 0 } = {}) => {\\n        const retry = async ({ error }) => {\\n          const delay = typeof delay_ === \"function\" ? delay_({ count, error }) : delay_;\\n          if (delay)\\n            await wait(delay);\\n          attemptRetry({ count: count + 1 });\\n        };\\n        try {\\n          const data = await fn();\\n          resolve(data);\\n        } catch (err) {\\n          if (count < retryCount && await shouldRetry2({ count, error: err }))\\n            return retry({ error: err });\\n          reject(err);\\n        }\\n      };\\n      attemptRetry();\\n    });\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/buildRequest.js\\n  init_stringify();\\n  function buildRequest(request, options = {}) {\\n    return async (args, overrideOptions = {}) => {\\n      const { dedupe = false, methods, retryDelay = 150, retryCount = 3, uid: uid2 } = {\\n        ...options,\\n        ...overrideOptions\\n      };\\n      const { method } = args;\\n      if (methods?.exclude?.includes(method))\\n        throw new MethodNotSupportedRpcError(new Error(\"method not supported\"), {\\n          method\\n        });\\n      if (methods?.include && !methods.include.includes(method))\\n        throw new MethodNotSupportedRpcError(new Error(\"method not supported\"), {\\n          method\\n        });\\n      const requestId = dedupe ? stringToHex(`${uid2}.${stringify(args)}`) : void 0;\\n      return withDedupe(() => withRetry(async () => {\\n        try {\\n          return await request(args);\\n        } catch (err_) {\\n          const err = err_;\\n          switch (err.code) {\\n            // -32700\\n            case ParseRpcError.code:\\n              throw new ParseRpcError(err);\\n            // -32600\\n            case InvalidRequestRpcError.code:\\n              throw new InvalidRequestRpcError(err);\\n            // -32601\\n            case MethodNotFoundRpcError.code:\\n              throw new MethodNotFoundRpcError(err, { method: args.method });\\n            // -32602\\n            case InvalidParamsRpcError.code:\\n              throw new InvalidParamsRpcError(err);\\n            // -32603\\n            case InternalRpcError.code:\\n              throw new InternalRpcError(err);\\n            // -32000\\n            case InvalidInputRpcError.code:\\n              throw new InvalidInputRpcError(err);\\n            // -32001\\n            case ResourceNotFoundRpcError.code:\\n              throw new ResourceNotFoundRpcError(err);\\n            // -32002\\n            case ResourceUnavailableRpcError.code:\\n              throw new ResourceUnavailableRpcError(err);\\n            // -32003\\n            case TransactionRejectedRpcError.code:\\n              throw new TransactionRejectedRpcError(err);\\n            // -32004\\n            case MethodNotSupportedRpcError.code:\\n              throw new MethodNotSupportedRpcError(err, {\\n                method: args.method\\n              });\\n            // -32005\\n            case LimitExceededRpcError.code:\\n              throw new LimitExceededRpcError(err);\\n            // -32006\\n            case JsonRpcVersionUnsupportedError.code:\\n              throw new JsonRpcVersionUnsupportedError(err);\\n            // 4001\\n            case UserRejectedRequestError.code:\\n              throw new UserRejectedRequestError(err);\\n            // 4100\\n            case UnauthorizedProviderError.code:\\n              throw new UnauthorizedProviderError(err);\\n            // 4200\\n            case UnsupportedProviderMethodError.code:\\n              throw new UnsupportedProviderMethodError(err);\\n            // 4900\\n            case ProviderDisconnectedError.code:\\n              throw new ProviderDisconnectedError(err);\\n            // 4901\\n            case ChainDisconnectedError.code:\\n              throw new ChainDisconnectedError(err);\\n            // 4902\\n            case SwitchChainError.code:\\n              throw new SwitchChainError(err);\\n            // 5700\\n            case UnsupportedNonOptionalCapabilityError.code:\\n              throw new UnsupportedNonOptionalCapabilityError(err);\\n            // 5710\\n            case UnsupportedChainIdError.code:\\n              throw new UnsupportedChainIdError(err);\\n            // 5720\\n            case DuplicateIdError.code:\\n              throw new DuplicateIdError(err);\\n            // 5730\\n            case UnknownBundleIdError.code:\\n              throw new UnknownBundleIdError(err);\\n            // 5740\\n            case BundleTooLargeError.code:\\n              throw new BundleTooLargeError(err);\\n            // 5750\\n            case AtomicReadyWalletRejectedUpgradeError.code:\\n              throw new AtomicReadyWalletRejectedUpgradeError(err);\\n            // 5760\\n            case AtomicityNotSupportedError.code:\\n              throw new AtomicityNotSupportedError(err);\\n            // CAIP-25: User Rejected Error\\n            // https://docs.walletconnect.com/2.0/specs/clients/sign/error-codes#rejected-caip-25\\n            case 5e3:\\n              throw new UserRejectedRequestError(err);\\n            default:\\n              if (err_ instanceof BaseError2)\\n                throw err_;\\n              throw new UnknownRpcError(err);\\n          }\\n        }\\n      }, {\\n        delay: ({ count, error }) => {\\n          if (error && error instanceof HttpRequestError) {\\n            const retryAfter = error?.headers?.get(\"Retry-After\");\\n            if (retryAfter?.match(/\\\\d/))\\n              return Number.parseInt(retryAfter) * 1e3;\\n          }\\n          return ~~(1 << count) * retryDelay;\\n        },\\n        retryCount,\\n        shouldRetry: ({ error }) => shouldRetry(error)\\n      }), { enabled: dedupe, id: requestId });\\n    };\\n  }\\n  function shouldRetry(error) {\\n    if (\"code\" in error && typeof error.code === \"number\") {\\n      if (error.code === -1)\\n        return true;\\n      if (error.code === LimitExceededRpcError.code)\\n        return true;\\n      if (error.code === InternalRpcError.code)\\n        return true;\\n      return false;\\n    }\\n    if (error instanceof HttpRequestError && error.status) {\\n      if (error.status === 403)\\n        return true;\\n      if (error.status === 408)\\n        return true;\\n      if (error.status === 413)\\n        return true;\\n      if (error.status === 429)\\n        return true;\\n      if (error.status === 500)\\n        return true;\\n      if (error.status === 502)\\n        return true;\\n      if (error.status === 503)\\n        return true;\\n      if (error.status === 504)\\n        return true;\\n      return false;\\n    }\\n    return true;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/clients/transports/createTransport.js\\n  function createTransport({ key, methods, name, request, retryCount = 3, retryDelay = 150, timeout, type }, value) {\\n    const uid2 = uid();\\n    return {\\n      config: {\\n        key,\\n        methods,\\n        name,\\n        request,\\n        retryCount,\\n        retryDelay,\\n        timeout,\\n        type\\n      },\\n      request: buildRequest(request, { methods, retryCount, retryDelay, uid: uid2 }),\\n      value\\n    };\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/clients/transports/custom.js\\n  function custom(provider, config2 = {}) {\\n    const { key = \"custom\", methods, name = \"Custom Provider\", retryDelay } = config2;\\n    return ({ retryCount: defaultRetryCount }) => createTransport({\\n      key,\\n      methods,\\n      name,\\n      request: provider.request.bind(provider),\\n      retryCount: config2.retryCount ?? defaultRetryCount,\\n      retryDelay,\\n      type: \"custom\"\\n    });\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/clients/transports/http.js\\n  init_request();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/transport.js\\n  init_base();\\n  var UrlRequiredError = class extends BaseError2 {\\n    constructor() {\\n      super(\"No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.\", {\\n        docsPath: \"/docs/clients/intro\",\\n        name: \"UrlRequiredError\"\\n      });\\n    }\\n  };\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/clients/transports/http.js\\n  init_createBatchScheduler();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/rpc/http.js\\n  init_request();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/promise/withTimeout.js\\n  function withTimeout(fn, { errorInstance = new Error(\"timed out\"), timeout, signal }) {\\n    return new Promise((resolve, reject) => {\\n      ;\\n      (async () => {\\n        let timeoutId;\\n        try {\\n          const controller = new AbortController();\\n          if (timeout > 0) {\\n            timeoutId = setTimeout(() => {\\n              if (signal) {\\n                controller.abort();\\n              } else {\\n                reject(errorInstance);\\n              }\\n            }, timeout);\\n          }\\n          resolve(await fn({ signal: controller?.signal || null }));\\n        } catch (err) {\\n          if (err?.name === \"AbortError\")\\n            reject(errorInstance);\\n          reject(err);\\n        } finally {\\n          clearTimeout(timeoutId);\\n        }\\n      })();\\n    });\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/rpc/http.js\\n  init_stringify();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/rpc/id.js\\n  function createIdStore() {\\n    return {\\n      current: 0,\\n      take() {\\n        return this.current++;\\n      },\\n      reset() {\\n        this.current = 0;\\n      }\\n    };\\n  }\\n  var idCache = /* @__PURE__ */ createIdStore();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/rpc/http.js\\n  function getHttpRpcClient(url, options = {}) {\\n    return {\\n      async request(params) {\\n        const { body, onRequest = options.onRequest, onResponse = options.onResponse, timeout = options.timeout ?? 1e4 } = params;\\n        const fetchOptions = {\\n          ...options.fetchOptions ?? {},\\n          ...params.fetchOptions ?? {}\\n        };\\n        const { headers, method, signal: signal_ } = fetchOptions;\\n        try {\\n          const response = await withTimeout(async ({ signal }) => {\\n            const init = {\\n              ...fetchOptions,\\n              body: Array.isArray(body) ? stringify(body.map((body2) => ({\\n                jsonrpc: \"2.0\",\\n                id: body2.id ?? idCache.take(),\\n                ...body2\\n              }))) : stringify({\\n                jsonrpc: \"2.0\",\\n                id: body.id ?? idCache.take(),\\n                ...body\\n              }),\\n              headers: {\\n                \"Content-Type\": \"application/json\",\\n                ...headers\\n              },\\n              method: method || \"POST\",\\n              signal: signal_ || (timeout > 0 ? signal : null)\\n            };\\n            const request = new Request(url, init);\\n            const args = await onRequest?.(request, init) ?? { ...init, url };\\n            const response2 = await fetch(args.url ?? url, args);\\n            return response2;\\n          }, {\\n            errorInstance: new TimeoutError({ body, url }),\\n            timeout,\\n            signal: true\\n          });\\n          if (onResponse)\\n            await onResponse(response);\\n          let data;\\n          if (response.headers.get(\"Content-Type\")?.startsWith(\"application/json\"))\\n            data = await response.json();\\n          else {\\n            data = await response.text();\\n            try {\\n              data = JSON.parse(data || \"{}\");\\n            } catch (err) {\\n              if (response.ok)\\n                throw err;\\n              data = { error: data };\\n            }\\n          }\\n          if (!response.ok) {\\n            throw new HttpRequestError({\\n              body,\\n              details: stringify(data.error) || response.statusText,\\n              headers: response.headers,\\n              status: response.status,\\n              url\\n            });\\n          }\\n          return data;\\n        } catch (err) {\\n          if (err instanceof HttpRequestError)\\n            throw err;\\n          if (err instanceof TimeoutError)\\n            throw err;\\n          throw new HttpRequestError({\\n            body,\\n            cause: err,\\n            url\\n          });\\n        }\\n      }\\n    };\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/clients/transports/http.js\\n  function http(url, config2 = {}) {\\n    const { batch, fetchOptions, key = \"http\", methods, name = \"HTTP JSON-RPC\", onFetchRequest, onFetchResponse, retryDelay, raw } = config2;\\n    return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {\\n      const { batchSize = 1e3, wait: wait2 = 0 } = typeof batch === \"object\" ? batch : {};\\n      const retryCount = config2.retryCount ?? retryCount_;\\n      const timeout = timeout_ ?? config2.timeout ?? 1e4;\\n      const url_ = url || chain?.rpcUrls.default.http[0];\\n      if (!url_)\\n        throw new UrlRequiredError();\\n      const rpcClient = getHttpRpcClient(url_, {\\n        fetchOptions,\\n        onRequest: onFetchRequest,\\n        onResponse: onFetchResponse,\\n        timeout\\n      });\\n      return createTransport({\\n        key,\\n        methods,\\n        name,\\n        async request({ method, params }) {\\n          const body = { method, params };\\n          const { schedule } = createBatchScheduler({\\n            id: url_,\\n            wait: wait2,\\n            shouldSplitBatch(requests) {\\n              return requests.length > batchSize;\\n            },\\n            fn: (body2) => rpcClient.request({\\n              body: body2\\n            }),\\n            sort: (a, b) => a.id - b.id\\n          });\\n          const fn = async (body2) => batch ? schedule(body2) : [\\n            await rpcClient.request({\\n              body: body2\\n            })\\n          ];\\n          const [{ error, result }] = await fn(body);\\n          if (raw)\\n            return { error, result };\\n          if (error)\\n            throw new RpcRequestError({\\n              body,\\n              error,\\n              url: url_\\n            });\\n          return result;\\n        },\\n        retryCount,\\n        retryDelay,\\n        timeout,\\n        type: \"http\"\\n      }, {\\n        fetchOptions,\\n        url: url_\\n      });\\n    };\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/ens/getEnsAddress.js\\n  init_abis();\\n  init_decodeFunctionResult();\\n  init_encodeFunctionData();\\n  init_getChainContractAddress();\\n  init_trim();\\n  init_toHex();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/ens/errors.js\\n  init_solidity();\\n  init_base();\\n  init_contract();\\n  function isNullUniversalResolverError(err, callType) {\\n    if (!(err instanceof BaseError2))\\n      return false;\\n    const cause = err.walk((e) => e instanceof ContractFunctionRevertedError);\\n    if (!(cause instanceof ContractFunctionRevertedError))\\n      return false;\\n    if (cause.data?.errorName === \"ResolverNotFound\")\\n      return true;\\n    if (cause.data?.errorName === \"ResolverWildcardNotSupported\")\\n      return true;\\n    if (cause.data?.errorName === \"ResolverNotContract\")\\n      return true;\\n    if (cause.data?.errorName === \"ResolverError\")\\n      return true;\\n    if (cause.data?.errorName === \"HttpError\")\\n      return true;\\n    if (cause.reason?.includes(\"Wildcard on non-extended resolvers is not supported\"))\\n      return true;\\n    if (callType === \"reverse\" && cause.reason === panicReasons[50])\\n      return true;\\n    return false;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/ens/getEnsAddress.js\\n  init_localBatchGatewayRequest();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/ens/namehash.js\\n  init_concat();\\n  init_toBytes();\\n  init_toHex();\\n  init_keccak256();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/ens/encodedLabelToLabelhash.js\\n  init_isHex();\\n  function encodedLabelToLabelhash(label) {\\n    if (label.length !== 66)\\n      return null;\\n    if (label.indexOf(\"[\") !== 0)\\n      return null;\\n    if (label.indexOf(\"]\") !== 65)\\n      return null;\\n    const hash2 = `0x${label.slice(1, 65)}`;\\n    if (!isHex(hash2))\\n      return null;\\n    return hash2;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/ens/namehash.js\\n  function namehash(name) {\\n    let result = new Uint8Array(32).fill(0);\\n    if (!name)\\n      return bytesToHex(result);\\n    const labels = name.split(\".\");\\n    for (let i = labels.length - 1; i >= 0; i -= 1) {\\n      const hashFromEncodedLabel = encodedLabelToLabelhash(labels[i]);\\n      const hashed = hashFromEncodedLabel ? toBytes(hashFromEncodedLabel) : keccak256(stringToBytes(labels[i]), \"bytes\");\\n      result = keccak256(concat([result, hashed]), \"bytes\");\\n    }\\n    return bytesToHex(result);\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/ens/packetToBytes.js\\n  init_toBytes();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/ens/encodeLabelhash.js\\n  function encodeLabelhash(hash2) {\\n    return `[${hash2.slice(2)}]`;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/ens/labelhash.js\\n  init_toBytes();\\n  init_toHex();\\n  init_keccak256();\\n  function labelhash(label) {\\n    const result = new Uint8Array(32).fill(0);\\n    if (!label)\\n      return bytesToHex(result);\\n    return encodedLabelToLabelhash(label) || keccak256(stringToBytes(label));\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/ens/packetToBytes.js\\n  function packetToBytes(packet) {\\n    const value = packet.replace(/^\\\\.|\\\\.$/gm, \"\");\\n    if (value.length === 0)\\n      return new Uint8Array(1);\\n    const bytes = new Uint8Array(stringToBytes(value).byteLength + 2);\\n    let offset = 0;\\n    const list = value.split(\".\");\\n    for (let i = 0; i < list.length; i++) {\\n      let encoded = stringToBytes(list[i]);\\n      if (encoded.byteLength > 255)\\n        encoded = stringToBytes(encodeLabelhash(labelhash(list[i])));\\n      bytes[offset] = encoded.length;\\n      bytes.set(encoded, offset + 1);\\n      offset += encoded.length + 1;\\n    }\\n    if (bytes.byteLength !== offset + 1)\\n      return bytes.slice(0, offset + 1);\\n    return bytes;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/ens/getEnsAddress.js\\n  async function getEnsAddress(client, parameters) {\\n    const { blockNumber, blockTag, coinType, name, gatewayUrls, strict } = parameters;\\n    const { chain } = client;\\n    const universalResolverAddress = (() => {\\n      if (parameters.universalResolverAddress)\\n        return parameters.universalResolverAddress;\\n      if (!chain)\\n        throw new Error(\"client chain not configured. universalResolverAddress is required.\");\\n      return getChainContractAddress({\\n        blockNumber,\\n        chain,\\n        contract: \"ensUniversalResolver\"\\n      });\\n    })();\\n    const tlds = chain?.ensTlds;\\n    if (tlds && !tlds.some((tld) => name.endsWith(tld)))\\n      return null;\\n    try {\\n      const functionData = encodeFunctionData({\\n        abi: addressResolverAbi,\\n        functionName: \"addr\",\\n        ...coinType != null ? { args: [namehash(name), BigInt(coinType)] } : { args: [namehash(name)] }\\n      });\\n      const readContractParameters = {\\n        address: universalResolverAddress,\\n        abi: universalResolverResolveAbi,\\n        functionName: \"resolve\",\\n        args: [\\n          toHex(packetToBytes(name)),\\n          functionData,\\n          gatewayUrls ?? [localBatchGatewayUrl]\\n        ],\\n        blockNumber,\\n        blockTag\\n      };\\n      const readContractAction = getAction(client, readContract, \"readContract\");\\n      const res = await readContractAction(readContractParameters);\\n      if (res[0] === \"0x\")\\n        return null;\\n      const address = decodeFunctionResult({\\n        abi: addressResolverAbi,\\n        args: coinType != null ? [namehash(name), BigInt(coinType)] : void 0,\\n        functionName: \"addr\",\\n        data: res[0]\\n      });\\n      if (address === \"0x\")\\n        return null;\\n      if (trim(address) === \"0x00\")\\n        return null;\\n      return address;\\n    } catch (err) {\\n      if (strict)\\n        throw err;\\n      if (isNullUniversalResolverError(err, \"resolve\"))\\n        return null;\\n      throw err;\\n    }\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/ens.js\\n  init_base();\\n  var EnsAvatarInvalidMetadataError = class extends BaseError2 {\\n    constructor({ data }) {\\n      super(\"Unable to extract image from metadata. The metadata may be malformed or invalid.\", {\\n        metaMessages: [\\n          \"- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.\",\\n          \"\",\\n          `Provided data: ${JSON.stringify(data)}`\\n        ],\\n        name: \"EnsAvatarInvalidMetadataError\"\\n      });\\n    }\\n  };\\n  var EnsAvatarInvalidNftUriError = class extends BaseError2 {\\n    constructor({ reason }) {\\n      super(`ENS NFT avatar URI is invalid. ${reason}`, {\\n        name: \"EnsAvatarInvalidNftUriError\"\\n      });\\n    }\\n  };\\n  var EnsAvatarUriResolutionError = class extends BaseError2 {\\n    constructor({ uri }) {\\n      super(`Unable to resolve ENS avatar URI \"${uri}\". The URI may be malformed, invalid, or does not respond with a valid image.`, { name: \"EnsAvatarUriResolutionError\" });\\n    }\\n  };\\n  var EnsAvatarUnsupportedNamespaceError = class extends BaseError2 {\\n    constructor({ namespace }) {\\n      super(`ENS NFT avatar namespace \"${namespace}\" is not supported. Must be \"erc721\" or \"erc1155\".`, { name: \"EnsAvatarUnsupportedNamespaceError\" });\\n    }\\n  };\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/ens/avatar/utils.js\\n  var networkRegex = /(?<protocol>https?:\\\\/\\\\/[^\\\\/]*|ipfs:\\\\/|ipns:\\\\/|ar:\\\\/)?(?<root>\\\\/)?(?<subpath>ipfs\\\\/|ipns\\\\/)?(?<target>[\\\\w\\\\-.]+)(?<subtarget>\\\\/.*)?/;\\n  var ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\\\\/(?<target>[\\\\w\\\\-.]+))?(?<subtarget>\\\\/.*)?$/;\\n  var base64Regex = /^data:([a-zA-Z\\\\-/+]*);base64,([^\"].*)/;\\n  var dataURIRegex = /^data:([a-zA-Z\\\\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;\\n  async function isImageUri(uri) {\\n    try {\\n      const res = await fetch(uri, { method: \"HEAD\" });\\n      if (res.status === 200) {\\n        const contentType = res.headers.get(\"content-type\");\\n        return contentType?.startsWith(\"image/\");\\n      }\\n      return false;\\n    } catch (error) {\\n      if (typeof error === \"object\" && typeof error.response !== \"undefined\") {\\n        return false;\\n      }\\n      if (!globalThis.hasOwnProperty(\"Image\"))\\n        return false;\\n      return new Promise((resolve) => {\\n        const img = new Image();\\n        img.onload = () => {\\n          resolve(true);\\n        };\\n        img.onerror = () => {\\n          resolve(false);\\n        };\\n        img.src = uri;\\n      });\\n    }\\n  }\\n  function getGateway(custom3, defaultGateway) {\\n    if (!custom3)\\n      return defaultGateway;\\n    if (custom3.endsWith(\"/\"))\\n      return custom3.slice(0, -1);\\n    return custom3;\\n  }\\n  function resolveAvatarUri({ uri, gatewayUrls }) {\\n    const isEncoded = base64Regex.test(uri);\\n    if (isEncoded)\\n      return { uri, isOnChain: true, isEncoded };\\n    const ipfsGateway = getGateway(gatewayUrls?.ipfs, \"https://ipfs.io\");\\n    const arweaveGateway = getGateway(gatewayUrls?.arweave, \"https://arweave.net\");\\n    const networkRegexMatch = uri.match(networkRegex);\\n    const { protocol, subpath, target, subtarget = \"\" } = networkRegexMatch?.groups || {};\\n    const isIPNS = protocol === \"ipns:/\" || subpath === \"ipns/\";\\n    const isIPFS = protocol === \"ipfs:/\" || subpath === \"ipfs/\" || ipfsHashRegex.test(uri);\\n    if (uri.startsWith(\"http\") && !isIPNS && !isIPFS) {\\n      let replacedUri = uri;\\n      if (gatewayUrls?.arweave)\\n        replacedUri = uri.replace(/https:\\\\/\\\\/arweave.net/g, gatewayUrls?.arweave);\\n      return { uri: replacedUri, isOnChain: false, isEncoded: false };\\n    }\\n    if ((isIPNS || isIPFS) && target) {\\n      return {\\n        uri: `${ipfsGateway}/${isIPNS ? \"ipns\" : \"ipfs\"}/${target}${subtarget}`,\\n        isOnChain: false,\\n        isEncoded: false\\n      };\\n    }\\n    if (protocol === \"ar:/\" && target) {\\n      return {\\n        uri: `${arweaveGateway}/${target}${subtarget || \"\"}`,\\n        isOnChain: false,\\n        isEncoded: false\\n      };\\n    }\\n    let parsedUri = uri.replace(dataURIRegex, \"\");\\n    if (parsedUri.startsWith(\"<svg\")) {\\n      parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;\\n    }\\n    if (parsedUri.startsWith(\"data:\") || parsedUri.startsWith(\"{\")) {\\n      return {\\n        uri: parsedUri,\\n        isOnChain: true,\\n        isEncoded: false\\n      };\\n    }\\n    throw new EnsAvatarUriResolutionError({ uri });\\n  }\\n  function getJsonImage(data) {\\n    if (typeof data !== \"object\" || !(\"image\" in data) && !(\"image_url\" in data) && !(\"image_data\" in data)) {\\n      throw new EnsAvatarInvalidMetadataError({ data });\\n    }\\n    return data.image || data.image_url || data.image_data;\\n  }\\n  async function getMetadataAvatarUri({ gatewayUrls, uri }) {\\n    try {\\n      const res = await fetch(uri).then((res2) => res2.json());\\n      const image = await parseAvatarUri({\\n        gatewayUrls,\\n        uri: getJsonImage(res)\\n      });\\n      return image;\\n    } catch {\\n      throw new EnsAvatarUriResolutionError({ uri });\\n    }\\n  }\\n  async function parseAvatarUri({ gatewayUrls, uri }) {\\n    const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });\\n    if (isOnChain)\\n      return resolvedURI;\\n    const isImage = await isImageUri(resolvedURI);\\n    if (isImage)\\n      return resolvedURI;\\n    throw new EnsAvatarUriResolutionError({ uri });\\n  }\\n  function parseNftUri(uri_) {\\n    let uri = uri_;\\n    if (uri.startsWith(\"did:nft:\")) {\\n      uri = uri.replace(\"did:nft:\", \"\").replace(/_/g, \"/\");\\n    }\\n    const [reference, asset_namespace, tokenID] = uri.split(\"/\");\\n    const [eip_namespace, chainID] = reference.split(\":\");\\n    const [erc_namespace, contractAddress] = asset_namespace.split(\":\");\\n    if (!eip_namespace || eip_namespace.toLowerCase() !== \"eip155\")\\n      throw new EnsAvatarInvalidNftUriError({ reason: \"Only EIP-155 supported\" });\\n    if (!chainID)\\n      throw new EnsAvatarInvalidNftUriError({ reason: \"Chain ID not found\" });\\n    if (!contractAddress)\\n      throw new EnsAvatarInvalidNftUriError({\\n        reason: \"Contract address not found\"\\n      });\\n    if (!tokenID)\\n      throw new EnsAvatarInvalidNftUriError({ reason: \"Token ID not found\" });\\n    if (!erc_namespace)\\n      throw new EnsAvatarInvalidNftUriError({ reason: \"ERC namespace not found\" });\\n    return {\\n      chainID: Number.parseInt(chainID),\\n      namespace: erc_namespace.toLowerCase(),\\n      contractAddress,\\n      tokenID\\n    };\\n  }\\n  async function getNftTokenUri(client, { nft }) {\\n    if (nft.namespace === \"erc721\") {\\n      return readContract(client, {\\n        address: nft.contractAddress,\\n        abi: [\\n          {\\n            name: \"tokenURI\",\\n            type: \"function\",\\n            stateMutability: \"view\",\\n            inputs: [{ name: \"tokenId\", type: \"uint256\" }],\\n            outputs: [{ name: \"\", type: \"string\" }]\\n          }\\n        ],\\n        functionName: \"tokenURI\",\\n        args: [BigInt(nft.tokenID)]\\n      });\\n    }\\n    if (nft.namespace === \"erc1155\") {\\n      return readContract(client, {\\n        address: nft.contractAddress,\\n        abi: [\\n          {\\n            name: \"uri\",\\n            type: \"function\",\\n            stateMutability: \"view\",\\n            inputs: [{ name: \"_id\", type: \"uint256\" }],\\n            outputs: [{ name: \"\", type: \"string\" }]\\n          }\\n        ],\\n        functionName: \"uri\",\\n        args: [BigInt(nft.tokenID)]\\n      });\\n    }\\n    throw new EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/ens/avatar/parseAvatarRecord.js\\n  async function parseAvatarRecord(client, { gatewayUrls, record }) {\\n    if (/eip155:/i.test(record))\\n      return parseNftAvatarUri(client, { gatewayUrls, record });\\n    return parseAvatarUri({ uri: record, gatewayUrls });\\n  }\\n  async function parseNftAvatarUri(client, { gatewayUrls, record }) {\\n    const nft = parseNftUri(record);\\n    const nftUri = await getNftTokenUri(client, { nft });\\n    const { uri: resolvedNftUri, isOnChain, isEncoded } = resolveAvatarUri({ uri: nftUri, gatewayUrls });\\n    if (isOnChain && (resolvedNftUri.includes(\"data:application/json;base64,\") || resolvedNftUri.startsWith(\"{\"))) {\\n      const encodedJson = isEncoded ? (\\n        // if it is encoded, decode it\\n        atob(resolvedNftUri.replace(\"data:application/json;base64,\", \"\"))\\n      ) : (\\n        // if it isn\\'t encoded assume it is a JSON string, but it could be anything (it will error if it is)\\n        resolvedNftUri\\n      );\\n      const decoded = JSON.parse(encodedJson);\\n      return parseAvatarUri({ uri: getJsonImage(decoded), gatewayUrls });\\n    }\\n    let uriTokenId = nft.tokenID;\\n    if (nft.namespace === \"erc1155\")\\n      uriTokenId = uriTokenId.replace(\"0x\", \"\").padStart(64, \"0\");\\n    return getMetadataAvatarUri({\\n      gatewayUrls,\\n      uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId)\\n    });\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/ens/getEnsText.js\\n  init_abis();\\n  init_decodeFunctionResult();\\n  init_encodeFunctionData();\\n  init_getChainContractAddress();\\n  init_toHex();\\n  init_localBatchGatewayRequest();\\n  async function getEnsText(client, parameters) {\\n    const { blockNumber, blockTag, key, name, gatewayUrls, strict } = parameters;\\n    const { chain } = client;\\n    const universalResolverAddress = (() => {\\n      if (parameters.universalResolverAddress)\\n        return parameters.universalResolverAddress;\\n      if (!chain)\\n        throw new Error(\"client chain not configured. universalResolverAddress is required.\");\\n      return getChainContractAddress({\\n        blockNumber,\\n        chain,\\n        contract: \"ensUniversalResolver\"\\n      });\\n    })();\\n    const tlds = chain?.ensTlds;\\n    if (tlds && !tlds.some((tld) => name.endsWith(tld)))\\n      return null;\\n    try {\\n      const readContractParameters = {\\n        address: universalResolverAddress,\\n        abi: universalResolverResolveAbi,\\n        functionName: \"resolve\",\\n        args: [\\n          toHex(packetToBytes(name)),\\n          encodeFunctionData({\\n            abi: textResolverAbi,\\n            functionName: \"text\",\\n            args: [namehash(name), key]\\n          }),\\n          gatewayUrls ?? [localBatchGatewayUrl]\\n        ],\\n        blockNumber,\\n        blockTag\\n      };\\n      const readContractAction = getAction(client, readContract, \"readContract\");\\n      const res = await readContractAction(readContractParameters);\\n      if (res[0] === \"0x\")\\n        return null;\\n      const record = decodeFunctionResult({\\n        abi: textResolverAbi,\\n        functionName: \"text\",\\n        data: res[0]\\n      });\\n      return record === \"\" ? null : record;\\n    } catch (err) {\\n      if (strict)\\n        throw err;\\n      if (isNullUniversalResolverError(err, \"resolve\"))\\n        return null;\\n      throw err;\\n    }\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/ens/getEnsAvatar.js\\n  async function getEnsAvatar(client, { blockNumber, blockTag, assetGatewayUrls, name, gatewayUrls, strict, universalResolverAddress }) {\\n    const record = await getAction(client, getEnsText, \"getEnsText\")({\\n      blockNumber,\\n      blockTag,\\n      key: \"avatar\",\\n      name,\\n      universalResolverAddress,\\n      gatewayUrls,\\n      strict\\n    });\\n    if (!record)\\n      return null;\\n    try {\\n      return await parseAvatarRecord(client, {\\n        record,\\n        gatewayUrls: assetGatewayUrls\\n      });\\n    } catch {\\n      return null;\\n    }\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/ens/getEnsName.js\\n  init_abis();\\n  init_getChainContractAddress();\\n  init_toHex();\\n  async function getEnsName(client, { address, blockNumber, blockTag, gatewayUrls, strict, universalResolverAddress: universalResolverAddress_ }) {\\n    let universalResolverAddress = universalResolverAddress_;\\n    if (!universalResolverAddress) {\\n      if (!client.chain)\\n        throw new Error(\"client chain not configured. universalResolverAddress is required.\");\\n      universalResolverAddress = getChainContractAddress({\\n        blockNumber,\\n        chain: client.chain,\\n        contract: \"ensUniversalResolver\"\\n      });\\n    }\\n    const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`;\\n    try {\\n      const readContractParameters = {\\n        address: universalResolverAddress,\\n        abi: universalResolverReverseAbi,\\n        functionName: \"reverse\",\\n        args: [toHex(packetToBytes(reverseNode))],\\n        blockNumber,\\n        blockTag\\n      };\\n      const readContractAction = getAction(client, readContract, \"readContract\");\\n      const [name, resolvedAddress] = gatewayUrls ? await readContractAction({\\n        ...readContractParameters,\\n        args: [...readContractParameters.args, gatewayUrls]\\n      }) : await readContractAction(readContractParameters);\\n      if (address.toLowerCase() !== resolvedAddress.toLowerCase())\\n        return null;\\n      return name;\\n    } catch (err) {\\n      if (strict)\\n        throw err;\\n      if (isNullUniversalResolverError(err, \"reverse\"))\\n        return null;\\n      throw err;\\n    }\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/ens/getEnsResolver.js\\n  init_getChainContractAddress();\\n  init_toHex();\\n  async function getEnsResolver(client, parameters) {\\n    const { blockNumber, blockTag, name } = parameters;\\n    const { chain } = client;\\n    const universalResolverAddress = (() => {\\n      if (parameters.universalResolverAddress)\\n        return parameters.universalResolverAddress;\\n      if (!chain)\\n        throw new Error(\"client chain not configured. universalResolverAddress is required.\");\\n      return getChainContractAddress({\\n        blockNumber,\\n        chain,\\n        contract: \"ensUniversalResolver\"\\n      });\\n    })();\\n    const tlds = chain?.ensTlds;\\n    if (tlds && !tlds.some((tld) => name.endsWith(tld)))\\n      throw new Error(`${name} is not a valid ENS TLD (${tlds?.join(\", \")}) for chain \"${chain.name}\" (id: ${chain.id}).`);\\n    const [resolverAddress] = await getAction(client, readContract, \"readContract\")({\\n      address: universalResolverAddress,\\n      abi: [\\n        {\\n          inputs: [{ type: \"bytes\" }],\\n          name: \"findResolver\",\\n          outputs: [{ type: \"address\" }, { type: \"bytes32\" }],\\n          stateMutability: \"view\",\\n          type: \"function\"\\n        }\\n      ],\\n      functionName: \"findResolver\",\\n      args: [toHex(packetToBytes(name))],\\n      blockNumber,\\n      blockTag\\n    });\\n    return resolverAddress;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/clients/decorators/public.js\\n  init_call();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/createAccessList.js\\n  init_parseAccount();\\n  init_toHex();\\n  init_getCallError();\\n  init_extract();\\n  init_transactionRequest();\\n  init_assertRequest();\\n  async function createAccessList(client, args) {\\n    const { account: account_ = client.account, blockNumber, blockTag = \"latest\", blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, to, value, ...rest } = args;\\n    const account = account_ ? parseAccount(account_) : void 0;\\n    try {\\n      assertRequest(args);\\n      const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;\\n      const block = blockNumberHex || blockTag;\\n      const chainFormat = client.chain?.formatters?.transactionRequest?.format;\\n      const format = chainFormat || formatTransactionRequest;\\n      const request = format({\\n        // Pick out extra data that might exist on the chain\\'s transaction request type.\\n        ...extract(rest, { format: chainFormat }),\\n        from: account?.address,\\n        blobs,\\n        data,\\n        gas,\\n        gasPrice,\\n        maxFeePerBlobGas,\\n        maxFeePerGas,\\n        maxPriorityFeePerGas,\\n        to,\\n        value\\n      });\\n      const response = await client.request({\\n        method: \"eth_createAccessList\",\\n        params: [request, block]\\n      });\\n      return {\\n        accessList: response.accessList,\\n        gasUsed: BigInt(response.gasUsed)\\n      };\\n    } catch (err) {\\n      throw getCallError(err, {\\n        ...args,\\n        account,\\n        chain: client.chain\\n      });\\n    }\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/createBlockFilter.js\\n  async function createBlockFilter(client) {\\n    const getRequest = createFilterRequestScope(client, {\\n      method: \"eth_newBlockFilter\"\\n    });\\n    const id = await client.request({\\n      method: \"eth_newBlockFilter\"\\n    });\\n    return { id, request: getRequest(id), type: \"block\" };\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/createEventFilter.js\\n  init_toHex();\\n  async function createEventFilter(client, { address, args, event, events: events_, fromBlock, strict, toBlock } = {}) {\\n    const events = events_ ?? (event ? [event] : void 0);\\n    const getRequest = createFilterRequestScope(client, {\\n      method: \"eth_newFilter\"\\n    });\\n    let topics = [];\\n    if (events) {\\n      const encoded = events.flatMap((event2) => encodeEventTopics({\\n        abi: [event2],\\n        eventName: event2.name,\\n        args\\n      }));\\n      topics = [encoded];\\n      if (event)\\n        topics = topics[0];\\n    }\\n    const id = await client.request({\\n      method: \"eth_newFilter\",\\n      params: [\\n        {\\n          address,\\n          fromBlock: typeof fromBlock === \"bigint\" ? numberToHex(fromBlock) : fromBlock,\\n          toBlock: typeof toBlock === \"bigint\" ? numberToHex(toBlock) : toBlock,\\n          ...topics.length ? { topics } : {}\\n        }\\n      ]\\n    });\\n    return {\\n      abi: events,\\n      args,\\n      eventName: event ? event.name : void 0,\\n      fromBlock,\\n      id,\\n      request: getRequest(id),\\n      strict: Boolean(strict),\\n      toBlock,\\n      type: \"event\"\\n    };\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/createPendingTransactionFilter.js\\n  async function createPendingTransactionFilter(client) {\\n    const getRequest = createFilterRequestScope(client, {\\n      method: \"eth_newPendingTransactionFilter\"\\n    });\\n    const id = await client.request({\\n      method: \"eth_newPendingTransactionFilter\"\\n    });\\n    return { id, request: getRequest(id), type: \"transaction\" };\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/getBlobBaseFee.js\\n  async function getBlobBaseFee(client) {\\n    const baseFee = await client.request({\\n      method: \"eth_blobBaseFee\"\\n    });\\n    return BigInt(baseFee);\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/getBlockTransactionCount.js\\n  init_fromHex();\\n  init_toHex();\\n  async function getBlockTransactionCount(client, { blockHash, blockNumber, blockTag = \"latest\" } = {}) {\\n    const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;\\n    let count;\\n    if (blockHash) {\\n      count = await client.request({\\n        method: \"eth_getBlockTransactionCountByHash\",\\n        params: [blockHash]\\n      }, { dedupe: true });\\n    } else {\\n      count = await client.request({\\n        method: \"eth_getBlockTransactionCountByNumber\",\\n        params: [blockNumberHex || blockTag]\\n      }, { dedupe: Boolean(blockNumberHex) });\\n    }\\n    return hexToNumber(count);\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/getCode.js\\n  init_toHex();\\n  async function getCode(client, { address, blockNumber, blockTag = \"latest\" }) {\\n    const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;\\n    const hex = await client.request({\\n      method: \"eth_getCode\",\\n      params: [address, blockNumberHex || blockTag]\\n    }, { dedupe: Boolean(blockNumberHex) });\\n    if (hex === \"0x\")\\n      return void 0;\\n    return hex;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/eip712.js\\n  init_base();\\n  var Eip712DomainNotFoundError = class extends BaseError2 {\\n    constructor({ address }) {\\n      super(`No EIP-712 domain found on contract \"${address}\".`, {\\n        metaMessages: [\\n          \"Ensure that:\",\\n          `- The contract is deployed at the address \"${address}\".`,\\n          \"- `eip712Domain()` function exists on the contract.\",\\n          \"- `eip712Domain()` function matches signature to ERC-5267 specification.\"\\n        ],\\n        name: \"Eip712DomainNotFoundError\"\\n      });\\n    }\\n  };\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/getEip712Domain.js\\n  async function getEip712Domain(client, parameters) {\\n    const { address, factory, factoryData } = parameters;\\n    try {\\n      const [fields, name, version4, chainId, verifyingContract, salt, extensions] = await getAction(client, readContract, \"readContract\")({\\n        abi,\\n        address,\\n        functionName: \"eip712Domain\",\\n        factory,\\n        factoryData\\n      });\\n      return {\\n        domain: {\\n          name,\\n          version: version4,\\n          chainId: Number(chainId),\\n          verifyingContract,\\n          salt\\n        },\\n        extensions,\\n        fields\\n      };\\n    } catch (e) {\\n      const error = e;\\n      if (error.name === \"ContractFunctionExecutionError\" && error.cause.name === \"ContractFunctionZeroDataError\") {\\n        throw new Eip712DomainNotFoundError({ address });\\n      }\\n      throw error;\\n    }\\n  }\\n  var abi = [\\n    {\\n      inputs: [],\\n      name: \"eip712Domain\",\\n      outputs: [\\n        { name: \"fields\", type: \"bytes1\" },\\n        { name: \"name\", type: \"string\" },\\n        { name: \"version\", type: \"string\" },\\n        { name: \"chainId\", type: \"uint256\" },\\n        { name: \"verifyingContract\", type: \"address\" },\\n        { name: \"salt\", type: \"bytes32\" },\\n        { name: \"extensions\", type: \"uint256[]\" }\\n      ],\\n      stateMutability: \"view\",\\n      type: \"function\"\\n    }\\n  ];\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/getFeeHistory.js\\n  init_toHex();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/formatters/feeHistory.js\\n  function formatFeeHistory(feeHistory) {\\n    return {\\n      baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),\\n      gasUsedRatio: feeHistory.gasUsedRatio,\\n      oldestBlock: BigInt(feeHistory.oldestBlock),\\n      reward: feeHistory.reward?.map((reward) => reward.map((value) => BigInt(value)))\\n    };\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/getFeeHistory.js\\n  async function getFeeHistory(client, { blockCount, blockNumber, blockTag = \"latest\", rewardPercentiles }) {\\n    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;\\n    const feeHistory = await client.request({\\n      method: \"eth_feeHistory\",\\n      params: [\\n        numberToHex(blockCount),\\n        blockNumberHex || blockTag,\\n        rewardPercentiles\\n      ]\\n    }, { dedupe: Boolean(blockNumberHex) });\\n    return formatFeeHistory(feeHistory);\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/getFilterLogs.js\\n  async function getFilterLogs(_client, { filter }) {\\n    const strict = filter.strict ?? false;\\n    const logs = await filter.request({\\n      method: \"eth_getFilterLogs\",\\n      params: [filter.id]\\n    });\\n    const formattedLogs = logs.map((log) => formatLog(log));\\n    if (!filter.abi)\\n      return formattedLogs;\\n    return parseEventLogs({\\n      abi: filter.abi,\\n      logs: formattedLogs,\\n      strict\\n    });\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/getProof.js\\n  init_toHex();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/chain/defineChain.js\\n  function defineChain(chain) {\\n    return {\\n      formatters: void 0,\\n      fees: void 0,\\n      serializers: void 0,\\n      ...chain\\n    };\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/typedData.js\\n  init_abi();\\n  init_address();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/errors/typedData.js\\n  init_stringify();\\n  init_base();\\n  var InvalidDomainError = class extends BaseError2 {\\n    constructor({ domain }) {\\n      super(`Invalid domain \"${stringify(domain)}\".`, {\\n        metaMessages: [\"Must be a valid EIP-712 domain.\"]\\n      });\\n    }\\n  };\\n  var InvalidPrimaryTypeError = class extends BaseError2 {\\n    constructor({ primaryType, types }) {\\n      super(`Invalid primary type \\\\`${primaryType}\\\\` must be one of \\\\`${JSON.stringify(Object.keys(types))}\\\\`.`, {\\n        docsPath: \"/api/glossary/Errors#typeddatainvalidprimarytypeerror\",\\n        metaMessages: [\"Check that the primary type is a key in `types`.\"]\\n      });\\n    }\\n  };\\n  var InvalidStructTypeError = class extends BaseError2 {\\n    constructor({ type }) {\\n      super(`Struct type \"${type}\" is invalid.`, {\\n        metaMessages: [\"Struct type must not be a Solidity type.\"],\\n        name: \"InvalidStructTypeError\"\\n      });\\n    }\\n  };\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/typedData.js\\n  init_isAddress();\\n  init_size();\\n  init_toHex();\\n  init_regex2();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/signature/hashTypedData.js\\n  init_encodeAbiParameters();\\n  init_concat();\\n  init_toHex();\\n  init_keccak256();\\n  function hashTypedData(parameters) {\\n    const { domain = {}, message, primaryType } = parameters;\\n    const types = {\\n      EIP712Domain: getTypesForEIP712Domain({ domain }),\\n      ...parameters.types\\n    };\\n    validateTypedData({\\n      domain,\\n      message,\\n      primaryType,\\n      types\\n    });\\n    const parts = [\"0x1901\"];\\n    if (domain)\\n      parts.push(hashDomain({\\n        domain,\\n        types\\n      }));\\n    if (primaryType !== \"EIP712Domain\")\\n      parts.push(hashStruct({\\n        data: message,\\n        primaryType,\\n        types\\n      }));\\n    return keccak256(concat(parts));\\n  }\\n  function hashDomain({ domain, types }) {\\n    return hashStruct({\\n      data: domain,\\n      primaryType: \"EIP712Domain\",\\n      types\\n    });\\n  }\\n  function hashStruct({ data, primaryType, types }) {\\n    const encoded = encodeData({\\n      data,\\n      primaryType,\\n      types\\n    });\\n    return keccak256(encoded);\\n  }\\n  function encodeData({ data, primaryType, types }) {\\n    const encodedTypes = [{ type: \"bytes32\" }];\\n    const encodedValues = [hashType({ primaryType, types })];\\n    for (const field of types[primaryType]) {\\n      const [type, value] = encodeField({\\n        types,\\n        name: field.name,\\n        type: field.type,\\n        value: data[field.name]\\n      });\\n      encodedTypes.push(type);\\n      encodedValues.push(value);\\n    }\\n    return encodeAbiParameters(encodedTypes, encodedValues);\\n  }\\n  function hashType({ primaryType, types }) {\\n    const encodedHashType = toHex(encodeType({ primaryType, types }));\\n    return keccak256(encodedHashType);\\n  }\\n  function encodeType({ primaryType, types }) {\\n    let result = \"\";\\n    const unsortedDeps = findTypeDependencies({ primaryType, types });\\n    unsortedDeps.delete(primaryType);\\n    const deps = [primaryType, ...Array.from(unsortedDeps).sort()];\\n    for (const type of deps) {\\n      result += `${type}(${types[type].map(({ name, type: t }) => `${t} ${name}`).join(\",\")})`;\\n    }\\n    return result;\\n  }\\n  function findTypeDependencies({ primaryType: primaryType_, types }, results = /* @__PURE__ */ new Set()) {\\n    const match = primaryType_.match(/^\\\\w*/u);\\n    const primaryType = match?.[0];\\n    if (results.has(primaryType) || types[primaryType] === void 0) {\\n      return results;\\n    }\\n    results.add(primaryType);\\n    for (const field of types[primaryType]) {\\n      findTypeDependencies({ primaryType: field.type, types }, results);\\n    }\\n    return results;\\n  }\\n  function encodeField({ types, name, type, value }) {\\n    if (types[type] !== void 0) {\\n      return [\\n        { type: \"bytes32\" },\\n        keccak256(encodeData({ data: value, primaryType: type, types }))\\n      ];\\n    }\\n    if (type === \"bytes\") {\\n      const prepend = value.length % 2 ? \"0\" : \"\";\\n      value = `0x${prepend + value.slice(2)}`;\\n      return [{ type: \"bytes32\" }, keccak256(value)];\\n    }\\n    if (type === \"string\")\\n      return [{ type: \"bytes32\" }, keccak256(toHex(value))];\\n    if (type.lastIndexOf(\"]\") === type.length - 1) {\\n      const parsedType = type.slice(0, type.lastIndexOf(\"[\"));\\n      const typeValuePairs = value.map((item) => encodeField({\\n        name,\\n        type: parsedType,\\n        types,\\n        value: item\\n      }));\\n      return [\\n        { type: \"bytes32\" },\\n        keccak256(encodeAbiParameters(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v)))\\n      ];\\n    }\\n    return [{ type }, value];\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/typedData.js\\n  init_stringify();\\n  function serializeTypedData(parameters) {\\n    const { domain: domain_, message: message_, primaryType, types } = parameters;\\n    const normalizeData = (struct, data_) => {\\n      const data = { ...data_ };\\n      for (const param of struct) {\\n        const { name, type } = param;\\n        if (type === \"address\")\\n          data[name] = data[name].toLowerCase();\\n      }\\n      return data;\\n    };\\n    const domain = (() => {\\n      if (!types.EIP712Domain)\\n        return {};\\n      if (!domain_)\\n        return {};\\n      return normalizeData(types.EIP712Domain, domain_);\\n    })();\\n    const message = (() => {\\n      if (primaryType === \"EIP712Domain\")\\n        return void 0;\\n      return normalizeData(types[primaryType], message_);\\n    })();\\n    return stringify({ domain, message, primaryType, types });\\n  }\\n  function validateTypedData(parameters) {\\n    const { domain, message, primaryType, types } = parameters;\\n    const validateData = (struct, data) => {\\n      for (const param of struct) {\\n        const { name, type } = param;\\n        const value = data[name];\\n        const integerMatch = type.match(integerRegex2);\\n        if (integerMatch && (typeof value === \"number\" || typeof value === \"bigint\")) {\\n          const [_type, base2, size_] = integerMatch;\\n          numberToHex(value, {\\n            signed: base2 === \"int\",\\n            size: Number.parseInt(size_) / 8\\n          });\\n        }\\n        if (type === \"address\" && typeof value === \"string\" && !isAddress(value))\\n          throw new InvalidAddressError({ address: value });\\n        const bytesMatch = type.match(bytesRegex2);\\n        if (bytesMatch) {\\n          const [_type, size_] = bytesMatch;\\n          if (size_ && size(value) !== Number.parseInt(size_))\\n            throw new BytesSizeMismatchError({\\n              expectedSize: Number.parseInt(size_),\\n              givenSize: size(value)\\n            });\\n        }\\n        const struct2 = types[type];\\n        if (struct2) {\\n          validateReference(type);\\n          validateData(struct2, value);\\n        }\\n      }\\n    };\\n    if (types.EIP712Domain && domain) {\\n      if (typeof domain !== \"object\")\\n        throw new InvalidDomainError({ domain });\\n      validateData(types.EIP712Domain, domain);\\n    }\\n    if (primaryType !== \"EIP712Domain\") {\\n      if (types[primaryType])\\n        validateData(types[primaryType], message);\\n      else\\n        throw new InvalidPrimaryTypeError({ primaryType, types });\\n    }\\n  }\\n  function getTypesForEIP712Domain({ domain }) {\\n    return [\\n      typeof domain?.name === \"string\" && { name: \"name\", type: \"string\" },\\n      domain?.version && { name: \"version\", type: \"string\" },\\n      (typeof domain?.chainId === \"number\" || typeof domain?.chainId === \"bigint\") && {\\n        name: \"chainId\",\\n        type: \"uint256\"\\n      },\\n      domain?.verifyingContract && {\\n        name: \"verifyingContract\",\\n        type: \"address\"\\n      },\\n      domain?.salt && { name: \"salt\", type: \"bytes32\" }\\n    ].filter(Boolean);\\n  }\\n  function validateReference(type) {\\n    if (type === \"address\" || type === \"bool\" || type === \"string\" || type.startsWith(\"bytes\") || type.startsWith(\"uint\") || type.startsWith(\"int\"))\\n      throw new InvalidStructTypeError({ type });\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/index.js\\n  init_encodeFunctionData();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/authorization/serializeAuthorizationList.js\\n  init_toHex();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/transaction/serializeTransaction.js\\n  init_transaction();\\n  init_concat();\\n  init_trim();\\n  init_toHex();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/transaction/assertTransaction.js\\n  init_number();\\n  init_address();\\n  init_base();\\n  init_chain();\\n  init_node();\\n  init_isAddress();\\n  init_size();\\n  init_slice();\\n  init_fromHex();\\n  function assertTransactionEIP7702(transaction) {\\n    const { authorizationList } = transaction;\\n    if (authorizationList) {\\n      for (const authorization of authorizationList) {\\n        const { chainId } = authorization;\\n        const address = authorization.address;\\n        if (!isAddress(address))\\n          throw new InvalidAddressError({ address });\\n        if (chainId < 0)\\n          throw new InvalidChainIdError({ chainId });\\n      }\\n    }\\n    assertTransactionEIP1559(transaction);\\n  }\\n  function assertTransactionEIP4844(transaction) {\\n    const { blobVersionedHashes } = transaction;\\n    if (blobVersionedHashes) {\\n      if (blobVersionedHashes.length === 0)\\n        throw new EmptyBlobError();\\n      for (const hash2 of blobVersionedHashes) {\\n        const size_ = size(hash2);\\n        const version4 = hexToNumber(slice(hash2, 0, 1));\\n        if (size_ !== 32)\\n          throw new InvalidVersionedHashSizeError({ hash: hash2, size: size_ });\\n        if (version4 !== versionedHashVersionKzg)\\n          throw new InvalidVersionedHashVersionError({\\n            hash: hash2,\\n            version: version4\\n          });\\n      }\\n    }\\n    assertTransactionEIP1559(transaction);\\n  }\\n  function assertTransactionEIP1559(transaction) {\\n    const { chainId, maxPriorityFeePerGas, maxFeePerGas, to } = transaction;\\n    if (chainId <= 0)\\n      throw new InvalidChainIdError({ chainId });\\n    if (to && !isAddress(to))\\n      throw new InvalidAddressError({ address: to });\\n    if (maxFeePerGas && maxFeePerGas > maxUint256)\\n      throw new FeeCapTooHighError({ maxFeePerGas });\\n    if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)\\n      throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });\\n  }\\n  function assertTransactionEIP2930(transaction) {\\n    const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;\\n    if (chainId <= 0)\\n      throw new InvalidChainIdError({ chainId });\\n    if (to && !isAddress(to))\\n      throw new InvalidAddressError({ address: to });\\n    if (maxPriorityFeePerGas || maxFeePerGas)\\n      throw new BaseError2(\"`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.\");\\n    if (gasPrice && gasPrice > maxUint256)\\n      throw new FeeCapTooHighError({ maxFeePerGas: gasPrice });\\n  }\\n  function assertTransactionLegacy(transaction) {\\n    const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;\\n    if (to && !isAddress(to))\\n      throw new InvalidAddressError({ address: to });\\n    if (typeof chainId !== \"undefined\" && chainId <= 0)\\n      throw new InvalidChainIdError({ chainId });\\n    if (maxPriorityFeePerGas || maxFeePerGas)\\n      throw new BaseError2(\"`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.\");\\n    if (gasPrice && gasPrice > maxUint256)\\n      throw new FeeCapTooHighError({ maxFeePerGas: gasPrice });\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/transaction/serializeAccessList.js\\n  init_address();\\n  init_transaction();\\n  init_isAddress();\\n  function serializeAccessList(accessList) {\\n    if (!accessList || accessList.length === 0)\\n      return [];\\n    const serializedAccessList = [];\\n    for (let i = 0; i < accessList.length; i++) {\\n      const { address, storageKeys } = accessList[i];\\n      for (let j = 0; j < storageKeys.length; j++) {\\n        if (storageKeys[j].length - 2 !== 64) {\\n          throw new InvalidStorageKeySizeError({ storageKey: storageKeys[j] });\\n        }\\n      }\\n      if (!isAddress(address, { strict: false })) {\\n        throw new InvalidAddressError({ address });\\n      }\\n      serializedAccessList.push([address, storageKeys]);\\n    }\\n    return serializedAccessList;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/transaction/serializeTransaction.js\\n  function serializeTransaction(transaction, signature) {\\n    const type = getTransactionType(transaction);\\n    if (type === \"eip1559\")\\n      return serializeTransactionEIP1559(transaction, signature);\\n    if (type === \"eip2930\")\\n      return serializeTransactionEIP2930(transaction, signature);\\n    if (type === \"eip4844\")\\n      return serializeTransactionEIP4844(transaction, signature);\\n    if (type === \"eip7702\")\\n      return serializeTransactionEIP7702(transaction, signature);\\n    return serializeTransactionLegacy(transaction, signature);\\n  }\\n  function serializeTransactionEIP7702(transaction, signature) {\\n    const { authorizationList, chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;\\n    assertTransactionEIP7702(transaction);\\n    const serializedAccessList = serializeAccessList(accessList);\\n    const serializedAuthorizationList = serializeAuthorizationList(authorizationList);\\n    return concatHex([\\n      \"0x04\",\\n      toRlp([\\n        toHex(chainId),\\n        nonce ? toHex(nonce) : \"0x\",\\n        maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : \"0x\",\\n        maxFeePerGas ? toHex(maxFeePerGas) : \"0x\",\\n        gas ? toHex(gas) : \"0x\",\\n        to ?? \"0x\",\\n        value ? toHex(value) : \"0x\",\\n        data ?? \"0x\",\\n        serializedAccessList,\\n        serializedAuthorizationList,\\n        ...toYParitySignatureArray(transaction, signature)\\n      ])\\n    ]);\\n  }\\n  function serializeTransactionEIP4844(transaction, signature) {\\n    const { chainId, gas, nonce, to, value, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;\\n    assertTransactionEIP4844(transaction);\\n    let blobVersionedHashes = transaction.blobVersionedHashes;\\n    let sidecars = transaction.sidecars;\\n    if (transaction.blobs && (typeof blobVersionedHashes === \"undefined\" || typeof sidecars === \"undefined\")) {\\n      const blobs2 = typeof transaction.blobs[0] === \"string\" ? transaction.blobs : transaction.blobs.map((x) => bytesToHex(x));\\n      const kzg = transaction.kzg;\\n      const commitments2 = blobsToCommitments({\\n        blobs: blobs2,\\n        kzg\\n      });\\n      if (typeof blobVersionedHashes === \"undefined\")\\n        blobVersionedHashes = commitmentsToVersionedHashes({\\n          commitments: commitments2\\n        });\\n      if (typeof sidecars === \"undefined\") {\\n        const proofs2 = blobsToProofs({ blobs: blobs2, commitments: commitments2, kzg });\\n        sidecars = toBlobSidecars({ blobs: blobs2, commitments: commitments2, proofs: proofs2 });\\n      }\\n    }\\n    const serializedAccessList = serializeAccessList(accessList);\\n    const serializedTransaction = [\\n      toHex(chainId),\\n      nonce ? toHex(nonce) : \"0x\",\\n      maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : \"0x\",\\n      maxFeePerGas ? toHex(maxFeePerGas) : \"0x\",\\n      gas ? toHex(gas) : \"0x\",\\n      to ?? \"0x\",\\n      value ? toHex(value) : \"0x\",\\n      data ?? \"0x\",\\n      serializedAccessList,\\n      maxFeePerBlobGas ? toHex(maxFeePerBlobGas) : \"0x\",\\n      blobVersionedHashes ?? [],\\n      ...toYParitySignatureArray(transaction, signature)\\n    ];\\n    const blobs = [];\\n    const commitments = [];\\n    const proofs = [];\\n    if (sidecars)\\n      for (let i = 0; i < sidecars.length; i++) {\\n        const { blob, commitment, proof } = sidecars[i];\\n        blobs.push(blob);\\n        commitments.push(commitment);\\n        proofs.push(proof);\\n      }\\n    return concatHex([\\n      \"0x03\",\\n      sidecars ? (\\n        // If sidecars are enabled, envelope turns into a \"wrapper\":\\n        toRlp([serializedTransaction, blobs, commitments, proofs])\\n      ) : (\\n        // If sidecars are disabled, standard envelope is used:\\n        toRlp(serializedTransaction)\\n      )\\n    ]);\\n  }\\n  function serializeTransactionEIP1559(transaction, signature) {\\n    const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;\\n    assertTransactionEIP1559(transaction);\\n    const serializedAccessList = serializeAccessList(accessList);\\n    const serializedTransaction = [\\n      toHex(chainId),\\n      nonce ? toHex(nonce) : \"0x\",\\n      maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : \"0x\",\\n      maxFeePerGas ? toHex(maxFeePerGas) : \"0x\",\\n      gas ? toHex(gas) : \"0x\",\\n      to ?? \"0x\",\\n      value ? toHex(value) : \"0x\",\\n      data ?? \"0x\",\\n      serializedAccessList,\\n      ...toYParitySignatureArray(transaction, signature)\\n    ];\\n    return concatHex([\\n      \"0x02\",\\n      toRlp(serializedTransaction)\\n    ]);\\n  }\\n  function serializeTransactionEIP2930(transaction, signature) {\\n    const { chainId, gas, data, nonce, to, value, accessList, gasPrice } = transaction;\\n    assertTransactionEIP2930(transaction);\\n    const serializedAccessList = serializeAccessList(accessList);\\n    const serializedTransaction = [\\n      toHex(chainId),\\n      nonce ? toHex(nonce) : \"0x\",\\n      gasPrice ? toHex(gasPrice) : \"0x\",\\n      gas ? toHex(gas) : \"0x\",\\n      to ?? \"0x\",\\n      value ? toHex(value) : \"0x\",\\n      data ?? \"0x\",\\n      serializedAccessList,\\n      ...toYParitySignatureArray(transaction, signature)\\n    ];\\n    return concatHex([\\n      \"0x01\",\\n      toRlp(serializedTransaction)\\n    ]);\\n  }\\n  function serializeTransactionLegacy(transaction, signature) {\\n    const { chainId = 0, gas, data, nonce, to, value, gasPrice } = transaction;\\n    assertTransactionLegacy(transaction);\\n    let serializedTransaction = [\\n      nonce ? toHex(nonce) : \"0x\",\\n      gasPrice ? toHex(gasPrice) : \"0x\",\\n      gas ? toHex(gas) : \"0x\",\\n      to ?? \"0x\",\\n      value ? toHex(value) : \"0x\",\\n      data ?? \"0x\"\\n    ];\\n    if (signature) {\\n      const v = (() => {\\n        if (signature.v >= 35n) {\\n          const inferredChainId = (signature.v - 35n) / 2n;\\n          if (inferredChainId > 0)\\n            return signature.v;\\n          return 27n + (signature.v === 35n ? 0n : 1n);\\n        }\\n        if (chainId > 0)\\n          return BigInt(chainId * 2) + BigInt(35n + signature.v - 27n);\\n        const v2 = 27n + (signature.v === 27n ? 0n : 1n);\\n        if (signature.v !== v2)\\n          throw new InvalidLegacyVError({ v: signature.v });\\n        return v2;\\n      })();\\n      const r = trim(signature.r);\\n      const s = trim(signature.s);\\n      serializedTransaction = [\\n        ...serializedTransaction,\\n        toHex(v),\\n        r === \"0x00\" ? \"0x\" : r,\\n        s === \"0x00\" ? \"0x\" : s\\n      ];\\n    } else if (chainId > 0) {\\n      serializedTransaction = [\\n        ...serializedTransaction,\\n        toHex(chainId),\\n        \"0x\",\\n        \"0x\"\\n      ];\\n    }\\n    return toRlp(serializedTransaction);\\n  }\\n  function toYParitySignatureArray(transaction, signature_) {\\n    const signature = signature_ ?? transaction;\\n    const { v, yParity } = signature;\\n    if (typeof signature.r === \"undefined\")\\n      return [];\\n    if (typeof signature.s === \"undefined\")\\n      return [];\\n    if (typeof v === \"undefined\" && typeof yParity === \"undefined\")\\n      return [];\\n    const r = trim(signature.r);\\n    const s = trim(signature.s);\\n    const yParity_ = (() => {\\n      if (typeof yParity === \"number\")\\n        return yParity ? toHex(1) : \"0x\";\\n      if (v === 0n)\\n        return \"0x\";\\n      if (v === 1n)\\n        return toHex(1);\\n      return v === 27n ? \"0x\" : toHex(1);\\n    })();\\n    return [yParity_, r === \"0x00\" ? \"0x\" : r, s === \"0x00\" ? \"0x\" : s];\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/authorization/serializeAuthorizationList.js\\n  function serializeAuthorizationList(authorizationList) {\\n    if (!authorizationList || authorizationList.length === 0)\\n      return [];\\n    const serializedAuthorizationList = [];\\n    for (const authorization of authorizationList) {\\n      const { chainId, nonce, ...signature } = authorization;\\n      const contractAddress = authorization.address;\\n      serializedAuthorizationList.push([\\n        chainId ? toHex(chainId) : \"0x\",\\n        contractAddress,\\n        nonce ? toHex(nonce) : \"0x\",\\n        ...toYParitySignatureArray({}, signature)\\n      ]);\\n    }\\n    return serializedAuthorizationList;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/formatters/transactionReceipt.js\\n  init_fromHex();\\n  init_formatter();\\n  var receiptStatuses = {\\n    \"0x0\": \"reverted\",\\n    \"0x1\": \"success\"\\n  };\\n  function formatTransactionReceipt(transactionReceipt) {\\n    const receipt = {\\n      ...transactionReceipt,\\n      blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,\\n      contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,\\n      cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,\\n      effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,\\n      gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,\\n      logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog(log)) : null,\\n      to: transactionReceipt.to ? transactionReceipt.to : null,\\n      transactionIndex: transactionReceipt.transactionIndex ? hexToNumber(transactionReceipt.transactionIndex) : null,\\n      status: transactionReceipt.status ? receiptStatuses[transactionReceipt.status] : null,\\n      type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null\\n    };\\n    if (transactionReceipt.blobGasPrice)\\n      receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);\\n    if (transactionReceipt.blobGasUsed)\\n      receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);\\n    return receipt;\\n  }\\n  var defineTransactionReceipt = /* @__PURE__ */ defineFormatter(\"transactionReceipt\", formatTransactionReceipt);\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/index.js\\n  init_fromHex();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/signature/hashMessage.js\\n  init_keccak256();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/constants/strings.js\\n  var presignMessagePrefix = \"\u0019Ethereum Signed Message:\\\\n\";\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/signature/toPrefixedMessage.js\\n  init_concat();\\n  init_size();\\n  init_toHex();\\n  function toPrefixedMessage(message_) {\\n    const message = (() => {\\n      if (typeof message_ === \"string\")\\n        return stringToHex(message_);\\n      if (typeof message_.raw === \"string\")\\n        return message_.raw;\\n      return bytesToHex(message_.raw);\\n    })();\\n    const prefix = stringToHex(`${presignMessagePrefix}${size(message)}`);\\n    return concat([prefix, message]);\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/signature/hashMessage.js\\n  function hashMessage(message, to_) {\\n    return keccak256(toPrefixedMessage(message), to_);\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/constants/bytes.js\\n  var erc6492MagicBytes = \"0x6492649264926492649264926492649264926492649264926492649264926492\";\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/signature/isErc6492Signature.js\\n  init_slice();\\n  function isErc6492Signature(signature) {\\n    return sliceHex(signature, -32) === erc6492MagicBytes;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/signature/serializeErc6492Signature.js\\n  init_encodeAbiParameters();\\n  init_concat();\\n  init_toBytes();\\n  function serializeErc6492Signature(parameters) {\\n    const { address, data, signature, to = \"hex\" } = parameters;\\n    const signature_ = concatHex([\\n      encodeAbiParameters([{ type: \"address\" }, { type: \"bytes\" }, { type: \"bytes\" }], [address, data, signature]),\\n      erc6492MagicBytes\\n    ]);\\n    if (to === \"hex\")\\n      return signature_;\\n    return hexToBytes(signature_);\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/formatters/proof.js\\n  function formatStorageProof(storageProof) {\\n    return storageProof.map((proof) => ({\\n      ...proof,\\n      value: BigInt(proof.value)\\n    }));\\n  }\\n  function formatProof(proof) {\\n    return {\\n      ...proof,\\n      balance: proof.balance ? BigInt(proof.balance) : void 0,\\n      nonce: proof.nonce ? hexToNumber(proof.nonce) : void 0,\\n      storageProof: proof.storageProof ? formatStorageProof(proof.storageProof) : void 0\\n    };\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/getProof.js\\n  async function getProof(client, { address, blockNumber, blockTag: blockTag_, storageKeys }) {\\n    const blockTag = blockTag_ ?? \"latest\";\\n    const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;\\n    const proof = await client.request({\\n      method: \"eth_getProof\",\\n      params: [address, storageKeys, blockNumberHex || blockTag]\\n    });\\n    return formatProof(proof);\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/getStorageAt.js\\n  init_toHex();\\n  async function getStorageAt(client, { address, blockNumber, blockTag = \"latest\", slot }) {\\n    const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;\\n    const data = await client.request({\\n      method: \"eth_getStorageAt\",\\n      params: [address, slot, blockNumberHex || blockTag]\\n    });\\n    return data;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/getTransaction.js\\n  init_transaction();\\n  init_toHex();\\n  async function getTransaction(client, { blockHash, blockNumber, blockTag: blockTag_, hash: hash2, index: index2 }) {\\n    const blockTag = blockTag_ || \"latest\";\\n    const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;\\n    let transaction = null;\\n    if (hash2) {\\n      transaction = await client.request({\\n        method: \"eth_getTransactionByHash\",\\n        params: [hash2]\\n      }, { dedupe: true });\\n    } else if (blockHash) {\\n      transaction = await client.request({\\n        method: \"eth_getTransactionByBlockHashAndIndex\",\\n        params: [blockHash, numberToHex(index2)]\\n      }, { dedupe: true });\\n    } else if (blockNumberHex || blockTag) {\\n      transaction = await client.request({\\n        method: \"eth_getTransactionByBlockNumberAndIndex\",\\n        params: [blockNumberHex || blockTag, numberToHex(index2)]\\n      }, { dedupe: Boolean(blockNumberHex) });\\n    }\\n    if (!transaction)\\n      throw new TransactionNotFoundError({\\n        blockHash,\\n        blockNumber,\\n        blockTag,\\n        hash: hash2,\\n        index: index2\\n      });\\n    const format = client.chain?.formatters?.transaction?.format || formatTransaction;\\n    return format(transaction);\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/getTransactionConfirmations.js\\n  async function getTransactionConfirmations(client, { hash: hash2, transactionReceipt }) {\\n    const [blockNumber, transaction] = await Promise.all([\\n      getAction(client, getBlockNumber, \"getBlockNumber\")({}),\\n      hash2 ? getAction(client, getTransaction, \"getTransaction\")({ hash: hash2 }) : void 0\\n    ]);\\n    const transactionBlockNumber = transactionReceipt?.blockNumber || transaction?.blockNumber;\\n    if (!transactionBlockNumber)\\n      return 0n;\\n    return blockNumber - transactionBlockNumber + 1n;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/getTransactionReceipt.js\\n  init_transaction();\\n  async function getTransactionReceipt(client, { hash: hash2 }) {\\n    const receipt = await client.request({\\n      method: \"eth_getTransactionReceipt\",\\n      params: [hash2]\\n    }, { dedupe: true });\\n    if (!receipt)\\n      throw new TransactionReceiptNotFoundError({ hash: hash2 });\\n    const format = client.chain?.formatters?.transactionReceipt?.format || formatTransactionReceipt;\\n    return format(receipt);\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/multicall.js\\n  init_abis();\\n  init_abi();\\n  init_base();\\n  init_contract();\\n  init_decodeFunctionResult();\\n  init_encodeFunctionData();\\n  init_getChainContractAddress();\\n  async function multicall(client, parameters) {\\n    const { allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, multicallAddress: multicallAddress_, stateOverride } = parameters;\\n    const contracts2 = parameters.contracts;\\n    const batchSize = batchSize_ ?? (typeof client.batch?.multicall === \"object\" && client.batch.multicall.batchSize || 1024);\\n    let multicallAddress = multicallAddress_;\\n    if (!multicallAddress) {\\n      if (!client.chain)\\n        throw new Error(\"client chain not configured. multicallAddress is required.\");\\n      multicallAddress = getChainContractAddress({\\n        blockNumber,\\n        chain: client.chain,\\n        contract: \"multicall3\"\\n      });\\n    }\\n    const chunkedCalls = [[]];\\n    let currentChunk = 0;\\n    let currentChunkSize = 0;\\n    for (let i = 0; i < contracts2.length; i++) {\\n      const { abi: abi2, address, args, functionName } = contracts2[i];\\n      try {\\n        const callData = encodeFunctionData({ abi: abi2, args, functionName });\\n        currentChunkSize += (callData.length - 2) / 2;\\n        if (\\n          // Check if batching is enabled.\\n          batchSize > 0 && // Check if the current size of the batch exceeds the size limit.\\n          currentChunkSize > batchSize && // Check if the current chunk is not already empty.\\n          chunkedCalls[currentChunk].length > 0\\n        ) {\\n          currentChunk++;\\n          currentChunkSize = (callData.length - 2) / 2;\\n          chunkedCalls[currentChunk] = [];\\n        }\\n        chunkedCalls[currentChunk] = [\\n          ...chunkedCalls[currentChunk],\\n          {\\n            allowFailure: true,\\n            callData,\\n            target: address\\n          }\\n        ];\\n      } catch (err) {\\n        const error = getContractError(err, {\\n          abi: abi2,\\n          address,\\n          args,\\n          docsPath: \"/docs/contract/multicall\",\\n          functionName\\n        });\\n        if (!allowFailure)\\n          throw error;\\n        chunkedCalls[currentChunk] = [\\n          ...chunkedCalls[currentChunk],\\n          {\\n            allowFailure: true,\\n            callData: \"0x\",\\n            target: address\\n          }\\n        ];\\n      }\\n    }\\n    const aggregate3Results = await Promise.allSettled(chunkedCalls.map((calls) => getAction(client, readContract, \"readContract\")({\\n      abi: multicall3Abi,\\n      address: multicallAddress,\\n      args: [calls],\\n      blockNumber,\\n      blockTag,\\n      functionName: \"aggregate3\",\\n      stateOverride\\n    })));\\n    const results = [];\\n    for (let i = 0; i < aggregate3Results.length; i++) {\\n      const result = aggregate3Results[i];\\n      if (result.status === \"rejected\") {\\n        if (!allowFailure)\\n          throw result.reason;\\n        for (let j = 0; j < chunkedCalls[i].length; j++) {\\n          results.push({\\n            status: \"failure\",\\n            error: result.reason,\\n            result: void 0\\n          });\\n        }\\n        continue;\\n      }\\n      const aggregate3Result = result.value;\\n      for (let j = 0; j < aggregate3Result.length; j++) {\\n        const { returnData, success } = aggregate3Result[j];\\n        const { callData } = chunkedCalls[i][j];\\n        const { abi: abi2, address, functionName, args } = contracts2[results.length];\\n        try {\\n          if (callData === \"0x\")\\n            throw new AbiDecodingZeroDataError();\\n          if (!success)\\n            throw new RawContractError({ data: returnData });\\n          const result2 = decodeFunctionResult({\\n            abi: abi2,\\n            args,\\n            data: returnData,\\n            functionName\\n          });\\n          results.push(allowFailure ? { result: result2, status: \"success\" } : result2);\\n        } catch (err) {\\n          const error = getContractError(err, {\\n            abi: abi2,\\n            address,\\n            args,\\n            docsPath: \"/docs/contract/multicall\",\\n            functionName\\n          });\\n          if (!allowFailure)\\n            throw error;\\n          results.push({ error, result: void 0, status: \"failure\" });\\n        }\\n      }\\n    }\\n    if (results.length !== contracts2.length)\\n      throw new BaseError2(\"multicall results mismatch\");\\n    return results;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/ox@0.6.9_typescript@5.8.3_zod@3.24.3/node_modules/ox/_esm/core/version.js\\n  var version3 = \"0.1.1\";\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/ox@0.6.9_typescript@5.8.3_zod@3.24.3/node_modules/ox/_esm/core/internal/errors.js\\n  function getVersion() {\\n    return version3;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/ox@0.6.9_typescript@5.8.3_zod@3.24.3/node_modules/ox/_esm/core/Errors.js\\n  var BaseError3 = class _BaseError extends Error {\\n    constructor(shortMessage, options = {}) {\\n      const details = (() => {\\n        if (options.cause instanceof _BaseError) {\\n          if (options.cause.details)\\n            return options.cause.details;\\n          if (options.cause.shortMessage)\\n            return options.cause.shortMessage;\\n        }\\n        if (options.cause?.message)\\n          return options.cause.message;\\n        return options.details;\\n      })();\\n      const docsPath8 = (() => {\\n        if (options.cause instanceof _BaseError)\\n          return options.cause.docsPath || options.docsPath;\\n        return options.docsPath;\\n      })();\\n      const docsBaseUrl = \"https://oxlib.sh\";\\n      const docs = `${docsBaseUrl}${docsPath8 ?? \"\"}`;\\n      const message = [\\n        shortMessage || \"An error occurred.\",\\n        ...options.metaMessages ? [\"\", ...options.metaMessages] : [],\\n        ...details || docsPath8 ? [\\n          \"\",\\n          details ? `Details: ${details}` : void 0,\\n          docsPath8 ? `See: ${docs}` : void 0\\n        ] : []\\n      ].filter((x) => typeof x === \"string\").join(\"\\\\n\");\\n      super(message, options.cause ? { cause: options.cause } : void 0);\\n      Object.defineProperty(this, \"details\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: void 0\\n      });\\n      Object.defineProperty(this, \"docs\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: void 0\\n      });\\n      Object.defineProperty(this, \"docsPath\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: void 0\\n      });\\n      Object.defineProperty(this, \"shortMessage\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: void 0\\n      });\\n      Object.defineProperty(this, \"cause\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: void 0\\n      });\\n      Object.defineProperty(this, \"name\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: \"BaseError\"\\n      });\\n      Object.defineProperty(this, \"version\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: `ox@${getVersion()}`\\n      });\\n      this.cause = options.cause;\\n      this.details = details;\\n      this.docs = docs;\\n      this.docsPath = docsPath8;\\n      this.shortMessage = shortMessage;\\n    }\\n    walk(fn) {\\n      return walk2(this, fn);\\n    }\\n  };\\n  function walk2(err, fn) {\\n    if (fn?.(err))\\n      return err;\\n    if (err && typeof err === \"object\" && \"cause\" in err && err.cause)\\n      return walk2(err.cause, fn);\\n    return fn ? null : err;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/ox@0.6.9_typescript@5.8.3_zod@3.24.3/node_modules/ox/_esm/core/Json.js\\n  var bigIntSuffix = \"#__bigint\";\\n  function stringify2(value, replacer, space) {\\n    return JSON.stringify(value, (key, value2) => {\\n      if (typeof replacer === \"function\")\\n        return replacer(key, value2);\\n      if (typeof value2 === \"bigint\")\\n        return value2.toString() + bigIntSuffix;\\n      return value2;\\n    }, space);\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/ox@0.6.9_typescript@5.8.3_zod@3.24.3/node_modules/ox/_esm/core/internal/bytes.js\\n  function assertSize2(bytes, size_) {\\n    if (size3(bytes) > size_)\\n      throw new SizeOverflowError2({\\n        givenSize: size3(bytes),\\n        maxSize: size_\\n      });\\n  }\\n  var charCodeMap2 = {\\n    zero: 48,\\n    nine: 57,\\n    A: 65,\\n    F: 70,\\n    a: 97,\\n    f: 102\\n  };\\n  function charCodeToBase162(char) {\\n    if (char >= charCodeMap2.zero && char <= charCodeMap2.nine)\\n      return char - charCodeMap2.zero;\\n    if (char >= charCodeMap2.A && char <= charCodeMap2.F)\\n      return char - (charCodeMap2.A - 10);\\n    if (char >= charCodeMap2.a && char <= charCodeMap2.f)\\n      return char - (charCodeMap2.a - 10);\\n    return void 0;\\n  }\\n  function pad2(bytes, options = {}) {\\n    const { dir, size: size5 = 32 } = options;\\n    if (size5 === 0)\\n      return bytes;\\n    if (bytes.length > size5)\\n      throw new SizeExceedsPaddingSizeError2({\\n        size: bytes.length,\\n        targetSize: size5,\\n        type: \"Bytes\"\\n      });\\n    const paddedBytes = new Uint8Array(size5);\\n    for (let i = 0; i < size5; i++) {\\n      const padEnd = dir === \"right\";\\n      paddedBytes[padEnd ? i : size5 - i - 1] = bytes[padEnd ? i : bytes.length - i - 1];\\n    }\\n    return paddedBytes;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/ox@0.6.9_typescript@5.8.3_zod@3.24.3/node_modules/ox/_esm/core/internal/hex.js\\n  function assertSize3(hex, size_) {\\n    if (size4(hex) > size_)\\n      throw new SizeOverflowError3({\\n        givenSize: size4(hex),\\n        maxSize: size_\\n      });\\n  }\\n  function assertStartOffset2(value, start) {\\n    if (typeof start === \"number\" && start > 0 && start > size4(value) - 1)\\n      throw new SliceOffsetOutOfBoundsError3({\\n        offset: start,\\n        position: \"start\",\\n        size: size4(value)\\n      });\\n  }\\n  function assertEndOffset2(value, start, end) {\\n    if (typeof start === \"number\" && typeof end === \"number\" && size4(value) !== end - start) {\\n      throw new SliceOffsetOutOfBoundsError3({\\n        offset: end,\\n        position: \"end\",\\n        size: size4(value)\\n      });\\n    }\\n  }\\n  function pad3(hex_, options = {}) {\\n    const { dir, size: size5 = 32 } = options;\\n    if (size5 === 0)\\n      return hex_;\\n    const hex = hex_.replace(\"0x\", \"\");\\n    if (hex.length > size5 * 2)\\n      throw new SizeExceedsPaddingSizeError3({\\n        size: Math.ceil(hex.length / 2),\\n        targetSize: size5,\\n        type: \"Hex\"\\n      });\\n    return `0x${hex[dir === \"right\" ? \"padEnd\" : \"padStart\"](size5 * 2, \"0\")}`;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/ox@0.6.9_typescript@5.8.3_zod@3.24.3/node_modules/ox/_esm/core/Bytes.js\\n  var encoder3 = /* @__PURE__ */ new TextEncoder();\\n  function from(value) {\\n    if (value instanceof Uint8Array)\\n      return value;\\n    if (typeof value === \"string\")\\n      return fromHex2(value);\\n    return fromArray(value);\\n  }\\n  function fromArray(value) {\\n    return value instanceof Uint8Array ? value : new Uint8Array(value);\\n  }\\n  function fromHex2(value, options = {}) {\\n    const { size: size5 } = options;\\n    let hex = value;\\n    if (size5) {\\n      assertSize3(value, size5);\\n      hex = padRight(value, size5);\\n    }\\n    let hexString = hex.slice(2);\\n    if (hexString.length % 2)\\n      hexString = `0${hexString}`;\\n    const length = hexString.length / 2;\\n    const bytes = new Uint8Array(length);\\n    for (let index2 = 0, j = 0; index2 < length; index2++) {\\n      const nibbleLeft = charCodeToBase162(hexString.charCodeAt(j++));\\n      const nibbleRight = charCodeToBase162(hexString.charCodeAt(j++));\\n      if (nibbleLeft === void 0 || nibbleRight === void 0) {\\n        throw new BaseError3(`Invalid byte sequence (\"${hexString[j - 2]}${hexString[j - 1]}\" in \"${hexString}\").`);\\n      }\\n      bytes[index2] = nibbleLeft * 16 + nibbleRight;\\n    }\\n    return bytes;\\n  }\\n  function fromString(value, options = {}) {\\n    const { size: size5 } = options;\\n    const bytes = encoder3.encode(value);\\n    if (typeof size5 === \"number\") {\\n      assertSize2(bytes, size5);\\n      return padRight2(bytes, size5);\\n    }\\n    return bytes;\\n  }\\n  function padRight2(value, size5) {\\n    return pad2(value, { dir: \"right\", size: size5 });\\n  }\\n  function size3(value) {\\n    return value.length;\\n  }\\n  var SizeOverflowError2 = class extends BaseError3 {\\n    constructor({ givenSize, maxSize }) {\\n      super(`Size cannot exceed \\\\`${maxSize}\\\\` bytes. Given size: \\\\`${givenSize}\\\\` bytes.`);\\n      Object.defineProperty(this, \"name\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: \"Bytes.SizeOverflowError\"\\n      });\\n    }\\n  };\\n  var SizeExceedsPaddingSizeError2 = class extends BaseError3 {\\n    constructor({ size: size5, targetSize, type }) {\\n      super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\\\\`${size5}\\\\`) exceeds padding size (\\\\`${targetSize}\\\\`).`);\\n      Object.defineProperty(this, \"name\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: \"Bytes.SizeExceedsPaddingSizeError\"\\n      });\\n    }\\n  };\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/ox@0.6.9_typescript@5.8.3_zod@3.24.3/node_modules/ox/_esm/core/Hex.js\\n  var encoder4 = /* @__PURE__ */ new TextEncoder();\\n  var hexes3 = /* @__PURE__ */ Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, \"0\"));\\n  function assert(value, options = {}) {\\n    const { strict = false } = options;\\n    if (!value)\\n      throw new InvalidHexTypeError(value);\\n    if (typeof value !== \"string\")\\n      throw new InvalidHexTypeError(value);\\n    if (strict) {\\n      if (!/^0x[0-9a-fA-F]*$/.test(value))\\n        throw new InvalidHexValueError(value);\\n    }\\n    if (!value.startsWith(\"0x\"))\\n      throw new InvalidHexValueError(value);\\n  }\\n  function concat2(...values) {\\n    return `0x${values.reduce((acc, x) => acc + x.replace(\"0x\", \"\"), \"\")}`;\\n  }\\n  function fromBoolean(value, options = {}) {\\n    const hex = `0x${Number(value)}`;\\n    if (typeof options.size === \"number\") {\\n      assertSize3(hex, options.size);\\n      return padLeft(hex, options.size);\\n    }\\n    return hex;\\n  }\\n  function fromBytes(value, options = {}) {\\n    let string = \"\";\\n    for (let i = 0; i < value.length; i++)\\n      string += hexes3[value[i]];\\n    const hex = `0x${string}`;\\n    if (typeof options.size === \"number\") {\\n      assertSize3(hex, options.size);\\n      return padRight(hex, options.size);\\n    }\\n    return hex;\\n  }\\n  function fromNumber(value, options = {}) {\\n    const { signed, size: size5 } = options;\\n    const value_ = BigInt(value);\\n    let maxValue;\\n    if (size5) {\\n      if (signed)\\n        maxValue = (1n << BigInt(size5) * 8n - 1n) - 1n;\\n      else\\n        maxValue = 2n ** (BigInt(size5) * 8n) - 1n;\\n    } else if (typeof value === \"number\") {\\n      maxValue = BigInt(Number.MAX_SAFE_INTEGER);\\n    }\\n    const minValue = typeof maxValue === \"bigint\" && signed ? -maxValue - 1n : 0;\\n    if (maxValue && value_ > maxValue || value_ < minValue) {\\n      const suffix = typeof value === \"bigint\" ? \"n\" : \"\";\\n      throw new IntegerOutOfRangeError2({\\n        max: maxValue ? `${maxValue}${suffix}` : void 0,\\n        min: `${minValue}${suffix}`,\\n        signed,\\n        size: size5,\\n        value: `${value}${suffix}`\\n      });\\n    }\\n    const stringValue = (signed && value_ < 0 ? (1n << BigInt(size5 * 8)) + BigInt(value_) : value_).toString(16);\\n    const hex = `0x${stringValue}`;\\n    if (size5)\\n      return padLeft(hex, size5);\\n    return hex;\\n  }\\n  function fromString2(value, options = {}) {\\n    return fromBytes(encoder4.encode(value), options);\\n  }\\n  function padLeft(value, size5) {\\n    return pad3(value, { dir: \"left\", size: size5 });\\n  }\\n  function padRight(value, size5) {\\n    return pad3(value, { dir: \"right\", size: size5 });\\n  }\\n  function slice2(value, start, end, options = {}) {\\n    const { strict } = options;\\n    assertStartOffset2(value, start);\\n    const value_ = `0x${value.replace(\"0x\", \"\").slice((start ?? 0) * 2, (end ?? value.length) * 2)}`;\\n    if (strict)\\n      assertEndOffset2(value_, start, end);\\n    return value_;\\n  }\\n  function size4(value) {\\n    return Math.ceil((value.length - 2) / 2);\\n  }\\n  function validate(value, options = {}) {\\n    const { strict = false } = options;\\n    try {\\n      assert(value, { strict });\\n      return true;\\n    } catch {\\n      return false;\\n    }\\n  }\\n  var IntegerOutOfRangeError2 = class extends BaseError3 {\\n    constructor({ max, min, signed, size: size5, value }) {\\n      super(`Number \\\\`${value}\\\\` is not in safe${size5 ? ` ${size5 * 8}-bit` : \"\"}${signed ? \" signed\" : \" unsigned\"} integer range ${max ? `(\\\\`${min}\\\\` to \\\\`${max}\\\\`)` : `(above \\\\`${min}\\\\`)`}`);\\n      Object.defineProperty(this, \"name\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: \"Hex.IntegerOutOfRangeError\"\\n      });\\n    }\\n  };\\n  var InvalidHexTypeError = class extends BaseError3 {\\n    constructor(value) {\\n      super(`Value \\\\`${typeof value === \"object\" ? stringify2(value) : value}\\\\` of type \\\\`${typeof value}\\\\` is an invalid hex type.`, {\\n        metaMessages: [\\'Hex types must be represented as `\"0x${string}\"`.\\']\\n      });\\n      Object.defineProperty(this, \"name\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: \"Hex.InvalidHexTypeError\"\\n      });\\n    }\\n  };\\n  var InvalidHexValueError = class extends BaseError3 {\\n    constructor(value) {\\n      super(`Value \\\\`${value}\\\\` is an invalid hex value.`, {\\n        metaMessages: [\\n          \\'Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).\\'\\n        ]\\n      });\\n      Object.defineProperty(this, \"name\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: \"Hex.InvalidHexValueError\"\\n      });\\n    }\\n  };\\n  var SizeOverflowError3 = class extends BaseError3 {\\n    constructor({ givenSize, maxSize }) {\\n      super(`Size cannot exceed \\\\`${maxSize}\\\\` bytes. Given size: \\\\`${givenSize}\\\\` bytes.`);\\n      Object.defineProperty(this, \"name\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: \"Hex.SizeOverflowError\"\\n      });\\n    }\\n  };\\n  var SliceOffsetOutOfBoundsError3 = class extends BaseError3 {\\n    constructor({ offset, position, size: size5 }) {\\n      super(`Slice ${position === \"start\" ? \"starting\" : \"ending\"} at offset \\\\`${offset}\\\\` is out-of-bounds (size: \\\\`${size5}\\\\`).`);\\n      Object.defineProperty(this, \"name\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: \"Hex.SliceOffsetOutOfBoundsError\"\\n      });\\n    }\\n  };\\n  var SizeExceedsPaddingSizeError3 = class extends BaseError3 {\\n    constructor({ size: size5, targetSize, type }) {\\n      super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\\\\`${size5}\\\\`) exceeds padding size (\\\\`${targetSize}\\\\`).`);\\n      Object.defineProperty(this, \"name\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: \"Hex.SizeExceedsPaddingSizeError\"\\n      });\\n    }\\n  };\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/ox@0.6.9_typescript@5.8.3_zod@3.24.3/node_modules/ox/_esm/core/Withdrawal.js\\n  function toRpc(withdrawal) {\\n    return {\\n      address: withdrawal.address,\\n      amount: fromNumber(withdrawal.amount),\\n      index: fromNumber(withdrawal.index),\\n      validatorIndex: fromNumber(withdrawal.validatorIndex)\\n    };\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/ox@0.6.9_typescript@5.8.3_zod@3.24.3/node_modules/ox/_esm/core/BlockOverrides.js\\n  function toRpc2(blockOverrides) {\\n    return {\\n      ...typeof blockOverrides.baseFeePerGas === \"bigint\" && {\\n        baseFeePerGas: fromNumber(blockOverrides.baseFeePerGas)\\n      },\\n      ...typeof blockOverrides.blobBaseFee === \"bigint\" && {\\n        blobBaseFee: fromNumber(blockOverrides.blobBaseFee)\\n      },\\n      ...typeof blockOverrides.feeRecipient === \"string\" && {\\n        feeRecipient: blockOverrides.feeRecipient\\n      },\\n      ...typeof blockOverrides.gasLimit === \"bigint\" && {\\n        gasLimit: fromNumber(blockOverrides.gasLimit)\\n      },\\n      ...typeof blockOverrides.number === \"bigint\" && {\\n        number: fromNumber(blockOverrides.number)\\n      },\\n      ...typeof blockOverrides.prevRandao === \"bigint\" && {\\n        prevRandao: fromNumber(blockOverrides.prevRandao)\\n      },\\n      ...typeof blockOverrides.time === \"bigint\" && {\\n        time: fromNumber(blockOverrides.time)\\n      },\\n      ...blockOverrides.withdrawals && {\\n        withdrawals: blockOverrides.withdrawals.map(toRpc)\\n      }\\n    };\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/simulateBlocks.js\\n  init_parseAccount();\\n  init_abi();\\n  init_contract();\\n  init_node();\\n  init_decodeFunctionResult();\\n  init_encodeFunctionData();\\n  init_toHex();\\n  init_getNodeError();\\n  init_transactionRequest();\\n  init_stateOverride2();\\n  init_assertRequest();\\n  async function simulateBlocks(client, parameters) {\\n    const { blockNumber, blockTag = \"latest\", blocks, returnFullTransactions, traceTransfers, validation } = parameters;\\n    try {\\n      const blockStateCalls = [];\\n      for (const block2 of blocks) {\\n        const blockOverrides = block2.blockOverrides ? toRpc2(block2.blockOverrides) : void 0;\\n        const calls = block2.calls.map((call_) => {\\n          const call2 = call_;\\n          const account = call2.account ? parseAccount(call2.account) : void 0;\\n          const request = {\\n            ...call2,\\n            data: call2.abi ? encodeFunctionData(call2) : call2.data,\\n            from: call2.from ?? account?.address\\n          };\\n          assertRequest(request);\\n          return formatTransactionRequest(request);\\n        });\\n        const stateOverrides = block2.stateOverrides ? serializeStateOverride(block2.stateOverrides) : void 0;\\n        blockStateCalls.push({\\n          blockOverrides,\\n          calls,\\n          stateOverrides\\n        });\\n      }\\n      const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;\\n      const block = blockNumberHex || blockTag;\\n      const result = await client.request({\\n        method: \"eth_simulateV1\",\\n        params: [\\n          { blockStateCalls, returnFullTransactions, traceTransfers, validation },\\n          block\\n        ]\\n      });\\n      return result.map((block2, i) => ({\\n        ...formatBlock(block2),\\n        calls: block2.calls.map((call2, j) => {\\n          const { abi: abi2, args, functionName, to } = blocks[i].calls[j];\\n          const data = call2.error?.data ?? call2.returnData;\\n          const gasUsed = BigInt(call2.gasUsed);\\n          const logs = call2.logs?.map((log) => formatLog(log));\\n          const status = call2.status === \"0x1\" ? \"success\" : \"failure\";\\n          const result2 = abi2 && status === \"success\" && data !== \"0x\" ? decodeFunctionResult({\\n            abi: abi2,\\n            data,\\n            functionName\\n          }) : null;\\n          const error = (() => {\\n            if (status === \"success\")\\n              return void 0;\\n            let error2 = void 0;\\n            if (call2.error?.data === \"0x\")\\n              error2 = new AbiDecodingZeroDataError();\\n            else if (call2.error)\\n              error2 = new RawContractError(call2.error);\\n            if (!error2)\\n              return void 0;\\n            return getContractError(error2, {\\n              abi: abi2 ?? [],\\n              address: to,\\n              args,\\n              functionName: functionName ?? \"<unknown>\"\\n            });\\n          })();\\n          return {\\n            data,\\n            gasUsed,\\n            logs,\\n            status,\\n            ...status === \"success\" ? {\\n              result: result2\\n            } : {\\n              error\\n            }\\n          };\\n        })\\n      }));\\n    } catch (e) {\\n      const cause = e;\\n      const error = getNodeError(cause, {});\\n      if (error instanceof UnknownNodeError)\\n        throw cause;\\n      throw error;\\n    }\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/ox@0.6.9_typescript@5.8.3_zod@3.24.3/node_modules/ox/_esm/core/AbiItem.js\\n  init_exports();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/@noble+hashes@1.7.2/node_modules/@noble/hashes/esm/_assert.js\\n  function anumber2(n) {\\n    if (!Number.isSafeInteger(n) || n < 0)\\n      throw new Error(\"positive integer expected, got \" + n);\\n  }\\n  function isBytes3(a) {\\n    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === \"Uint8Array\";\\n  }\\n  function abytes3(b, ...lengths) {\\n    if (!isBytes3(b))\\n      throw new Error(\"Uint8Array expected\");\\n    if (lengths.length > 0 && !lengths.includes(b.length))\\n      throw new Error(\"Uint8Array expected of length \" + lengths + \", got length=\" + b.length);\\n  }\\n  function aexists2(instance, checkFinished = true) {\\n    if (instance.destroyed)\\n      throw new Error(\"Hash instance has been destroyed\");\\n    if (checkFinished && instance.finished)\\n      throw new Error(\"Hash#digest() has already been called\");\\n  }\\n  function aoutput2(out, instance) {\\n    abytes3(out);\\n    const min = instance.outputLen;\\n    if (out.length < min) {\\n      throw new Error(\"digestInto() expects output buffer of length at least \" + min);\\n    }\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/@noble+hashes@1.7.2/node_modules/@noble/hashes/esm/utils.js\\n  function u322(arr) {\\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\\n  }\\n  var isLE2 = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();\\n  function byteSwap2(word) {\\n    return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;\\n  }\\n  function byteSwap322(arr) {\\n    for (let i = 0; i < arr.length; i++) {\\n      arr[i] = byteSwap2(arr[i]);\\n    }\\n  }\\n  var hasHexBuiltin = (\\n    // @ts-ignore\\n    typeof Uint8Array.from([]).toHex === \"function\" && typeof Uint8Array.fromHex === \"function\"\\n  );\\n  function utf8ToBytes3(str) {\\n    if (typeof str !== \"string\")\\n      throw new Error(\"utf8ToBytes expected string, got \" + typeof str);\\n    return new Uint8Array(new TextEncoder().encode(str));\\n  }\\n  function toBytes3(data) {\\n    if (typeof data === \"string\")\\n      data = utf8ToBytes3(data);\\n    abytes3(data);\\n    return data;\\n  }\\n  var Hash2 = class {\\n    // Safe version that clones internal state\\n    clone() {\\n      return this._cloneInto();\\n    }\\n  };\\n  function wrapConstructor2(hashCons) {\\n    const hashC = (msg) => hashCons().update(toBytes3(msg)).digest();\\n    const tmp = hashCons();\\n    hashC.outputLen = tmp.outputLen;\\n    hashC.blockLen = tmp.blockLen;\\n    hashC.create = () => hashCons();\\n    return hashC;\\n  }\\n  function wrapXOFConstructorWithOpts2(hashCons) {\\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes3(msg)).digest();\\n    const tmp = hashCons({});\\n    hashC.outputLen = tmp.outputLen;\\n    hashC.blockLen = tmp.blockLen;\\n    hashC.create = (opts) => hashCons(opts);\\n    return hashC;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/@noble+hashes@1.7.2/node_modules/@noble/hashes/esm/_u64.js\\n  var U32_MASK642 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\\n  var _32n2 = /* @__PURE__ */ BigInt(32);\\n  function fromBig2(n, le = false) {\\n    if (le)\\n      return { h: Number(n & U32_MASK642), l: Number(n >> _32n2 & U32_MASK642) };\\n    return { h: Number(n >> _32n2 & U32_MASK642) | 0, l: Number(n & U32_MASK642) | 0 };\\n  }\\n  function split2(lst, le = false) {\\n    let Ah = new Uint32Array(lst.length);\\n    let Al = new Uint32Array(lst.length);\\n    for (let i = 0; i < lst.length; i++) {\\n      const { h, l } = fromBig2(lst[i], le);\\n      [Ah[i], Al[i]] = [h, l];\\n    }\\n    return [Ah, Al];\\n  }\\n  var rotlSH2 = (h, l, s) => h << s | l >>> 32 - s;\\n  var rotlSL2 = (h, l, s) => l << s | h >>> 32 - s;\\n  var rotlBH2 = (h, l, s) => l << s - 32 | h >>> 64 - s;\\n  var rotlBL2 = (h, l, s) => h << s - 32 | l >>> 64 - s;\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/@noble+hashes@1.7.2/node_modules/@noble/hashes/esm/sha3.js\\n  var SHA3_PI2 = [];\\n  var SHA3_ROTL2 = [];\\n  var _SHA3_IOTA2 = [];\\n  var _0n7 = /* @__PURE__ */ BigInt(0);\\n  var _1n7 = /* @__PURE__ */ BigInt(1);\\n  var _2n6 = /* @__PURE__ */ BigInt(2);\\n  var _7n2 = /* @__PURE__ */ BigInt(7);\\n  var _256n2 = /* @__PURE__ */ BigInt(256);\\n  var _0x71n2 = /* @__PURE__ */ BigInt(113);\\n  for (let round = 0, R = _1n7, x = 1, y = 0; round < 24; round++) {\\n    [x, y] = [y, (2 * x + 3 * y) % 5];\\n    SHA3_PI2.push(2 * (5 * y + x));\\n    SHA3_ROTL2.push((round + 1) * (round + 2) / 2 % 64);\\n    let t = _0n7;\\n    for (let j = 0; j < 7; j++) {\\n      R = (R << _1n7 ^ (R >> _7n2) * _0x71n2) % _256n2;\\n      if (R & _2n6)\\n        t ^= _1n7 << (_1n7 << /* @__PURE__ */ BigInt(j)) - _1n7;\\n    }\\n    _SHA3_IOTA2.push(t);\\n  }\\n  var [SHA3_IOTA_H2, SHA3_IOTA_L2] = /* @__PURE__ */ split2(_SHA3_IOTA2, true);\\n  var rotlH2 = (h, l, s) => s > 32 ? rotlBH2(h, l, s) : rotlSH2(h, l, s);\\n  var rotlL2 = (h, l, s) => s > 32 ? rotlBL2(h, l, s) : rotlSL2(h, l, s);\\n  function keccakP2(s, rounds = 24) {\\n    const B = new Uint32Array(5 * 2);\\n    for (let round = 24 - rounds; round < 24; round++) {\\n      for (let x = 0; x < 10; x++)\\n        B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\\n      for (let x = 0; x < 10; x += 2) {\\n        const idx1 = (x + 8) % 10;\\n        const idx0 = (x + 2) % 10;\\n        const B0 = B[idx0];\\n        const B1 = B[idx0 + 1];\\n        const Th = rotlH2(B0, B1, 1) ^ B[idx1];\\n        const Tl = rotlL2(B0, B1, 1) ^ B[idx1 + 1];\\n        for (let y = 0; y < 50; y += 10) {\\n          s[x + y] ^= Th;\\n          s[x + y + 1] ^= Tl;\\n        }\\n      }\\n      let curH = s[2];\\n      let curL = s[3];\\n      for (let t = 0; t < 24; t++) {\\n        const shift = SHA3_ROTL2[t];\\n        const Th = rotlH2(curH, curL, shift);\\n        const Tl = rotlL2(curH, curL, shift);\\n        const PI = SHA3_PI2[t];\\n        curH = s[PI];\\n        curL = s[PI + 1];\\n        s[PI] = Th;\\n        s[PI + 1] = Tl;\\n      }\\n      for (let y = 0; y < 50; y += 10) {\\n        for (let x = 0; x < 10; x++)\\n          B[x] = s[y + x];\\n        for (let x = 0; x < 10; x++)\\n          s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\\n      }\\n      s[0] ^= SHA3_IOTA_H2[round];\\n      s[1] ^= SHA3_IOTA_L2[round];\\n    }\\n    B.fill(0);\\n  }\\n  var Keccak2 = class _Keccak extends Hash2 {\\n    // NOTE: we accept arguments in bytes instead of bits here.\\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\\n      super();\\n      this.pos = 0;\\n      this.posOut = 0;\\n      this.finished = false;\\n      this.destroyed = false;\\n      this.enableXOF = false;\\n      this.blockLen = blockLen;\\n      this.suffix = suffix;\\n      this.outputLen = outputLen;\\n      this.enableXOF = enableXOF;\\n      this.rounds = rounds;\\n      anumber2(outputLen);\\n      if (0 >= this.blockLen || this.blockLen >= 200)\\n        throw new Error(\"Sha3 supports only keccak-f1600 function\");\\n      this.state = new Uint8Array(200);\\n      this.state32 = u322(this.state);\\n    }\\n    keccak() {\\n      if (!isLE2)\\n        byteSwap322(this.state32);\\n      keccakP2(this.state32, this.rounds);\\n      if (!isLE2)\\n        byteSwap322(this.state32);\\n      this.posOut = 0;\\n      this.pos = 0;\\n    }\\n    update(data) {\\n      aexists2(this);\\n      const { blockLen, state } = this;\\n      data = toBytes3(data);\\n      const len = data.length;\\n      for (let pos = 0; pos < len; ) {\\n        const take = Math.min(blockLen - this.pos, len - pos);\\n        for (let i = 0; i < take; i++)\\n          state[this.pos++] ^= data[pos++];\\n        if (this.pos === blockLen)\\n          this.keccak();\\n      }\\n      return this;\\n    }\\n    finish() {\\n      if (this.finished)\\n        return;\\n      this.finished = true;\\n      const { state, suffix, pos, blockLen } = this;\\n      state[pos] ^= suffix;\\n      if ((suffix & 128) !== 0 && pos === blockLen - 1)\\n        this.keccak();\\n      state[blockLen - 1] ^= 128;\\n      this.keccak();\\n    }\\n    writeInto(out) {\\n      aexists2(this, false);\\n      abytes3(out);\\n      this.finish();\\n      const bufferOut = this.state;\\n      const { blockLen } = this;\\n      for (let pos = 0, len = out.length; pos < len; ) {\\n        if (this.posOut >= blockLen)\\n          this.keccak();\\n        const take = Math.min(blockLen - this.posOut, len - pos);\\n        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\\n        this.posOut += take;\\n        pos += take;\\n      }\\n      return out;\\n    }\\n    xofInto(out) {\\n      if (!this.enableXOF)\\n        throw new Error(\"XOF is not possible for this instance\");\\n      return this.writeInto(out);\\n    }\\n    xof(bytes) {\\n      anumber2(bytes);\\n      return this.xofInto(new Uint8Array(bytes));\\n    }\\n    digestInto(out) {\\n      aoutput2(out, this);\\n      if (this.finished)\\n        throw new Error(\"digest() was already called\");\\n      this.writeInto(out);\\n      this.destroy();\\n      return out;\\n    }\\n    digest() {\\n      return this.digestInto(new Uint8Array(this.outputLen));\\n    }\\n    destroy() {\\n      this.destroyed = true;\\n      this.state.fill(0);\\n    }\\n    _cloneInto(to) {\\n      const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\\n      to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\\n      to.state32.set(this.state32);\\n      to.pos = this.pos;\\n      to.posOut = this.posOut;\\n      to.finished = this.finished;\\n      to.rounds = rounds;\\n      to.suffix = suffix;\\n      to.outputLen = outputLen;\\n      to.enableXOF = enableXOF;\\n      to.destroyed = this.destroyed;\\n      return to;\\n    }\\n  };\\n  var gen2 = (suffix, blockLen, outputLen) => wrapConstructor2(() => new Keccak2(blockLen, suffix, outputLen));\\n  var sha3_2242 = /* @__PURE__ */ gen2(6, 144, 224 / 8);\\n  var sha3_2562 = /* @__PURE__ */ gen2(6, 136, 256 / 8);\\n  var sha3_3842 = /* @__PURE__ */ gen2(6, 104, 384 / 8);\\n  var sha3_5122 = /* @__PURE__ */ gen2(6, 72, 512 / 8);\\n  var keccak_2242 = /* @__PURE__ */ gen2(1, 144, 224 / 8);\\n  var keccak_2562 = /* @__PURE__ */ gen2(1, 136, 256 / 8);\\n  var keccak_3842 = /* @__PURE__ */ gen2(1, 104, 384 / 8);\\n  var keccak_5122 = /* @__PURE__ */ gen2(1, 72, 512 / 8);\\n  var genShake2 = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts2((opts = {}) => new Keccak2(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));\\n  var shake1282 = /* @__PURE__ */ genShake2(31, 168, 128 / 8);\\n  var shake2562 = /* @__PURE__ */ genShake2(31, 136, 256 / 8);\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/ox@0.6.9_typescript@5.8.3_zod@3.24.3/node_modules/ox/_esm/core/Hash.js\\n  function keccak2562(value, options = {}) {\\n    const { as = typeof value === \"string\" ? \"Hex\" : \"Bytes\" } = options;\\n    const bytes = keccak_2562(from(value));\\n    if (as === \"Bytes\")\\n      return bytes;\\n    return fromBytes(bytes);\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/ox@0.6.9_typescript@5.8.3_zod@3.24.3/node_modules/ox/_esm/core/internal/lru.js\\n  var LruMap2 = class extends Map {\\n    constructor(size5) {\\n      super();\\n      Object.defineProperty(this, \"maxSize\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: void 0\\n      });\\n      this.maxSize = size5;\\n    }\\n    get(key) {\\n      const value = super.get(key);\\n      if (super.has(key) && value !== void 0) {\\n        this.delete(key);\\n        super.set(key, value);\\n      }\\n      return value;\\n    }\\n    set(key, value) {\\n      super.set(key, value);\\n      if (this.maxSize && this.size > this.maxSize) {\\n        const firstKey = this.keys().next().value;\\n        if (firstKey)\\n          this.delete(firstKey);\\n      }\\n      return this;\\n    }\\n  };\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/ox@0.6.9_typescript@5.8.3_zod@3.24.3/node_modules/ox/_esm/core/Caches.js\\n  var caches = {\\n    checksum: /* @__PURE__ */ new LruMap2(8192)\\n  };\\n  var checksum = caches.checksum;\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/ox@0.6.9_typescript@5.8.3_zod@3.24.3/node_modules/ox/_esm/core/Address.js\\n  var addressRegex2 = /^0x[a-fA-F0-9]{40}$/;\\n  function assert2(value, options = {}) {\\n    const { strict = true } = options;\\n    if (!addressRegex2.test(value))\\n      throw new InvalidAddressError2({\\n        address: value,\\n        cause: new InvalidInputError()\\n      });\\n    if (strict) {\\n      if (value.toLowerCase() === value)\\n        return;\\n      if (checksum2(value) !== value)\\n        throw new InvalidAddressError2({\\n          address: value,\\n          cause: new InvalidChecksumError()\\n        });\\n    }\\n  }\\n  function checksum2(address) {\\n    if (checksum.has(address))\\n      return checksum.get(address);\\n    assert2(address, { strict: false });\\n    const hexAddress = address.substring(2).toLowerCase();\\n    const hash2 = keccak2562(fromString(hexAddress), { as: \"Bytes\" });\\n    const characters = hexAddress.split(\"\");\\n    for (let i = 0; i < 40; i += 2) {\\n      if (hash2[i >> 1] >> 4 >= 8 && characters[i]) {\\n        characters[i] = characters[i].toUpperCase();\\n      }\\n      if ((hash2[i >> 1] & 15) >= 8 && characters[i + 1]) {\\n        characters[i + 1] = characters[i + 1].toUpperCase();\\n      }\\n    }\\n    const result = `0x${characters.join(\"\")}`;\\n    checksum.set(address, result);\\n    return result;\\n  }\\n  function validate2(address, options = {}) {\\n    const { strict = true } = options ?? {};\\n    try {\\n      assert2(address, { strict });\\n      return true;\\n    } catch {\\n      return false;\\n    }\\n  }\\n  var InvalidAddressError2 = class extends BaseError3 {\\n    constructor({ address, cause }) {\\n      super(`Address \"${address}\" is invalid.`, {\\n        cause\\n      });\\n      Object.defineProperty(this, \"name\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: \"Address.InvalidAddressError\"\\n      });\\n    }\\n  };\\n  var InvalidInputError = class extends BaseError3 {\\n    constructor() {\\n      super(\"Address is not a 20 byte (40 hexadecimal character) value.\");\\n      Object.defineProperty(this, \"name\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: \"Address.InvalidInputError\"\\n      });\\n    }\\n  };\\n  var InvalidChecksumError = class extends BaseError3 {\\n    constructor() {\\n      super(\"Address does not match its checksum counterpart.\");\\n      Object.defineProperty(this, \"name\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: \"Address.InvalidChecksumError\"\\n      });\\n    }\\n  };\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/ox@0.6.9_typescript@5.8.3_zod@3.24.3/node_modules/ox/_esm/core/internal/abiItem.js\\n  function normalizeSignature2(signature) {\\n    let active = true;\\n    let current = \"\";\\n    let level = 0;\\n    let result = \"\";\\n    let valid = false;\\n    for (let i = 0; i < signature.length; i++) {\\n      const char = signature[i];\\n      if ([\"(\", \")\", \",\"].includes(char))\\n        active = true;\\n      if (char === \"(\")\\n        level++;\\n      if (char === \")\")\\n        level--;\\n      if (!active)\\n        continue;\\n      if (level === 0) {\\n        if (char === \" \" && [\"event\", \"function\", \"error\", \"\"].includes(result))\\n          result = \"\";\\n        else {\\n          result += char;\\n          if (char === \")\") {\\n            valid = true;\\n            break;\\n          }\\n        }\\n        continue;\\n      }\\n      if (char === \" \") {\\n        if (signature[i - 1] !== \",\" && current !== \",\" && current !== \",(\") {\\n          current = \"\";\\n          active = false;\\n        }\\n        continue;\\n      }\\n      result += char;\\n      current += char;\\n    }\\n    if (!valid)\\n      throw new BaseError3(\"Unable to normalize signature.\");\\n    return result;\\n  }\\n  function isArgOfType2(arg, abiParameter) {\\n    const argType = typeof arg;\\n    const abiParameterType = abiParameter.type;\\n    switch (abiParameterType) {\\n      case \"address\":\\n        return validate2(arg, { strict: false });\\n      case \"bool\":\\n        return argType === \"boolean\";\\n      case \"function\":\\n        return argType === \"string\";\\n      case \"string\":\\n        return argType === \"string\";\\n      default: {\\n        if (abiParameterType === \"tuple\" && \"components\" in abiParameter)\\n          return Object.values(abiParameter.components).every((component, index2) => {\\n            return isArgOfType2(Object.values(arg)[index2], component);\\n          });\\n        if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))\\n          return argType === \"number\" || argType === \"bigint\";\\n        if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\\n          return argType === \"string\" || arg instanceof Uint8Array;\\n        if (/[a-z]+[1-9]{0,3}(\\\\[[0-9]{0,}\\\\])+$/.test(abiParameterType)) {\\n          return Array.isArray(arg) && arg.every((x) => isArgOfType2(x, {\\n            ...abiParameter,\\n            // Pop off `[]` or `[M]` from end of type\\n            type: abiParameterType.replace(/(\\\\[[0-9]{0,}\\\\])$/, \"\")\\n          }));\\n        }\\n        return false;\\n      }\\n    }\\n  }\\n  function getAmbiguousTypes2(sourceParameters, targetParameters, args) {\\n    for (const parameterIndex in sourceParameters) {\\n      const sourceParameter = sourceParameters[parameterIndex];\\n      const targetParameter = targetParameters[parameterIndex];\\n      if (sourceParameter.type === \"tuple\" && targetParameter.type === \"tuple\" && \"components\" in sourceParameter && \"components\" in targetParameter)\\n        return getAmbiguousTypes2(sourceParameter.components, targetParameter.components, args[parameterIndex]);\\n      const types = [sourceParameter.type, targetParameter.type];\\n      const ambiguous = (() => {\\n        if (types.includes(\"address\") && types.includes(\"bytes20\"))\\n          return true;\\n        if (types.includes(\"address\") && types.includes(\"string\"))\\n          return validate2(args[parameterIndex], {\\n            strict: false\\n          });\\n        if (types.includes(\"address\") && types.includes(\"bytes\"))\\n          return validate2(args[parameterIndex], {\\n            strict: false\\n          });\\n        return false;\\n      })();\\n      if (ambiguous)\\n        return types;\\n    }\\n    return;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/ox@0.6.9_typescript@5.8.3_zod@3.24.3/node_modules/ox/_esm/core/AbiItem.js\\n  function from2(abiItem, options = {}) {\\n    const { prepare = true } = options;\\n    const item = (() => {\\n      if (Array.isArray(abiItem))\\n        return parseAbiItem(abiItem);\\n      if (typeof abiItem === \"string\")\\n        return parseAbiItem(abiItem);\\n      return abiItem;\\n    })();\\n    return {\\n      ...item,\\n      ...prepare ? { hash: getSignatureHash(item) } : {}\\n    };\\n  }\\n  function fromAbi(abi2, name, options) {\\n    const { args = [], prepare = true } = options ?? {};\\n    const isSelector = validate(name, { strict: false });\\n    const abiItems = abi2.filter((abiItem2) => {\\n      if (isSelector) {\\n        if (abiItem2.type === \"function\" || abiItem2.type === \"error\")\\n          return getSelector(abiItem2) === slice2(name, 0, 4);\\n        if (abiItem2.type === \"event\")\\n          return getSignatureHash(abiItem2) === name;\\n        return false;\\n      }\\n      return \"name\" in abiItem2 && abiItem2.name === name;\\n    });\\n    if (abiItems.length === 0)\\n      throw new NotFoundError({ name });\\n    if (abiItems.length === 1)\\n      return {\\n        ...abiItems[0],\\n        ...prepare ? { hash: getSignatureHash(abiItems[0]) } : {}\\n      };\\n    let matchedAbiItem = void 0;\\n    for (const abiItem2 of abiItems) {\\n      if (!(\"inputs\" in abiItem2))\\n        continue;\\n      if (!args || args.length === 0) {\\n        if (!abiItem2.inputs || abiItem2.inputs.length === 0)\\n          return {\\n            ...abiItem2,\\n            ...prepare ? { hash: getSignatureHash(abiItem2) } : {}\\n          };\\n        continue;\\n      }\\n      if (!abiItem2.inputs)\\n        continue;\\n      if (abiItem2.inputs.length === 0)\\n        continue;\\n      if (abiItem2.inputs.length !== args.length)\\n        continue;\\n      const matched = args.every((arg, index2) => {\\n        const abiParameter = \"inputs\" in abiItem2 && abiItem2.inputs[index2];\\n        if (!abiParameter)\\n          return false;\\n        return isArgOfType2(arg, abiParameter);\\n      });\\n      if (matched) {\\n        if (matchedAbiItem && \"inputs\" in matchedAbiItem && matchedAbiItem.inputs) {\\n          const ambiguousTypes = getAmbiguousTypes2(abiItem2.inputs, matchedAbiItem.inputs, args);\\n          if (ambiguousTypes)\\n            throw new AmbiguityError({\\n              abiItem: abiItem2,\\n              type: ambiguousTypes[0]\\n            }, {\\n              abiItem: matchedAbiItem,\\n              type: ambiguousTypes[1]\\n            });\\n        }\\n        matchedAbiItem = abiItem2;\\n      }\\n    }\\n    const abiItem = (() => {\\n      if (matchedAbiItem)\\n        return matchedAbiItem;\\n      const [abiItem2, ...overloads] = abiItems;\\n      return { ...abiItem2, overloads };\\n    })();\\n    if (!abiItem)\\n      throw new NotFoundError({ name });\\n    return {\\n      ...abiItem,\\n      ...prepare ? { hash: getSignatureHash(abiItem) } : {}\\n    };\\n  }\\n  function getSelector(abiItem) {\\n    return slice2(getSignatureHash(abiItem), 0, 4);\\n  }\\n  function getSignature(abiItem) {\\n    const signature = (() => {\\n      if (typeof abiItem === \"string\")\\n        return abiItem;\\n      return formatAbiItem(abiItem);\\n    })();\\n    return normalizeSignature2(signature);\\n  }\\n  function getSignatureHash(abiItem) {\\n    if (typeof abiItem !== \"string\" && \"hash\" in abiItem && abiItem.hash)\\n      return abiItem.hash;\\n    return keccak2562(fromString2(getSignature(abiItem)));\\n  }\\n  var AmbiguityError = class extends BaseError3 {\\n    constructor(x, y) {\\n      super(\"Found ambiguous types in overloaded ABI Items.\", {\\n        metaMessages: [\\n          // TODO: abitype to add support for signature-formatted ABI items.\\n          `\\\\`${x.type}\\\\` in \\\\`${normalizeSignature2(formatAbiItem(x.abiItem))}\\\\`, and`,\\n          `\\\\`${y.type}\\\\` in \\\\`${normalizeSignature2(formatAbiItem(y.abiItem))}\\\\``,\\n          \"\",\\n          \"These types encode differently and cannot be distinguished at runtime.\",\\n          \"Remove one of the ambiguous items in the ABI.\"\\n        ]\\n      });\\n      Object.defineProperty(this, \"name\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: \"AbiItem.AmbiguityError\"\\n      });\\n    }\\n  };\\n  var NotFoundError = class extends BaseError3 {\\n    constructor({ name, data, type = \"item\" }) {\\n      const selector = (() => {\\n        if (name)\\n          return ` with name \"${name}\"`;\\n        if (data)\\n          return ` with data \"${data}\"`;\\n        return \"\";\\n      })();\\n      super(`ABI ${type}${selector} not found.`);\\n      Object.defineProperty(this, \"name\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: \"AbiItem.NotFoundError\"\\n      });\\n    }\\n  };\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/ox@0.6.9_typescript@5.8.3_zod@3.24.3/node_modules/ox/_esm/core/Solidity.js\\n  var arrayRegex = /^(.*)\\\\[([0-9]*)\\\\]$/;\\n  var bytesRegex3 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\\n  var integerRegex3 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\\n  var maxInt82 = 2n ** (8n - 1n) - 1n;\\n  var maxInt162 = 2n ** (16n - 1n) - 1n;\\n  var maxInt242 = 2n ** (24n - 1n) - 1n;\\n  var maxInt322 = 2n ** (32n - 1n) - 1n;\\n  var maxInt402 = 2n ** (40n - 1n) - 1n;\\n  var maxInt482 = 2n ** (48n - 1n) - 1n;\\n  var maxInt562 = 2n ** (56n - 1n) - 1n;\\n  var maxInt642 = 2n ** (64n - 1n) - 1n;\\n  var maxInt722 = 2n ** (72n - 1n) - 1n;\\n  var maxInt802 = 2n ** (80n - 1n) - 1n;\\n  var maxInt882 = 2n ** (88n - 1n) - 1n;\\n  var maxInt962 = 2n ** (96n - 1n) - 1n;\\n  var maxInt1042 = 2n ** (104n - 1n) - 1n;\\n  var maxInt1122 = 2n ** (112n - 1n) - 1n;\\n  var maxInt1202 = 2n ** (120n - 1n) - 1n;\\n  var maxInt1282 = 2n ** (128n - 1n) - 1n;\\n  var maxInt1362 = 2n ** (136n - 1n) - 1n;\\n  var maxInt1442 = 2n ** (144n - 1n) - 1n;\\n  var maxInt1522 = 2n ** (152n - 1n) - 1n;\\n  var maxInt1602 = 2n ** (160n - 1n) - 1n;\\n  var maxInt1682 = 2n ** (168n - 1n) - 1n;\\n  var maxInt1762 = 2n ** (176n - 1n) - 1n;\\n  var maxInt1842 = 2n ** (184n - 1n) - 1n;\\n  var maxInt1922 = 2n ** (192n - 1n) - 1n;\\n  var maxInt2002 = 2n ** (200n - 1n) - 1n;\\n  var maxInt2082 = 2n ** (208n - 1n) - 1n;\\n  var maxInt2162 = 2n ** (216n - 1n) - 1n;\\n  var maxInt2242 = 2n ** (224n - 1n) - 1n;\\n  var maxInt2322 = 2n ** (232n - 1n) - 1n;\\n  var maxInt2402 = 2n ** (240n - 1n) - 1n;\\n  var maxInt2482 = 2n ** (248n - 1n) - 1n;\\n  var maxInt2562 = 2n ** (256n - 1n) - 1n;\\n  var minInt82 = -(2n ** (8n - 1n));\\n  var minInt162 = -(2n ** (16n - 1n));\\n  var minInt242 = -(2n ** (24n - 1n));\\n  var minInt322 = -(2n ** (32n - 1n));\\n  var minInt402 = -(2n ** (40n - 1n));\\n  var minInt482 = -(2n ** (48n - 1n));\\n  var minInt562 = -(2n ** (56n - 1n));\\n  var minInt642 = -(2n ** (64n - 1n));\\n  var minInt722 = -(2n ** (72n - 1n));\\n  var minInt802 = -(2n ** (80n - 1n));\\n  var minInt882 = -(2n ** (88n - 1n));\\n  var minInt962 = -(2n ** (96n - 1n));\\n  var minInt1042 = -(2n ** (104n - 1n));\\n  var minInt1122 = -(2n ** (112n - 1n));\\n  var minInt1202 = -(2n ** (120n - 1n));\\n  var minInt1282 = -(2n ** (128n - 1n));\\n  var minInt1362 = -(2n ** (136n - 1n));\\n  var minInt1442 = -(2n ** (144n - 1n));\\n  var minInt1522 = -(2n ** (152n - 1n));\\n  var minInt1602 = -(2n ** (160n - 1n));\\n  var minInt1682 = -(2n ** (168n - 1n));\\n  var minInt1762 = -(2n ** (176n - 1n));\\n  var minInt1842 = -(2n ** (184n - 1n));\\n  var minInt1922 = -(2n ** (192n - 1n));\\n  var minInt2002 = -(2n ** (200n - 1n));\\n  var minInt2082 = -(2n ** (208n - 1n));\\n  var minInt2162 = -(2n ** (216n - 1n));\\n  var minInt2242 = -(2n ** (224n - 1n));\\n  var minInt2322 = -(2n ** (232n - 1n));\\n  var minInt2402 = -(2n ** (240n - 1n));\\n  var minInt2482 = -(2n ** (248n - 1n));\\n  var minInt2562 = -(2n ** (256n - 1n));\\n  var maxUint82 = 2n ** 8n - 1n;\\n  var maxUint162 = 2n ** 16n - 1n;\\n  var maxUint242 = 2n ** 24n - 1n;\\n  var maxUint322 = 2n ** 32n - 1n;\\n  var maxUint402 = 2n ** 40n - 1n;\\n  var maxUint482 = 2n ** 48n - 1n;\\n  var maxUint562 = 2n ** 56n - 1n;\\n  var maxUint642 = 2n ** 64n - 1n;\\n  var maxUint722 = 2n ** 72n - 1n;\\n  var maxUint802 = 2n ** 80n - 1n;\\n  var maxUint882 = 2n ** 88n - 1n;\\n  var maxUint962 = 2n ** 96n - 1n;\\n  var maxUint1042 = 2n ** 104n - 1n;\\n  var maxUint1122 = 2n ** 112n - 1n;\\n  var maxUint1202 = 2n ** 120n - 1n;\\n  var maxUint1282 = 2n ** 128n - 1n;\\n  var maxUint1362 = 2n ** 136n - 1n;\\n  var maxUint1442 = 2n ** 144n - 1n;\\n  var maxUint1522 = 2n ** 152n - 1n;\\n  var maxUint1602 = 2n ** 160n - 1n;\\n  var maxUint1682 = 2n ** 168n - 1n;\\n  var maxUint1762 = 2n ** 176n - 1n;\\n  var maxUint1842 = 2n ** 184n - 1n;\\n  var maxUint1922 = 2n ** 192n - 1n;\\n  var maxUint2002 = 2n ** 200n - 1n;\\n  var maxUint2082 = 2n ** 208n - 1n;\\n  var maxUint2162 = 2n ** 216n - 1n;\\n  var maxUint2242 = 2n ** 224n - 1n;\\n  var maxUint2322 = 2n ** 232n - 1n;\\n  var maxUint2402 = 2n ** 240n - 1n;\\n  var maxUint2482 = 2n ** 248n - 1n;\\n  var maxUint2562 = 2n ** 256n - 1n;\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/ox@0.6.9_typescript@5.8.3_zod@3.24.3/node_modules/ox/_esm/core/internal/abiParameters.js\\n  function prepareParameters({ checksumAddress: checksumAddress2, parameters, values }) {\\n    const preparedParameters = [];\\n    for (let i = 0; i < parameters.length; i++) {\\n      preparedParameters.push(prepareParameter({\\n        checksumAddress: checksumAddress2,\\n        parameter: parameters[i],\\n        value: values[i]\\n      }));\\n    }\\n    return preparedParameters;\\n  }\\n  function prepareParameter({ checksumAddress: checksumAddress2 = false, parameter: parameter_, value }) {\\n    const parameter = parameter_;\\n    const arrayComponents = getArrayComponents2(parameter.type);\\n    if (arrayComponents) {\\n      const [length, type] = arrayComponents;\\n      return encodeArray2(value, {\\n        checksumAddress: checksumAddress2,\\n        length,\\n        parameter: {\\n          ...parameter,\\n          type\\n        }\\n      });\\n    }\\n    if (parameter.type === \"tuple\") {\\n      return encodeTuple2(value, {\\n        checksumAddress: checksumAddress2,\\n        parameter\\n      });\\n    }\\n    if (parameter.type === \"address\") {\\n      return encodeAddress2(value, {\\n        checksum: checksumAddress2\\n      });\\n    }\\n    if (parameter.type === \"bool\") {\\n      return encodeBoolean(value);\\n    }\\n    if (parameter.type.startsWith(\"uint\") || parameter.type.startsWith(\"int\")) {\\n      const signed = parameter.type.startsWith(\"int\");\\n      const [, , size5 = \"256\"] = integerRegex3.exec(parameter.type) ?? [];\\n      return encodeNumber2(value, {\\n        signed,\\n        size: Number(size5)\\n      });\\n    }\\n    if (parameter.type.startsWith(\"bytes\")) {\\n      return encodeBytes2(value, { type: parameter.type });\\n    }\\n    if (parameter.type === \"string\") {\\n      return encodeString2(value);\\n    }\\n    throw new InvalidTypeError(parameter.type);\\n  }\\n  function encode(preparedParameters) {\\n    let staticSize = 0;\\n    for (let i = 0; i < preparedParameters.length; i++) {\\n      const { dynamic, encoded } = preparedParameters[i];\\n      if (dynamic)\\n        staticSize += 32;\\n      else\\n        staticSize += size4(encoded);\\n    }\\n    const staticParameters = [];\\n    const dynamicParameters = [];\\n    let dynamicSize = 0;\\n    for (let i = 0; i < preparedParameters.length; i++) {\\n      const { dynamic, encoded } = preparedParameters[i];\\n      if (dynamic) {\\n        staticParameters.push(fromNumber(staticSize + dynamicSize, { size: 32 }));\\n        dynamicParameters.push(encoded);\\n        dynamicSize += size4(encoded);\\n      } else {\\n        staticParameters.push(encoded);\\n      }\\n    }\\n    return concat2(...staticParameters, ...dynamicParameters);\\n  }\\n  function encodeAddress2(value, options) {\\n    const { checksum: checksum3 = false } = options;\\n    assert2(value, { strict: checksum3 });\\n    return {\\n      dynamic: false,\\n      encoded: padLeft(value.toLowerCase())\\n    };\\n  }\\n  function encodeArray2(value, options) {\\n    const { checksumAddress: checksumAddress2, length, parameter } = options;\\n    const dynamic = length === null;\\n    if (!Array.isArray(value))\\n      throw new InvalidArrayError2(value);\\n    if (!dynamic && value.length !== length)\\n      throw new ArrayLengthMismatchError({\\n        expectedLength: length,\\n        givenLength: value.length,\\n        type: `${parameter.type}[${length}]`\\n      });\\n    let dynamicChild = false;\\n    const preparedParameters = [];\\n    for (let i = 0; i < value.length; i++) {\\n      const preparedParam = prepareParameter({\\n        checksumAddress: checksumAddress2,\\n        parameter,\\n        value: value[i]\\n      });\\n      if (preparedParam.dynamic)\\n        dynamicChild = true;\\n      preparedParameters.push(preparedParam);\\n    }\\n    if (dynamic || dynamicChild) {\\n      const data = encode(preparedParameters);\\n      if (dynamic) {\\n        const length2 = fromNumber(preparedParameters.length, { size: 32 });\\n        return {\\n          dynamic: true,\\n          encoded: preparedParameters.length > 0 ? concat2(length2, data) : length2\\n        };\\n      }\\n      if (dynamicChild)\\n        return { dynamic: true, encoded: data };\\n    }\\n    return {\\n      dynamic: false,\\n      encoded: concat2(...preparedParameters.map(({ encoded }) => encoded))\\n    };\\n  }\\n  function encodeBytes2(value, { type }) {\\n    const [, parametersize] = type.split(\"bytes\");\\n    const bytesSize = size4(value);\\n    if (!parametersize) {\\n      let value_ = value;\\n      if (bytesSize % 32 !== 0)\\n        value_ = padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32);\\n      return {\\n        dynamic: true,\\n        encoded: concat2(padLeft(fromNumber(bytesSize, { size: 32 })), value_)\\n      };\\n    }\\n    if (bytesSize !== Number.parseInt(parametersize))\\n      throw new BytesSizeMismatchError2({\\n        expectedSize: Number.parseInt(parametersize),\\n        value\\n      });\\n    return { dynamic: false, encoded: padRight(value) };\\n  }\\n  function encodeBoolean(value) {\\n    if (typeof value !== \"boolean\")\\n      throw new BaseError3(`Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\\\`true\\\\` or \\\\`false\\\\`.`);\\n    return { dynamic: false, encoded: padLeft(fromBoolean(value)) };\\n  }\\n  function encodeNumber2(value, { signed, size: size5 }) {\\n    if (typeof size5 === \"number\") {\\n      const max = 2n ** (BigInt(size5) - (signed ? 1n : 0n)) - 1n;\\n      const min = signed ? -max - 1n : 0n;\\n      if (value > max || value < min)\\n        throw new IntegerOutOfRangeError2({\\n          max: max.toString(),\\n          min: min.toString(),\\n          signed,\\n          size: size5 / 8,\\n          value: value.toString()\\n        });\\n    }\\n    return {\\n      dynamic: false,\\n      encoded: fromNumber(value, {\\n        size: 32,\\n        signed\\n      })\\n    };\\n  }\\n  function encodeString2(value) {\\n    const hexValue = fromString2(value);\\n    const partsLength = Math.ceil(size4(hexValue) / 32);\\n    const parts = [];\\n    for (let i = 0; i < partsLength; i++) {\\n      parts.push(padRight(slice2(hexValue, i * 32, (i + 1) * 32)));\\n    }\\n    return {\\n      dynamic: true,\\n      encoded: concat2(padRight(fromNumber(size4(hexValue), { size: 32 })), ...parts)\\n    };\\n  }\\n  function encodeTuple2(value, options) {\\n    const { checksumAddress: checksumAddress2, parameter } = options;\\n    let dynamic = false;\\n    const preparedParameters = [];\\n    for (let i = 0; i < parameter.components.length; i++) {\\n      const param_ = parameter.components[i];\\n      const index2 = Array.isArray(value) ? i : param_.name;\\n      const preparedParam = prepareParameter({\\n        checksumAddress: checksumAddress2,\\n        parameter: param_,\\n        value: value[index2]\\n      });\\n      preparedParameters.push(preparedParam);\\n      if (preparedParam.dynamic)\\n        dynamic = true;\\n    }\\n    return {\\n      dynamic,\\n      encoded: dynamic ? encode(preparedParameters) : concat2(...preparedParameters.map(({ encoded }) => encoded))\\n    };\\n  }\\n  function getArrayComponents2(type) {\\n    const matches = type.match(/^(.*)\\\\[(\\\\d+)?\\\\]$/);\\n    return matches ? (\\n      // Return `null` if the array is dynamic.\\n      [matches[2] ? Number(matches[2]) : null, matches[1]]\\n    ) : void 0;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/ox@0.6.9_typescript@5.8.3_zod@3.24.3/node_modules/ox/_esm/core/AbiParameters.js\\n  function encode2(parameters, values, options) {\\n    const { checksumAddress: checksumAddress2 = false } = options ?? {};\\n    if (parameters.length !== values.length)\\n      throw new LengthMismatchError({\\n        expectedLength: parameters.length,\\n        givenLength: values.length\\n      });\\n    const preparedParameters = prepareParameters({\\n      checksumAddress: checksumAddress2,\\n      parameters,\\n      values\\n    });\\n    const data = encode(preparedParameters);\\n    if (data.length === 0)\\n      return \"0x\";\\n    return data;\\n  }\\n  function encodePacked(types, values) {\\n    if (types.length !== values.length)\\n      throw new LengthMismatchError({\\n        expectedLength: types.length,\\n        givenLength: values.length\\n      });\\n    const data = [];\\n    for (let i = 0; i < types.length; i++) {\\n      const type = types[i];\\n      const value = values[i];\\n      data.push(encodePacked.encode(type, value));\\n    }\\n    return concat2(...data);\\n  }\\n  (function(encodePacked2) {\\n    function encode4(type, value, isArray = false) {\\n      if (type === \"address\") {\\n        const address = value;\\n        assert2(address);\\n        return padLeft(address.toLowerCase(), isArray ? 32 : 0);\\n      }\\n      if (type === \"string\")\\n        return fromString2(value);\\n      if (type === \"bytes\")\\n        return value;\\n      if (type === \"bool\")\\n        return padLeft(fromBoolean(value), isArray ? 32 : 1);\\n      const intMatch = type.match(integerRegex3);\\n      if (intMatch) {\\n        const [_type, baseType, bits = \"256\"] = intMatch;\\n        const size5 = Number.parseInt(bits) / 8;\\n        return fromNumber(value, {\\n          size: isArray ? 32 : size5,\\n          signed: baseType === \"int\"\\n        });\\n      }\\n      const bytesMatch = type.match(bytesRegex3);\\n      if (bytesMatch) {\\n        const [_type, size5] = bytesMatch;\\n        if (Number.parseInt(size5) !== (value.length - 2) / 2)\\n          throw new BytesSizeMismatchError2({\\n            expectedSize: Number.parseInt(size5),\\n            value\\n          });\\n        return padRight(value, isArray ? 32 : 0);\\n      }\\n      const arrayMatch = type.match(arrayRegex);\\n      if (arrayMatch && Array.isArray(value)) {\\n        const [_type, childType] = arrayMatch;\\n        const data = [];\\n        for (let i = 0; i < value.length; i++) {\\n          data.push(encode4(childType, value[i], true));\\n        }\\n        if (data.length === 0)\\n          return \"0x\";\\n        return concat2(...data);\\n      }\\n      throw new InvalidTypeError(type);\\n    }\\n    encodePacked2.encode = encode4;\\n  })(encodePacked || (encodePacked = {}));\\n  var ArrayLengthMismatchError = class extends BaseError3 {\\n    constructor({ expectedLength, givenLength, type }) {\\n      super(`Array length mismatch for type \\\\`${type}\\\\`. Expected: \\\\`${expectedLength}\\\\`. Given: \\\\`${givenLength}\\\\`.`);\\n      Object.defineProperty(this, \"name\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: \"AbiParameters.ArrayLengthMismatchError\"\\n      });\\n    }\\n  };\\n  var BytesSizeMismatchError2 = class extends BaseError3 {\\n    constructor({ expectedSize, value }) {\\n      super(`Size of bytes \"${value}\" (bytes${size4(value)}) does not match expected size (bytes${expectedSize}).`);\\n      Object.defineProperty(this, \"name\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: \"AbiParameters.BytesSizeMismatchError\"\\n      });\\n    }\\n  };\\n  var LengthMismatchError = class extends BaseError3 {\\n    constructor({ expectedLength, givenLength }) {\\n      super([\\n        \"ABI encoding parameters/values length mismatch.\",\\n        `Expected length (parameters): ${expectedLength}`,\\n        `Given length (values): ${givenLength}`\\n      ].join(\"\\\\n\"));\\n      Object.defineProperty(this, \"name\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: \"AbiParameters.LengthMismatchError\"\\n      });\\n    }\\n  };\\n  var InvalidArrayError2 = class extends BaseError3 {\\n    constructor(value) {\\n      super(`Value \\\\`${value}\\\\` is not a valid array.`);\\n      Object.defineProperty(this, \"name\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: \"AbiParameters.InvalidArrayError\"\\n      });\\n    }\\n  };\\n  var InvalidTypeError = class extends BaseError3 {\\n    constructor(type) {\\n      super(`Type \\\\`${type}\\\\` is not a valid ABI Type.`);\\n      Object.defineProperty(this, \"name\", {\\n        enumerable: true,\\n        configurable: true,\\n        writable: true,\\n        value: \"AbiParameters.InvalidTypeError\"\\n      });\\n    }\\n  };\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/ox@0.6.9_typescript@5.8.3_zod@3.24.3/node_modules/ox/_esm/core/AbiConstructor.js\\n  function encode3(abiConstructor, options) {\\n    const { bytecode, args } = options;\\n    return concat2(bytecode, abiConstructor.inputs?.length && args?.length ? encode2(abiConstructor.inputs, args) : \"0x\");\\n  }\\n  function from3(abiConstructor) {\\n    return from2(abiConstructor);\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/ox@0.6.9_typescript@5.8.3_zod@3.24.3/node_modules/ox/_esm/core/AbiFunction.js\\n  function encodeData2(abiFunction, ...args) {\\n    const { overloads } = abiFunction;\\n    const item = overloads ? fromAbi2([abiFunction, ...overloads], abiFunction.name, {\\n      args: args[0]\\n    }) : abiFunction;\\n    const selector = getSelector2(item);\\n    const data = args.length > 0 ? encode2(item.inputs, args[0]) : void 0;\\n    return data ? concat2(selector, data) : selector;\\n  }\\n  function from4(abiFunction, options = {}) {\\n    return from2(abiFunction, options);\\n  }\\n  function fromAbi2(abi2, name, options) {\\n    const item = fromAbi(abi2, name, options);\\n    if (item.type !== \"function\")\\n      throw new NotFoundError({ name, type: \"function\" });\\n    return item;\\n  }\\n  function getSelector2(abiItem) {\\n    return getSelector(abiItem);\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/simulateCalls.js\\n  init_parseAccount();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/constants/address.js\\n  var ethAddress = \"0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\";\\n  var zeroAddress = \"0x0000000000000000000000000000000000000000\";\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/simulateCalls.js\\n  init_contracts();\\n  init_base();\\n  init_encodeFunctionData();\\n  var getBalanceCode = \"0x6080604052348015600e575f80fd5b5061016d8061001c5f395ff3fe608060405234801561000f575f80fd5b5060043610610029575f3560e01c8063f8b2cb4f1461002d575b5f80fd5b610047600480360381019061004291906100db565b61005d565b604051610054919061011e565b60405180910390f35b5f8173ffffffffffffffffffffffffffffffffffffffff16319050919050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6100aa82610081565b9050919050565b6100ba816100a0565b81146100c4575f80fd5b50565b5f813590506100d5816100b1565b92915050565b5f602082840312156100f0576100ef61007d565b5b5f6100fd848285016100c7565b91505092915050565b5f819050919050565b61011881610106565b82525050565b5f6020820190506101315f83018461010f565b9291505056fea26469706673582212203b9fe929fe995c7cf9887f0bdba8a36dd78e8b73f149b17d2d9ad7cd09d2dc6264736f6c634300081a0033\";\\n  async function simulateCalls(client, parameters) {\\n    const { blockNumber, blockTag, calls, stateOverrides, traceAssetChanges, traceTransfers, validation } = parameters;\\n    const account = parameters.account ? parseAccount(parameters.account) : void 0;\\n    if (traceAssetChanges && !account)\\n      throw new BaseError2(\"`account` is required when `traceAssetChanges` is true\");\\n    const getBalanceData = account ? encode3(from3(\"constructor(bytes, bytes)\"), {\\n      bytecode: deploylessCallViaBytecodeBytecode,\\n      args: [\\n        getBalanceCode,\\n        encodeData2(from4(\"function getBalance(address)\"), [account.address])\\n      ]\\n    }) : void 0;\\n    const assetAddresses = traceAssetChanges ? await Promise.all(parameters.calls.map(async (call2) => {\\n      if (!call2.data && !call2.abi)\\n        return;\\n      const { accessList } = await createAccessList(client, {\\n        account: account.address,\\n        ...call2,\\n        data: call2.abi ? encodeFunctionData(call2) : call2.data\\n      });\\n      return accessList.map(({ address, storageKeys }) => storageKeys.length > 0 ? address : null);\\n    })).then((x) => x.flat().filter(Boolean)) : [];\\n    const resultsStateOverrides = stateOverrides?.map((override) => {\\n      if (override.address === account?.address)\\n        return {\\n          ...override,\\n          nonce: 0\\n        };\\n      return override;\\n    });\\n    const blocks = await simulateBlocks(client, {\\n      blockNumber,\\n      blockTag,\\n      blocks: [\\n        ...traceAssetChanges ? [\\n          // ETH pre balances\\n          {\\n            calls: [{ data: getBalanceData }],\\n            stateOverrides\\n          },\\n          // Asset pre balances\\n          {\\n            calls: assetAddresses.map((address, i) => ({\\n              abi: [\\n                from4(\"function balanceOf(address) returns (uint256)\")\\n              ],\\n              functionName: \"balanceOf\",\\n              args: [account.address],\\n              to: address,\\n              from: zeroAddress,\\n              nonce: i\\n            })),\\n            stateOverrides: [\\n              {\\n                address: zeroAddress,\\n                nonce: 0\\n              }\\n            ]\\n          }\\n        ] : [],\\n        {\\n          calls: [...calls, {}].map((call2, index2) => ({\\n            ...call2,\\n            from: account?.address,\\n            nonce: index2\\n          })),\\n          stateOverrides: resultsStateOverrides\\n        },\\n        ...traceAssetChanges ? [\\n          // ETH post balances\\n          {\\n            calls: [{ data: getBalanceData }]\\n          },\\n          // Asset post balances\\n          {\\n            calls: assetAddresses.map((address, i) => ({\\n              abi: [\\n                from4(\"function balanceOf(address) returns (uint256)\")\\n              ],\\n              functionName: \"balanceOf\",\\n              args: [account.address],\\n              to: address,\\n              from: zeroAddress,\\n              nonce: i\\n            })),\\n            stateOverrides: [\\n              {\\n                address: zeroAddress,\\n                nonce: 0\\n              }\\n            ]\\n          },\\n          // Decimals\\n          {\\n            calls: assetAddresses.map((address, i) => ({\\n              to: address,\\n              abi: [\\n                from4(\"function decimals() returns (uint256)\")\\n              ],\\n              functionName: \"decimals\",\\n              from: zeroAddress,\\n              nonce: i\\n            })),\\n            stateOverrides: [\\n              {\\n                address: zeroAddress,\\n                nonce: 0\\n              }\\n            ]\\n          },\\n          // Token URI\\n          {\\n            calls: assetAddresses.map((address, i) => ({\\n              to: address,\\n              abi: [\\n                from4(\"function tokenURI(uint256) returns (string)\")\\n              ],\\n              functionName: \"tokenURI\",\\n              args: [0n],\\n              from: zeroAddress,\\n              nonce: i\\n            })),\\n            stateOverrides: [\\n              {\\n                address: zeroAddress,\\n                nonce: 0\\n              }\\n            ]\\n          },\\n          // Symbols\\n          {\\n            calls: assetAddresses.map((address, i) => ({\\n              to: address,\\n              abi: [from4(\"function symbol() returns (string)\")],\\n              functionName: \"symbol\",\\n              from: zeroAddress,\\n              nonce: i\\n            })),\\n            stateOverrides: [\\n              {\\n                address: zeroAddress,\\n                nonce: 0\\n              }\\n            ]\\n          }\\n        ] : []\\n      ],\\n      traceTransfers,\\n      validation\\n    });\\n    const block_results = traceAssetChanges ? blocks[2] : blocks[0];\\n    const [block_ethPre, block_assetsPre, , block_ethPost, block_assetsPost, block_decimals, block_tokenURI, block_symbols] = traceAssetChanges ? blocks : [];\\n    const { calls: block_calls, ...block } = block_results;\\n    const results = block_calls.slice(0, -1) ?? [];\\n    const ethPre = block_ethPre?.calls ?? [];\\n    const assetsPre = block_assetsPre?.calls ?? [];\\n    const balancesPre = [...ethPre, ...assetsPre].map((call2) => call2.status === \"success\" ? hexToBigInt(call2.data) : null);\\n    const ethPost = block_ethPost?.calls ?? [];\\n    const assetsPost = block_assetsPost?.calls ?? [];\\n    const balancesPost = [...ethPost, ...assetsPost].map((call2) => call2.status === \"success\" ? hexToBigInt(call2.data) : null);\\n    const decimals = (block_decimals?.calls ?? []).map((x) => x.status === \"success\" ? x.result : null);\\n    const symbols = (block_symbols?.calls ?? []).map((x) => x.status === \"success\" ? x.result : null);\\n    const tokenURI = (block_tokenURI?.calls ?? []).map((x) => x.status === \"success\" ? x.result : null);\\n    const changes = [];\\n    for (const [i, balancePost] of balancesPost.entries()) {\\n      const balancePre = balancesPre[i];\\n      if (typeof balancePost !== \"bigint\")\\n        continue;\\n      if (typeof balancePre !== \"bigint\")\\n        continue;\\n      const decimals_ = decimals[i - 1];\\n      const symbol_ = symbols[i - 1];\\n      const tokenURI_ = tokenURI[i - 1];\\n      const token = (() => {\\n        if (i === 0)\\n          return {\\n            address: ethAddress,\\n            decimals: 18,\\n            symbol: \"ETH\"\\n          };\\n        return {\\n          address: assetAddresses[i - 1],\\n          decimals: tokenURI_ || decimals_ ? Number(decimals_ ?? 1) : void 0,\\n          symbol: symbol_ ?? void 0\\n        };\\n      })();\\n      if (changes.some((change) => change.token.address === token.address))\\n        continue;\\n      changes.push({\\n        token,\\n        value: {\\n          pre: balancePre,\\n          post: balancePost,\\n          diff: balancePost - balancePre\\n        }\\n      });\\n    }\\n    return {\\n      assetChanges: changes,\\n      block,\\n      results\\n    };\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/verifyHash.js\\n  init_abis();\\n  init_contracts();\\n  init_contract();\\n  init_encodeDeployData();\\n  init_getAddress();\\n  init_isAddressEqual();\\n  init_isHex();\\n  init_toHex();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/signature/serializeSignature.js\\n  init_secp256k1();\\n  init_fromHex();\\n  init_toBytes();\\n  function serializeSignature({ r, s, to = \"hex\", v, yParity }) {\\n    const yParity_ = (() => {\\n      if (yParity === 0 || yParity === 1)\\n        return yParity;\\n      if (v && (v === 27n || v === 28n || v >= 35n))\\n        return v % 2n === 0n ? 1 : 0;\\n      throw new Error(\"Invalid `v` or `yParity` value\");\\n    })();\\n    const signature = `0x${new secp256k1.Signature(hexToBigInt(r), hexToBigInt(s)).toCompactHex()}${yParity_ === 0 ? \"1b\" : \"1c\"}`;\\n    if (to === \"hex\")\\n      return signature;\\n    return hexToBytes(signature);\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/verifyHash.js\\n  init_call();\\n  async function verifyHash(client, parameters) {\\n    const { address, factory, factoryData, hash: hash2, signature, universalSignatureVerifierAddress = client.chain?.contracts?.universalSignatureVerifier?.address, ...rest } = parameters;\\n    const signatureHex = (() => {\\n      if (isHex(signature))\\n        return signature;\\n      if (typeof signature === \"object\" && \"r\" in signature && \"s\" in signature)\\n        return serializeSignature(signature);\\n      return bytesToHex(signature);\\n    })();\\n    const wrappedSignature = await (async () => {\\n      if (!factory && !factoryData)\\n        return signatureHex;\\n      if (isErc6492Signature(signatureHex))\\n        return signatureHex;\\n      return serializeErc6492Signature({\\n        address: factory,\\n        data: factoryData,\\n        signature: signatureHex\\n      });\\n    })();\\n    try {\\n      const args = universalSignatureVerifierAddress ? {\\n        to: universalSignatureVerifierAddress,\\n        data: encodeFunctionData({\\n          abi: universalSignatureValidatorAbi,\\n          functionName: \"isValidSig\",\\n          args: [address, hash2, wrappedSignature]\\n        }),\\n        ...rest\\n      } : {\\n        data: encodeDeployData({\\n          abi: universalSignatureValidatorAbi,\\n          args: [address, hash2, wrappedSignature],\\n          bytecode: universalSignatureValidatorByteCode\\n        }),\\n        ...rest\\n      };\\n      const { data } = await getAction(client, call, \"call\")(args);\\n      return hexToBool(data ?? \"0x0\");\\n    } catch (error) {\\n      try {\\n        const verified = isAddressEqual(getAddress(address), await recoverAddress({ hash: hash2, signature }));\\n        if (verified)\\n          return true;\\n      } catch {\\n      }\\n      if (error instanceof CallExecutionError) {\\n        return false;\\n      }\\n      throw error;\\n    }\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/verifyMessage.js\\n  async function verifyMessage(client, { address, message, factory, factoryData, signature, ...callRequest }) {\\n    const hash2 = hashMessage(message);\\n    return verifyHash(client, {\\n      address,\\n      factory,\\n      factoryData,\\n      hash: hash2,\\n      signature,\\n      ...callRequest\\n    });\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/verifyTypedData.js\\n  async function verifyTypedData(client, parameters) {\\n    const { address, factory, factoryData, signature, message, primaryType, types, domain, ...callRequest } = parameters;\\n    const hash2 = hashTypedData({ message, primaryType, types, domain });\\n    return verifyHash(client, {\\n      address,\\n      factory,\\n      factoryData,\\n      hash: hash2,\\n      signature,\\n      ...callRequest\\n    });\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/waitForTransactionReceipt.js\\n  init_transaction();\\n  init_withResolvers();\\n  init_stringify();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/watchBlockNumber.js\\n  init_fromHex();\\n  init_stringify();\\n  function watchBlockNumber(client, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client.pollingInterval }) {\\n    const enablePolling = (() => {\\n      if (typeof poll_ !== \"undefined\")\\n        return poll_;\\n      if (client.transport.type === \"webSocket\")\\n        return false;\\n      if (client.transport.type === \"fallback\" && client.transport.transports[0].config.type === \"webSocket\")\\n        return false;\\n      return true;\\n    })();\\n    let prevBlockNumber;\\n    const pollBlockNumber = () => {\\n      const observerId = stringify([\\n        \"watchBlockNumber\",\\n        client.uid,\\n        emitOnBegin,\\n        emitMissed,\\n        pollingInterval\\n      ]);\\n      return observe(observerId, { onBlockNumber, onError }, (emit) => poll(async () => {\\n        try {\\n          const blockNumber = await getAction(client, getBlockNumber, \"getBlockNumber\")({ cacheTime: 0 });\\n          if (prevBlockNumber) {\\n            if (blockNumber === prevBlockNumber)\\n              return;\\n            if (blockNumber - prevBlockNumber > 1 && emitMissed) {\\n              for (let i = prevBlockNumber + 1n; i < blockNumber; i++) {\\n                emit.onBlockNumber(i, prevBlockNumber);\\n                prevBlockNumber = i;\\n              }\\n            }\\n          }\\n          if (!prevBlockNumber || blockNumber > prevBlockNumber) {\\n            emit.onBlockNumber(blockNumber, prevBlockNumber);\\n            prevBlockNumber = blockNumber;\\n          }\\n        } catch (err) {\\n          emit.onError?.(err);\\n        }\\n      }, {\\n        emitOnBegin,\\n        interval: pollingInterval\\n      }));\\n    };\\n    const subscribeBlockNumber = () => {\\n      const observerId = stringify([\\n        \"watchBlockNumber\",\\n        client.uid,\\n        emitOnBegin,\\n        emitMissed\\n      ]);\\n      return observe(observerId, { onBlockNumber, onError }, (emit) => {\\n        let active = true;\\n        let unsubscribe = () => active = false;\\n        (async () => {\\n          try {\\n            const transport = (() => {\\n              if (client.transport.type === \"fallback\") {\\n                const transport2 = client.transport.transports.find((transport3) => transport3.config.type === \"webSocket\");\\n                if (!transport2)\\n                  return client.transport;\\n                return transport2.value;\\n              }\\n              return client.transport;\\n            })();\\n            const { unsubscribe: unsubscribe_ } = await transport.subscribe({\\n              params: [\"newHeads\"],\\n              onData(data) {\\n                if (!active)\\n                  return;\\n                const blockNumber = hexToBigInt(data.result?.number);\\n                emit.onBlockNumber(blockNumber, prevBlockNumber);\\n                prevBlockNumber = blockNumber;\\n              },\\n              onError(error) {\\n                emit.onError?.(error);\\n              }\\n            });\\n            unsubscribe = unsubscribe_;\\n            if (!active)\\n              unsubscribe();\\n          } catch (err) {\\n            onError?.(err);\\n          }\\n        })();\\n        return () => unsubscribe();\\n      });\\n    };\\n    return enablePolling ? pollBlockNumber() : subscribeBlockNumber();\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/waitForTransactionReceipt.js\\n  async function waitForTransactionReceipt(client, {\\n    confirmations = 1,\\n    hash: hash2,\\n    onReplaced,\\n    pollingInterval = client.pollingInterval,\\n    retryCount = 6,\\n    retryDelay = ({ count }) => ~~(1 << count) * 200,\\n    // exponential backoff\\n    timeout = 18e4\\n  }) {\\n    const observerId = stringify([\"waitForTransactionReceipt\", client.uid, hash2]);\\n    let transaction;\\n    let replacedTransaction;\\n    let receipt;\\n    let retrying = false;\\n    const { promise, resolve, reject } = withResolvers();\\n    const timer = timeout ? setTimeout(() => reject(new WaitForTransactionReceiptTimeoutError({ hash: hash2 })), timeout) : void 0;\\n    const _unobserve = observe(observerId, { onReplaced, resolve, reject }, (emit) => {\\n      const _unwatch = getAction(client, watchBlockNumber, \"watchBlockNumber\")({\\n        emitMissed: true,\\n        emitOnBegin: true,\\n        poll: true,\\n        pollingInterval,\\n        async onBlockNumber(blockNumber_) {\\n          const done = (fn) => {\\n            clearTimeout(timer);\\n            _unwatch();\\n            fn();\\n            _unobserve();\\n          };\\n          let blockNumber = blockNumber_;\\n          if (retrying)\\n            return;\\n          try {\\n            if (receipt) {\\n              if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))\\n                return;\\n              done(() => emit.resolve(receipt));\\n              return;\\n            }\\n            if (!transaction) {\\n              retrying = true;\\n              await withRetry(async () => {\\n                transaction = await getAction(client, getTransaction, \"getTransaction\")({ hash: hash2 });\\n                if (transaction.blockNumber)\\n                  blockNumber = transaction.blockNumber;\\n              }, {\\n                delay: retryDelay,\\n                retryCount\\n              });\\n              retrying = false;\\n            }\\n            receipt = await getAction(client, getTransactionReceipt, \"getTransactionReceipt\")({ hash: hash2 });\\n            if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))\\n              return;\\n            done(() => emit.resolve(receipt));\\n          } catch (err) {\\n            if (err instanceof TransactionNotFoundError || err instanceof TransactionReceiptNotFoundError) {\\n              if (!transaction) {\\n                retrying = false;\\n                return;\\n              }\\n              try {\\n                replacedTransaction = transaction;\\n                retrying = true;\\n                const block = await withRetry(() => getAction(client, getBlock, \"getBlock\")({\\n                  blockNumber,\\n                  includeTransactions: true\\n                }), {\\n                  delay: retryDelay,\\n                  retryCount,\\n                  shouldRetry: ({ error }) => error instanceof BlockNotFoundError\\n                });\\n                retrying = false;\\n                const replacementTransaction = block.transactions.find(({ from: from5, nonce }) => from5 === replacedTransaction.from && nonce === replacedTransaction.nonce);\\n                if (!replacementTransaction)\\n                  return;\\n                receipt = await getAction(client, getTransactionReceipt, \"getTransactionReceipt\")({\\n                  hash: replacementTransaction.hash\\n                });\\n                if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))\\n                  return;\\n                let reason = \"replaced\";\\n                if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value && replacementTransaction.input === replacedTransaction.input) {\\n                  reason = \"repriced\";\\n                } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {\\n                  reason = \"cancelled\";\\n                }\\n                done(() => {\\n                  emit.onReplaced?.({\\n                    reason,\\n                    replacedTransaction,\\n                    transaction: replacementTransaction,\\n                    transactionReceipt: receipt\\n                  });\\n                  emit.resolve(receipt);\\n                });\\n              } catch (err_) {\\n                done(() => emit.reject(err_));\\n              }\\n            } else {\\n              done(() => emit.reject(err));\\n            }\\n          }\\n        }\\n      });\\n    });\\n    return promise;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/watchBlocks.js\\n  init_stringify();\\n  function watchBlocks(client, { blockTag = \"latest\", emitMissed = false, emitOnBegin = false, onBlock, onError, includeTransactions: includeTransactions_, poll: poll_, pollingInterval = client.pollingInterval }) {\\n    const enablePolling = (() => {\\n      if (typeof poll_ !== \"undefined\")\\n        return poll_;\\n      if (client.transport.type === \"webSocket\")\\n        return false;\\n      if (client.transport.type === \"fallback\" && client.transport.transports[0].config.type === \"webSocket\")\\n        return false;\\n      return true;\\n    })();\\n    const includeTransactions = includeTransactions_ ?? false;\\n    let prevBlock;\\n    const pollBlocks = () => {\\n      const observerId = stringify([\\n        \"watchBlocks\",\\n        client.uid,\\n        blockTag,\\n        emitMissed,\\n        emitOnBegin,\\n        includeTransactions,\\n        pollingInterval\\n      ]);\\n      return observe(observerId, { onBlock, onError }, (emit) => poll(async () => {\\n        try {\\n          const block = await getAction(client, getBlock, \"getBlock\")({\\n            blockTag,\\n            includeTransactions\\n          });\\n          if (block.number && prevBlock?.number) {\\n            if (block.number === prevBlock.number)\\n              return;\\n            if (block.number - prevBlock.number > 1 && emitMissed) {\\n              for (let i = prevBlock?.number + 1n; i < block.number; i++) {\\n                const block2 = await getAction(client, getBlock, \"getBlock\")({\\n                  blockNumber: i,\\n                  includeTransactions\\n                });\\n                emit.onBlock(block2, prevBlock);\\n                prevBlock = block2;\\n              }\\n            }\\n          }\\n          if (\\n            // If no previous block exists, emit.\\n            !prevBlock?.number || // If the block tag is \"pending\" with no block number, emit.\\n            blockTag === \"pending\" && !block?.number || // If the next block number is greater than the previous block number, emit.\\n            // We don\\'t want to emit blocks in the past.\\n            block.number && block.number > prevBlock.number\\n          ) {\\n            emit.onBlock(block, prevBlock);\\n            prevBlock = block;\\n          }\\n        } catch (err) {\\n          emit.onError?.(err);\\n        }\\n      }, {\\n        emitOnBegin,\\n        interval: pollingInterval\\n      }));\\n    };\\n    const subscribeBlocks = () => {\\n      let active = true;\\n      let emitFetched = true;\\n      let unsubscribe = () => active = false;\\n      (async () => {\\n        try {\\n          if (emitOnBegin) {\\n            getAction(client, getBlock, \"getBlock\")({\\n              blockTag,\\n              includeTransactions\\n            }).then((block) => {\\n              if (!active)\\n                return;\\n              if (!emitFetched)\\n                return;\\n              onBlock(block, void 0);\\n              emitFetched = false;\\n            });\\n          }\\n          const transport = (() => {\\n            if (client.transport.type === \"fallback\") {\\n              const transport2 = client.transport.transports.find((transport3) => transport3.config.type === \"webSocket\");\\n              if (!transport2)\\n                return client.transport;\\n              return transport2.value;\\n            }\\n            return client.transport;\\n          })();\\n          const { unsubscribe: unsubscribe_ } = await transport.subscribe({\\n            params: [\"newHeads\"],\\n            async onData(data) {\\n              if (!active)\\n                return;\\n              const block = await getAction(client, getBlock, \"getBlock\")({\\n                blockNumber: data.blockNumber,\\n                includeTransactions\\n              }).catch(() => {\\n              });\\n              if (!active)\\n                return;\\n              onBlock(block, prevBlock);\\n              emitFetched = false;\\n              prevBlock = block;\\n            },\\n            onError(error) {\\n              onError?.(error);\\n            }\\n          });\\n          unsubscribe = unsubscribe_;\\n          if (!active)\\n            unsubscribe();\\n        } catch (err) {\\n          onError?.(err);\\n        }\\n      })();\\n      return () => unsubscribe();\\n    };\\n    return enablePolling ? pollBlocks() : subscribeBlocks();\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/watchEvent.js\\n  init_stringify();\\n  init_abi();\\n  init_rpc();\\n  function watchEvent(client, { address, args, batch = true, event, events, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ }) {\\n    const enablePolling = (() => {\\n      if (typeof poll_ !== \"undefined\")\\n        return poll_;\\n      if (typeof fromBlock === \"bigint\")\\n        return true;\\n      if (client.transport.type === \"webSocket\")\\n        return false;\\n      if (client.transport.type === \"fallback\" && client.transport.transports[0].config.type === \"webSocket\")\\n        return false;\\n      return true;\\n    })();\\n    const strict = strict_ ?? false;\\n    const pollEvent = () => {\\n      const observerId = stringify([\\n        \"watchEvent\",\\n        address,\\n        args,\\n        batch,\\n        client.uid,\\n        event,\\n        pollingInterval,\\n        fromBlock\\n      ]);\\n      return observe(observerId, { onLogs, onError }, (emit) => {\\n        let previousBlockNumber;\\n        if (fromBlock !== void 0)\\n          previousBlockNumber = fromBlock - 1n;\\n        let filter;\\n        let initialized = false;\\n        const unwatch = poll(async () => {\\n          if (!initialized) {\\n            try {\\n              filter = await getAction(client, createEventFilter, \"createEventFilter\")({\\n                address,\\n                args,\\n                event,\\n                events,\\n                strict,\\n                fromBlock\\n              });\\n            } catch {\\n            }\\n            initialized = true;\\n            return;\\n          }\\n          try {\\n            let logs;\\n            if (filter) {\\n              logs = await getAction(client, getFilterChanges, \"getFilterChanges\")({ filter });\\n            } else {\\n              const blockNumber = await getAction(client, getBlockNumber, \"getBlockNumber\")({});\\n              if (previousBlockNumber && previousBlockNumber !== blockNumber) {\\n                logs = await getAction(client, getLogs, \"getLogs\")({\\n                  address,\\n                  args,\\n                  event,\\n                  events,\\n                  fromBlock: previousBlockNumber + 1n,\\n                  toBlock: blockNumber\\n                });\\n              } else {\\n                logs = [];\\n              }\\n              previousBlockNumber = blockNumber;\\n            }\\n            if (logs.length === 0)\\n              return;\\n            if (batch)\\n              emit.onLogs(logs);\\n            else\\n              for (const log of logs)\\n                emit.onLogs([log]);\\n          } catch (err) {\\n            if (filter && err instanceof InvalidInputRpcError)\\n              initialized = false;\\n            emit.onError?.(err);\\n          }\\n        }, {\\n          emitOnBegin: true,\\n          interval: pollingInterval\\n        });\\n        return async () => {\\n          if (filter)\\n            await getAction(client, uninstallFilter, \"uninstallFilter\")({ filter });\\n          unwatch();\\n        };\\n      });\\n    };\\n    const subscribeEvent = () => {\\n      let active = true;\\n      let unsubscribe = () => active = false;\\n      (async () => {\\n        try {\\n          const transport = (() => {\\n            if (client.transport.type === \"fallback\") {\\n              const transport2 = client.transport.transports.find((transport3) => transport3.config.type === \"webSocket\");\\n              if (!transport2)\\n                return client.transport;\\n              return transport2.value;\\n            }\\n            return client.transport;\\n          })();\\n          const events_ = events ?? (event ? [event] : void 0);\\n          let topics = [];\\n          if (events_) {\\n            const encoded = events_.flatMap((event2) => encodeEventTopics({\\n              abi: [event2],\\n              eventName: event2.name,\\n              args\\n            }));\\n            topics = [encoded];\\n            if (event)\\n              topics = topics[0];\\n          }\\n          const { unsubscribe: unsubscribe_ } = await transport.subscribe({\\n            params: [\"logs\", { address, topics }],\\n            onData(data) {\\n              if (!active)\\n                return;\\n              const log = data.result;\\n              try {\\n                const { eventName, args: args2 } = decodeEventLog({\\n                  abi: events_ ?? [],\\n                  data: log.data,\\n                  topics: log.topics,\\n                  strict\\n                });\\n                const formatted = formatLog(log, { args: args2, eventName });\\n                onLogs([formatted]);\\n              } catch (err) {\\n                let eventName;\\n                let isUnnamed;\\n                if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {\\n                  if (strict_)\\n                    return;\\n                  eventName = err.abiItem.name;\\n                  isUnnamed = err.abiItem.inputs?.some((x) => !(\"name\" in x && x.name));\\n                }\\n                const formatted = formatLog(log, {\\n                  args: isUnnamed ? [] : {},\\n                  eventName\\n                });\\n                onLogs([formatted]);\\n              }\\n            },\\n            onError(error) {\\n              onError?.(error);\\n            }\\n          });\\n          unsubscribe = unsubscribe_;\\n          if (!active)\\n            unsubscribe();\\n        } catch (err) {\\n          onError?.(err);\\n        }\\n      })();\\n      return () => unsubscribe();\\n    };\\n    return enablePolling ? pollEvent() : subscribeEvent();\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/public/watchPendingTransactions.js\\n  init_stringify();\\n  function watchPendingTransactions(client, { batch = true, onError, onTransactions, poll: poll_, pollingInterval = client.pollingInterval }) {\\n    const enablePolling = typeof poll_ !== \"undefined\" ? poll_ : client.transport.type !== \"webSocket\";\\n    const pollPendingTransactions = () => {\\n      const observerId = stringify([\\n        \"watchPendingTransactions\",\\n        client.uid,\\n        batch,\\n        pollingInterval\\n      ]);\\n      return observe(observerId, { onTransactions, onError }, (emit) => {\\n        let filter;\\n        const unwatch = poll(async () => {\\n          try {\\n            if (!filter) {\\n              try {\\n                filter = await getAction(client, createPendingTransactionFilter, \"createPendingTransactionFilter\")({});\\n                return;\\n              } catch (err) {\\n                unwatch();\\n                throw err;\\n              }\\n            }\\n            const hashes = await getAction(client, getFilterChanges, \"getFilterChanges\")({ filter });\\n            if (hashes.length === 0)\\n              return;\\n            if (batch)\\n              emit.onTransactions(hashes);\\n            else\\n              for (const hash2 of hashes)\\n                emit.onTransactions([hash2]);\\n          } catch (err) {\\n            emit.onError?.(err);\\n          }\\n        }, {\\n          emitOnBegin: true,\\n          interval: pollingInterval\\n        });\\n        return async () => {\\n          if (filter)\\n            await getAction(client, uninstallFilter, \"uninstallFilter\")({ filter });\\n          unwatch();\\n        };\\n      });\\n    };\\n    const subscribePendingTransactions = () => {\\n      let active = true;\\n      let unsubscribe = () => active = false;\\n      (async () => {\\n        try {\\n          const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({\\n            params: [\"newPendingTransactions\"],\\n            onData(data) {\\n              if (!active)\\n                return;\\n              const transaction = data.result;\\n              onTransactions([transaction]);\\n            },\\n            onError(error) {\\n              onError?.(error);\\n            }\\n          });\\n          unsubscribe = unsubscribe_;\\n          if (!active)\\n            unsubscribe();\\n        } catch (err) {\\n          onError?.(err);\\n        }\\n      })();\\n      return () => unsubscribe();\\n    };\\n    return enablePolling ? pollPendingTransactions() : subscribePendingTransactions();\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/siwe/parseSiweMessage.js\\n  function parseSiweMessage(message) {\\n    const { scheme, statement, ...prefix } = message.match(prefixRegex)?.groups ?? {};\\n    const { chainId, expirationTime, issuedAt, notBefore, requestId, ...suffix } = message.match(suffixRegex)?.groups ?? {};\\n    const resources = message.split(\"Resources:\")[1]?.split(\"\\\\n- \").slice(1);\\n    return {\\n      ...prefix,\\n      ...suffix,\\n      ...chainId ? { chainId: Number(chainId) } : {},\\n      ...expirationTime ? { expirationTime: new Date(expirationTime) } : {},\\n      ...issuedAt ? { issuedAt: new Date(issuedAt) } : {},\\n      ...notBefore ? { notBefore: new Date(notBefore) } : {},\\n      ...requestId ? { requestId } : {},\\n      ...resources ? { resources } : {},\\n      ...scheme ? { scheme } : {},\\n      ...statement ? { statement } : {}\\n    };\\n  }\\n  var prefixRegex = /^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\\\\/\\\\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\\\\n)(?<address>0x[a-fA-F0-9]{40})\\\\n\\\\n(?:(?<statement>.*)\\\\n\\\\n)?/;\\n  var suffixRegex = /(?:URI: (?<uri>.+))\\\\n(?:Version: (?<version>.+))\\\\n(?:Chain ID: (?<chainId>\\\\d+))\\\\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\\\\n(?:Issued At: (?<issuedAt>.+))(?:\\\\nExpiration Time: (?<expirationTime>.+))?(?:\\\\nNot Before: (?<notBefore>.+))?(?:\\\\nRequest ID: (?<requestId>.+))?/;\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/utils/siwe/validateSiweMessage.js\\n  init_isAddressEqual();\\n  function validateSiweMessage(parameters) {\\n    const { address, domain, message, nonce, scheme, time = /* @__PURE__ */ new Date() } = parameters;\\n    if (domain && message.domain !== domain)\\n      return false;\\n    if (nonce && message.nonce !== nonce)\\n      return false;\\n    if (scheme && message.scheme !== scheme)\\n      return false;\\n    if (message.expirationTime && time >= message.expirationTime)\\n      return false;\\n    if (message.notBefore && time < message.notBefore)\\n      return false;\\n    try {\\n      if (!message.address)\\n        return false;\\n      if (address && !isAddressEqual(message.address, address))\\n        return false;\\n    } catch {\\n      return false;\\n    }\\n    return true;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/siwe/verifySiweMessage.js\\n  async function verifySiweMessage(client, parameters) {\\n    const { address, domain, message, nonce, scheme, signature, time = /* @__PURE__ */ new Date(), ...callRequest } = parameters;\\n    const parsed = parseSiweMessage(message);\\n    if (!parsed.address)\\n      return false;\\n    const isValid2 = validateSiweMessage({\\n      address,\\n      domain,\\n      message: parsed,\\n      nonce,\\n      scheme,\\n      time\\n    });\\n    if (!isValid2)\\n      return false;\\n    const hash2 = hashMessage(message);\\n    return verifyHash(client, {\\n      address: parsed.address,\\n      hash: hash2,\\n      signature,\\n      ...callRequest\\n    });\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/clients/decorators/public.js\\n  function publicActions(client) {\\n    return {\\n      call: (args) => call(client, args),\\n      createAccessList: (args) => createAccessList(client, args),\\n      createBlockFilter: () => createBlockFilter(client),\\n      createContractEventFilter: (args) => createContractEventFilter(client, args),\\n      createEventFilter: (args) => createEventFilter(client, args),\\n      createPendingTransactionFilter: () => createPendingTransactionFilter(client),\\n      estimateContractGas: (args) => estimateContractGas(client, args),\\n      estimateGas: (args) => estimateGas(client, args),\\n      getBalance: (args) => getBalance(client, args),\\n      getBlobBaseFee: () => getBlobBaseFee(client),\\n      getBlock: (args) => getBlock(client, args),\\n      getBlockNumber: (args) => getBlockNumber(client, args),\\n      getBlockTransactionCount: (args) => getBlockTransactionCount(client, args),\\n      getBytecode: (args) => getCode(client, args),\\n      getChainId: () => getChainId(client),\\n      getCode: (args) => getCode(client, args),\\n      getContractEvents: (args) => getContractEvents(client, args),\\n      getEip712Domain: (args) => getEip712Domain(client, args),\\n      getEnsAddress: (args) => getEnsAddress(client, args),\\n      getEnsAvatar: (args) => getEnsAvatar(client, args),\\n      getEnsName: (args) => getEnsName(client, args),\\n      getEnsResolver: (args) => getEnsResolver(client, args),\\n      getEnsText: (args) => getEnsText(client, args),\\n      getFeeHistory: (args) => getFeeHistory(client, args),\\n      estimateFeesPerGas: (args) => estimateFeesPerGas(client, args),\\n      getFilterChanges: (args) => getFilterChanges(client, args),\\n      getFilterLogs: (args) => getFilterLogs(client, args),\\n      getGasPrice: () => getGasPrice(client),\\n      getLogs: (args) => getLogs(client, args),\\n      getProof: (args) => getProof(client, args),\\n      estimateMaxPriorityFeePerGas: (args) => estimateMaxPriorityFeePerGas(client, args),\\n      getStorageAt: (args) => getStorageAt(client, args),\\n      getTransaction: (args) => getTransaction(client, args),\\n      getTransactionConfirmations: (args) => getTransactionConfirmations(client, args),\\n      getTransactionCount: (args) => getTransactionCount(client, args),\\n      getTransactionReceipt: (args) => getTransactionReceipt(client, args),\\n      multicall: (args) => multicall(client, args),\\n      prepareTransactionRequest: (args) => prepareTransactionRequest(client, args),\\n      readContract: (args) => readContract(client, args),\\n      sendRawTransaction: (args) => sendRawTransaction(client, args),\\n      simulate: (args) => simulateBlocks(client, args),\\n      simulateBlocks: (args) => simulateBlocks(client, args),\\n      simulateCalls: (args) => simulateCalls(client, args),\\n      simulateContract: (args) => simulateContract(client, args),\\n      verifyMessage: (args) => verifyMessage(client, args),\\n      verifySiweMessage: (args) => verifySiweMessage(client, args),\\n      verifyTypedData: (args) => verifyTypedData(client, args),\\n      uninstallFilter: (args) => uninstallFilter(client, args),\\n      waitForTransactionReceipt: (args) => waitForTransactionReceipt(client, args),\\n      watchBlocks: (args) => watchBlocks(client, args),\\n      watchBlockNumber: (args) => watchBlockNumber(client, args),\\n      watchContractEvent: (args) => watchContractEvent(client, args),\\n      watchEvent: (args) => watchEvent(client, args),\\n      watchPendingTransactions: (args) => watchPendingTransactions(client, args)\\n    };\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/clients/createPublicClient.js\\n  function createPublicClient(parameters) {\\n    const { key = \"public\", name = \"Public Client\" } = parameters;\\n    const client = createClient({\\n      ...parameters,\\n      key,\\n      name,\\n      type: \"publicClient\"\\n    });\\n    return client.extend(publicActions);\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/wallet/addChain.js\\n  init_toHex();\\n  async function addChain(client, { chain }) {\\n    const { id, name, nativeCurrency, rpcUrls, blockExplorers } = chain;\\n    await client.request({\\n      method: \"wallet_addEthereumChain\",\\n      params: [\\n        {\\n          chainId: numberToHex(id),\\n          chainName: name,\\n          nativeCurrency,\\n          rpcUrls: rpcUrls.default.http,\\n          blockExplorerUrls: blockExplorers ? Object.values(blockExplorers).map(({ url }) => url) : void 0\\n        }\\n      ]\\n    }, { dedupe: true, retryCount: 0 });\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/wallet/deployContract.js\\n  init_encodeDeployData();\\n  function deployContract(walletClient, parameters) {\\n    const { abi: abi2, args, bytecode, ...request } = parameters;\\n    const calldata = encodeDeployData({ abi: abi2, args, bytecode });\\n    return sendTransaction(walletClient, {\\n      ...request,\\n      ...request.authorizationList ? { to: null } : {},\\n      data: calldata\\n    });\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/wallet/getAddresses.js\\n  init_getAddress();\\n  async function getAddresses(client) {\\n    if (client.account?.type === \"local\")\\n      return [client.account.address];\\n    const addresses = await client.request({ method: \"eth_accounts\" }, { dedupe: true });\\n    return addresses.map((address) => checksumAddress(address));\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/wallet/getPermissions.js\\n  async function getPermissions(client) {\\n    const permissions = await client.request({ method: \"wallet_getPermissions\" }, { dedupe: true });\\n    return permissions;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/wallet/prepareAuthorization.js\\n  init_parseAccount();\\n  init_isAddressEqual();\\n  async function prepareAuthorization(client, parameters) {\\n    const { account: account_ = client.account, chainId, nonce } = parameters;\\n    if (!account_)\\n      throw new AccountNotFoundError({\\n        docsPath: \"/docs/eip7702/prepareAuthorization\"\\n      });\\n    const account = parseAccount(account_);\\n    const executor = (() => {\\n      if (!parameters.executor)\\n        return void 0;\\n      if (parameters.executor === \"self\")\\n        return parameters.executor;\\n      return parseAccount(parameters.executor);\\n    })();\\n    const authorization = {\\n      address: parameters.contractAddress ?? parameters.address,\\n      chainId,\\n      nonce\\n    };\\n    if (typeof authorization.chainId === \"undefined\")\\n      authorization.chainId = client.chain?.id ?? await getAction(client, getChainId, \"getChainId\")({});\\n    if (typeof authorization.nonce === \"undefined\") {\\n      authorization.nonce = await getAction(client, getTransactionCount, \"getTransactionCount\")({\\n        address: account.address,\\n        blockTag: \"pending\"\\n      });\\n      if (executor === \"self\" || executor?.address && isAddressEqual(executor.address, account.address))\\n        authorization.nonce += 1;\\n    }\\n    return authorization;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/wallet/requestAddresses.js\\n  init_getAddress();\\n  async function requestAddresses(client) {\\n    const addresses = await client.request({ method: \"eth_requestAccounts\" }, { dedupe: true, retryCount: 0 });\\n    return addresses.map((address) => getAddress(address));\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/wallet/requestPermissions.js\\n  async function requestPermissions(client, permissions) {\\n    return client.request({\\n      method: \"wallet_requestPermissions\",\\n      params: [permissions]\\n    }, { retryCount: 0 });\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/wallet/signAuthorization.js\\n  init_parseAccount();\\n  async function signAuthorization(client, parameters) {\\n    const { account: account_ = client.account } = parameters;\\n    if (!account_)\\n      throw new AccountNotFoundError({\\n        docsPath: \"/docs/eip7702/signAuthorization\"\\n      });\\n    const account = parseAccount(account_);\\n    if (!account.signAuthorization)\\n      throw new AccountTypeNotSupportedError({\\n        docsPath: \"/docs/eip7702/signAuthorization\",\\n        metaMessages: [\\n          \"The `signAuthorization` Action does not support JSON-RPC Accounts.\"\\n        ],\\n        type: account.type\\n      });\\n    const authorization = await prepareAuthorization(client, parameters);\\n    return account.signAuthorization(authorization);\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/wallet/signMessage.js\\n  init_parseAccount();\\n  init_toHex();\\n  async function signMessage(client, { account: account_ = client.account, message }) {\\n    if (!account_)\\n      throw new AccountNotFoundError({\\n        docsPath: \"/docs/actions/wallet/signMessage\"\\n      });\\n    const account = parseAccount(account_);\\n    if (account.signMessage)\\n      return account.signMessage({ message });\\n    const message_ = (() => {\\n      if (typeof message === \"string\")\\n        return stringToHex(message);\\n      if (message.raw instanceof Uint8Array)\\n        return toHex(message.raw);\\n      return message.raw;\\n    })();\\n    return client.request({\\n      method: \"personal_sign\",\\n      params: [message_, account.address]\\n    }, { retryCount: 0 });\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/wallet/signTransaction.js\\n  init_parseAccount();\\n  init_toHex();\\n  init_transactionRequest();\\n  init_assertRequest();\\n  async function signTransaction(client, parameters) {\\n    const { account: account_ = client.account, chain = client.chain, ...transaction } = parameters;\\n    if (!account_)\\n      throw new AccountNotFoundError({\\n        docsPath: \"/docs/actions/wallet/signTransaction\"\\n      });\\n    const account = parseAccount(account_);\\n    assertRequest({\\n      account,\\n      ...parameters\\n    });\\n    const chainId = await getAction(client, getChainId, \"getChainId\")({});\\n    if (chain !== null)\\n      assertCurrentChain({\\n        currentChainId: chainId,\\n        chain\\n      });\\n    const formatters2 = chain?.formatters || client.chain?.formatters;\\n    const format = formatters2?.transactionRequest?.format || formatTransactionRequest;\\n    if (account.signTransaction)\\n      return account.signTransaction({\\n        ...transaction,\\n        chainId\\n      }, { serializer: client.chain?.serializers?.transaction });\\n    return await client.request({\\n      method: \"eth_signTransaction\",\\n      params: [\\n        {\\n          ...format(transaction),\\n          chainId: numberToHex(chainId),\\n          from: account.address\\n        }\\n      ]\\n    }, { retryCount: 0 });\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/wallet/signTypedData.js\\n  init_parseAccount();\\n  async function signTypedData(client, parameters) {\\n    const { account: account_ = client.account, domain, message, primaryType } = parameters;\\n    if (!account_)\\n      throw new AccountNotFoundError({\\n        docsPath: \"/docs/actions/wallet/signTypedData\"\\n      });\\n    const account = parseAccount(account_);\\n    const types = {\\n      EIP712Domain: getTypesForEIP712Domain({ domain }),\\n      ...parameters.types\\n    };\\n    validateTypedData({ domain, message, primaryType, types });\\n    if (account.signTypedData)\\n      return account.signTypedData({ domain, message, primaryType, types });\\n    const typedData = serializeTypedData({ domain, message, primaryType, types });\\n    return client.request({\\n      method: \"eth_signTypedData_v4\",\\n      params: [account.address, typedData]\\n    }, { retryCount: 0 });\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/wallet/switchChain.js\\n  init_toHex();\\n  async function switchChain(client, { id }) {\\n    await client.request({\\n      method: \"wallet_switchEthereumChain\",\\n      params: [\\n        {\\n          chainId: numberToHex(id)\\n        }\\n      ]\\n    }, { retryCount: 0 });\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/actions/wallet/watchAsset.js\\n  async function watchAsset(client, params) {\\n    const added = await client.request({\\n      method: \"wallet_watchAsset\",\\n      params\\n    }, { retryCount: 0 });\\n    return added;\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/clients/decorators/wallet.js\\n  function walletActions(client) {\\n    return {\\n      addChain: (args) => addChain(client, args),\\n      deployContract: (args) => deployContract(client, args),\\n      getAddresses: () => getAddresses(client),\\n      getChainId: () => getChainId(client),\\n      getPermissions: () => getPermissions(client),\\n      prepareAuthorization: (args) => prepareAuthorization(client, args),\\n      prepareTransactionRequest: (args) => prepareTransactionRequest(client, args),\\n      requestAddresses: () => requestAddresses(client),\\n      requestPermissions: (args) => requestPermissions(client, args),\\n      sendRawTransaction: (args) => sendRawTransaction(client, args),\\n      sendTransaction: (args) => sendTransaction(client, args),\\n      signAuthorization: (args) => signAuthorization(client, args),\\n      signMessage: (args) => signMessage(client, args),\\n      signTransaction: (args) => signTransaction(client, args),\\n      signTypedData: (args) => signTypedData(client, args),\\n      switchChain: (args) => switchChain(client, args),\\n      watchAsset: (args) => watchAsset(client, args),\\n      writeContract: (args) => writeContract(client, args)\\n    };\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/clients/createWalletClient.js\\n  function createWalletClient(parameters) {\\n    const { key = \"wallet\", name = \"Wallet Client\", transport } = parameters;\\n    const client = createClient({\\n      ...parameters,\\n      key,\\n      name,\\n      transport,\\n      type: \"walletClient\"\\n    });\\n    return client.extend(walletActions);\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/index.js\\n  init_toHex();\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/op-stack/contracts.js\\n  var contracts = {\\n    gasPriceOracle: { address: \"0x420000000000000000000000000000000000000F\" },\\n    l1Block: { address: \"0x4200000000000000000000000000000000000015\" },\\n    l2CrossDomainMessenger: {\\n      address: \"0x4200000000000000000000000000000000000007\"\\n    },\\n    l2Erc721Bridge: { address: \"0x4200000000000000000000000000000000000014\" },\\n    l2StandardBridge: { address: \"0x4200000000000000000000000000000000000010\" },\\n    l2ToL1MessagePasser: {\\n      address: \"0x4200000000000000000000000000000000000016\"\\n    }\\n  };\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/op-stack/formatters.js\\n  init_fromHex();\\n  var formatters = {\\n    block: /* @__PURE__ */ defineBlock({\\n      format(args) {\\n        const transactions = args.transactions?.map((transaction) => {\\n          if (typeof transaction === \"string\")\\n            return transaction;\\n          const formatted = formatTransaction(transaction);\\n          if (formatted.typeHex === \"0x7e\") {\\n            formatted.isSystemTx = transaction.isSystemTx;\\n            formatted.mint = transaction.mint ? hexToBigInt(transaction.mint) : void 0;\\n            formatted.sourceHash = transaction.sourceHash;\\n            formatted.type = \"deposit\";\\n          }\\n          return formatted;\\n        });\\n        return {\\n          transactions,\\n          stateRoot: args.stateRoot\\n        };\\n      }\\n    }),\\n    transaction: /* @__PURE__ */ defineTransaction({\\n      format(args) {\\n        const transaction = {};\\n        if (args.type === \"0x7e\") {\\n          transaction.isSystemTx = args.isSystemTx;\\n          transaction.mint = args.mint ? hexToBigInt(args.mint) : void 0;\\n          transaction.sourceHash = args.sourceHash;\\n          transaction.type = \"deposit\";\\n        }\\n        return transaction;\\n      }\\n    }),\\n    transactionReceipt: /* @__PURE__ */ defineTransactionReceipt({\\n      format(args) {\\n        return {\\n          l1GasPrice: args.l1GasPrice ? hexToBigInt(args.l1GasPrice) : null,\\n          l1GasUsed: args.l1GasUsed ? hexToBigInt(args.l1GasUsed) : null,\\n          l1Fee: args.l1Fee ? hexToBigInt(args.l1Fee) : null,\\n          l1FeeScalar: args.l1FeeScalar ? Number(args.l1FeeScalar) : null\\n        };\\n      }\\n    })\\n  };\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/op-stack/serializers.js\\n  init_address();\\n  init_isAddress();\\n  init_concat();\\n  init_toHex();\\n  function serializeTransaction2(transaction, signature) {\\n    if (isDeposit(transaction))\\n      return serializeTransactionDeposit(transaction);\\n    return serializeTransaction(transaction, signature);\\n  }\\n  var serializers = {\\n    transaction: serializeTransaction2\\n  };\\n  function serializeTransactionDeposit(transaction) {\\n    assertTransactionDeposit(transaction);\\n    const { sourceHash, data, from: from5, gas, isSystemTx, mint, to, value } = transaction;\\n    const serializedTransaction = [\\n      sourceHash,\\n      from5,\\n      to ?? \"0x\",\\n      mint ? toHex(mint) : \"0x\",\\n      value ? toHex(value) : \"0x\",\\n      gas ? toHex(gas) : \"0x\",\\n      isSystemTx ? \"0x1\" : \"0x\",\\n      data ?? \"0x\"\\n    ];\\n    return concatHex([\\n      \"0x7e\",\\n      toRlp(serializedTransaction)\\n    ]);\\n  }\\n  function isDeposit(transaction) {\\n    if (transaction.type === \"deposit\")\\n      return true;\\n    if (typeof transaction.sourceHash !== \"undefined\")\\n      return true;\\n    return false;\\n  }\\n  function assertTransactionDeposit(transaction) {\\n    const { from: from5, to } = transaction;\\n    if (from5 && !isAddress(from5))\\n      throw new InvalidAddressError({ address: from5 });\\n    if (to && !isAddress(to))\\n      throw new InvalidAddressError({ address: to });\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/op-stack/chainConfig.js\\n  var chainConfig = {\\n    contracts,\\n    formatters,\\n    serializers\\n  };\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/chains/definitions/base.js\\n  var sourceId = 1;\\n  var base = /* @__PURE__ */ defineChain({\\n    ...chainConfig,\\n    id: 8453,\\n    name: \"Base\",\\n    nativeCurrency: { name: \"Ether\", symbol: \"ETH\", decimals: 18 },\\n    rpcUrls: {\\n      default: {\\n        http: [\"https://mainnet.base.org\"]\\n      }\\n    },\\n    blockExplorers: {\\n      default: {\\n        name: \"Basescan\",\\n        url: \"https://basescan.org\",\\n        apiUrl: \"https://api.basescan.org/api\"\\n      }\\n    },\\n    contracts: {\\n      ...chainConfig.contracts,\\n      disputeGameFactory: {\\n        [sourceId]: {\\n          address: \"0x43edB88C4B80fDD2AdFF2412A7BebF9dF42cB40e\"\\n        }\\n      },\\n      l2OutputOracle: {\\n        [sourceId]: {\\n          address: \"0x56315b90c40730925ec5485cf004d835058518A0\"\\n        }\\n      },\\n      multicall3: {\\n        address: \"0xca11bde05977b3631167028862be2a173976ca11\",\\n        blockCreated: 5022\\n      },\\n      portal: {\\n        [sourceId]: {\\n          address: \"0x49048044D57e1C92A77f79988d21Fa8fAF74E97e\",\\n          blockCreated: 17482143\\n        }\\n      },\\n      l1StandardBridge: {\\n        [sourceId]: {\\n          address: \"0x3154Cf16ccdb4C6d922629664174b904d80F2C35\",\\n          blockCreated: 17482143\\n        }\\n      }\\n    },\\n    sourceId\\n  });\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/viem@2.27.2_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10_zod@3.24.3/node_modules/viem/_esm/chains/definitions/baseSepolia.js\\n  var sourceId2 = 11155111;\\n  var baseSepolia = /* @__PURE__ */ defineChain({\\n    ...chainConfig,\\n    id: 84532,\\n    network: \"base-sepolia\",\\n    name: \"Base Sepolia\",\\n    nativeCurrency: { name: \"Sepolia Ether\", symbol: \"ETH\", decimals: 18 },\\n    rpcUrls: {\\n      default: {\\n        http: [\"https://sepolia.base.org\"]\\n      }\\n    },\\n    blockExplorers: {\\n      default: {\\n        name: \"Basescan\",\\n        url: \"https://sepolia.basescan.org\",\\n        apiUrl: \"https://api-sepolia.basescan.org/api\"\\n      }\\n    },\\n    contracts: {\\n      ...chainConfig.contracts,\\n      disputeGameFactory: {\\n        [sourceId2]: {\\n          address: \"0xd6E6dBf4F7EA0ac412fD8b65ED297e64BB7a06E1\"\\n        }\\n      },\\n      l2OutputOracle: {\\n        [sourceId2]: {\\n          address: \"0x84457ca9D0163FbC4bbfe4Dfbb20ba46e48DF254\"\\n        }\\n      },\\n      portal: {\\n        [sourceId2]: {\\n          address: \"0x49f53e41452c74589e85ca1677426ba426459e85\",\\n          blockCreated: 4446677\\n        }\\n      },\\n      l1StandardBridge: {\\n        [sourceId2]: {\\n          address: \"0xfd0Bf71F60660E2f608ed56e1659C450eB113120\",\\n          blockCreated: 4446677\\n        }\\n      },\\n      multicall3: {\\n        address: \"0xca11bde05977b3631167028862be2a173976ca11\",\\n        blockCreated: 1059647\\n      }\\n    },\\n    testnet: true,\\n    sourceId: sourceId2\\n  });\\n\\n  // src/types/shared/evm/config.ts\\n  var config = {\\n    \"84532\": {\\n      usdcAddress: \"0x036CbD53842c5426634e7929541eC2318f3dCF7e\",\\n      usdcName: \"USDC\"\\n    },\\n    \"8453\": {\\n      usdcAddress: \"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\",\\n      usdcName: \"USDC\"\\n    },\\n    \"43113\": {\\n      usdcAddress: \"0x5425890298aed601595a70AB815c96711a31Bc65\",\\n      usdcName: \"USD Coin\"\\n    },\\n    \"43114\": {\\n      usdcAddress: \"0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E\",\\n      usdcName: \"USDC\"\\n    },\\n    \"4689\": {\\n      usdcAddress: \"0xcdf79194c6c285077a58da47641d4dbe51f63542\",\\n      usdcName: \"Bridged USDC\"\\n    }\\n  };\\n\\n  // src/types/shared/evm/eip3009.ts\\n  var authorizationTypes = {\\n    TransferWithAuthorization: [\\n      { name: \"from\", type: \"address\" },\\n      { name: \"to\", type: \"address\" },\\n      { name: \"value\", type: \"uint256\" },\\n      { name: \"validAfter\", type: \"uint256\" },\\n      { name: \"validBefore\", type: \"uint256\" },\\n      { name: \"nonce\", type: \"bytes32\" }\\n    ]\\n  };\\n\\n  // src/types/shared/evm/erc20PermitABI.ts\\n  var usdcABI = [\\n    {\\n      anonymous: false,\\n      inputs: [\\n        {\\n          indexed: true,\\n          internalType: \"address\",\\n          name: \"owner\",\\n          type: \"address\"\\n        },\\n        {\\n          indexed: true,\\n          internalType: \"address\",\\n          name: \"spender\",\\n          type: \"address\"\\n        },\\n        {\\n          indexed: false,\\n          internalType: \"uint256\",\\n          name: \"value\",\\n          type: \"uint256\"\\n        }\\n      ],\\n      name: \"Approval\",\\n      type: \"event\"\\n    },\\n    {\\n      anonymous: false,\\n      inputs: [\\n        {\\n          indexed: true,\\n          internalType: \"address\",\\n          name: \"authorizer\",\\n          type: \"address\"\\n        },\\n        {\\n          indexed: true,\\n          internalType: \"bytes32\",\\n          name: \"nonce\",\\n          type: \"bytes32\"\\n        }\\n      ],\\n      name: \"AuthorizationCanceled\",\\n      type: \"event\"\\n    },\\n    {\\n      anonymous: false,\\n      inputs: [\\n        {\\n          indexed: true,\\n          internalType: \"address\",\\n          name: \"authorizer\",\\n          type: \"address\"\\n        },\\n        {\\n          indexed: true,\\n          internalType: \"bytes32\",\\n          name: \"nonce\",\\n          type: \"bytes32\"\\n        }\\n      ],\\n      name: \"AuthorizationUsed\",\\n      type: \"event\"\\n    },\\n    {\\n      anonymous: false,\\n      inputs: [\\n        {\\n          indexed: true,\\n          internalType: \"address\",\\n          name: \"_account\",\\n          type: \"address\"\\n        }\\n      ],\\n      name: \"Blacklisted\",\\n      type: \"event\"\\n    },\\n    {\\n      anonymous: false,\\n      inputs: [\\n        {\\n          indexed: true,\\n          internalType: \"address\",\\n          name: \"newBlacklister\",\\n          type: \"address\"\\n        }\\n      ],\\n      name: \"BlacklisterChanged\",\\n      type: \"event\"\\n    },\\n    {\\n      anonymous: false,\\n      inputs: [\\n        {\\n          indexed: true,\\n          internalType: \"address\",\\n          name: \"burner\",\\n          type: \"address\"\\n        },\\n        {\\n          indexed: false,\\n          internalType: \"uint256\",\\n          name: \"amount\",\\n          type: \"uint256\"\\n        }\\n      ],\\n      name: \"Burn\",\\n      type: \"event\"\\n    },\\n    {\\n      anonymous: false,\\n      inputs: [\\n        {\\n          indexed: true,\\n          internalType: \"address\",\\n          name: \"newMasterMinter\",\\n          type: \"address\"\\n        }\\n      ],\\n      name: \"MasterMinterChanged\",\\n      type: \"event\"\\n    },\\n    {\\n      anonymous: false,\\n      inputs: [\\n        {\\n          indexed: true,\\n          internalType: \"address\",\\n          name: \"minter\",\\n          type: \"address\"\\n        },\\n        { indexed: true, internalType: \"address\", name: \"to\", type: \"address\" },\\n        {\\n          indexed: false,\\n          internalType: \"uint256\",\\n          name: \"amount\",\\n          type: \"uint256\"\\n        }\\n      ],\\n      name: \"Mint\",\\n      type: \"event\"\\n    },\\n    {\\n      anonymous: false,\\n      inputs: [\\n        {\\n          indexed: true,\\n          internalType: \"address\",\\n          name: \"minter\",\\n          type: \"address\"\\n        },\\n        {\\n          indexed: false,\\n          internalType: \"uint256\",\\n          name: \"minterAllowedAmount\",\\n          type: \"uint256\"\\n        }\\n      ],\\n      name: \"MinterConfigured\",\\n      type: \"event\"\\n    },\\n    {\\n      anonymous: false,\\n      inputs: [\\n        {\\n          indexed: true,\\n          internalType: \"address\",\\n          name: \"oldMinter\",\\n          type: \"address\"\\n        }\\n      ],\\n      name: \"MinterRemoved\",\\n      type: \"event\"\\n    },\\n    {\\n      anonymous: false,\\n      inputs: [\\n        {\\n          indexed: false,\\n          internalType: \"address\",\\n          name: \"previousOwner\",\\n          type: \"address\"\\n        },\\n        {\\n          indexed: false,\\n          internalType: \"address\",\\n          name: \"newOwner\",\\n          type: \"address\"\\n        }\\n      ],\\n      name: \"OwnershipTransferred\",\\n      type: \"event\"\\n    },\\n    { anonymous: false, inputs: [], name: \"Pause\", type: \"event\" },\\n    {\\n      anonymous: false,\\n      inputs: [\\n        {\\n          indexed: true,\\n          internalType: \"address\",\\n          name: \"newAddress\",\\n          type: \"address\"\\n        }\\n      ],\\n      name: \"PauserChanged\",\\n      type: \"event\"\\n    },\\n    {\\n      anonymous: false,\\n      inputs: [\\n        {\\n          indexed: true,\\n          internalType: \"address\",\\n          name: \"newRescuer\",\\n          type: \"address\"\\n        }\\n      ],\\n      name: \"RescuerChanged\",\\n      type: \"event\"\\n    },\\n    {\\n      anonymous: false,\\n      inputs: [\\n        { indexed: true, internalType: \"address\", name: \"from\", type: \"address\" },\\n        { indexed: true, internalType: \"address\", name: \"to\", type: \"address\" },\\n        {\\n          indexed: false,\\n          internalType: \"uint256\",\\n          name: \"value\",\\n          type: \"uint256\"\\n        }\\n      ],\\n      name: \"Transfer\",\\n      type: \"event\"\\n    },\\n    {\\n      anonymous: false,\\n      inputs: [\\n        {\\n          indexed: true,\\n          internalType: \"address\",\\n          name: \"_account\",\\n          type: \"address\"\\n        }\\n      ],\\n      name: \"UnBlacklisted\",\\n      type: \"event\"\\n    },\\n    { anonymous: false, inputs: [], name: \"Unpause\", type: \"event\" },\\n    {\\n      inputs: [],\\n      name: \"CANCEL_AUTHORIZATION_TYPEHASH\",\\n      outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\\n      stateMutability: \"view\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [],\\n      name: \"DOMAIN_SEPARATOR\",\\n      outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\\n      stateMutability: \"view\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [],\\n      name: \"PERMIT_TYPEHASH\",\\n      outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\\n      stateMutability: \"view\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [],\\n      name: \"RECEIVE_WITH_AUTHORIZATION_TYPEHASH\",\\n      outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\\n      stateMutability: \"view\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [],\\n      name: \"TRANSFER_WITH_AUTHORIZATION_TYPEHASH\",\\n      outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\\n      stateMutability: \"view\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [\\n        { internalType: \"address\", name: \"owner\", type: \"address\" },\\n        { internalType: \"address\", name: \"spender\", type: \"address\" }\\n      ],\\n      name: \"allowance\",\\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\\n      stateMutability: \"view\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [\\n        { internalType: \"address\", name: \"spender\", type: \"address\" },\\n        { internalType: \"uint256\", name: \"value\", type: \"uint256\" }\\n      ],\\n      name: \"approve\",\\n      outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\\n      stateMutability: \"nonpayable\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [\\n        { internalType: \"address\", name: \"authorizer\", type: \"address\" },\\n        { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" }\\n      ],\\n      name: \"authorizationState\",\\n      outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\\n      stateMutability: \"view\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [{ internalType: \"address\", name: \"account\", type: \"address\" }],\\n      name: \"balanceOf\",\\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\\n      stateMutability: \"view\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [{ internalType: \"address\", name: \"_account\", type: \"address\" }],\\n      name: \"blacklist\",\\n      outputs: [],\\n      stateMutability: \"nonpayable\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [],\\n      name: \"blacklister\",\\n      outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\\n      stateMutability: \"view\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [{ internalType: \"uint256\", name: \"_amount\", type: \"uint256\" }],\\n      name: \"burn\",\\n      outputs: [],\\n      stateMutability: \"nonpayable\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [\\n        { internalType: \"address\", name: \"authorizer\", type: \"address\" },\\n        { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\\n        { internalType: \"uint8\", name: \"v\", type: \"uint8\" },\\n        { internalType: \"bytes32\", name: \"r\", type: \"bytes32\" },\\n        { internalType: \"bytes32\", name: \"s\", type: \"bytes32\" }\\n      ],\\n      name: \"cancelAuthorization\",\\n      outputs: [],\\n      stateMutability: \"nonpayable\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [\\n        { internalType: \"address\", name: \"authorizer\", type: \"address\" },\\n        { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\\n        { internalType: \"bytes\", name: \"signature\", type: \"bytes\" }\\n      ],\\n      name: \"cancelAuthorization\",\\n      outputs: [],\\n      stateMutability: \"nonpayable\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [\\n        { internalType: \"address\", name: \"minter\", type: \"address\" },\\n        { internalType: \"uint256\", name: \"minterAllowedAmount\", type: \"uint256\" }\\n      ],\\n      name: \"configureMinter\",\\n      outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\\n      stateMutability: \"nonpayable\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [],\\n      name: \"currency\",\\n      outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\\n      stateMutability: \"view\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [],\\n      name: \"decimals\",\\n      outputs: [{ internalType: \"uint8\", name: \"\", type: \"uint8\" }],\\n      stateMutability: \"view\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [\\n        { internalType: \"address\", name: \"spender\", type: \"address\" },\\n        { internalType: \"uint256\", name: \"decrement\", type: \"uint256\" }\\n      ],\\n      name: \"decreaseAllowance\",\\n      outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\\n      stateMutability: \"nonpayable\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [\\n        { internalType: \"address\", name: \"spender\", type: \"address\" },\\n        { internalType: \"uint256\", name: \"increment\", type: \"uint256\" }\\n      ],\\n      name: \"increaseAllowance\",\\n      outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\\n      stateMutability: \"nonpayable\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [\\n        { internalType: \"string\", name: \"tokenName\", type: \"string\" },\\n        { internalType: \"string\", name: \"tokenSymbol\", type: \"string\" },\\n        { internalType: \"string\", name: \"tokenCurrency\", type: \"string\" },\\n        { internalType: \"uint8\", name: \"tokenDecimals\", type: \"uint8\" },\\n        { internalType: \"address\", name: \"newMasterMinter\", type: \"address\" },\\n        { internalType: \"address\", name: \"newPauser\", type: \"address\" },\\n        { internalType: \"address\", name: \"newBlacklister\", type: \"address\" },\\n        { internalType: \"address\", name: \"newOwner\", type: \"address\" }\\n      ],\\n      name: \"initialize\",\\n      outputs: [],\\n      stateMutability: \"nonpayable\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [{ internalType: \"string\", name: \"newName\", type: \"string\" }],\\n      name: \"initializeV2\",\\n      outputs: [],\\n      stateMutability: \"nonpayable\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [{ internalType: \"address\", name: \"lostAndFound\", type: \"address\" }],\\n      name: \"initializeV2_1\",\\n      outputs: [],\\n      stateMutability: \"nonpayable\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [\\n        {\\n          internalType: \"address[]\",\\n          name: \"accountsToBlacklist\",\\n          type: \"address[]\"\\n        },\\n        { internalType: \"string\", name: \"newSymbol\", type: \"string\" }\\n      ],\\n      name: \"initializeV2_2\",\\n      outputs: [],\\n      stateMutability: \"nonpayable\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [{ internalType: \"address\", name: \"_account\", type: \"address\" }],\\n      name: \"isBlacklisted\",\\n      outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\\n      stateMutability: \"view\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [{ internalType: \"address\", name: \"account\", type: \"address\" }],\\n      name: \"isMinter\",\\n      outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\\n      stateMutability: \"view\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [],\\n      name: \"masterMinter\",\\n      outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\\n      stateMutability: \"view\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [\\n        { internalType: \"address\", name: \"_to\", type: \"address\" },\\n        { internalType: \"uint256\", name: \"_amount\", type: \"uint256\" }\\n      ],\\n      name: \"mint\",\\n      outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\\n      stateMutability: \"nonpayable\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [{ internalType: \"address\", name: \"minter\", type: \"address\" }],\\n      name: \"minterAllowance\",\\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\\n      stateMutability: \"view\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [],\\n      name: \"name\",\\n      outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\\n      stateMutability: \"view\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [{ internalType: \"address\", name: \"owner\", type: \"address\" }],\\n      name: \"nonces\",\\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\\n      stateMutability: \"view\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [],\\n      name: \"owner\",\\n      outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\\n      stateMutability: \"view\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [],\\n      name: \"pause\",\\n      outputs: [],\\n      stateMutability: \"nonpayable\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [],\\n      name: \"paused\",\\n      outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\\n      stateMutability: \"view\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [],\\n      name: \"pauser\",\\n      outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\\n      stateMutability: \"view\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [\\n        { internalType: \"address\", name: \"owner\", type: \"address\" },\\n        { internalType: \"address\", name: \"spender\", type: \"address\" },\\n        { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\\n        { internalType: \"uint256\", name: \"deadline\", type: \"uint256\" },\\n        { internalType: \"bytes\", name: \"signature\", type: \"bytes\" }\\n      ],\\n      name: \"permit\",\\n      outputs: [],\\n      stateMutability: \"nonpayable\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [\\n        { internalType: \"address\", name: \"owner\", type: \"address\" },\\n        { internalType: \"address\", name: \"spender\", type: \"address\" },\\n        { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\\n        { internalType: \"uint256\", name: \"deadline\", type: \"uint256\" },\\n        { internalType: \"uint8\", name: \"v\", type: \"uint8\" },\\n        { internalType: \"bytes32\", name: \"r\", type: \"bytes32\" },\\n        { internalType: \"bytes32\", name: \"s\", type: \"bytes32\" }\\n      ],\\n      name: \"permit\",\\n      outputs: [],\\n      stateMutability: \"nonpayable\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [\\n        { internalType: \"address\", name: \"from\", type: \"address\" },\\n        { internalType: \"address\", name: \"to\", type: \"address\" },\\n        { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\\n        { internalType: \"uint256\", name: \"validAfter\", type: \"uint256\" },\\n        { internalType: \"uint256\", name: \"validBefore\", type: \"uint256\" },\\n        { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\\n        { internalType: \"bytes\", name: \"signature\", type: \"bytes\" }\\n      ],\\n      name: \"receiveWithAuthorization\",\\n      outputs: [],\\n      stateMutability: \"nonpayable\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [\\n        { internalType: \"address\", name: \"from\", type: \"address\" },\\n        { internalType: \"address\", name: \"to\", type: \"address\" },\\n        { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\\n        { internalType: \"uint256\", name: \"validAfter\", type: \"uint256\" },\\n        { internalType: \"uint256\", name: \"validBefore\", type: \"uint256\" },\\n        { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\\n        { internalType: \"uint8\", name: \"v\", type: \"uint8\" },\\n        { internalType: \"bytes32\", name: \"r\", type: \"bytes32\" },\\n        { internalType: \"bytes32\", name: \"s\", type: \"bytes32\" }\\n      ],\\n      name: \"receiveWithAuthorization\",\\n      outputs: [],\\n      stateMutability: \"nonpayable\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [{ internalType: \"address\", name: \"minter\", type: \"address\" }],\\n      name: \"removeMinter\",\\n      outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\\n      stateMutability: \"nonpayable\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [\\n        {\\n          internalType: \"contract IERC20\",\\n          name: \"tokenContract\",\\n          type: \"address\"\\n        },\\n        { internalType: \"address\", name: \"to\", type: \"address\" },\\n        { internalType: \"uint256\", name: \"amount\", type: \"uint256\" }\\n      ],\\n      name: \"rescueERC20\",\\n      outputs: [],\\n      stateMutability: \"nonpayable\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [],\\n      name: \"rescuer\",\\n      outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\\n      stateMutability: \"view\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [],\\n      name: \"symbol\",\\n      outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\\n      stateMutability: \"view\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [],\\n      name: \"totalSupply\",\\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\\n      stateMutability: \"view\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [\\n        { internalType: \"address\", name: \"to\", type: \"address\" },\\n        { internalType: \"uint256\", name: \"value\", type: \"uint256\" }\\n      ],\\n      name: \"transfer\",\\n      outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\\n      stateMutability: \"nonpayable\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [\\n        { internalType: \"address\", name: \"from\", type: \"address\" },\\n        { internalType: \"address\", name: \"to\", type: \"address\" },\\n        { internalType: \"uint256\", name: \"value\", type: \"uint256\" }\\n      ],\\n      name: \"transferFrom\",\\n      outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\\n      stateMutability: \"nonpayable\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [{ internalType: \"address\", name: \"newOwner\", type: \"address\" }],\\n      name: \"transferOwnership\",\\n      outputs: [],\\n      stateMutability: \"nonpayable\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [\\n        { internalType: \"address\", name: \"from\", type: \"address\" },\\n        { internalType: \"address\", name: \"to\", type: \"address\" },\\n        { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\\n        { internalType: \"uint256\", name: \"validAfter\", type: \"uint256\" },\\n        { internalType: \"uint256\", name: \"validBefore\", type: \"uint256\" },\\n        { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\\n        { internalType: \"bytes\", name: \"signature\", type: \"bytes\" }\\n      ],\\n      name: \"transferWithAuthorization\",\\n      outputs: [],\\n      stateMutability: \"nonpayable\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [\\n        { internalType: \"address\", name: \"from\", type: \"address\" },\\n        { internalType: \"address\", name: \"to\", type: \"address\" },\\n        { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\\n        { internalType: \"uint256\", name: \"validAfter\", type: \"uint256\" },\\n        { internalType: \"uint256\", name: \"validBefore\", type: \"uint256\" },\\n        { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\\n        { internalType: \"uint8\", name: \"v\", type: \"uint8\" },\\n        { internalType: \"bytes32\", name: \"r\", type: \"bytes32\" },\\n        { internalType: \"bytes32\", name: \"s\", type: \"bytes32\" }\\n      ],\\n      name: \"transferWithAuthorization\",\\n      outputs: [],\\n      stateMutability: \"nonpayable\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [{ internalType: \"address\", name: \"_account\", type: \"address\" }],\\n      name: \"unBlacklist\",\\n      outputs: [],\\n      stateMutability: \"nonpayable\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [],\\n      name: \"unpause\",\\n      outputs: [],\\n      stateMutability: \"nonpayable\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [{ internalType: \"address\", name: \"_newBlacklister\", type: \"address\" }],\\n      name: \"updateBlacklister\",\\n      outputs: [],\\n      stateMutability: \"nonpayable\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [{ internalType: \"address\", name: \"_newMasterMinter\", type: \"address\" }],\\n      name: \"updateMasterMinter\",\\n      outputs: [],\\n      stateMutability: \"nonpayable\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [{ internalType: \"address\", name: \"_newPauser\", type: \"address\" }],\\n      name: \"updatePauser\",\\n      outputs: [],\\n      stateMutability: \"nonpayable\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [{ internalType: \"address\", name: \"newRescuer\", type: \"address\" }],\\n      name: \"updateRescuer\",\\n      outputs: [],\\n      stateMutability: \"nonpayable\",\\n      type: \"function\"\\n    },\\n    {\\n      inputs: [],\\n      name: \"version\",\\n      outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\\n      stateMutability: \"pure\",\\n      type: \"function\"\\n    }\\n  ];\\n\\n  // src/types/shared/evm/wallet.ts\\n  function isSignerWallet(wallet) {\\n    return \"chain\" in wallet && \"transport\" in wallet;\\n  }\\n  function isAccount(wallet) {\\n    return \"address\" in wallet && \"type\" in wallet;\\n  }\\n\\n  // src/shared/base64.ts\\n  function safeBase64Encode(data) {\\n    if (typeof globalThis !== \"undefined\" && typeof globalThis.btoa === \"function\") {\\n      return globalThis.btoa(data);\\n    }\\n    return Buffer.from(data).toString(\"base64\");\\n  }\\n\\n  // ../../../examples/typescript/node_modules/.pnpm/zod@3.24.3/node_modules/zod/lib/index.mjs\\n  var util;\\n  (function(util2) {\\n    util2.assertEqual = (val) => val;\\n    function assertIs(_arg) {\\n    }\\n    util2.assertIs = assertIs;\\n    function assertNever(_x) {\\n      throw new Error();\\n    }\\n    util2.assertNever = assertNever;\\n    util2.arrayToEnum = (items) => {\\n      const obj = {};\\n      for (const item of items) {\\n        obj[item] = item;\\n      }\\n      return obj;\\n    };\\n    util2.getValidEnumValues = (obj) => {\\n      const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\\n      const filtered = {};\\n      for (const k of validKeys) {\\n        filtered[k] = obj[k];\\n      }\\n      return util2.objectValues(filtered);\\n    };\\n    util2.objectValues = (obj) => {\\n      return util2.objectKeys(obj).map(function(e) {\\n        return obj[e];\\n      });\\n    };\\n    util2.objectKeys = typeof Object.keys === \"function\" ? (obj) => Object.keys(obj) : (object) => {\\n      const keys = [];\\n      for (const key in object) {\\n        if (Object.prototype.hasOwnProperty.call(object, key)) {\\n          keys.push(key);\\n        }\\n      }\\n      return keys;\\n    };\\n    util2.find = (arr, checker) => {\\n      for (const item of arr) {\\n        if (checker(item))\\n          return item;\\n      }\\n      return void 0;\\n    };\\n    util2.isInteger = typeof Number.isInteger === \"function\" ? (val) => Number.isInteger(val) : (val) => typeof val === \"number\" && isFinite(val) && Math.floor(val) === val;\\n    function joinValues(array, separator = \" | \") {\\n      return array.map((val) => typeof val === \"string\" ? `\\'${val}\\'` : val).join(separator);\\n    }\\n    util2.joinValues = joinValues;\\n    util2.jsonStringifyReplacer = (_, value) => {\\n      if (typeof value === \"bigint\") {\\n        return value.toString();\\n      }\\n      return value;\\n    };\\n  })(util || (util = {}));\\n  var objectUtil;\\n  (function(objectUtil2) {\\n    objectUtil2.mergeShapes = (first, second) => {\\n      return {\\n        ...first,\\n        ...second\\n        // second overwrites first\\n      };\\n    };\\n  })(objectUtil || (objectUtil = {}));\\n  var ZodParsedType = util.arrayToEnum([\\n    \"string\",\\n    \"nan\",\\n    \"number\",\\n    \"integer\",\\n    \"float\",\\n    \"boolean\",\\n    \"date\",\\n    \"bigint\",\\n    \"symbol\",\\n    \"function\",\\n    \"undefined\",\\n    \"null\",\\n    \"array\",\\n    \"object\",\\n    \"unknown\",\\n    \"promise\",\\n    \"void\",\\n    \"never\",\\n    \"map\",\\n    \"set\"\\n  ]);\\n  var getParsedType = (data) => {\\n    const t = typeof data;\\n    switch (t) {\\n      case \"undefined\":\\n        return ZodParsedType.undefined;\\n      case \"string\":\\n        return ZodParsedType.string;\\n      case \"number\":\\n        return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\\n      case \"boolean\":\\n        return ZodParsedType.boolean;\\n      case \"function\":\\n        return ZodParsedType.function;\\n      case \"bigint\":\\n        return ZodParsedType.bigint;\\n      case \"symbol\":\\n        return ZodParsedType.symbol;\\n      case \"object\":\\n        if (Array.isArray(data)) {\\n          return ZodParsedType.array;\\n        }\\n        if (data === null) {\\n          return ZodParsedType.null;\\n        }\\n        if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\\n          return ZodParsedType.promise;\\n        }\\n        if (typeof Map !== \"undefined\" && data instanceof Map) {\\n          return ZodParsedType.map;\\n        }\\n        if (typeof Set !== \"undefined\" && data instanceof Set) {\\n          return ZodParsedType.set;\\n        }\\n        if (typeof Date !== \"undefined\" && data instanceof Date) {\\n          return ZodParsedType.date;\\n        }\\n        return ZodParsedType.object;\\n      default:\\n        return ZodParsedType.unknown;\\n    }\\n  };\\n  var ZodIssueCode = util.arrayToEnum([\\n    \"invalid_type\",\\n    \"invalid_literal\",\\n    \"custom\",\\n    \"invalid_union\",\\n    \"invalid_union_discriminator\",\\n    \"invalid_enum_value\",\\n    \"unrecognized_keys\",\\n    \"invalid_arguments\",\\n    \"invalid_return_type\",\\n    \"invalid_date\",\\n    \"invalid_string\",\\n    \"too_small\",\\n    \"too_big\",\\n    \"invalid_intersection_types\",\\n    \"not_multiple_of\",\\n    \"not_finite\"\\n  ]);\\n  var quotelessJson = (obj) => {\\n    const json = JSON.stringify(obj, null, 2);\\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\\n  };\\n  var ZodError = class _ZodError extends Error {\\n    get errors() {\\n      return this.issues;\\n    }\\n    constructor(issues) {\\n      super();\\n      this.issues = [];\\n      this.addIssue = (sub) => {\\n        this.issues = [...this.issues, sub];\\n      };\\n      this.addIssues = (subs = []) => {\\n        this.issues = [...this.issues, ...subs];\\n      };\\n      const actualProto = new.target.prototype;\\n      if (Object.setPrototypeOf) {\\n        Object.setPrototypeOf(this, actualProto);\\n      } else {\\n        this.__proto__ = actualProto;\\n      }\\n      this.name = \"ZodError\";\\n      this.issues = issues;\\n    }\\n    format(_mapper) {\\n      const mapper = _mapper || function(issue) {\\n        return issue.message;\\n      };\\n      const fieldErrors = { _errors: [] };\\n      const processError = (error) => {\\n        for (const issue of error.issues) {\\n          if (issue.code === \"invalid_union\") {\\n            issue.unionErrors.map(processError);\\n          } else if (issue.code === \"invalid_return_type\") {\\n            processError(issue.returnTypeError);\\n          } else if (issue.code === \"invalid_arguments\") {\\n            processError(issue.argumentsError);\\n          } else if (issue.path.length === 0) {\\n            fieldErrors._errors.push(mapper(issue));\\n          } else {\\n            let curr = fieldErrors;\\n            let i = 0;\\n            while (i < issue.path.length) {\\n              const el = issue.path[i];\\n              const terminal = i === issue.path.length - 1;\\n              if (!terminal) {\\n                curr[el] = curr[el] || { _errors: [] };\\n              } else {\\n                curr[el] = curr[el] || { _errors: [] };\\n                curr[el]._errors.push(mapper(issue));\\n              }\\n              curr = curr[el];\\n              i++;\\n            }\\n          }\\n        }\\n      };\\n      processError(this);\\n      return fieldErrors;\\n    }\\n    static assert(value) {\\n      if (!(value instanceof _ZodError)) {\\n        throw new Error(`Not a ZodError: ${value}`);\\n      }\\n    }\\n    toString() {\\n      return this.message;\\n    }\\n    get message() {\\n      return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\\n    }\\n    get isEmpty() {\\n      return this.issues.length === 0;\\n    }\\n    flatten(mapper = (issue) => issue.message) {\\n      const fieldErrors = {};\\n      const formErrors = [];\\n      for (const sub of this.issues) {\\n        if (sub.path.length > 0) {\\n          fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\\n          fieldErrors[sub.path[0]].push(mapper(sub));\\n        } else {\\n          formErrors.push(mapper(sub));\\n        }\\n      }\\n      return { formErrors, fieldErrors };\\n    }\\n    get formErrors() {\\n      return this.flatten();\\n    }\\n  };\\n  ZodError.create = (issues) => {\\n    const error = new ZodError(issues);\\n    return error;\\n  };\\n  var errorMap = (issue, _ctx) => {\\n    let message;\\n    switch (issue.code) {\\n      case ZodIssueCode.invalid_type:\\n        if (issue.received === ZodParsedType.undefined) {\\n          message = \"Required\";\\n        } else {\\n          message = `Expected ${issue.expected}, received ${issue.received}`;\\n        }\\n        break;\\n      case ZodIssueCode.invalid_literal:\\n        message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\\n        break;\\n      case ZodIssueCode.unrecognized_keys:\\n        message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\\n        break;\\n      case ZodIssueCode.invalid_union:\\n        message = `Invalid input`;\\n        break;\\n      case ZodIssueCode.invalid_union_discriminator:\\n        message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\\n        break;\\n      case ZodIssueCode.invalid_enum_value:\\n        message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received \\'${issue.received}\\'`;\\n        break;\\n      case ZodIssueCode.invalid_arguments:\\n        message = `Invalid function arguments`;\\n        break;\\n      case ZodIssueCode.invalid_return_type:\\n        message = `Invalid function return type`;\\n        break;\\n      case ZodIssueCode.invalid_date:\\n        message = `Invalid date`;\\n        break;\\n      case ZodIssueCode.invalid_string:\\n        if (typeof issue.validation === \"object\") {\\n          if (\"includes\" in issue.validation) {\\n            message = `Invalid input: must include \"${issue.validation.includes}\"`;\\n            if (typeof issue.validation.position === \"number\") {\\n              message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\\n            }\\n          } else if (\"startsWith\" in issue.validation) {\\n            message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\\n          } else if (\"endsWith\" in issue.validation) {\\n            message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\\n          } else {\\n            util.assertNever(issue.validation);\\n          }\\n        } else if (issue.validation !== \"regex\") {\\n          message = `Invalid ${issue.validation}`;\\n        } else {\\n          message = \"Invalid\";\\n        }\\n        break;\\n      case ZodIssueCode.too_small:\\n        if (issue.type === \"array\")\\n          message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\\n        else if (issue.type === \"string\")\\n          message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\\n        else if (issue.type === \"number\")\\n          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\\n        else if (issue.type === \"date\")\\n          message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;\\n        else\\n          message = \"Invalid input\";\\n        break;\\n      case ZodIssueCode.too_big:\\n        if (issue.type === \"array\")\\n          message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\\n        else if (issue.type === \"string\")\\n          message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\\n        else if (issue.type === \"number\")\\n          message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\\n        else if (issue.type === \"bigint\")\\n          message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\\n        else if (issue.type === \"date\")\\n          message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;\\n        else\\n          message = \"Invalid input\";\\n        break;\\n      case ZodIssueCode.custom:\\n        message = `Invalid input`;\\n        break;\\n      case ZodIssueCode.invalid_intersection_types:\\n        message = `Intersection results could not be merged`;\\n        break;\\n      case ZodIssueCode.not_multiple_of:\\n        message = `Number must be a multiple of ${issue.multipleOf}`;\\n        break;\\n      case ZodIssueCode.not_finite:\\n        message = \"Number must be finite\";\\n        break;\\n      default:\\n        message = _ctx.defaultError;\\n        util.assertNever(issue);\\n    }\\n    return { message };\\n  };\\n  var overrideErrorMap = errorMap;\\n  function setErrorMap(map) {\\n    overrideErrorMap = map;\\n  }\\n  function getErrorMap() {\\n    return overrideErrorMap;\\n  }\\n  var makeIssue = (params) => {\\n    const { data, path, errorMaps, issueData } = params;\\n    const fullPath = [...path, ...issueData.path || []];\\n    const fullIssue = {\\n      ...issueData,\\n      path: fullPath\\n    };\\n    if (issueData.message !== void 0) {\\n      return {\\n        ...issueData,\\n        path: fullPath,\\n        message: issueData.message\\n      };\\n    }\\n    let errorMessage = \"\";\\n    const maps = errorMaps.filter((m) => !!m).slice().reverse();\\n    for (const map of maps) {\\n      errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\\n    }\\n    return {\\n      ...issueData,\\n      path: fullPath,\\n      message: errorMessage\\n    };\\n  };\\n  var EMPTY_PATH = [];\\n  function addIssueToContext(ctx, issueData) {\\n    const overrideMap = getErrorMap();\\n    const issue = makeIssue({\\n      issueData,\\n      data: ctx.data,\\n      path: ctx.path,\\n      errorMaps: [\\n        ctx.common.contextualErrorMap,\\n        // contextual error map is first priority\\n        ctx.schemaErrorMap,\\n        // then schema-bound map if available\\n        overrideMap,\\n        // then global override map\\n        overrideMap === errorMap ? void 0 : errorMap\\n        // then global default map\\n      ].filter((x) => !!x)\\n    });\\n    ctx.common.issues.push(issue);\\n  }\\n  var ParseStatus = class _ParseStatus {\\n    constructor() {\\n      this.value = \"valid\";\\n    }\\n    dirty() {\\n      if (this.value === \"valid\")\\n        this.value = \"dirty\";\\n    }\\n    abort() {\\n      if (this.value !== \"aborted\")\\n        this.value = \"aborted\";\\n    }\\n    static mergeArray(status, results) {\\n      const arrayValue = [];\\n      for (const s of results) {\\n        if (s.status === \"aborted\")\\n          return INVALID;\\n        if (s.status === \"dirty\")\\n          status.dirty();\\n        arrayValue.push(s.value);\\n      }\\n      return { status: status.value, value: arrayValue };\\n    }\\n    static async mergeObjectAsync(status, pairs) {\\n      const syncPairs = [];\\n      for (const pair of pairs) {\\n        const key = await pair.key;\\n        const value = await pair.value;\\n        syncPairs.push({\\n          key,\\n          value\\n        });\\n      }\\n      return _ParseStatus.mergeObjectSync(status, syncPairs);\\n    }\\n    static mergeObjectSync(status, pairs) {\\n      const finalObject = {};\\n      for (const pair of pairs) {\\n        const { key, value } = pair;\\n        if (key.status === \"aborted\")\\n          return INVALID;\\n        if (value.status === \"aborted\")\\n          return INVALID;\\n        if (key.status === \"dirty\")\\n          status.dirty();\\n        if (value.status === \"dirty\")\\n          status.dirty();\\n        if (key.value !== \"__proto__\" && (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\\n          finalObject[key.value] = value.value;\\n        }\\n      }\\n      return { status: status.value, value: finalObject };\\n    }\\n  };\\n  var INVALID = Object.freeze({\\n    status: \"aborted\"\\n  });\\n  var DIRTY = (value) => ({ status: \"dirty\", value });\\n  var OK = (value) => ({ status: \"valid\", value });\\n  var isAborted = (x) => x.status === \"aborted\";\\n  var isDirty = (x) => x.status === \"dirty\";\\n  var isValid = (x) => x.status === \"valid\";\\n  var isAsync = (x) => typeof Promise !== \"undefined\" && x instanceof Promise;\\n  function __classPrivateFieldGet(receiver, state, kind, f) {\\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\\n  }\\n  function __classPrivateFieldSet(receiver, state, value, kind, f) {\\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\\n  }\\n  var errorUtil;\\n  (function(errorUtil2) {\\n    errorUtil2.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\\n    errorUtil2.toString = (message) => typeof message === \"string\" ? message : message === null || message === void 0 ? void 0 : message.message;\\n  })(errorUtil || (errorUtil = {}));\\n  var _ZodEnum_cache;\\n  var _ZodNativeEnum_cache;\\n  var ParseInputLazyPath = class {\\n    constructor(parent, value, path, key) {\\n      this._cachedPath = [];\\n      this.parent = parent;\\n      this.data = value;\\n      this._path = path;\\n      this._key = key;\\n    }\\n    get path() {\\n      if (!this._cachedPath.length) {\\n        if (this._key instanceof Array) {\\n          this._cachedPath.push(...this._path, ...this._key);\\n        } else {\\n          this._cachedPath.push(...this._path, this._key);\\n        }\\n      }\\n      return this._cachedPath;\\n    }\\n  };\\n  var handleResult = (ctx, result) => {\\n    if (isValid(result)) {\\n      return { success: true, data: result.value };\\n    } else {\\n      if (!ctx.common.issues.length) {\\n        throw new Error(\"Validation failed but no issues detected.\");\\n      }\\n      return {\\n        success: false,\\n        get error() {\\n          if (this._error)\\n            return this._error;\\n          const error = new ZodError(ctx.common.issues);\\n          this._error = error;\\n          return this._error;\\n        }\\n      };\\n    }\\n  };\\n  function processCreateParams(params) {\\n    if (!params)\\n      return {};\\n    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;\\n    if (errorMap2 && (invalid_type_error || required_error)) {\\n      throw new Error(`Can\\'t use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\\n    }\\n    if (errorMap2)\\n      return { errorMap: errorMap2, description };\\n    const customMap = (iss, ctx) => {\\n      var _a, _b;\\n      const { message } = params;\\n      if (iss.code === \"invalid_enum_value\") {\\n        return { message: message !== null && message !== void 0 ? message : ctx.defaultError };\\n      }\\n      if (typeof ctx.data === \"undefined\") {\\n        return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };\\n      }\\n      if (iss.code !== \"invalid_type\")\\n        return { message: ctx.defaultError };\\n      return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };\\n    };\\n    return { errorMap: customMap, description };\\n  }\\n  var ZodType = class {\\n    get description() {\\n      return this._def.description;\\n    }\\n    _getType(input) {\\n      return getParsedType(input.data);\\n    }\\n    _getOrReturnCtx(input, ctx) {\\n      return ctx || {\\n        common: input.parent.common,\\n        data: input.data,\\n        parsedType: getParsedType(input.data),\\n        schemaErrorMap: this._def.errorMap,\\n        path: input.path,\\n        parent: input.parent\\n      };\\n    }\\n    _processInputParams(input) {\\n      return {\\n        status: new ParseStatus(),\\n        ctx: {\\n          common: input.parent.common,\\n          data: input.data,\\n          parsedType: getParsedType(input.data),\\n          schemaErrorMap: this._def.errorMap,\\n          path: input.path,\\n          parent: input.parent\\n        }\\n      };\\n    }\\n    _parseSync(input) {\\n      const result = this._parse(input);\\n      if (isAsync(result)) {\\n        throw new Error(\"Synchronous parse encountered promise.\");\\n      }\\n      return result;\\n    }\\n    _parseAsync(input) {\\n      const result = this._parse(input);\\n      return Promise.resolve(result);\\n    }\\n    parse(data, params) {\\n      const result = this.safeParse(data, params);\\n      if (result.success)\\n        return result.data;\\n      throw result.error;\\n    }\\n    safeParse(data, params) {\\n      var _a;\\n      const ctx = {\\n        common: {\\n          issues: [],\\n          async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,\\n          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap\\n        },\\n        path: (params === null || params === void 0 ? void 0 : params.path) || [],\\n        schemaErrorMap: this._def.errorMap,\\n        parent: null,\\n        data,\\n        parsedType: getParsedType(data)\\n      };\\n      const result = this._parseSync({ data, path: ctx.path, parent: ctx });\\n      return handleResult(ctx, result);\\n    }\\n    \"~validate\"(data) {\\n      var _a, _b;\\n      const ctx = {\\n        common: {\\n          issues: [],\\n          async: !!this[\"~standard\"].async\\n        },\\n        path: [],\\n        schemaErrorMap: this._def.errorMap,\\n        parent: null,\\n        data,\\n        parsedType: getParsedType(data)\\n      };\\n      if (!this[\"~standard\"].async) {\\n        try {\\n          const result = this._parseSync({ data, path: [], parent: ctx });\\n          return isValid(result) ? {\\n            value: result.value\\n          } : {\\n            issues: ctx.common.issues\\n          };\\n        } catch (err) {\\n          if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes(\"encountered\")) {\\n            this[\"~standard\"].async = true;\\n          }\\n          ctx.common = {\\n            issues: [],\\n            async: true\\n          };\\n        }\\n      }\\n      return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {\\n        value: result.value\\n      } : {\\n        issues: ctx.common.issues\\n      });\\n    }\\n    async parseAsync(data, params) {\\n      const result = await this.safeParseAsync(data, params);\\n      if (result.success)\\n        return result.data;\\n      throw result.error;\\n    }\\n    async safeParseAsync(data, params) {\\n      const ctx = {\\n        common: {\\n          issues: [],\\n          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\\n          async: true\\n        },\\n        path: (params === null || params === void 0 ? void 0 : params.path) || [],\\n        schemaErrorMap: this._def.errorMap,\\n        parent: null,\\n        data,\\n        parsedType: getParsedType(data)\\n      };\\n      const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\\n      const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\\n      return handleResult(ctx, result);\\n    }\\n    refine(check, message) {\\n      const getIssueProperties = (val) => {\\n        if (typeof message === \"string\" || typeof message === \"undefined\") {\\n          return { message };\\n        } else if (typeof message === \"function\") {\\n          return message(val);\\n        } else {\\n          return message;\\n        }\\n      };\\n      return this._refinement((val, ctx) => {\\n        const result = check(val);\\n        const setError = () => ctx.addIssue({\\n          code: ZodIssueCode.custom,\\n          ...getIssueProperties(val)\\n        });\\n        if (typeof Promise !== \"undefined\" && result instanceof Promise) {\\n          return result.then((data) => {\\n            if (!data) {\\n              setError();\\n              return false;\\n            } else {\\n              return true;\\n            }\\n          });\\n        }\\n        if (!result) {\\n          setError();\\n          return false;\\n        } else {\\n          return true;\\n        }\\n      });\\n    }\\n    refinement(check, refinementData) {\\n      return this._refinement((val, ctx) => {\\n        if (!check(val)) {\\n          ctx.addIssue(typeof refinementData === \"function\" ? refinementData(val, ctx) : refinementData);\\n          return false;\\n        } else {\\n          return true;\\n        }\\n      });\\n    }\\n    _refinement(refinement) {\\n      return new ZodEffects({\\n        schema: this,\\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\\n        effect: { type: \"refinement\", refinement }\\n      });\\n    }\\n    superRefine(refinement) {\\n      return this._refinement(refinement);\\n    }\\n    constructor(def) {\\n      this.spa = this.safeParseAsync;\\n      this._def = def;\\n      this.parse = this.parse.bind(this);\\n      this.safeParse = this.safeParse.bind(this);\\n      this.parseAsync = this.parseAsync.bind(this);\\n      this.safeParseAsync = this.safeParseAsync.bind(this);\\n      this.spa = this.spa.bind(this);\\n      this.refine = this.refine.bind(this);\\n      this.refinement = this.refinement.bind(this);\\n      this.superRefine = this.superRefine.bind(this);\\n      this.optional = this.optional.bind(this);\\n      this.nullable = this.nullable.bind(this);\\n      this.nullish = this.nullish.bind(this);\\n      this.array = this.array.bind(this);\\n      this.promise = this.promise.bind(this);\\n      this.or = this.or.bind(this);\\n      this.and = this.and.bind(this);\\n      this.transform = this.transform.bind(this);\\n      this.brand = this.brand.bind(this);\\n      this.default = this.default.bind(this);\\n      this.catch = this.catch.bind(this);\\n      this.describe = this.describe.bind(this);\\n      this.pipe = this.pipe.bind(this);\\n      this.readonly = this.readonly.bind(this);\\n      this.isNullable = this.isNullable.bind(this);\\n      this.isOptional = this.isOptional.bind(this);\\n      this[\"~standard\"] = {\\n        version: 1,\\n        vendor: \"zod\",\\n        validate: (data) => this[\"~validate\"](data)\\n      };\\n    }\\n    optional() {\\n      return ZodOptional.create(this, this._def);\\n    }\\n    nullable() {\\n      return ZodNullable.create(this, this._def);\\n    }\\n    nullish() {\\n      return this.nullable().optional();\\n    }\\n    array() {\\n      return ZodArray.create(this);\\n    }\\n    promise() {\\n      return ZodPromise.create(this, this._def);\\n    }\\n    or(option) {\\n      return ZodUnion.create([this, option], this._def);\\n    }\\n    and(incoming) {\\n      return ZodIntersection.create(this, incoming, this._def);\\n    }\\n    transform(transform) {\\n      return new ZodEffects({\\n        ...processCreateParams(this._def),\\n        schema: this,\\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\\n        effect: { type: \"transform\", transform }\\n      });\\n    }\\n    default(def) {\\n      const defaultValueFunc = typeof def === \"function\" ? def : () => def;\\n      return new ZodDefault({\\n        ...processCreateParams(this._def),\\n        innerType: this,\\n        defaultValue: defaultValueFunc,\\n        typeName: ZodFirstPartyTypeKind.ZodDefault\\n      });\\n    }\\n    brand() {\\n      return new ZodBranded({\\n        typeName: ZodFirstPartyTypeKind.ZodBranded,\\n        type: this,\\n        ...processCreateParams(this._def)\\n      });\\n    }\\n    catch(def) {\\n      const catchValueFunc = typeof def === \"function\" ? def : () => def;\\n      return new ZodCatch({\\n        ...processCreateParams(this._def),\\n        innerType: this,\\n        catchValue: catchValueFunc,\\n        typeName: ZodFirstPartyTypeKind.ZodCatch\\n      });\\n    }\\n    describe(description) {\\n      const This = this.constructor;\\n      return new This({\\n        ...this._def,\\n        description\\n      });\\n    }\\n    pipe(target) {\\n      return ZodPipeline.create(this, target);\\n    }\\n    readonly() {\\n      return ZodReadonly.create(this);\\n    }\\n    isOptional() {\\n      return this.safeParse(void 0).success;\\n    }\\n    isNullable() {\\n      return this.safeParse(null).success;\\n    }\\n  };\\n  var cuidRegex = /^c[^\\\\s-]{8,}$/i;\\n  var cuid2Regex = /^[0-9a-z]+$/;\\n  var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;\\n  var uuidRegex = /^[0-9a-fA-F]{8}\\\\b-[0-9a-fA-F]{4}\\\\b-[0-9a-fA-F]{4}\\\\b-[0-9a-fA-F]{4}\\\\b-[0-9a-fA-F]{12}$/i;\\n  var nanoidRegex = /^[a-z0-9_-]{21}$/i;\\n  var jwtRegex = /^[A-Za-z0-9-_]+\\\\.[A-Za-z0-9-_]+\\\\.[A-Za-z0-9-_]*$/;\\n  var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\\\d+Y)|(?:[-+]?\\\\d+[.,]\\\\d+Y$))?(?:(?:[-+]?\\\\d+M)|(?:[-+]?\\\\d+[.,]\\\\d+M$))?(?:(?:[-+]?\\\\d+W)|(?:[-+]?\\\\d+[.,]\\\\d+W$))?(?:(?:[-+]?\\\\d+D)|(?:[-+]?\\\\d+[.,]\\\\d+D$))?(?:T(?=[\\\\d+-])(?:(?:[-+]?\\\\d+H)|(?:[-+]?\\\\d+[.,]\\\\d+H$))?(?:(?:[-+]?\\\\d+M)|(?:[-+]?\\\\d+[.,]\\\\d+M$))?(?:[-+]?\\\\d+(?:[.,]\\\\d+)?S)?)??$/;\\n  var emailRegex = /^(?!\\\\.)(?!.*\\\\.\\\\.)([A-Z0-9_\\'+\\\\-\\\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\\\-]*\\\\.)+[A-Z]{2,}$/i;\\n  var _emojiRegex = `^(\\\\\\\\p{Extended_Pictographic}|\\\\\\\\p{Emoji_Component})+$`;\\n  var emojiRegex;\\n  var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\\n  var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\\\/(3[0-2]|[12]?[0-9])$/;\\n  var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;\\n  var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\\n  var base64Regex2 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\\n  var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;\\n  var dateRegexSource = `((\\\\\\\\d\\\\\\\\d[2468][048]|\\\\\\\\d\\\\\\\\d[13579][26]|\\\\\\\\d\\\\\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\\\\\d|30)|(02)-(0[1-9]|1\\\\\\\\d|2[0-8])))`;\\n  var dateRegex = new RegExp(`^${dateRegexSource}$`);\\n  function timeRegexSource(args) {\\n    let regex = `([01]\\\\\\\\d|2[0-3]):[0-5]\\\\\\\\d:[0-5]\\\\\\\\d`;\\n    if (args.precision) {\\n      regex = `${regex}\\\\\\\\.\\\\\\\\d{${args.precision}}`;\\n    } else if (args.precision == null) {\\n      regex = `${regex}(\\\\\\\\.\\\\\\\\d+)?`;\\n    }\\n    return regex;\\n  }\\n  function timeRegex(args) {\\n    return new RegExp(`^${timeRegexSource(args)}$`);\\n  }\\n  function datetimeRegex(args) {\\n    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\\n    const opts = [];\\n    opts.push(args.local ? `Z?` : `Z`);\\n    if (args.offset)\\n      opts.push(`([+-]\\\\\\\\d{2}:?\\\\\\\\d{2})`);\\n    regex = `${regex}(${opts.join(\"|\")})`;\\n    return new RegExp(`^${regex}$`);\\n  }\\n  function isValidIP(ip, version4) {\\n    if ((version4 === \"v4\" || !version4) && ipv4Regex.test(ip)) {\\n      return true;\\n    }\\n    if ((version4 === \"v6\" || !version4) && ipv6Regex.test(ip)) {\\n      return true;\\n    }\\n    return false;\\n  }\\n  function isValidJWT(jwt, alg) {\\n    if (!jwtRegex.test(jwt))\\n      return false;\\n    try {\\n      const [header] = jwt.split(\".\");\\n      const base64 = header.replace(/-/g, \"+\").replace(/_/g, \"/\").padEnd(header.length + (4 - header.length % 4) % 4, \"=\");\\n      const decoded = JSON.parse(atob(base64));\\n      if (typeof decoded !== \"object\" || decoded === null)\\n        return false;\\n      if (!decoded.typ || !decoded.alg)\\n        return false;\\n      if (alg && decoded.alg !== alg)\\n        return false;\\n      return true;\\n    } catch (_a) {\\n      return false;\\n    }\\n  }\\n  function isValidCidr(ip, version4) {\\n    if ((version4 === \"v4\" || !version4) && ipv4CidrRegex.test(ip)) {\\n      return true;\\n    }\\n    if ((version4 === \"v6\" || !version4) && ipv6CidrRegex.test(ip)) {\\n      return true;\\n    }\\n    return false;\\n  }\\n  var ZodString = class _ZodString extends ZodType {\\n    _parse(input) {\\n      if (this._def.coerce) {\\n        input.data = String(input.data);\\n      }\\n      const parsedType = this._getType(input);\\n      if (parsedType !== ZodParsedType.string) {\\n        const ctx2 = this._getOrReturnCtx(input);\\n        addIssueToContext(ctx2, {\\n          code: ZodIssueCode.invalid_type,\\n          expected: ZodParsedType.string,\\n          received: ctx2.parsedType\\n        });\\n        return INVALID;\\n      }\\n      const status = new ParseStatus();\\n      let ctx = void 0;\\n      for (const check of this._def.checks) {\\n        if (check.kind === \"min\") {\\n          if (input.data.length < check.value) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              code: ZodIssueCode.too_small,\\n              minimum: check.value,\\n              type: \"string\",\\n              inclusive: true,\\n              exact: false,\\n              message: check.message\\n            });\\n            status.dirty();\\n          }\\n        } else if (check.kind === \"max\") {\\n          if (input.data.length > check.value) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              code: ZodIssueCode.too_big,\\n              maximum: check.value,\\n              type: \"string\",\\n              inclusive: true,\\n              exact: false,\\n              message: check.message\\n            });\\n            status.dirty();\\n          }\\n        } else if (check.kind === \"length\") {\\n          const tooBig = input.data.length > check.value;\\n          const tooSmall = input.data.length < check.value;\\n          if (tooBig || tooSmall) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            if (tooBig) {\\n              addIssueToContext(ctx, {\\n                code: ZodIssueCode.too_big,\\n                maximum: check.value,\\n                type: \"string\",\\n                inclusive: true,\\n                exact: true,\\n                message: check.message\\n              });\\n            } else if (tooSmall) {\\n              addIssueToContext(ctx, {\\n                code: ZodIssueCode.too_small,\\n                minimum: check.value,\\n                type: \"string\",\\n                inclusive: true,\\n                exact: true,\\n                message: check.message\\n              });\\n            }\\n            status.dirty();\\n          }\\n        } else if (check.kind === \"email\") {\\n          if (!emailRegex.test(input.data)) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              validation: \"email\",\\n              code: ZodIssueCode.invalid_string,\\n              message: check.message\\n            });\\n            status.dirty();\\n          }\\n        } else if (check.kind === \"emoji\") {\\n          if (!emojiRegex) {\\n            emojiRegex = new RegExp(_emojiRegex, \"u\");\\n          }\\n          if (!emojiRegex.test(input.data)) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              validation: \"emoji\",\\n              code: ZodIssueCode.invalid_string,\\n              message: check.message\\n            });\\n            status.dirty();\\n          }\\n        } else if (check.kind === \"uuid\") {\\n          if (!uuidRegex.test(input.data)) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              validation: \"uuid\",\\n              code: ZodIssueCode.invalid_string,\\n              message: check.message\\n            });\\n            status.dirty();\\n          }\\n        } else if (check.kind === \"nanoid\") {\\n          if (!nanoidRegex.test(input.data)) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              validation: \"nanoid\",\\n              code: ZodIssueCode.invalid_string,\\n              message: check.message\\n            });\\n            status.dirty();\\n          }\\n        } else if (check.kind === \"cuid\") {\\n          if (!cuidRegex.test(input.data)) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              validation: \"cuid\",\\n              code: ZodIssueCode.invalid_string,\\n              message: check.message\\n            });\\n            status.dirty();\\n          }\\n        } else if (check.kind === \"cuid2\") {\\n          if (!cuid2Regex.test(input.data)) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              validation: \"cuid2\",\\n              code: ZodIssueCode.invalid_string,\\n              message: check.message\\n            });\\n            status.dirty();\\n          }\\n        } else if (check.kind === \"ulid\") {\\n          if (!ulidRegex.test(input.data)) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              validation: \"ulid\",\\n              code: ZodIssueCode.invalid_string,\\n              message: check.message\\n            });\\n            status.dirty();\\n          }\\n        } else if (check.kind === \"url\") {\\n          try {\\n            new URL(input.data);\\n          } catch (_a) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              validation: \"url\",\\n              code: ZodIssueCode.invalid_string,\\n              message: check.message\\n            });\\n            status.dirty();\\n          }\\n        } else if (check.kind === \"regex\") {\\n          check.regex.lastIndex = 0;\\n          const testResult = check.regex.test(input.data);\\n          if (!testResult) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              validation: \"regex\",\\n              code: ZodIssueCode.invalid_string,\\n              message: check.message\\n            });\\n            status.dirty();\\n          }\\n        } else if (check.kind === \"trim\") {\\n          input.data = input.data.trim();\\n        } else if (check.kind === \"includes\") {\\n          if (!input.data.includes(check.value, check.position)) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              code: ZodIssueCode.invalid_string,\\n              validation: { includes: check.value, position: check.position },\\n              message: check.message\\n            });\\n            status.dirty();\\n          }\\n        } else if (check.kind === \"toLowerCase\") {\\n          input.data = input.data.toLowerCase();\\n        } else if (check.kind === \"toUpperCase\") {\\n          input.data = input.data.toUpperCase();\\n        } else if (check.kind === \"startsWith\") {\\n          if (!input.data.startsWith(check.value)) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              code: ZodIssueCode.invalid_string,\\n              validation: { startsWith: check.value },\\n              message: check.message\\n            });\\n            status.dirty();\\n          }\\n        } else if (check.kind === \"endsWith\") {\\n          if (!input.data.endsWith(check.value)) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              code: ZodIssueCode.invalid_string,\\n              validation: { endsWith: check.value },\\n              message: check.message\\n            });\\n            status.dirty();\\n          }\\n        } else if (check.kind === \"datetime\") {\\n          const regex = datetimeRegex(check);\\n          if (!regex.test(input.data)) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              code: ZodIssueCode.invalid_string,\\n              validation: \"datetime\",\\n              message: check.message\\n            });\\n            status.dirty();\\n          }\\n        } else if (check.kind === \"date\") {\\n          const regex = dateRegex;\\n          if (!regex.test(input.data)) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              code: ZodIssueCode.invalid_string,\\n              validation: \"date\",\\n              message: check.message\\n            });\\n            status.dirty();\\n          }\\n        } else if (check.kind === \"time\") {\\n          const regex = timeRegex(check);\\n          if (!regex.test(input.data)) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              code: ZodIssueCode.invalid_string,\\n              validation: \"time\",\\n              message: check.message\\n            });\\n            status.dirty();\\n          }\\n        } else if (check.kind === \"duration\") {\\n          if (!durationRegex.test(input.data)) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              validation: \"duration\",\\n              code: ZodIssueCode.invalid_string,\\n              message: check.message\\n            });\\n            status.dirty();\\n          }\\n        } else if (check.kind === \"ip\") {\\n          if (!isValidIP(input.data, check.version)) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              validation: \"ip\",\\n              code: ZodIssueCode.invalid_string,\\n              message: check.message\\n            });\\n            status.dirty();\\n          }\\n        } else if (check.kind === \"jwt\") {\\n          if (!isValidJWT(input.data, check.alg)) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              validation: \"jwt\",\\n              code: ZodIssueCode.invalid_string,\\n              message: check.message\\n            });\\n            status.dirty();\\n          }\\n        } else if (check.kind === \"cidr\") {\\n          if (!isValidCidr(input.data, check.version)) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              validation: \"cidr\",\\n              code: ZodIssueCode.invalid_string,\\n              message: check.message\\n            });\\n            status.dirty();\\n          }\\n        } else if (check.kind === \"base64\") {\\n          if (!base64Regex2.test(input.data)) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              validation: \"base64\",\\n              code: ZodIssueCode.invalid_string,\\n              message: check.message\\n            });\\n            status.dirty();\\n          }\\n        } else if (check.kind === \"base64url\") {\\n          if (!base64urlRegex.test(input.data)) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              validation: \"base64url\",\\n              code: ZodIssueCode.invalid_string,\\n              message: check.message\\n            });\\n            status.dirty();\\n          }\\n        } else {\\n          util.assertNever(check);\\n        }\\n      }\\n      return { status: status.value, value: input.data };\\n    }\\n    _regex(regex, validation, message) {\\n      return this.refinement((data) => regex.test(data), {\\n        validation,\\n        code: ZodIssueCode.invalid_string,\\n        ...errorUtil.errToObj(message)\\n      });\\n    }\\n    _addCheck(check) {\\n      return new _ZodString({\\n        ...this._def,\\n        checks: [...this._def.checks, check]\\n      });\\n    }\\n    email(message) {\\n      return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\\n    }\\n    url(message) {\\n      return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\\n    }\\n    emoji(message) {\\n      return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message) });\\n    }\\n    uuid(message) {\\n      return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\\n    }\\n    nanoid(message) {\\n      return this._addCheck({ kind: \"nanoid\", ...errorUtil.errToObj(message) });\\n    }\\n    cuid(message) {\\n      return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\\n    }\\n    cuid2(message) {\\n      return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message) });\\n    }\\n    ulid(message) {\\n      return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message) });\\n    }\\n    base64(message) {\\n      return this._addCheck({ kind: \"base64\", ...errorUtil.errToObj(message) });\\n    }\\n    base64url(message) {\\n      return this._addCheck({\\n        kind: \"base64url\",\\n        ...errorUtil.errToObj(message)\\n      });\\n    }\\n    jwt(options) {\\n      return this._addCheck({ kind: \"jwt\", ...errorUtil.errToObj(options) });\\n    }\\n    ip(options) {\\n      return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\\n    }\\n    cidr(options) {\\n      return this._addCheck({ kind: \"cidr\", ...errorUtil.errToObj(options) });\\n    }\\n    datetime(options) {\\n      var _a, _b;\\n      if (typeof options === \"string\") {\\n        return this._addCheck({\\n          kind: \"datetime\",\\n          precision: null,\\n          offset: false,\\n          local: false,\\n          message: options\\n        });\\n      }\\n      return this._addCheck({\\n        kind: \"datetime\",\\n        precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\\n        offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,\\n        local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,\\n        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)\\n      });\\n    }\\n    date(message) {\\n      return this._addCheck({ kind: \"date\", message });\\n    }\\n    time(options) {\\n      if (typeof options === \"string\") {\\n        return this._addCheck({\\n          kind: \"time\",\\n          precision: null,\\n          message: options\\n        });\\n      }\\n      return this._addCheck({\\n        kind: \"time\",\\n        precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\\n        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)\\n      });\\n    }\\n    duration(message) {\\n      return this._addCheck({ kind: \"duration\", ...errorUtil.errToObj(message) });\\n    }\\n    regex(regex, message) {\\n      return this._addCheck({\\n        kind: \"regex\",\\n        regex,\\n        ...errorUtil.errToObj(message)\\n      });\\n    }\\n    includes(value, options) {\\n      return this._addCheck({\\n        kind: \"includes\",\\n        value,\\n        position: options === null || options === void 0 ? void 0 : options.position,\\n        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)\\n      });\\n    }\\n    startsWith(value, message) {\\n      return this._addCheck({\\n        kind: \"startsWith\",\\n        value,\\n        ...errorUtil.errToObj(message)\\n      });\\n    }\\n    endsWith(value, message) {\\n      return this._addCheck({\\n        kind: \"endsWith\",\\n        value,\\n        ...errorUtil.errToObj(message)\\n      });\\n    }\\n    min(minLength, message) {\\n      return this._addCheck({\\n        kind: \"min\",\\n        value: minLength,\\n        ...errorUtil.errToObj(message)\\n      });\\n    }\\n    max(maxLength, message) {\\n      return this._addCheck({\\n        kind: \"max\",\\n        value: maxLength,\\n        ...errorUtil.errToObj(message)\\n      });\\n    }\\n    length(len, message) {\\n      return this._addCheck({\\n        kind: \"length\",\\n        value: len,\\n        ...errorUtil.errToObj(message)\\n      });\\n    }\\n    /**\\n     * Equivalent to `.min(1)`\\n     */\\n    nonempty(message) {\\n      return this.min(1, errorUtil.errToObj(message));\\n    }\\n    trim() {\\n      return new _ZodString({\\n        ...this._def,\\n        checks: [...this._def.checks, { kind: \"trim\" }]\\n      });\\n    }\\n    toLowerCase() {\\n      return new _ZodString({\\n        ...this._def,\\n        checks: [...this._def.checks, { kind: \"toLowerCase\" }]\\n      });\\n    }\\n    toUpperCase() {\\n      return new _ZodString({\\n        ...this._def,\\n        checks: [...this._def.checks, { kind: \"toUpperCase\" }]\\n      });\\n    }\\n    get isDatetime() {\\n      return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\\n    }\\n    get isDate() {\\n      return !!this._def.checks.find((ch) => ch.kind === \"date\");\\n    }\\n    get isTime() {\\n      return !!this._def.checks.find((ch) => ch.kind === \"time\");\\n    }\\n    get isDuration() {\\n      return !!this._def.checks.find((ch) => ch.kind === \"duration\");\\n    }\\n    get isEmail() {\\n      return !!this._def.checks.find((ch) => ch.kind === \"email\");\\n    }\\n    get isURL() {\\n      return !!this._def.checks.find((ch) => ch.kind === \"url\");\\n    }\\n    get isEmoji() {\\n      return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\\n    }\\n    get isUUID() {\\n      return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\\n    }\\n    get isNANOID() {\\n      return !!this._def.checks.find((ch) => ch.kind === \"nanoid\");\\n    }\\n    get isCUID() {\\n      return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\\n    }\\n    get isCUID2() {\\n      return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\\n    }\\n    get isULID() {\\n      return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\\n    }\\n    get isIP() {\\n      return !!this._def.checks.find((ch) => ch.kind === \"ip\");\\n    }\\n    get isCIDR() {\\n      return !!this._def.checks.find((ch) => ch.kind === \"cidr\");\\n    }\\n    get isBase64() {\\n      return !!this._def.checks.find((ch) => ch.kind === \"base64\");\\n    }\\n    get isBase64url() {\\n      return !!this._def.checks.find((ch) => ch.kind === \"base64url\");\\n    }\\n    get minLength() {\\n      let min = null;\\n      for (const ch of this._def.checks) {\\n        if (ch.kind === \"min\") {\\n          if (min === null || ch.value > min)\\n            min = ch.value;\\n        }\\n      }\\n      return min;\\n    }\\n    get maxLength() {\\n      let max = null;\\n      for (const ch of this._def.checks) {\\n        if (ch.kind === \"max\") {\\n          if (max === null || ch.value < max)\\n            max = ch.value;\\n        }\\n      }\\n      return max;\\n    }\\n  };\\n  ZodString.create = (params) => {\\n    var _a;\\n    return new ZodString({\\n      checks: [],\\n      typeName: ZodFirstPartyTypeKind.ZodString,\\n      coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  function floatSafeRemainder(val, step) {\\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\\n    const valInt = parseInt(val.toFixed(decCount).replace(\".\", \"\"));\\n    const stepInt = parseInt(step.toFixed(decCount).replace(\".\", \"\"));\\n    return valInt % stepInt / Math.pow(10, decCount);\\n  }\\n  var ZodNumber = class _ZodNumber extends ZodType {\\n    constructor() {\\n      super(...arguments);\\n      this.min = this.gte;\\n      this.max = this.lte;\\n      this.step = this.multipleOf;\\n    }\\n    _parse(input) {\\n      if (this._def.coerce) {\\n        input.data = Number(input.data);\\n      }\\n      const parsedType = this._getType(input);\\n      if (parsedType !== ZodParsedType.number) {\\n        const ctx2 = this._getOrReturnCtx(input);\\n        addIssueToContext(ctx2, {\\n          code: ZodIssueCode.invalid_type,\\n          expected: ZodParsedType.number,\\n          received: ctx2.parsedType\\n        });\\n        return INVALID;\\n      }\\n      let ctx = void 0;\\n      const status = new ParseStatus();\\n      for (const check of this._def.checks) {\\n        if (check.kind === \"int\") {\\n          if (!util.isInteger(input.data)) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              code: ZodIssueCode.invalid_type,\\n              expected: \"integer\",\\n              received: \"float\",\\n              message: check.message\\n            });\\n            status.dirty();\\n          }\\n        } else if (check.kind === \"min\") {\\n          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\\n          if (tooSmall) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              code: ZodIssueCode.too_small,\\n              minimum: check.value,\\n              type: \"number\",\\n              inclusive: check.inclusive,\\n              exact: false,\\n              message: check.message\\n            });\\n            status.dirty();\\n          }\\n        } else if (check.kind === \"max\") {\\n          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\\n          if (tooBig) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              code: ZodIssueCode.too_big,\\n              maximum: check.value,\\n              type: \"number\",\\n              inclusive: check.inclusive,\\n              exact: false,\\n              message: check.message\\n            });\\n            status.dirty();\\n          }\\n        } else if (check.kind === \"multipleOf\") {\\n          if (floatSafeRemainder(input.data, check.value) !== 0) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              code: ZodIssueCode.not_multiple_of,\\n              multipleOf: check.value,\\n              message: check.message\\n            });\\n            status.dirty();\\n          }\\n        } else if (check.kind === \"finite\") {\\n          if (!Number.isFinite(input.data)) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              code: ZodIssueCode.not_finite,\\n              message: check.message\\n            });\\n            status.dirty();\\n          }\\n        } else {\\n          util.assertNever(check);\\n        }\\n      }\\n      return { status: status.value, value: input.data };\\n    }\\n    gte(value, message) {\\n      return this.setLimit(\"min\", value, true, errorUtil.toString(message));\\n    }\\n    gt(value, message) {\\n      return this.setLimit(\"min\", value, false, errorUtil.toString(message));\\n    }\\n    lte(value, message) {\\n      return this.setLimit(\"max\", value, true, errorUtil.toString(message));\\n    }\\n    lt(value, message) {\\n      return this.setLimit(\"max\", value, false, errorUtil.toString(message));\\n    }\\n    setLimit(kind, value, inclusive, message) {\\n      return new _ZodNumber({\\n        ...this._def,\\n        checks: [\\n          ...this._def.checks,\\n          {\\n            kind,\\n            value,\\n            inclusive,\\n            message: errorUtil.toString(message)\\n          }\\n        ]\\n      });\\n    }\\n    _addCheck(check) {\\n      return new _ZodNumber({\\n        ...this._def,\\n        checks: [...this._def.checks, check]\\n      });\\n    }\\n    int(message) {\\n      return this._addCheck({\\n        kind: \"int\",\\n        message: errorUtil.toString(message)\\n      });\\n    }\\n    positive(message) {\\n      return this._addCheck({\\n        kind: \"min\",\\n        value: 0,\\n        inclusive: false,\\n        message: errorUtil.toString(message)\\n      });\\n    }\\n    negative(message) {\\n      return this._addCheck({\\n        kind: \"max\",\\n        value: 0,\\n        inclusive: false,\\n        message: errorUtil.toString(message)\\n      });\\n    }\\n    nonpositive(message) {\\n      return this._addCheck({\\n        kind: \"max\",\\n        value: 0,\\n        inclusive: true,\\n        message: errorUtil.toString(message)\\n      });\\n    }\\n    nonnegative(message) {\\n      return this._addCheck({\\n        kind: \"min\",\\n        value: 0,\\n        inclusive: true,\\n        message: errorUtil.toString(message)\\n      });\\n    }\\n    multipleOf(value, message) {\\n      return this._addCheck({\\n        kind: \"multipleOf\",\\n        value,\\n        message: errorUtil.toString(message)\\n      });\\n    }\\n    finite(message) {\\n      return this._addCheck({\\n        kind: \"finite\",\\n        message: errorUtil.toString(message)\\n      });\\n    }\\n    safe(message) {\\n      return this._addCheck({\\n        kind: \"min\",\\n        inclusive: true,\\n        value: Number.MIN_SAFE_INTEGER,\\n        message: errorUtil.toString(message)\\n      })._addCheck({\\n        kind: \"max\",\\n        inclusive: true,\\n        value: Number.MAX_SAFE_INTEGER,\\n        message: errorUtil.toString(message)\\n      });\\n    }\\n    get minValue() {\\n      let min = null;\\n      for (const ch of this._def.checks) {\\n        if (ch.kind === \"min\") {\\n          if (min === null || ch.value > min)\\n            min = ch.value;\\n        }\\n      }\\n      return min;\\n    }\\n    get maxValue() {\\n      let max = null;\\n      for (const ch of this._def.checks) {\\n        if (ch.kind === \"max\") {\\n          if (max === null || ch.value < max)\\n            max = ch.value;\\n        }\\n      }\\n      return max;\\n    }\\n    get isInt() {\\n      return !!this._def.checks.find((ch) => ch.kind === \"int\" || ch.kind === \"multipleOf\" && util.isInteger(ch.value));\\n    }\\n    get isFinite() {\\n      let max = null, min = null;\\n      for (const ch of this._def.checks) {\\n        if (ch.kind === \"finite\" || ch.kind === \"int\" || ch.kind === \"multipleOf\") {\\n          return true;\\n        } else if (ch.kind === \"min\") {\\n          if (min === null || ch.value > min)\\n            min = ch.value;\\n        } else if (ch.kind === \"max\") {\\n          if (max === null || ch.value < max)\\n            max = ch.value;\\n        }\\n      }\\n      return Number.isFinite(min) && Number.isFinite(max);\\n    }\\n  };\\n  ZodNumber.create = (params) => {\\n    return new ZodNumber({\\n      checks: [],\\n      typeName: ZodFirstPartyTypeKind.ZodNumber,\\n      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  var ZodBigInt = class _ZodBigInt extends ZodType {\\n    constructor() {\\n      super(...arguments);\\n      this.min = this.gte;\\n      this.max = this.lte;\\n    }\\n    _parse(input) {\\n      if (this._def.coerce) {\\n        try {\\n          input.data = BigInt(input.data);\\n        } catch (_a) {\\n          return this._getInvalidInput(input);\\n        }\\n      }\\n      const parsedType = this._getType(input);\\n      if (parsedType !== ZodParsedType.bigint) {\\n        return this._getInvalidInput(input);\\n      }\\n      let ctx = void 0;\\n      const status = new ParseStatus();\\n      for (const check of this._def.checks) {\\n        if (check.kind === \"min\") {\\n          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\\n          if (tooSmall) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              code: ZodIssueCode.too_small,\\n              type: \"bigint\",\\n              minimum: check.value,\\n              inclusive: check.inclusive,\\n              message: check.message\\n            });\\n            status.dirty();\\n          }\\n        } else if (check.kind === \"max\") {\\n          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\\n          if (tooBig) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              code: ZodIssueCode.too_big,\\n              type: \"bigint\",\\n              maximum: check.value,\\n              inclusive: check.inclusive,\\n              message: check.message\\n            });\\n            status.dirty();\\n          }\\n        } else if (check.kind === \"multipleOf\") {\\n          if (input.data % check.value !== BigInt(0)) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              code: ZodIssueCode.not_multiple_of,\\n              multipleOf: check.value,\\n              message: check.message\\n            });\\n            status.dirty();\\n          }\\n        } else {\\n          util.assertNever(check);\\n        }\\n      }\\n      return { status: status.value, value: input.data };\\n    }\\n    _getInvalidInput(input) {\\n      const ctx = this._getOrReturnCtx(input);\\n      addIssueToContext(ctx, {\\n        code: ZodIssueCode.invalid_type,\\n        expected: ZodParsedType.bigint,\\n        received: ctx.parsedType\\n      });\\n      return INVALID;\\n    }\\n    gte(value, message) {\\n      return this.setLimit(\"min\", value, true, errorUtil.toString(message));\\n    }\\n    gt(value, message) {\\n      return this.setLimit(\"min\", value, false, errorUtil.toString(message));\\n    }\\n    lte(value, message) {\\n      return this.setLimit(\"max\", value, true, errorUtil.toString(message));\\n    }\\n    lt(value, message) {\\n      return this.setLimit(\"max\", value, false, errorUtil.toString(message));\\n    }\\n    setLimit(kind, value, inclusive, message) {\\n      return new _ZodBigInt({\\n        ...this._def,\\n        checks: [\\n          ...this._def.checks,\\n          {\\n            kind,\\n            value,\\n            inclusive,\\n            message: errorUtil.toString(message)\\n          }\\n        ]\\n      });\\n    }\\n    _addCheck(check) {\\n      return new _ZodBigInt({\\n        ...this._def,\\n        checks: [...this._def.checks, check]\\n      });\\n    }\\n    positive(message) {\\n      return this._addCheck({\\n        kind: \"min\",\\n        value: BigInt(0),\\n        inclusive: false,\\n        message: errorUtil.toString(message)\\n      });\\n    }\\n    negative(message) {\\n      return this._addCheck({\\n        kind: \"max\",\\n        value: BigInt(0),\\n        inclusive: false,\\n        message: errorUtil.toString(message)\\n      });\\n    }\\n    nonpositive(message) {\\n      return this._addCheck({\\n        kind: \"max\",\\n        value: BigInt(0),\\n        inclusive: true,\\n        message: errorUtil.toString(message)\\n      });\\n    }\\n    nonnegative(message) {\\n      return this._addCheck({\\n        kind: \"min\",\\n        value: BigInt(0),\\n        inclusive: true,\\n        message: errorUtil.toString(message)\\n      });\\n    }\\n    multipleOf(value, message) {\\n      return this._addCheck({\\n        kind: \"multipleOf\",\\n        value,\\n        message: errorUtil.toString(message)\\n      });\\n    }\\n    get minValue() {\\n      let min = null;\\n      for (const ch of this._def.checks) {\\n        if (ch.kind === \"min\") {\\n          if (min === null || ch.value > min)\\n            min = ch.value;\\n        }\\n      }\\n      return min;\\n    }\\n    get maxValue() {\\n      let max = null;\\n      for (const ch of this._def.checks) {\\n        if (ch.kind === \"max\") {\\n          if (max === null || ch.value < max)\\n            max = ch.value;\\n        }\\n      }\\n      return max;\\n    }\\n  };\\n  ZodBigInt.create = (params) => {\\n    var _a;\\n    return new ZodBigInt({\\n      checks: [],\\n      typeName: ZodFirstPartyTypeKind.ZodBigInt,\\n      coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  var ZodBoolean = class extends ZodType {\\n    _parse(input) {\\n      if (this._def.coerce) {\\n        input.data = Boolean(input.data);\\n      }\\n      const parsedType = this._getType(input);\\n      if (parsedType !== ZodParsedType.boolean) {\\n        const ctx = this._getOrReturnCtx(input);\\n        addIssueToContext(ctx, {\\n          code: ZodIssueCode.invalid_type,\\n          expected: ZodParsedType.boolean,\\n          received: ctx.parsedType\\n        });\\n        return INVALID;\\n      }\\n      return OK(input.data);\\n    }\\n  };\\n  ZodBoolean.create = (params) => {\\n    return new ZodBoolean({\\n      typeName: ZodFirstPartyTypeKind.ZodBoolean,\\n      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  var ZodDate = class _ZodDate extends ZodType {\\n    _parse(input) {\\n      if (this._def.coerce) {\\n        input.data = new Date(input.data);\\n      }\\n      const parsedType = this._getType(input);\\n      if (parsedType !== ZodParsedType.date) {\\n        const ctx2 = this._getOrReturnCtx(input);\\n        addIssueToContext(ctx2, {\\n          code: ZodIssueCode.invalid_type,\\n          expected: ZodParsedType.date,\\n          received: ctx2.parsedType\\n        });\\n        return INVALID;\\n      }\\n      if (isNaN(input.data.getTime())) {\\n        const ctx2 = this._getOrReturnCtx(input);\\n        addIssueToContext(ctx2, {\\n          code: ZodIssueCode.invalid_date\\n        });\\n        return INVALID;\\n      }\\n      const status = new ParseStatus();\\n      let ctx = void 0;\\n      for (const check of this._def.checks) {\\n        if (check.kind === \"min\") {\\n          if (input.data.getTime() < check.value) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              code: ZodIssueCode.too_small,\\n              message: check.message,\\n              inclusive: true,\\n              exact: false,\\n              minimum: check.value,\\n              type: \"date\"\\n            });\\n            status.dirty();\\n          }\\n        } else if (check.kind === \"max\") {\\n          if (input.data.getTime() > check.value) {\\n            ctx = this._getOrReturnCtx(input, ctx);\\n            addIssueToContext(ctx, {\\n              code: ZodIssueCode.too_big,\\n              message: check.message,\\n              inclusive: true,\\n              exact: false,\\n              maximum: check.value,\\n              type: \"date\"\\n            });\\n            status.dirty();\\n          }\\n        } else {\\n          util.assertNever(check);\\n        }\\n      }\\n      return {\\n        status: status.value,\\n        value: new Date(input.data.getTime())\\n      };\\n    }\\n    _addCheck(check) {\\n      return new _ZodDate({\\n        ...this._def,\\n        checks: [...this._def.checks, check]\\n      });\\n    }\\n    min(minDate, message) {\\n      return this._addCheck({\\n        kind: \"min\",\\n        value: minDate.getTime(),\\n        message: errorUtil.toString(message)\\n      });\\n    }\\n    max(maxDate, message) {\\n      return this._addCheck({\\n        kind: \"max\",\\n        value: maxDate.getTime(),\\n        message: errorUtil.toString(message)\\n      });\\n    }\\n    get minDate() {\\n      let min = null;\\n      for (const ch of this._def.checks) {\\n        if (ch.kind === \"min\") {\\n          if (min === null || ch.value > min)\\n            min = ch.value;\\n        }\\n      }\\n      return min != null ? new Date(min) : null;\\n    }\\n    get maxDate() {\\n      let max = null;\\n      for (const ch of this._def.checks) {\\n        if (ch.kind === \"max\") {\\n          if (max === null || ch.value < max)\\n            max = ch.value;\\n        }\\n      }\\n      return max != null ? new Date(max) : null;\\n    }\\n  };\\n  ZodDate.create = (params) => {\\n    return new ZodDate({\\n      checks: [],\\n      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\\n      typeName: ZodFirstPartyTypeKind.ZodDate,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  var ZodSymbol = class extends ZodType {\\n    _parse(input) {\\n      const parsedType = this._getType(input);\\n      if (parsedType !== ZodParsedType.symbol) {\\n        const ctx = this._getOrReturnCtx(input);\\n        addIssueToContext(ctx, {\\n          code: ZodIssueCode.invalid_type,\\n          expected: ZodParsedType.symbol,\\n          received: ctx.parsedType\\n        });\\n        return INVALID;\\n      }\\n      return OK(input.data);\\n    }\\n  };\\n  ZodSymbol.create = (params) => {\\n    return new ZodSymbol({\\n      typeName: ZodFirstPartyTypeKind.ZodSymbol,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  var ZodUndefined = class extends ZodType {\\n    _parse(input) {\\n      const parsedType = this._getType(input);\\n      if (parsedType !== ZodParsedType.undefined) {\\n        const ctx = this._getOrReturnCtx(input);\\n        addIssueToContext(ctx, {\\n          code: ZodIssueCode.invalid_type,\\n          expected: ZodParsedType.undefined,\\n          received: ctx.parsedType\\n        });\\n        return INVALID;\\n      }\\n      return OK(input.data);\\n    }\\n  };\\n  ZodUndefined.create = (params) => {\\n    return new ZodUndefined({\\n      typeName: ZodFirstPartyTypeKind.ZodUndefined,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  var ZodNull = class extends ZodType {\\n    _parse(input) {\\n      const parsedType = this._getType(input);\\n      if (parsedType !== ZodParsedType.null) {\\n        const ctx = this._getOrReturnCtx(input);\\n        addIssueToContext(ctx, {\\n          code: ZodIssueCode.invalid_type,\\n          expected: ZodParsedType.null,\\n          received: ctx.parsedType\\n        });\\n        return INVALID;\\n      }\\n      return OK(input.data);\\n    }\\n  };\\n  ZodNull.create = (params) => {\\n    return new ZodNull({\\n      typeName: ZodFirstPartyTypeKind.ZodNull,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  var ZodAny = class extends ZodType {\\n    constructor() {\\n      super(...arguments);\\n      this._any = true;\\n    }\\n    _parse(input) {\\n      return OK(input.data);\\n    }\\n  };\\n  ZodAny.create = (params) => {\\n    return new ZodAny({\\n      typeName: ZodFirstPartyTypeKind.ZodAny,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  var ZodUnknown = class extends ZodType {\\n    constructor() {\\n      super(...arguments);\\n      this._unknown = true;\\n    }\\n    _parse(input) {\\n      return OK(input.data);\\n    }\\n  };\\n  ZodUnknown.create = (params) => {\\n    return new ZodUnknown({\\n      typeName: ZodFirstPartyTypeKind.ZodUnknown,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  var ZodNever = class extends ZodType {\\n    _parse(input) {\\n      const ctx = this._getOrReturnCtx(input);\\n      addIssueToContext(ctx, {\\n        code: ZodIssueCode.invalid_type,\\n        expected: ZodParsedType.never,\\n        received: ctx.parsedType\\n      });\\n      return INVALID;\\n    }\\n  };\\n  ZodNever.create = (params) => {\\n    return new ZodNever({\\n      typeName: ZodFirstPartyTypeKind.ZodNever,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  var ZodVoid = class extends ZodType {\\n    _parse(input) {\\n      const parsedType = this._getType(input);\\n      if (parsedType !== ZodParsedType.undefined) {\\n        const ctx = this._getOrReturnCtx(input);\\n        addIssueToContext(ctx, {\\n          code: ZodIssueCode.invalid_type,\\n          expected: ZodParsedType.void,\\n          received: ctx.parsedType\\n        });\\n        return INVALID;\\n      }\\n      return OK(input.data);\\n    }\\n  };\\n  ZodVoid.create = (params) => {\\n    return new ZodVoid({\\n      typeName: ZodFirstPartyTypeKind.ZodVoid,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  var ZodArray = class _ZodArray extends ZodType {\\n    _parse(input) {\\n      const { ctx, status } = this._processInputParams(input);\\n      const def = this._def;\\n      if (ctx.parsedType !== ZodParsedType.array) {\\n        addIssueToContext(ctx, {\\n          code: ZodIssueCode.invalid_type,\\n          expected: ZodParsedType.array,\\n          received: ctx.parsedType\\n        });\\n        return INVALID;\\n      }\\n      if (def.exactLength !== null) {\\n        const tooBig = ctx.data.length > def.exactLength.value;\\n        const tooSmall = ctx.data.length < def.exactLength.value;\\n        if (tooBig || tooSmall) {\\n          addIssueToContext(ctx, {\\n            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\\n            minimum: tooSmall ? def.exactLength.value : void 0,\\n            maximum: tooBig ? def.exactLength.value : void 0,\\n            type: \"array\",\\n            inclusive: true,\\n            exact: true,\\n            message: def.exactLength.message\\n          });\\n          status.dirty();\\n        }\\n      }\\n      if (def.minLength !== null) {\\n        if (ctx.data.length < def.minLength.value) {\\n          addIssueToContext(ctx, {\\n            code: ZodIssueCode.too_small,\\n            minimum: def.minLength.value,\\n            type: \"array\",\\n            inclusive: true,\\n            exact: false,\\n            message: def.minLength.message\\n          });\\n          status.dirty();\\n        }\\n      }\\n      if (def.maxLength !== null) {\\n        if (ctx.data.length > def.maxLength.value) {\\n          addIssueToContext(ctx, {\\n            code: ZodIssueCode.too_big,\\n            maximum: def.maxLength.value,\\n            type: \"array\",\\n            inclusive: true,\\n            exact: false,\\n            message: def.maxLength.message\\n          });\\n          status.dirty();\\n        }\\n      }\\n      if (ctx.common.async) {\\n        return Promise.all([...ctx.data].map((item, i) => {\\n          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\\n        })).then((result2) => {\\n          return ParseStatus.mergeArray(status, result2);\\n        });\\n      }\\n      const result = [...ctx.data].map((item, i) => {\\n        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\\n      });\\n      return ParseStatus.mergeArray(status, result);\\n    }\\n    get element() {\\n      return this._def.type;\\n    }\\n    min(minLength, message) {\\n      return new _ZodArray({\\n        ...this._def,\\n        minLength: { value: minLength, message: errorUtil.toString(message) }\\n      });\\n    }\\n    max(maxLength, message) {\\n      return new _ZodArray({\\n        ...this._def,\\n        maxLength: { value: maxLength, message: errorUtil.toString(message) }\\n      });\\n    }\\n    length(len, message) {\\n      return new _ZodArray({\\n        ...this._def,\\n        exactLength: { value: len, message: errorUtil.toString(message) }\\n      });\\n    }\\n    nonempty(message) {\\n      return this.min(1, message);\\n    }\\n  };\\n  ZodArray.create = (schema, params) => {\\n    return new ZodArray({\\n      type: schema,\\n      minLength: null,\\n      maxLength: null,\\n      exactLength: null,\\n      typeName: ZodFirstPartyTypeKind.ZodArray,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  function deepPartialify(schema) {\\n    if (schema instanceof ZodObject) {\\n      const newShape = {};\\n      for (const key in schema.shape) {\\n        const fieldSchema = schema.shape[key];\\n        newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\\n      }\\n      return new ZodObject({\\n        ...schema._def,\\n        shape: () => newShape\\n      });\\n    } else if (schema instanceof ZodArray) {\\n      return new ZodArray({\\n        ...schema._def,\\n        type: deepPartialify(schema.element)\\n      });\\n    } else if (schema instanceof ZodOptional) {\\n      return ZodOptional.create(deepPartialify(schema.unwrap()));\\n    } else if (schema instanceof ZodNullable) {\\n      return ZodNullable.create(deepPartialify(schema.unwrap()));\\n    } else if (schema instanceof ZodTuple) {\\n      return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\\n    } else {\\n      return schema;\\n    }\\n  }\\n  var ZodObject = class _ZodObject extends ZodType {\\n    constructor() {\\n      super(...arguments);\\n      this._cached = null;\\n      this.nonstrict = this.passthrough;\\n      this.augment = this.extend;\\n    }\\n    _getCached() {\\n      if (this._cached !== null)\\n        return this._cached;\\n      const shape = this._def.shape();\\n      const keys = util.objectKeys(shape);\\n      return this._cached = { shape, keys };\\n    }\\n    _parse(input) {\\n      const parsedType = this._getType(input);\\n      if (parsedType !== ZodParsedType.object) {\\n        const ctx2 = this._getOrReturnCtx(input);\\n        addIssueToContext(ctx2, {\\n          code: ZodIssueCode.invalid_type,\\n          expected: ZodParsedType.object,\\n          received: ctx2.parsedType\\n        });\\n        return INVALID;\\n      }\\n      const { status, ctx } = this._processInputParams(input);\\n      const { shape, keys: shapeKeys } = this._getCached();\\n      const extraKeys = [];\\n      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\")) {\\n        for (const key in ctx.data) {\\n          if (!shapeKeys.includes(key)) {\\n            extraKeys.push(key);\\n          }\\n        }\\n      }\\n      const pairs = [];\\n      for (const key of shapeKeys) {\\n        const keyValidator = shape[key];\\n        const value = ctx.data[key];\\n        pairs.push({\\n          key: { status: \"valid\", value: key },\\n          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\\n          alwaysSet: key in ctx.data\\n        });\\n      }\\n      if (this._def.catchall instanceof ZodNever) {\\n        const unknownKeys = this._def.unknownKeys;\\n        if (unknownKeys === \"passthrough\") {\\n          for (const key of extraKeys) {\\n            pairs.push({\\n              key: { status: \"valid\", value: key },\\n              value: { status: \"valid\", value: ctx.data[key] }\\n            });\\n          }\\n        } else if (unknownKeys === \"strict\") {\\n          if (extraKeys.length > 0) {\\n            addIssueToContext(ctx, {\\n              code: ZodIssueCode.unrecognized_keys,\\n              keys: extraKeys\\n            });\\n            status.dirty();\\n          }\\n        } else if (unknownKeys === \"strip\") ;\\n        else {\\n          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\\n        }\\n      } else {\\n        const catchall = this._def.catchall;\\n        for (const key of extraKeys) {\\n          const value = ctx.data[key];\\n          pairs.push({\\n            key: { status: \"valid\", value: key },\\n            value: catchall._parse(\\n              new ParseInputLazyPath(ctx, value, ctx.path, key)\\n              //, ctx.child(key), value, getParsedType(value)\\n            ),\\n            alwaysSet: key in ctx.data\\n          });\\n        }\\n      }\\n      if (ctx.common.async) {\\n        return Promise.resolve().then(async () => {\\n          const syncPairs = [];\\n          for (const pair of pairs) {\\n            const key = await pair.key;\\n            const value = await pair.value;\\n            syncPairs.push({\\n              key,\\n              value,\\n              alwaysSet: pair.alwaysSet\\n            });\\n          }\\n          return syncPairs;\\n        }).then((syncPairs) => {\\n          return ParseStatus.mergeObjectSync(status, syncPairs);\\n        });\\n      } else {\\n        return ParseStatus.mergeObjectSync(status, pairs);\\n      }\\n    }\\n    get shape() {\\n      return this._def.shape();\\n    }\\n    strict(message) {\\n      errorUtil.errToObj;\\n      return new _ZodObject({\\n        ...this._def,\\n        unknownKeys: \"strict\",\\n        ...message !== void 0 ? {\\n          errorMap: (issue, ctx) => {\\n            var _a, _b, _c, _d;\\n            const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;\\n            if (issue.code === \"unrecognized_keys\")\\n              return {\\n                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError\\n              };\\n            return {\\n              message: defaultError\\n            };\\n          }\\n        } : {}\\n      });\\n    }\\n    strip() {\\n      return new _ZodObject({\\n        ...this._def,\\n        unknownKeys: \"strip\"\\n      });\\n    }\\n    passthrough() {\\n      return new _ZodObject({\\n        ...this._def,\\n        unknownKeys: \"passthrough\"\\n      });\\n    }\\n    // const AugmentFactory =\\n    //   <Def extends ZodObjectDef>(def: Def) =>\\n    //   <Augmentation extends ZodRawShape>(\\n    //     augmentation: Augmentation\\n    //   ): ZodObject<\\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\\n    //     Def[\"unknownKeys\"],\\n    //     Def[\"catchall\"]\\n    //   > => {\\n    //     return new ZodObject({\\n    //       ...def,\\n    //       shape: () => ({\\n    //         ...def.shape(),\\n    //         ...augmentation,\\n    //       }),\\n    //     }) as any;\\n    //   };\\n    extend(augmentation) {\\n      return new _ZodObject({\\n        ...this._def,\\n        shape: () => ({\\n          ...this._def.shape(),\\n          ...augmentation\\n        })\\n      });\\n    }\\n    /**\\n     * Prior to zod@1.0.12 there was a bug in the\\n     * inferred type of merged objects. Please\\n     * upgrade if you are experiencing issues.\\n     */\\n    merge(merging) {\\n      const merged = new _ZodObject({\\n        unknownKeys: merging._def.unknownKeys,\\n        catchall: merging._def.catchall,\\n        shape: () => ({\\n          ...this._def.shape(),\\n          ...merging._def.shape()\\n        }),\\n        typeName: ZodFirstPartyTypeKind.ZodObject\\n      });\\n      return merged;\\n    }\\n    // merge<\\n    //   Incoming extends AnyZodObject,\\n    //   Augmentation extends Incoming[\"shape\"],\\n    //   NewOutput extends {\\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\\n    //       ? Augmentation[k][\"_output\"]\\n    //       : k extends keyof Output\\n    //       ? Output[k]\\n    //       : never;\\n    //   },\\n    //   NewInput extends {\\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\\n    //       ? Augmentation[k][\"_input\"]\\n    //       : k extends keyof Input\\n    //       ? Input[k]\\n    //       : never;\\n    //   }\\n    // >(\\n    //   merging: Incoming\\n    // ): ZodObject<\\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\\n    //   Incoming[\"_def\"][\"unknownKeys\"],\\n    //   Incoming[\"_def\"][\"catchall\"],\\n    //   NewOutput,\\n    //   NewInput\\n    // > {\\n    //   const merged: any = new ZodObject({\\n    //     unknownKeys: merging._def.unknownKeys,\\n    //     catchall: merging._def.catchall,\\n    //     shape: () =>\\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\\n    //   }) as any;\\n    //   return merged;\\n    // }\\n    setKey(key, schema) {\\n      return this.augment({ [key]: schema });\\n    }\\n    // merge<Incoming extends AnyZodObject>(\\n    //   merging: Incoming\\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\\n    // ZodObject<\\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\\n    //   Incoming[\"_def\"][\"unknownKeys\"],\\n    //   Incoming[\"_def\"][\"catchall\"]\\n    // > {\\n    //   // const mergedShape = objectUtil.mergeShapes(\\n    //   //   this._def.shape(),\\n    //   //   merging._def.shape()\\n    //   // );\\n    //   const merged: any = new ZodObject({\\n    //     unknownKeys: merging._def.unknownKeys,\\n    //     catchall: merging._def.catchall,\\n    //     shape: () =>\\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\\n    //   }) as any;\\n    //   return merged;\\n    // }\\n    catchall(index2) {\\n      return new _ZodObject({\\n        ...this._def,\\n        catchall: index2\\n      });\\n    }\\n    pick(mask) {\\n      const shape = {};\\n      util.objectKeys(mask).forEach((key) => {\\n        if (mask[key] && this.shape[key]) {\\n          shape[key] = this.shape[key];\\n        }\\n      });\\n      return new _ZodObject({\\n        ...this._def,\\n        shape: () => shape\\n      });\\n    }\\n    omit(mask) {\\n      const shape = {};\\n      util.objectKeys(this.shape).forEach((key) => {\\n        if (!mask[key]) {\\n          shape[key] = this.shape[key];\\n        }\\n      });\\n      return new _ZodObject({\\n        ...this._def,\\n        shape: () => shape\\n      });\\n    }\\n    /**\\n     * @deprecated\\n     */\\n    deepPartial() {\\n      return deepPartialify(this);\\n    }\\n    partial(mask) {\\n      const newShape = {};\\n      util.objectKeys(this.shape).forEach((key) => {\\n        const fieldSchema = this.shape[key];\\n        if (mask && !mask[key]) {\\n          newShape[key] = fieldSchema;\\n        } else {\\n          newShape[key] = fieldSchema.optional();\\n        }\\n      });\\n      return new _ZodObject({\\n        ...this._def,\\n        shape: () => newShape\\n      });\\n    }\\n    required(mask) {\\n      const newShape = {};\\n      util.objectKeys(this.shape).forEach((key) => {\\n        if (mask && !mask[key]) {\\n          newShape[key] = this.shape[key];\\n        } else {\\n          const fieldSchema = this.shape[key];\\n          let newField = fieldSchema;\\n          while (newField instanceof ZodOptional) {\\n            newField = newField._def.innerType;\\n          }\\n          newShape[key] = newField;\\n        }\\n      });\\n      return new _ZodObject({\\n        ...this._def,\\n        shape: () => newShape\\n      });\\n    }\\n    keyof() {\\n      return createZodEnum(util.objectKeys(this.shape));\\n    }\\n  };\\n  ZodObject.create = (shape, params) => {\\n    return new ZodObject({\\n      shape: () => shape,\\n      unknownKeys: \"strip\",\\n      catchall: ZodNever.create(),\\n      typeName: ZodFirstPartyTypeKind.ZodObject,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  ZodObject.strictCreate = (shape, params) => {\\n    return new ZodObject({\\n      shape: () => shape,\\n      unknownKeys: \"strict\",\\n      catchall: ZodNever.create(),\\n      typeName: ZodFirstPartyTypeKind.ZodObject,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  ZodObject.lazycreate = (shape, params) => {\\n    return new ZodObject({\\n      shape,\\n      unknownKeys: \"strip\",\\n      catchall: ZodNever.create(),\\n      typeName: ZodFirstPartyTypeKind.ZodObject,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  var ZodUnion = class extends ZodType {\\n    _parse(input) {\\n      const { ctx } = this._processInputParams(input);\\n      const options = this._def.options;\\n      function handleResults(results) {\\n        for (const result of results) {\\n          if (result.result.status === \"valid\") {\\n            return result.result;\\n          }\\n        }\\n        for (const result of results) {\\n          if (result.result.status === \"dirty\") {\\n            ctx.common.issues.push(...result.ctx.common.issues);\\n            return result.result;\\n          }\\n        }\\n        const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\\n        addIssueToContext(ctx, {\\n          code: ZodIssueCode.invalid_union,\\n          unionErrors\\n        });\\n        return INVALID;\\n      }\\n      if (ctx.common.async) {\\n        return Promise.all(options.map(async (option) => {\\n          const childCtx = {\\n            ...ctx,\\n            common: {\\n              ...ctx.common,\\n              issues: []\\n            },\\n            parent: null\\n          };\\n          return {\\n            result: await option._parseAsync({\\n              data: ctx.data,\\n              path: ctx.path,\\n              parent: childCtx\\n            }),\\n            ctx: childCtx\\n          };\\n        })).then(handleResults);\\n      } else {\\n        let dirty = void 0;\\n        const issues = [];\\n        for (const option of options) {\\n          const childCtx = {\\n            ...ctx,\\n            common: {\\n              ...ctx.common,\\n              issues: []\\n            },\\n            parent: null\\n          };\\n          const result = option._parseSync({\\n            data: ctx.data,\\n            path: ctx.path,\\n            parent: childCtx\\n          });\\n          if (result.status === \"valid\") {\\n            return result;\\n          } else if (result.status === \"dirty\" && !dirty) {\\n            dirty = { result, ctx: childCtx };\\n          }\\n          if (childCtx.common.issues.length) {\\n            issues.push(childCtx.common.issues);\\n          }\\n        }\\n        if (dirty) {\\n          ctx.common.issues.push(...dirty.ctx.common.issues);\\n          return dirty.result;\\n        }\\n        const unionErrors = issues.map((issues2) => new ZodError(issues2));\\n        addIssueToContext(ctx, {\\n          code: ZodIssueCode.invalid_union,\\n          unionErrors\\n        });\\n        return INVALID;\\n      }\\n    }\\n    get options() {\\n      return this._def.options;\\n    }\\n  };\\n  ZodUnion.create = (types, params) => {\\n    return new ZodUnion({\\n      options: types,\\n      typeName: ZodFirstPartyTypeKind.ZodUnion,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  var getDiscriminator = (type) => {\\n    if (type instanceof ZodLazy) {\\n      return getDiscriminator(type.schema);\\n    } else if (type instanceof ZodEffects) {\\n      return getDiscriminator(type.innerType());\\n    } else if (type instanceof ZodLiteral) {\\n      return [type.value];\\n    } else if (type instanceof ZodEnum) {\\n      return type.options;\\n    } else if (type instanceof ZodNativeEnum) {\\n      return util.objectValues(type.enum);\\n    } else if (type instanceof ZodDefault) {\\n      return getDiscriminator(type._def.innerType);\\n    } else if (type instanceof ZodUndefined) {\\n      return [void 0];\\n    } else if (type instanceof ZodNull) {\\n      return [null];\\n    } else if (type instanceof ZodOptional) {\\n      return [void 0, ...getDiscriminator(type.unwrap())];\\n    } else if (type instanceof ZodNullable) {\\n      return [null, ...getDiscriminator(type.unwrap())];\\n    } else if (type instanceof ZodBranded) {\\n      return getDiscriminator(type.unwrap());\\n    } else if (type instanceof ZodReadonly) {\\n      return getDiscriminator(type.unwrap());\\n    } else if (type instanceof ZodCatch) {\\n      return getDiscriminator(type._def.innerType);\\n    } else {\\n      return [];\\n    }\\n  };\\n  var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {\\n    _parse(input) {\\n      const { ctx } = this._processInputParams(input);\\n      if (ctx.parsedType !== ZodParsedType.object) {\\n        addIssueToContext(ctx, {\\n          code: ZodIssueCode.invalid_type,\\n          expected: ZodParsedType.object,\\n          received: ctx.parsedType\\n        });\\n        return INVALID;\\n      }\\n      const discriminator = this.discriminator;\\n      const discriminatorValue = ctx.data[discriminator];\\n      const option = this.optionsMap.get(discriminatorValue);\\n      if (!option) {\\n        addIssueToContext(ctx, {\\n          code: ZodIssueCode.invalid_union_discriminator,\\n          options: Array.from(this.optionsMap.keys()),\\n          path: [discriminator]\\n        });\\n        return INVALID;\\n      }\\n      if (ctx.common.async) {\\n        return option._parseAsync({\\n          data: ctx.data,\\n          path: ctx.path,\\n          parent: ctx\\n        });\\n      } else {\\n        return option._parseSync({\\n          data: ctx.data,\\n          path: ctx.path,\\n          parent: ctx\\n        });\\n      }\\n    }\\n    get discriminator() {\\n      return this._def.discriminator;\\n    }\\n    get options() {\\n      return this._def.options;\\n    }\\n    get optionsMap() {\\n      return this._def.optionsMap;\\n    }\\n    /**\\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\\n     * have a different value for each object in the union.\\n     * @param discriminator the name of the discriminator property\\n     * @param types an array of object schemas\\n     * @param params\\n     */\\n    static create(discriminator, options, params) {\\n      const optionsMap = /* @__PURE__ */ new Map();\\n      for (const type of options) {\\n        const discriminatorValues = getDiscriminator(type.shape[discriminator]);\\n        if (!discriminatorValues.length) {\\n          throw new Error(`A discriminator value for key \\\\`${discriminator}\\\\` could not be extracted from all schema options`);\\n        }\\n        for (const value of discriminatorValues) {\\n          if (optionsMap.has(value)) {\\n            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\\n          }\\n          optionsMap.set(value, type);\\n        }\\n      }\\n      return new _ZodDiscriminatedUnion({\\n        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\\n        discriminator,\\n        options,\\n        optionsMap,\\n        ...processCreateParams(params)\\n      });\\n    }\\n  };\\n  function mergeValues(a, b) {\\n    const aType = getParsedType(a);\\n    const bType = getParsedType(b);\\n    if (a === b) {\\n      return { valid: true, data: a };\\n    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\\n      const bKeys = util.objectKeys(b);\\n      const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);\\n      const newObj = { ...a, ...b };\\n      for (const key of sharedKeys) {\\n        const sharedValue = mergeValues(a[key], b[key]);\\n        if (!sharedValue.valid) {\\n          return { valid: false };\\n        }\\n        newObj[key] = sharedValue.data;\\n      }\\n      return { valid: true, data: newObj };\\n    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\\n      if (a.length !== b.length) {\\n        return { valid: false };\\n      }\\n      const newArray = [];\\n      for (let index2 = 0; index2 < a.length; index2++) {\\n        const itemA = a[index2];\\n        const itemB = b[index2];\\n        const sharedValue = mergeValues(itemA, itemB);\\n        if (!sharedValue.valid) {\\n          return { valid: false };\\n        }\\n        newArray.push(sharedValue.data);\\n      }\\n      return { valid: true, data: newArray };\\n    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {\\n      return { valid: true, data: a };\\n    } else {\\n      return { valid: false };\\n    }\\n  }\\n  var ZodIntersection = class extends ZodType {\\n    _parse(input) {\\n      const { status, ctx } = this._processInputParams(input);\\n      const handleParsed = (parsedLeft, parsedRight) => {\\n        if (isAborted(parsedLeft) || isAborted(parsedRight)) {\\n          return INVALID;\\n        }\\n        const merged = mergeValues(parsedLeft.value, parsedRight.value);\\n        if (!merged.valid) {\\n          addIssueToContext(ctx, {\\n            code: ZodIssueCode.invalid_intersection_types\\n          });\\n          return INVALID;\\n        }\\n        if (isDirty(parsedLeft) || isDirty(parsedRight)) {\\n          status.dirty();\\n        }\\n        return { status: status.value, value: merged.data };\\n      };\\n      if (ctx.common.async) {\\n        return Promise.all([\\n          this._def.left._parseAsync({\\n            data: ctx.data,\\n            path: ctx.path,\\n            parent: ctx\\n          }),\\n          this._def.right._parseAsync({\\n            data: ctx.data,\\n            path: ctx.path,\\n            parent: ctx\\n          })\\n        ]).then(([left, right]) => handleParsed(left, right));\\n      } else {\\n        return handleParsed(this._def.left._parseSync({\\n          data: ctx.data,\\n          path: ctx.path,\\n          parent: ctx\\n        }), this._def.right._parseSync({\\n          data: ctx.data,\\n          path: ctx.path,\\n          parent: ctx\\n        }));\\n      }\\n    }\\n  };\\n  ZodIntersection.create = (left, right, params) => {\\n    return new ZodIntersection({\\n      left,\\n      right,\\n      typeName: ZodFirstPartyTypeKind.ZodIntersection,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  var ZodTuple = class _ZodTuple extends ZodType {\\n    _parse(input) {\\n      const { status, ctx } = this._processInputParams(input);\\n      if (ctx.parsedType !== ZodParsedType.array) {\\n        addIssueToContext(ctx, {\\n          code: ZodIssueCode.invalid_type,\\n          expected: ZodParsedType.array,\\n          received: ctx.parsedType\\n        });\\n        return INVALID;\\n      }\\n      if (ctx.data.length < this._def.items.length) {\\n        addIssueToContext(ctx, {\\n          code: ZodIssueCode.too_small,\\n          minimum: this._def.items.length,\\n          inclusive: true,\\n          exact: false,\\n          type: \"array\"\\n        });\\n        return INVALID;\\n      }\\n      const rest = this._def.rest;\\n      if (!rest && ctx.data.length > this._def.items.length) {\\n        addIssueToContext(ctx, {\\n          code: ZodIssueCode.too_big,\\n          maximum: this._def.items.length,\\n          inclusive: true,\\n          exact: false,\\n          type: \"array\"\\n        });\\n        status.dirty();\\n      }\\n      const items = [...ctx.data].map((item, itemIndex) => {\\n        const schema = this._def.items[itemIndex] || this._def.rest;\\n        if (!schema)\\n          return null;\\n        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\\n      }).filter((x) => !!x);\\n      if (ctx.common.async) {\\n        return Promise.all(items).then((results) => {\\n          return ParseStatus.mergeArray(status, results);\\n        });\\n      } else {\\n        return ParseStatus.mergeArray(status, items);\\n      }\\n    }\\n    get items() {\\n      return this._def.items;\\n    }\\n    rest(rest) {\\n      return new _ZodTuple({\\n        ...this._def,\\n        rest\\n      });\\n    }\\n  };\\n  ZodTuple.create = (schemas, params) => {\\n    if (!Array.isArray(schemas)) {\\n      throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\\n    }\\n    return new ZodTuple({\\n      items: schemas,\\n      typeName: ZodFirstPartyTypeKind.ZodTuple,\\n      rest: null,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  var ZodRecord = class _ZodRecord extends ZodType {\\n    get keySchema() {\\n      return this._def.keyType;\\n    }\\n    get valueSchema() {\\n      return this._def.valueType;\\n    }\\n    _parse(input) {\\n      const { status, ctx } = this._processInputParams(input);\\n      if (ctx.parsedType !== ZodParsedType.object) {\\n        addIssueToContext(ctx, {\\n          code: ZodIssueCode.invalid_type,\\n          expected: ZodParsedType.object,\\n          received: ctx.parsedType\\n        });\\n        return INVALID;\\n      }\\n      const pairs = [];\\n      const keyType = this._def.keyType;\\n      const valueType = this._def.valueType;\\n      for (const key in ctx.data) {\\n        pairs.push({\\n          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\\n          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\\n          alwaysSet: key in ctx.data\\n        });\\n      }\\n      if (ctx.common.async) {\\n        return ParseStatus.mergeObjectAsync(status, pairs);\\n      } else {\\n        return ParseStatus.mergeObjectSync(status, pairs);\\n      }\\n    }\\n    get element() {\\n      return this._def.valueType;\\n    }\\n    static create(first, second, third) {\\n      if (second instanceof ZodType) {\\n        return new _ZodRecord({\\n          keyType: first,\\n          valueType: second,\\n          typeName: ZodFirstPartyTypeKind.ZodRecord,\\n          ...processCreateParams(third)\\n        });\\n      }\\n      return new _ZodRecord({\\n        keyType: ZodString.create(),\\n        valueType: first,\\n        typeName: ZodFirstPartyTypeKind.ZodRecord,\\n        ...processCreateParams(second)\\n      });\\n    }\\n  };\\n  var ZodMap = class extends ZodType {\\n    get keySchema() {\\n      return this._def.keyType;\\n    }\\n    get valueSchema() {\\n      return this._def.valueType;\\n    }\\n    _parse(input) {\\n      const { status, ctx } = this._processInputParams(input);\\n      if (ctx.parsedType !== ZodParsedType.map) {\\n        addIssueToContext(ctx, {\\n          code: ZodIssueCode.invalid_type,\\n          expected: ZodParsedType.map,\\n          received: ctx.parsedType\\n        });\\n        return INVALID;\\n      }\\n      const keyType = this._def.keyType;\\n      const valueType = this._def.valueType;\\n      const pairs = [...ctx.data.entries()].map(([key, value], index2) => {\\n        return {\\n          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, \"key\"])),\\n          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, \"value\"]))\\n        };\\n      });\\n      if (ctx.common.async) {\\n        const finalMap = /* @__PURE__ */ new Map();\\n        return Promise.resolve().then(async () => {\\n          for (const pair of pairs) {\\n            const key = await pair.key;\\n            const value = await pair.value;\\n            if (key.status === \"aborted\" || value.status === \"aborted\") {\\n              return INVALID;\\n            }\\n            if (key.status === \"dirty\" || value.status === \"dirty\") {\\n              status.dirty();\\n            }\\n            finalMap.set(key.value, value.value);\\n          }\\n          return { status: status.value, value: finalMap };\\n        });\\n      } else {\\n        const finalMap = /* @__PURE__ */ new Map();\\n        for (const pair of pairs) {\\n          const key = pair.key;\\n          const value = pair.value;\\n          if (key.status === \"aborted\" || value.status === \"aborted\") {\\n            return INVALID;\\n          }\\n          if (key.status === \"dirty\" || value.status === \"dirty\") {\\n            status.dirty();\\n          }\\n          finalMap.set(key.value, value.value);\\n        }\\n        return { status: status.value, value: finalMap };\\n      }\\n    }\\n  };\\n  ZodMap.create = (keyType, valueType, params) => {\\n    return new ZodMap({\\n      valueType,\\n      keyType,\\n      typeName: ZodFirstPartyTypeKind.ZodMap,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  var ZodSet = class _ZodSet extends ZodType {\\n    _parse(input) {\\n      const { status, ctx } = this._processInputParams(input);\\n      if (ctx.parsedType !== ZodParsedType.set) {\\n        addIssueToContext(ctx, {\\n          code: ZodIssueCode.invalid_type,\\n          expected: ZodParsedType.set,\\n          received: ctx.parsedType\\n        });\\n        return INVALID;\\n      }\\n      const def = this._def;\\n      if (def.minSize !== null) {\\n        if (ctx.data.size < def.minSize.value) {\\n          addIssueToContext(ctx, {\\n            code: ZodIssueCode.too_small,\\n            minimum: def.minSize.value,\\n            type: \"set\",\\n            inclusive: true,\\n            exact: false,\\n            message: def.minSize.message\\n          });\\n          status.dirty();\\n        }\\n      }\\n      if (def.maxSize !== null) {\\n        if (ctx.data.size > def.maxSize.value) {\\n          addIssueToContext(ctx, {\\n            code: ZodIssueCode.too_big,\\n            maximum: def.maxSize.value,\\n            type: \"set\",\\n            inclusive: true,\\n            exact: false,\\n            message: def.maxSize.message\\n          });\\n          status.dirty();\\n        }\\n      }\\n      const valueType = this._def.valueType;\\n      function finalizeSet(elements2) {\\n        const parsedSet = /* @__PURE__ */ new Set();\\n        for (const element of elements2) {\\n          if (element.status === \"aborted\")\\n            return INVALID;\\n          if (element.status === \"dirty\")\\n            status.dirty();\\n          parsedSet.add(element.value);\\n        }\\n        return { status: status.value, value: parsedSet };\\n      }\\n      const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\\n      if (ctx.common.async) {\\n        return Promise.all(elements).then((elements2) => finalizeSet(elements2));\\n      } else {\\n        return finalizeSet(elements);\\n      }\\n    }\\n    min(minSize, message) {\\n      return new _ZodSet({\\n        ...this._def,\\n        minSize: { value: minSize, message: errorUtil.toString(message) }\\n      });\\n    }\\n    max(maxSize, message) {\\n      return new _ZodSet({\\n        ...this._def,\\n        maxSize: { value: maxSize, message: errorUtil.toString(message) }\\n      });\\n    }\\n    size(size5, message) {\\n      return this.min(size5, message).max(size5, message);\\n    }\\n    nonempty(message) {\\n      return this.min(1, message);\\n    }\\n  };\\n  ZodSet.create = (valueType, params) => {\\n    return new ZodSet({\\n      valueType,\\n      minSize: null,\\n      maxSize: null,\\n      typeName: ZodFirstPartyTypeKind.ZodSet,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  var ZodFunction = class _ZodFunction extends ZodType {\\n    constructor() {\\n      super(...arguments);\\n      this.validate = this.implement;\\n    }\\n    _parse(input) {\\n      const { ctx } = this._processInputParams(input);\\n      if (ctx.parsedType !== ZodParsedType.function) {\\n        addIssueToContext(ctx, {\\n          code: ZodIssueCode.invalid_type,\\n          expected: ZodParsedType.function,\\n          received: ctx.parsedType\\n        });\\n        return INVALID;\\n      }\\n      function makeArgsIssue(args, error) {\\n        return makeIssue({\\n          data: args,\\n          path: ctx.path,\\n          errorMaps: [\\n            ctx.common.contextualErrorMap,\\n            ctx.schemaErrorMap,\\n            getErrorMap(),\\n            errorMap\\n          ].filter((x) => !!x),\\n          issueData: {\\n            code: ZodIssueCode.invalid_arguments,\\n            argumentsError: error\\n          }\\n        });\\n      }\\n      function makeReturnsIssue(returns, error) {\\n        return makeIssue({\\n          data: returns,\\n          path: ctx.path,\\n          errorMaps: [\\n            ctx.common.contextualErrorMap,\\n            ctx.schemaErrorMap,\\n            getErrorMap(),\\n            errorMap\\n          ].filter((x) => !!x),\\n          issueData: {\\n            code: ZodIssueCode.invalid_return_type,\\n            returnTypeError: error\\n          }\\n        });\\n      }\\n      const params = { errorMap: ctx.common.contextualErrorMap };\\n      const fn = ctx.data;\\n      if (this._def.returns instanceof ZodPromise) {\\n        const me = this;\\n        return OK(async function(...args) {\\n          const error = new ZodError([]);\\n          const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {\\n            error.addIssue(makeArgsIssue(args, e));\\n            throw error;\\n          });\\n          const result = await Reflect.apply(fn, this, parsedArgs);\\n          const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {\\n            error.addIssue(makeReturnsIssue(result, e));\\n            throw error;\\n          });\\n          return parsedReturns;\\n        });\\n      } else {\\n        const me = this;\\n        return OK(function(...args) {\\n          const parsedArgs = me._def.args.safeParse(args, params);\\n          if (!parsedArgs.success) {\\n            throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\\n          }\\n          const result = Reflect.apply(fn, this, parsedArgs.data);\\n          const parsedReturns = me._def.returns.safeParse(result, params);\\n          if (!parsedReturns.success) {\\n            throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\\n          }\\n          return parsedReturns.data;\\n        });\\n      }\\n    }\\n    parameters() {\\n      return this._def.args;\\n    }\\n    returnType() {\\n      return this._def.returns;\\n    }\\n    args(...items) {\\n      return new _ZodFunction({\\n        ...this._def,\\n        args: ZodTuple.create(items).rest(ZodUnknown.create())\\n      });\\n    }\\n    returns(returnType) {\\n      return new _ZodFunction({\\n        ...this._def,\\n        returns: returnType\\n      });\\n    }\\n    implement(func) {\\n      const validatedFunc = this.parse(func);\\n      return validatedFunc;\\n    }\\n    strictImplement(func) {\\n      const validatedFunc = this.parse(func);\\n      return validatedFunc;\\n    }\\n    static create(args, returns, params) {\\n      return new _ZodFunction({\\n        args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),\\n        returns: returns || ZodUnknown.create(),\\n        typeName: ZodFirstPartyTypeKind.ZodFunction,\\n        ...processCreateParams(params)\\n      });\\n    }\\n  };\\n  var ZodLazy = class extends ZodType {\\n    get schema() {\\n      return this._def.getter();\\n    }\\n    _parse(input) {\\n      const { ctx } = this._processInputParams(input);\\n      const lazySchema = this._def.getter();\\n      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\\n    }\\n  };\\n  ZodLazy.create = (getter, params) => {\\n    return new ZodLazy({\\n      getter,\\n      typeName: ZodFirstPartyTypeKind.ZodLazy,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  var ZodLiteral = class extends ZodType {\\n    _parse(input) {\\n      if (input.data !== this._def.value) {\\n        const ctx = this._getOrReturnCtx(input);\\n        addIssueToContext(ctx, {\\n          received: ctx.data,\\n          code: ZodIssueCode.invalid_literal,\\n          expected: this._def.value\\n        });\\n        return INVALID;\\n      }\\n      return { status: \"valid\", value: input.data };\\n    }\\n    get value() {\\n      return this._def.value;\\n    }\\n  };\\n  ZodLiteral.create = (value, params) => {\\n    return new ZodLiteral({\\n      value,\\n      typeName: ZodFirstPartyTypeKind.ZodLiteral,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  function createZodEnum(values, params) {\\n    return new ZodEnum({\\n      values,\\n      typeName: ZodFirstPartyTypeKind.ZodEnum,\\n      ...processCreateParams(params)\\n    });\\n  }\\n  var ZodEnum = class _ZodEnum extends ZodType {\\n    constructor() {\\n      super(...arguments);\\n      _ZodEnum_cache.set(this, void 0);\\n    }\\n    _parse(input) {\\n      if (typeof input.data !== \"string\") {\\n        const ctx = this._getOrReturnCtx(input);\\n        const expectedValues = this._def.values;\\n        addIssueToContext(ctx, {\\n          expected: util.joinValues(expectedValues),\\n          received: ctx.parsedType,\\n          code: ZodIssueCode.invalid_type\\n        });\\n        return INVALID;\\n      }\\n      if (!__classPrivateFieldGet(this, _ZodEnum_cache, \"f\")) {\\n        __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), \"f\");\\n      }\\n      if (!__classPrivateFieldGet(this, _ZodEnum_cache, \"f\").has(input.data)) {\\n        const ctx = this._getOrReturnCtx(input);\\n        const expectedValues = this._def.values;\\n        addIssueToContext(ctx, {\\n          received: ctx.data,\\n          code: ZodIssueCode.invalid_enum_value,\\n          options: expectedValues\\n        });\\n        return INVALID;\\n      }\\n      return OK(input.data);\\n    }\\n    get options() {\\n      return this._def.values;\\n    }\\n    get enum() {\\n      const enumValues = {};\\n      for (const val of this._def.values) {\\n        enumValues[val] = val;\\n      }\\n      return enumValues;\\n    }\\n    get Values() {\\n      const enumValues = {};\\n      for (const val of this._def.values) {\\n        enumValues[val] = val;\\n      }\\n      return enumValues;\\n    }\\n    get Enum() {\\n      const enumValues = {};\\n      for (const val of this._def.values) {\\n        enumValues[val] = val;\\n      }\\n      return enumValues;\\n    }\\n    extract(values, newDef = this._def) {\\n      return _ZodEnum.create(values, {\\n        ...this._def,\\n        ...newDef\\n      });\\n    }\\n    exclude(values, newDef = this._def) {\\n      return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {\\n        ...this._def,\\n        ...newDef\\n      });\\n    }\\n  };\\n  _ZodEnum_cache = /* @__PURE__ */ new WeakMap();\\n  ZodEnum.create = createZodEnum;\\n  var ZodNativeEnum = class extends ZodType {\\n    constructor() {\\n      super(...arguments);\\n      _ZodNativeEnum_cache.set(this, void 0);\\n    }\\n    _parse(input) {\\n      const nativeEnumValues = util.getValidEnumValues(this._def.values);\\n      const ctx = this._getOrReturnCtx(input);\\n      if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\\n        const expectedValues = util.objectValues(nativeEnumValues);\\n        addIssueToContext(ctx, {\\n          expected: util.joinValues(expectedValues),\\n          received: ctx.parsedType,\\n          code: ZodIssueCode.invalid_type\\n        });\\n        return INVALID;\\n      }\\n      if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, \"f\")) {\\n        __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), \"f\");\\n      }\\n      if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, \"f\").has(input.data)) {\\n        const expectedValues = util.objectValues(nativeEnumValues);\\n        addIssueToContext(ctx, {\\n          received: ctx.data,\\n          code: ZodIssueCode.invalid_enum_value,\\n          options: expectedValues\\n        });\\n        return INVALID;\\n      }\\n      return OK(input.data);\\n    }\\n    get enum() {\\n      return this._def.values;\\n    }\\n  };\\n  _ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();\\n  ZodNativeEnum.create = (values, params) => {\\n    return new ZodNativeEnum({\\n      values,\\n      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  var ZodPromise = class extends ZodType {\\n    unwrap() {\\n      return this._def.type;\\n    }\\n    _parse(input) {\\n      const { ctx } = this._processInputParams(input);\\n      if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {\\n        addIssueToContext(ctx, {\\n          code: ZodIssueCode.invalid_type,\\n          expected: ZodParsedType.promise,\\n          received: ctx.parsedType\\n        });\\n        return INVALID;\\n      }\\n      const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\\n      return OK(promisified.then((data) => {\\n        return this._def.type.parseAsync(data, {\\n          path: ctx.path,\\n          errorMap: ctx.common.contextualErrorMap\\n        });\\n      }));\\n    }\\n  };\\n  ZodPromise.create = (schema, params) => {\\n    return new ZodPromise({\\n      type: schema,\\n      typeName: ZodFirstPartyTypeKind.ZodPromise,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  var ZodEffects = class extends ZodType {\\n    innerType() {\\n      return this._def.schema;\\n    }\\n    sourceType() {\\n      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;\\n    }\\n    _parse(input) {\\n      const { status, ctx } = this._processInputParams(input);\\n      const effect = this._def.effect || null;\\n      const checkCtx = {\\n        addIssue: (arg) => {\\n          addIssueToContext(ctx, arg);\\n          if (arg.fatal) {\\n            status.abort();\\n          } else {\\n            status.dirty();\\n          }\\n        },\\n        get path() {\\n          return ctx.path;\\n        }\\n      };\\n      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\\n      if (effect.type === \"preprocess\") {\\n        const processed = effect.transform(ctx.data, checkCtx);\\n        if (ctx.common.async) {\\n          return Promise.resolve(processed).then(async (processed2) => {\\n            if (status.value === \"aborted\")\\n              return INVALID;\\n            const result = await this._def.schema._parseAsync({\\n              data: processed2,\\n              path: ctx.path,\\n              parent: ctx\\n            });\\n            if (result.status === \"aborted\")\\n              return INVALID;\\n            if (result.status === \"dirty\")\\n              return DIRTY(result.value);\\n            if (status.value === \"dirty\")\\n              return DIRTY(result.value);\\n            return result;\\n          });\\n        } else {\\n          if (status.value === \"aborted\")\\n            return INVALID;\\n          const result = this._def.schema._parseSync({\\n            data: processed,\\n            path: ctx.path,\\n            parent: ctx\\n          });\\n          if (result.status === \"aborted\")\\n            return INVALID;\\n          if (result.status === \"dirty\")\\n            return DIRTY(result.value);\\n          if (status.value === \"dirty\")\\n            return DIRTY(result.value);\\n          return result;\\n        }\\n      }\\n      if (effect.type === \"refinement\") {\\n        const executeRefinement = (acc) => {\\n          const result = effect.refinement(acc, checkCtx);\\n          if (ctx.common.async) {\\n            return Promise.resolve(result);\\n          }\\n          if (result instanceof Promise) {\\n            throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\\n          }\\n          return acc;\\n        };\\n        if (ctx.common.async === false) {\\n          const inner = this._def.schema._parseSync({\\n            data: ctx.data,\\n            path: ctx.path,\\n            parent: ctx\\n          });\\n          if (inner.status === \"aborted\")\\n            return INVALID;\\n          if (inner.status === \"dirty\")\\n            status.dirty();\\n          executeRefinement(inner.value);\\n          return { status: status.value, value: inner.value };\\n        } else {\\n          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {\\n            if (inner.status === \"aborted\")\\n              return INVALID;\\n            if (inner.status === \"dirty\")\\n              status.dirty();\\n            return executeRefinement(inner.value).then(() => {\\n              return { status: status.value, value: inner.value };\\n            });\\n          });\\n        }\\n      }\\n      if (effect.type === \"transform\") {\\n        if (ctx.common.async === false) {\\n          const base2 = this._def.schema._parseSync({\\n            data: ctx.data,\\n            path: ctx.path,\\n            parent: ctx\\n          });\\n          if (!isValid(base2))\\n            return base2;\\n          const result = effect.transform(base2.value, checkCtx);\\n          if (result instanceof Promise) {\\n            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\\n          }\\n          return { status: status.value, value: result };\\n        } else {\\n          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base2) => {\\n            if (!isValid(base2))\\n              return base2;\\n            return Promise.resolve(effect.transform(base2.value, checkCtx)).then((result) => ({ status: status.value, value: result }));\\n          });\\n        }\\n      }\\n      util.assertNever(effect);\\n    }\\n  };\\n  ZodEffects.create = (schema, effect, params) => {\\n    return new ZodEffects({\\n      schema,\\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\\n      effect,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  ZodEffects.createWithPreprocess = (preprocess, schema, params) => {\\n    return new ZodEffects({\\n      schema,\\n      effect: { type: \"preprocess\", transform: preprocess },\\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  var ZodOptional = class extends ZodType {\\n    _parse(input) {\\n      const parsedType = this._getType(input);\\n      if (parsedType === ZodParsedType.undefined) {\\n        return OK(void 0);\\n      }\\n      return this._def.innerType._parse(input);\\n    }\\n    unwrap() {\\n      return this._def.innerType;\\n    }\\n  };\\n  ZodOptional.create = (type, params) => {\\n    return new ZodOptional({\\n      innerType: type,\\n      typeName: ZodFirstPartyTypeKind.ZodOptional,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  var ZodNullable = class extends ZodType {\\n    _parse(input) {\\n      const parsedType = this._getType(input);\\n      if (parsedType === ZodParsedType.null) {\\n        return OK(null);\\n      }\\n      return this._def.innerType._parse(input);\\n    }\\n    unwrap() {\\n      return this._def.innerType;\\n    }\\n  };\\n  ZodNullable.create = (type, params) => {\\n    return new ZodNullable({\\n      innerType: type,\\n      typeName: ZodFirstPartyTypeKind.ZodNullable,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  var ZodDefault = class extends ZodType {\\n    _parse(input) {\\n      const { ctx } = this._processInputParams(input);\\n      let data = ctx.data;\\n      if (ctx.parsedType === ZodParsedType.undefined) {\\n        data = this._def.defaultValue();\\n      }\\n      return this._def.innerType._parse({\\n        data,\\n        path: ctx.path,\\n        parent: ctx\\n      });\\n    }\\n    removeDefault() {\\n      return this._def.innerType;\\n    }\\n  };\\n  ZodDefault.create = (type, params) => {\\n    return new ZodDefault({\\n      innerType: type,\\n      typeName: ZodFirstPartyTypeKind.ZodDefault,\\n      defaultValue: typeof params.default === \"function\" ? params.default : () => params.default,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  var ZodCatch = class extends ZodType {\\n    _parse(input) {\\n      const { ctx } = this._processInputParams(input);\\n      const newCtx = {\\n        ...ctx,\\n        common: {\\n          ...ctx.common,\\n          issues: []\\n        }\\n      };\\n      const result = this._def.innerType._parse({\\n        data: newCtx.data,\\n        path: newCtx.path,\\n        parent: {\\n          ...newCtx\\n        }\\n      });\\n      if (isAsync(result)) {\\n        return result.then((result2) => {\\n          return {\\n            status: \"valid\",\\n            value: result2.status === \"valid\" ? result2.value : this._def.catchValue({\\n              get error() {\\n                return new ZodError(newCtx.common.issues);\\n              },\\n              input: newCtx.data\\n            })\\n          };\\n        });\\n      } else {\\n        return {\\n          status: \"valid\",\\n          value: result.status === \"valid\" ? result.value : this._def.catchValue({\\n            get error() {\\n              return new ZodError(newCtx.common.issues);\\n            },\\n            input: newCtx.data\\n          })\\n        };\\n      }\\n    }\\n    removeCatch() {\\n      return this._def.innerType;\\n    }\\n  };\\n  ZodCatch.create = (type, params) => {\\n    return new ZodCatch({\\n      innerType: type,\\n      typeName: ZodFirstPartyTypeKind.ZodCatch,\\n      catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  var ZodNaN = class extends ZodType {\\n    _parse(input) {\\n      const parsedType = this._getType(input);\\n      if (parsedType !== ZodParsedType.nan) {\\n        const ctx = this._getOrReturnCtx(input);\\n        addIssueToContext(ctx, {\\n          code: ZodIssueCode.invalid_type,\\n          expected: ZodParsedType.nan,\\n          received: ctx.parsedType\\n        });\\n        return INVALID;\\n      }\\n      return { status: \"valid\", value: input.data };\\n    }\\n  };\\n  ZodNaN.create = (params) => {\\n    return new ZodNaN({\\n      typeName: ZodFirstPartyTypeKind.ZodNaN,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  var BRAND = Symbol(\"zod_brand\");\\n  var ZodBranded = class extends ZodType {\\n    _parse(input) {\\n      const { ctx } = this._processInputParams(input);\\n      const data = ctx.data;\\n      return this._def.type._parse({\\n        data,\\n        path: ctx.path,\\n        parent: ctx\\n      });\\n    }\\n    unwrap() {\\n      return this._def.type;\\n    }\\n  };\\n  var ZodPipeline = class _ZodPipeline extends ZodType {\\n    _parse(input) {\\n      const { status, ctx } = this._processInputParams(input);\\n      if (ctx.common.async) {\\n        const handleAsync = async () => {\\n          const inResult = await this._def.in._parseAsync({\\n            data: ctx.data,\\n            path: ctx.path,\\n            parent: ctx\\n          });\\n          if (inResult.status === \"aborted\")\\n            return INVALID;\\n          if (inResult.status === \"dirty\") {\\n            status.dirty();\\n            return DIRTY(inResult.value);\\n          } else {\\n            return this._def.out._parseAsync({\\n              data: inResult.value,\\n              path: ctx.path,\\n              parent: ctx\\n            });\\n          }\\n        };\\n        return handleAsync();\\n      } else {\\n        const inResult = this._def.in._parseSync({\\n          data: ctx.data,\\n          path: ctx.path,\\n          parent: ctx\\n        });\\n        if (inResult.status === \"aborted\")\\n          return INVALID;\\n        if (inResult.status === \"dirty\") {\\n          status.dirty();\\n          return {\\n            status: \"dirty\",\\n            value: inResult.value\\n          };\\n        } else {\\n          return this._def.out._parseSync({\\n            data: inResult.value,\\n            path: ctx.path,\\n            parent: ctx\\n          });\\n        }\\n      }\\n    }\\n    static create(a, b) {\\n      return new _ZodPipeline({\\n        in: a,\\n        out: b,\\n        typeName: ZodFirstPartyTypeKind.ZodPipeline\\n      });\\n    }\\n  };\\n  var ZodReadonly = class extends ZodType {\\n    _parse(input) {\\n      const result = this._def.innerType._parse(input);\\n      const freeze = (data) => {\\n        if (isValid(data)) {\\n          data.value = Object.freeze(data.value);\\n        }\\n        return data;\\n      };\\n      return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);\\n    }\\n    unwrap() {\\n      return this._def.innerType;\\n    }\\n  };\\n  ZodReadonly.create = (type, params) => {\\n    return new ZodReadonly({\\n      innerType: type,\\n      typeName: ZodFirstPartyTypeKind.ZodReadonly,\\n      ...processCreateParams(params)\\n    });\\n  };\\n  function cleanParams(params, data) {\\n    const p = typeof params === \"function\" ? params(data) : typeof params === \"string\" ? { message: params } : params;\\n    const p2 = typeof p === \"string\" ? { message: p } : p;\\n    return p2;\\n  }\\n  function custom2(check, _params = {}, fatal) {\\n    if (check)\\n      return ZodAny.create().superRefine((data, ctx) => {\\n        var _a, _b;\\n        const r = check(data);\\n        if (r instanceof Promise) {\\n          return r.then((r2) => {\\n            var _a2, _b2;\\n            if (!r2) {\\n              const params = cleanParams(_params, data);\\n              const _fatal = (_b2 = (_a2 = params.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;\\n              ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\\n            }\\n          });\\n        }\\n        if (!r) {\\n          const params = cleanParams(_params, data);\\n          const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;\\n          ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\\n        }\\n        return;\\n      });\\n    return ZodAny.create();\\n  }\\n  var late = {\\n    object: ZodObject.lazycreate\\n  };\\n  var ZodFirstPartyTypeKind;\\n  (function(ZodFirstPartyTypeKind2) {\\n    ZodFirstPartyTypeKind2[\"ZodString\"] = \"ZodString\";\\n    ZodFirstPartyTypeKind2[\"ZodNumber\"] = \"ZodNumber\";\\n    ZodFirstPartyTypeKind2[\"ZodNaN\"] = \"ZodNaN\";\\n    ZodFirstPartyTypeKind2[\"ZodBigInt\"] = \"ZodBigInt\";\\n    ZodFirstPartyTypeKind2[\"ZodBoolean\"] = \"ZodBoolean\";\\n    ZodFirstPartyTypeKind2[\"ZodDate\"] = \"ZodDate\";\\n    ZodFirstPartyTypeKind2[\"ZodSymbol\"] = \"ZodSymbol\";\\n    ZodFirstPartyTypeKind2[\"ZodUndefined\"] = \"ZodUndefined\";\\n    ZodFirstPartyTypeKind2[\"ZodNull\"] = \"ZodNull\";\\n    ZodFirstPartyTypeKind2[\"ZodAny\"] = \"ZodAny\";\\n    ZodFirstPartyTypeKind2[\"ZodUnknown\"] = \"ZodUnknown\";\\n    ZodFirstPartyTypeKind2[\"ZodNever\"] = \"ZodNever\";\\n    ZodFirstPartyTypeKind2[\"ZodVoid\"] = \"ZodVoid\";\\n    ZodFirstPartyTypeKind2[\"ZodArray\"] = \"ZodArray\";\\n    ZodFirstPartyTypeKind2[\"ZodObject\"] = \"ZodObject\";\\n    ZodFirstPartyTypeKind2[\"ZodUnion\"] = \"ZodUnion\";\\n    ZodFirstPartyTypeKind2[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\\n    ZodFirstPartyTypeKind2[\"ZodIntersection\"] = \"ZodIntersection\";\\n    ZodFirstPartyTypeKind2[\"ZodTuple\"] = \"ZodTuple\";\\n    ZodFirstPartyTypeKind2[\"ZodRecord\"] = \"ZodRecord\";\\n    ZodFirstPartyTypeKind2[\"ZodMap\"] = \"ZodMap\";\\n    ZodFirstPartyTypeKind2[\"ZodSet\"] = \"ZodSet\";\\n    ZodFirstPartyTypeKind2[\"ZodFunction\"] = \"ZodFunction\";\\n    ZodFirstPartyTypeKind2[\"ZodLazy\"] = \"ZodLazy\";\\n    ZodFirstPartyTypeKind2[\"ZodLiteral\"] = \"ZodLiteral\";\\n    ZodFirstPartyTypeKind2[\"ZodEnum\"] = \"ZodEnum\";\\n    ZodFirstPartyTypeKind2[\"ZodEffects\"] = \"ZodEffects\";\\n    ZodFirstPartyTypeKind2[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\\n    ZodFirstPartyTypeKind2[\"ZodOptional\"] = \"ZodOptional\";\\n    ZodFirstPartyTypeKind2[\"ZodNullable\"] = \"ZodNullable\";\\n    ZodFirstPartyTypeKind2[\"ZodDefault\"] = \"ZodDefault\";\\n    ZodFirstPartyTypeKind2[\"ZodCatch\"] = \"ZodCatch\";\\n    ZodFirstPartyTypeKind2[\"ZodPromise\"] = \"ZodPromise\";\\n    ZodFirstPartyTypeKind2[\"ZodBranded\"] = \"ZodBranded\";\\n    ZodFirstPartyTypeKind2[\"ZodPipeline\"] = \"ZodPipeline\";\\n    ZodFirstPartyTypeKind2[\"ZodReadonly\"] = \"ZodReadonly\";\\n  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\\n  var instanceOfType = (cls, params = {\\n    message: `Input not instance of ${cls.name}`\\n  }) => custom2((data) => data instanceof cls, params);\\n  var stringType = ZodString.create;\\n  var numberType = ZodNumber.create;\\n  var nanType = ZodNaN.create;\\n  var bigIntType = ZodBigInt.create;\\n  var booleanType = ZodBoolean.create;\\n  var dateType = ZodDate.create;\\n  var symbolType = ZodSymbol.create;\\n  var undefinedType = ZodUndefined.create;\\n  var nullType = ZodNull.create;\\n  var anyType = ZodAny.create;\\n  var unknownType = ZodUnknown.create;\\n  var neverType = ZodNever.create;\\n  var voidType = ZodVoid.create;\\n  var arrayType = ZodArray.create;\\n  var objectType = ZodObject.create;\\n  var strictObjectType = ZodObject.strictCreate;\\n  var unionType = ZodUnion.create;\\n  var discriminatedUnionType = ZodDiscriminatedUnion.create;\\n  var intersectionType = ZodIntersection.create;\\n  var tupleType = ZodTuple.create;\\n  var recordType = ZodRecord.create;\\n  var mapType = ZodMap.create;\\n  var setType = ZodSet.create;\\n  var functionType = ZodFunction.create;\\n  var lazyType = ZodLazy.create;\\n  var literalType = ZodLiteral.create;\\n  var enumType = ZodEnum.create;\\n  var nativeEnumType = ZodNativeEnum.create;\\n  var promiseType = ZodPromise.create;\\n  var effectsType = ZodEffects.create;\\n  var optionalType = ZodOptional.create;\\n  var nullableType = ZodNullable.create;\\n  var preprocessType = ZodEffects.createWithPreprocess;\\n  var pipelineType = ZodPipeline.create;\\n  var ostring = () => stringType().optional();\\n  var onumber = () => numberType().optional();\\n  var oboolean = () => booleanType().optional();\\n  var coerce = {\\n    string: (arg) => ZodString.create({ ...arg, coerce: true }),\\n    number: (arg) => ZodNumber.create({ ...arg, coerce: true }),\\n    boolean: (arg) => ZodBoolean.create({\\n      ...arg,\\n      coerce: true\\n    }),\\n    bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),\\n    date: (arg) => ZodDate.create({ ...arg, coerce: true })\\n  };\\n  var NEVER = INVALID;\\n  var z = /* @__PURE__ */ Object.freeze({\\n    __proto__: null,\\n    defaultErrorMap: errorMap,\\n    setErrorMap,\\n    getErrorMap,\\n    makeIssue,\\n    EMPTY_PATH,\\n    addIssueToContext,\\n    ParseStatus,\\n    INVALID,\\n    DIRTY,\\n    OK,\\n    isAborted,\\n    isDirty,\\n    isValid,\\n    isAsync,\\n    get util() {\\n      return util;\\n    },\\n    get objectUtil() {\\n      return objectUtil;\\n    },\\n    ZodParsedType,\\n    getParsedType,\\n    ZodType,\\n    datetimeRegex,\\n    ZodString,\\n    ZodNumber,\\n    ZodBigInt,\\n    ZodBoolean,\\n    ZodDate,\\n    ZodSymbol,\\n    ZodUndefined,\\n    ZodNull,\\n    ZodAny,\\n    ZodUnknown,\\n    ZodNever,\\n    ZodVoid,\\n    ZodArray,\\n    ZodObject,\\n    ZodUnion,\\n    ZodDiscriminatedUnion,\\n    ZodIntersection,\\n    ZodTuple,\\n    ZodRecord,\\n    ZodMap,\\n    ZodSet,\\n    ZodFunction,\\n    ZodLazy,\\n    ZodLiteral,\\n    ZodEnum,\\n    ZodNativeEnum,\\n    ZodPromise,\\n    ZodEffects,\\n    ZodTransformer: ZodEffects,\\n    ZodOptional,\\n    ZodNullable,\\n    ZodDefault,\\n    ZodCatch,\\n    ZodNaN,\\n    BRAND,\\n    ZodBranded,\\n    ZodPipeline,\\n    ZodReadonly,\\n    custom: custom2,\\n    Schema: ZodType,\\n    ZodSchema: ZodType,\\n    late,\\n    get ZodFirstPartyTypeKind() {\\n      return ZodFirstPartyTypeKind;\\n    },\\n    coerce,\\n    any: anyType,\\n    array: arrayType,\\n    bigint: bigIntType,\\n    boolean: booleanType,\\n    date: dateType,\\n    discriminatedUnion: discriminatedUnionType,\\n    effect: effectsType,\\n    \"enum\": enumType,\\n    \"function\": functionType,\\n    \"instanceof\": instanceOfType,\\n    intersection: intersectionType,\\n    lazy: lazyType,\\n    literal: literalType,\\n    map: mapType,\\n    nan: nanType,\\n    nativeEnum: nativeEnumType,\\n    never: neverType,\\n    \"null\": nullType,\\n    nullable: nullableType,\\n    number: numberType,\\n    object: objectType,\\n    oboolean,\\n    onumber,\\n    optional: optionalType,\\n    ostring,\\n    pipeline: pipelineType,\\n    preprocess: preprocessType,\\n    promise: promiseType,\\n    record: recordType,\\n    set: setType,\\n    strictObject: strictObjectType,\\n    string: stringType,\\n    symbol: symbolType,\\n    transformer: effectsType,\\n    tuple: tupleType,\\n    \"undefined\": undefinedType,\\n    union: unionType,\\n    unknown: unknownType,\\n    \"void\": voidType,\\n    NEVER,\\n    ZodIssueCode,\\n    quotelessJson,\\n    ZodError\\n  });\\n\\n  // src/types/shared/money.ts\\n  var moneySchema = z.union([z.string().transform((x) => x.replace(/[^0-9.-]+/g, \"\")), z.number()]).pipe(z.coerce.number().min(1e-4).max(999999999));\\n\\n  // src/types/shared/network.ts\\n  var NetworkSchema = z.enum([\\n    \"base-sepolia\",\\n    \"base\",\\n    \"avalanche-fuji\",\\n    \"avalanche\",\\n    \"iotex\"\\n  ]);\\n  var SupportedEVMNetworks = [\\n    \"base-sepolia\",\\n    \"base\",\\n    \"avalanche-fuji\",\\n    \"avalanche\",\\n    \"iotex\"\\n  ];\\n  var EvmNetworkToChainId = /* @__PURE__ */ new Map([\\n    [\"base-sepolia\", 84532],\\n    [\"base\", 8453],\\n    [\"avalanche-fuji\", 43113],\\n    [\"avalanche\", 43114],\\n    [\"iotex\", 4689]\\n  ]);\\n  var ChainIdToNetwork = Object.fromEntries(\\n    SupportedEVMNetworks.map((network) => [EvmNetworkToChainId.get(network), network])\\n  );\\n\\n  // src/shared/network.ts\\n  function getNetworkId(network) {\\n    if (EvmNetworkToChainId.has(network)) {\\n      return EvmNetworkToChainId.get(network);\\n    }\\n    throw new Error(`Unsupported network: ${network}`);\\n  }\\n\\n  // src/types/verify/x402Specs.ts\\n  var EvmMaxAtomicUnits = 18;\\n  var EvmAddressRegex = /^0x[0-9a-fA-F]{40}$/;\\n  var MixedAddressRegex = /^0x[a-fA-F0-9]{40}|[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$/;\\n  var HexEncoded64ByteRegex = /^0x[0-9a-fA-F]{64}$/;\\n  var EvmSignatureRegex = /^0x[0-9a-fA-F]{130}$/;\\n  var schemes = [\"exact\"];\\n  var x402Versions = [1];\\n  var ErrorReasons = [\"insufficient_funds\", \"invalid_scheme\", \"invalid_network\"];\\n  var isInteger = (value) => Number.isInteger(Number(value)) && Number(value) >= 0;\\n  var hasMaxLength = (maxLength) => (value) => value.length <= maxLength;\\n  var PaymentRequirementsSchema = z.object({\\n    scheme: z.enum(schemes),\\n    network: NetworkSchema,\\n    maxAmountRequired: z.string().refine(isInteger),\\n    resource: z.string().url(),\\n    description: z.string(),\\n    mimeType: z.string(),\\n    outputSchema: z.record(z.any()).optional(),\\n    payTo: z.string().regex(MixedAddressRegex),\\n    maxTimeoutSeconds: z.number().int(),\\n    asset: z.string().regex(MixedAddressRegex),\\n    extra: z.record(z.any()).optional()\\n  });\\n  var ExactEvmPayloadAuthorizationSchema = z.object({\\n    from: z.string().regex(EvmAddressRegex),\\n    to: z.string().regex(EvmAddressRegex),\\n    value: z.string().refine(isInteger).refine(hasMaxLength(EvmMaxAtomicUnits)),\\n    validAfter: z.string().refine(isInteger),\\n    validBefore: z.string().refine(isInteger),\\n    nonce: z.string().regex(HexEncoded64ByteRegex)\\n  });\\n  var ExactEvmPayloadSchema = z.object({\\n    signature: z.string().regex(EvmSignatureRegex),\\n    authorization: ExactEvmPayloadAuthorizationSchema\\n  });\\n  var PaymentPayloadSchema = z.object({\\n    x402Version: z.number().refine((val) => x402Versions.includes(val)),\\n    scheme: z.enum(schemes),\\n    network: NetworkSchema,\\n    payload: ExactEvmPayloadSchema\\n  });\\n  var VerifyResponseSchema = z.object({\\n    isValid: z.boolean(),\\n    invalidReason: z.enum(ErrorReasons).optional(),\\n    payer: z.string().regex(MixedAddressRegex).optional()\\n  });\\n  var SettleResponseSchema = z.object({\\n    success: z.boolean(),\\n    errorReason: z.enum(ErrorReasons).optional(),\\n    payer: z.string().regex(MixedAddressRegex).optional(),\\n    transaction: z.string().regex(MixedAddressRegex),\\n    network: NetworkSchema\\n  });\\n  var SupportedPaymentKindSchema = z.object({\\n    x402Version: z.number().refine((val) => x402Versions.includes(val)),\\n    scheme: z.enum(schemes),\\n    network: NetworkSchema\\n  });\\n  var SupportedPaymentKindsResponseSchema = z.object({\\n    kinds: z.array(SupportedPaymentKindSchema)\\n  });\\n\\n  // src/types/verify/facilitator.ts\\n  var facilitatorRequestSchema = z.object({\\n    paymentHeader: z.string(),\\n    paymentRequirements: PaymentRequirementsSchema\\n  });\\n\\n  // src/shared/evm/usdc.ts\\n  function getUsdcAddress(client) {\\n    return config[client.chain.id.toString()].usdcAddress;\\n  }\\n  function getUsdcAddressForChain(chainId) {\\n    return config[chainId.toString()].usdcAddress;\\n  }\\n  var versionCache = null;\\n  async function getVersion2(client) {\\n    if (versionCache !== null) {\\n      return versionCache;\\n    }\\n    const version4 = await client.readContract({\\n      address: getUsdcAddress(client),\\n      abi: usdcABI,\\n      functionName: \"version\"\\n    });\\n    versionCache = version4;\\n    return versionCache;\\n  }\\n  async function getUSDCBalance(client, address) {\\n    const balance = await client.readContract({\\n      address: getUsdcAddressForChain(client.chain.id),\\n      abi: usdcABI,\\n      functionName: \"balanceOf\",\\n      args: [address]\\n    });\\n    return balance;\\n  }\\n\\n  // src/schemes/exact/evm/sign.ts\\n  async function signAuthorization2(walletClient, { from: from5, to, value, validAfter, validBefore, nonce }, { asset, network, extra }) {\\n    const chainId = getNetworkId(network);\\n    const name = extra?.name;\\n    const version4 = extra?.version;\\n    const account = isSignerWallet(walletClient) ? walletClient.account : walletClient;\\n    const data = {\\n      account,\\n      types: authorizationTypes,\\n      domain: {\\n        name,\\n        version: version4,\\n        chainId,\\n        verifyingContract: asset\\n      },\\n      primaryType: \"TransferWithAuthorization\",\\n      message: {\\n        from: from5,\\n        to,\\n        value,\\n        validAfter,\\n        validBefore,\\n        nonce\\n      }\\n    };\\n    if (isSignerWallet(walletClient)) {\\n      const signature = await walletClient.signTypedData(data);\\n      return {\\n        signature\\n      };\\n    } else if (isAccount(walletClient) && walletClient.signTypedData) {\\n      const signature = await walletClient.signTypedData(data);\\n      return {\\n        signature\\n      };\\n    } else {\\n      throw new Error(\"Invalid wallet client provided does not support signTypedData\");\\n    }\\n  }\\n  function createNonce() {\\n    const cryptoObj = typeof globalThis.crypto !== \"undefined\" && typeof globalThis.crypto.getRandomValues === \"function\" ? globalThis.crypto : (\\n      // Dynamic require is needed to support node.js\\n      // eslint-disable-next-line @typescript-eslint/no-require-imports\\n      __require(\"crypto\").webcrypto\\n    );\\n    return toHex(cryptoObj.getRandomValues(new Uint8Array(32)));\\n  }\\n\\n  // src/schemes/exact/evm/utils/paymentUtils.ts\\n  function encodePayment(payment) {\\n    const safe = {\\n      ...payment,\\n      payload: {\\n        ...payment.payload,\\n        authorization: Object.fromEntries(\\n          Object.entries(payment.payload.authorization).map(([key, value]) => [\\n            key,\\n            typeof value === \"bigint\" ? value.toString() : value\\n          ])\\n        )\\n      }\\n    };\\n    return safeBase64Encode(JSON.stringify(safe));\\n  }\\n\\n  // src/schemes/exact/evm/client.ts\\n  function preparePaymentHeader(from5, x402Version, paymentRequirements) {\\n    const nonce = createNonce();\\n    const validAfter = BigInt(\\n      Math.floor(Date.now() / 1e3) - 600\\n      // 10 minutes before\\n    ).toString();\\n    const validBefore = BigInt(\\n      Math.floor(Date.now() / 1e3 + paymentRequirements.maxTimeoutSeconds)\\n    ).toString();\\n    return {\\n      x402Version,\\n      scheme: paymentRequirements.scheme,\\n      network: paymentRequirements.network,\\n      payload: {\\n        signature: void 0,\\n        authorization: {\\n          from: from5,\\n          to: paymentRequirements.payTo,\\n          value: paymentRequirements.maxAmountRequired,\\n          validAfter: validAfter.toString(),\\n          validBefore: validBefore.toString(),\\n          nonce\\n        }\\n      }\\n    };\\n  }\\n  async function signPaymentHeader(client, paymentRequirements, unsignedPaymentHeader) {\\n    const { signature } = await signAuthorization2(\\n      client,\\n      unsignedPaymentHeader.payload.authorization,\\n      paymentRequirements\\n    );\\n    return {\\n      ...unsignedPaymentHeader,\\n      payload: {\\n        ...unsignedPaymentHeader.payload,\\n        signature\\n      }\\n    };\\n  }\\n  async function createPayment(client, x402Version, paymentRequirements) {\\n    const from5 = isSignerWallet(client) ? client.account.address : client.address;\\n    const unsignedPaymentHeader = preparePaymentHeader(from5, x402Version, paymentRequirements);\\n    return signPaymentHeader(client, paymentRequirements, unsignedPaymentHeader);\\n  }\\n  async function createPaymentHeader(client, x402Version, paymentRequirements) {\\n    const payment = await createPayment(client, x402Version, paymentRequirements);\\n    return encodePayment(payment);\\n  }\\n\\n  // src/paywall/scripts.ts\\n  function safeBase64Encode2(data) {\\n    return window.btoa(data);\\n  }\\n  function selectPaymentRequirements(paymentRequirements, network, scheme = \"exact\") {\\n    const requirementsArray = Array.isArray(paymentRequirements) ? paymentRequirements : [paymentRequirements];\\n    const matching = requirementsArray.filter((req) => {\\n      const schemeMatch = !scheme || req.scheme === scheme;\\n      const networkMatch = !network || req.network === network;\\n      return schemeMatch && networkMatch;\\n    });\\n    return matching.length > 0 ? matching[0] : requirementsArray[0];\\n  }\\n  function ensureValidAmount(paymentRequirements) {\\n    const updatedRequirements = JSON.parse(JSON.stringify(paymentRequirements));\\n    if (window.x402?.amount) {\\n      try {\\n        const amountInBaseUnits = Math.round(window.x402.amount * 1e6);\\n        updatedRequirements.maxAmountRequired = amountInBaseUnits.toString();\\n      } catch (error) {\\n        console.error(\"Failed to parse amount:\", error);\\n      }\\n    }\\n    if (!updatedRequirements.maxAmountRequired || !/^\\\\d+$/.test(updatedRequirements.maxAmountRequired)) {\\n      updatedRequirements.maxAmountRequired = \"10000\";\\n    }\\n    return updatedRequirements;\\n  }\\n  function ensureFunctionsAreAvailable() {\\n    return {\\n      createPaymentHeader,\\n      createPayment,\\n      signAuthorization: signAuthorization2,\\n      createNonce,\\n      getVersion: getVersion2,\\n      encodePayment\\n    };\\n  }\\n  function updatePaymentUI(x402) {\\n    if (!x402) return;\\n    const amount = x402.amount || 0;\\n    const testnet = x402.testnet ?? true;\\n    const chainName = testnet ? \"Base Sepolia\" : \"Base\";\\n    const network = testnet ? \"base-sepolia\" : \"base\";\\n    const paymentRequirements = selectPaymentRequirements(\\n      x402.paymentRequirements,\\n      network,\\n      \"exact\"\\n    );\\n    const descriptionEl = document.getElementById(\"payment-description\");\\n    if (descriptionEl) {\\n      descriptionEl.textContent = paymentRequirements.description ? `${paymentRequirements.description}. To access this content, please pay $${amount} ${chainName} USDC.` : `To access this content, please pay $${amount} ${chainName} USDC.`;\\n    }\\n    const instructionsEl = document.getElementById(\"instructions\");\\n    if (instructionsEl) {\\n      if (testnet) {\\n        instructionsEl.style.display = \"block\";\\n      } else {\\n        instructionsEl.style.display = \"none\";\\n      }\\n    }\\n    const amountEl = document.getElementById(\"payment-amount\");\\n    if (amountEl) {\\n      amountEl.textContent = `$${amount} USDC`;\\n    }\\n    const networkEl = document.getElementById(\"payment-network\");\\n    if (networkEl) {\\n      networkEl.textContent = chainName;\\n    }\\n    const loadingElement = document.getElementById(\"loading-message\");\\n    if (loadingElement) {\\n      loadingElement.style.display = \"none\";\\n    }\\n    const walletConnectionElement = document.getElementById(\"wallet-connection\");\\n    if (walletConnectionElement) {\\n      walletConnectionElement.style.display = \"block\";\\n    }\\n  }\\n  async function connectWallet(chain) {\\n    if (!window.ethereum) {\\n      throw new Error(\"No injected Ethereum provider found. Please install MetaMask or similar.\");\\n    }\\n    const addresses = await window.ethereum.request({\\n      method: \"eth_requestAccounts\"\\n    });\\n    if (!addresses || addresses.length === 0) {\\n      throw new Error(\"No accounts found\");\\n    }\\n    try {\\n      await window.ethereum.request({\\n        method: \"wallet_switchEthereumChain\",\\n        params: [{ chainId: `0x${chain.id.toString(16)}` }]\\n      });\\n    } catch (switchError) {\\n      const error = switchError;\\n      if (error.code === 4902) {\\n        await window.ethereum.request({\\n          method: \"wallet_addEthereumChain\",\\n          params: [\\n            {\\n              chainId: `0x${chain.id.toString(16)}`,\\n              chainName: chain.name,\\n              nativeCurrency: chain.nativeCurrency,\\n              rpcUrls: [chain.rpcUrls.default.http[0]],\\n              blockExplorerUrls: [chain.blockExplorers?.default.url]\\n            }\\n          ]\\n        });\\n      } else {\\n        throw switchError;\\n      }\\n    }\\n    return addresses[0];\\n  }\\n  async function initializeApp() {\\n    const x402 = window.x402;\\n    if (!x402) {\\n      console.error(\"x402 configuration not found\");\\n      return;\\n    }\\n    ensureFunctionsAreAvailable();\\n    const chain = x402.testnet ? baseSepolia : base;\\n    const network = x402.testnet ? \"base-sepolia\" : \"base\";\\n    let walletClient = null;\\n    let address;\\n    const publicClient = createPublicClient({\\n      chain,\\n      transport: http()\\n    }).extend(publicActions);\\n    const connectWalletBtn = document.getElementById(\"connect-wallet\");\\n    const paymentSection = document.getElementById(\"payment-section\");\\n    const payButton = document.getElementById(\"pay-button\");\\n    const statusDiv = document.getElementById(\"status\");\\n    if (!connectWalletBtn || !paymentSection || !payButton || !statusDiv) {\\n      console.error(\"Required DOM elements not found\");\\n      return;\\n    }\\n    const handleWalletConnect = async () => {\\n      try {\\n        statusDiv.textContent = \"Connecting wallet...\";\\n        address = await connectWallet(chain);\\n        if (!address || !window.ethereum) {\\n          throw new Error(\"No account selected in your wallet\");\\n        }\\n        walletClient = createWalletClient({\\n          chain,\\n          transport: custom(window.ethereum),\\n          account: address\\n        }).extend(publicActions);\\n        const accountEl = document.getElementById(\"payment-account\");\\n        if (accountEl) {\\n          accountEl.textContent = `${address.slice(0, 6)}...${address.slice(-4)}`;\\n        }\\n        connectWalletBtn.textContent = \"Connected\";\\n        connectWalletBtn.classList.add(\"connected\");\\n        connectWalletBtn.disabled = true;\\n        paymentSection.classList.remove(\"hidden\");\\n        statusDiv.textContent = \"Wallet connected! You can now proceed with payment.\";\\n        connectWalletBtn.removeEventListener(\"click\", handleWalletConnect);\\n      } catch (error) {\\n        statusDiv.textContent = error instanceof Error ? error.message : \"Failed to connect wallet\";\\n        connectWalletBtn.textContent = \"Connect wallet\";\\n        connectWalletBtn.classList.remove(\"connected\");\\n        connectWalletBtn.disabled = false;\\n        paymentSection.classList.add(\"hidden\");\\n      }\\n    };\\n    const handlePayment = async () => {\\n      if (!walletClient || !address) {\\n        statusDiv.textContent = \"No wallet connected. Please connect your wallet first.\";\\n        return;\\n      }\\n      try {\\n        statusDiv.textContent = \"Checking USDC balance...\";\\n        const balance = await getUSDCBalance(publicClient, address);\\n        if (balance === 0n) {\\n          throw new Error(\\n            `Your USDC balance is 0. Please make sure you have USDC tokens on ${chain.name}`\\n          );\\n        }\\n      } catch (error) {\\n        statusDiv.textContent = error instanceof Error ? error.message : \"Failed to check USDC balance\";\\n        return;\\n      }\\n      statusDiv.textContent = \"Creating payment signature...\";\\n      try {\\n        const paymentRequirements = selectPaymentRequirements(\\n          x402.paymentRequirements,\\n          network,\\n          \"exact\"\\n        );\\n        const validPaymentRequirements = ensureValidAmount(paymentRequirements);\\n        const initialPayment = await createPayment(walletClient, 1, validPaymentRequirements);\\n        initialPayment.x402Version = 1;\\n        const paymentHeader = safeBase64Encode2(JSON.stringify(initialPayment));\\n        statusDiv.textContent = \"Requesting content with payment...\";\\n        try {\\n          const response = await fetch(x402.currentUrl, {\\n            headers: {\\n              \"X-PAYMENT\": paymentHeader,\\n              \"Access-Control-Expose-Headers\": \"X-PAYMENT-RESPONSE\"\\n            }\\n          });\\n          if (response.ok) {\\n            const contentType = response.headers.get(\"content-type\");\\n            if (contentType && contentType.includes(\"text/html\")) {\\n              document.documentElement.innerHTML = await response.text();\\n            } else {\\n              const blob = await response.blob();\\n              const url = window.URL.createObjectURL(blob);\\n              window.location.href = url;\\n            }\\n          } else if (response.status === 402) {\\n            try {\\n              const errorData = await response.json();\\n              if (errorData && typeof errorData.x402Version === \"number\") {\\n                const retryPayment = await createPayment(\\n                  walletClient,\\n                  errorData.x402Version,\\n                  validPaymentRequirements\\n                );\\n                retryPayment.x402Version = errorData.x402Version;\\n                const retryHeader = safeBase64Encode2(JSON.stringify(retryPayment));\\n                const retryResponse = await fetch(x402.currentUrl, {\\n                  headers: {\\n                    \"X-PAYMENT\": retryHeader,\\n                    \"Access-Control-Expose-Headers\": \"X-PAYMENT-RESPONSE\"\\n                  }\\n                });\\n                if (retryResponse.ok) {\\n                  const contentType = retryResponse.headers.get(\"content-type\");\\n                  if (contentType && contentType.includes(\"text/html\")) {\\n                    document.documentElement.innerHTML = await retryResponse.text();\\n                  } else {\\n                    const blob = await retryResponse.blob();\\n                    const url = window.URL.createObjectURL(blob);\\n                    window.location.href = url;\\n                  }\\n                  return;\\n                } else {\\n                  throw new Error(`Payment failed: ${retryResponse.statusText}`);\\n                }\\n              } else {\\n                throw new Error(`Payment failed: ${response.statusText}`);\\n              }\\n            } catch {\\n              throw new Error(`Payment failed: ${response.statusText}`);\\n            }\\n          } else {\\n            throw new Error(`Request failed: ${response.status} ${response.statusText}`);\\n          }\\n        } catch (fetchError) {\\n          throw fetchError;\\n        }\\n      } catch (error) {\\n        statusDiv.textContent = error instanceof Error ? error.message : \"Payment failed\";\\n      }\\n    };\\n    connectWalletBtn.addEventListener(\"click\", handleWalletConnect);\\n    payButton.addEventListener(\"click\", handlePayment);\\n  }\\n  window.addEventListener(\"load\", () => {\\n    updatePaymentUI(window.x402);\\n    initializeApp().catch((error) => {\\n      console.error(\"Failed to initialize app:\", error);\\n      const statusDiv = document.getElementById(\"status\");\\n      if (statusDiv) {\\n        statusDiv.textContent = error instanceof Error ? error.message : \"Failed to initialize app\";\\n      }\\n    });\\n  });\\n})();\\n/*! Bundled license information:\\n\\n@noble/hashes/esm/utils.js:\\n@noble/hashes/esm/utils.js:\\n  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)\\n\\n@noble/curves/esm/abstract/utils.js:\\n@noble/curves/esm/abstract/modular.js:\\n@noble/curves/esm/abstract/curve.js:\\n@noble/curves/esm/abstract/weierstrass.js:\\n@noble/curves/esm/_shortw_utils.js:\\n@noble/curves/esm/secp256k1.js:\\n  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)\\n*/\\n</script></body></html>';\n\n// src/types/shared/evm/config.ts\nvar config = {\n  \"84532\": {\n    usdcAddress: \"0x036CbD53842c5426634e7929541eC2318f3dCF7e\",\n    usdcName: \"USDC\"\n  },\n  \"8453\": {\n    usdcAddress: \"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\",\n    usdcName: \"USDC\"\n  },\n  \"43113\": {\n    usdcAddress: \"0x5425890298aed601595a70AB815c96711a31Bc65\",\n    usdcName: \"USD Coin\"\n  },\n  \"43114\": {\n    usdcAddress: \"0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E\",\n    usdcName: \"USDC\"\n  },\n  \"4689\": {\n    usdcAddress: \"0xcdf79194c6c285077a58da47641d4dbe51f63542\",\n    usdcName: \"Bridged USDC\"\n  }\n};\n\n// src/shared/paywall.ts\nfunction getPaywallHtml({\n  amount,\n  testnet,\n  paymentRequirements,\n  currentUrl\n}) {\n  const configScript = `\n  <script>\n    window.x402 = {\n      amount: ${amount},\n      paymentRequirements: ${JSON.stringify(paymentRequirements)},\n      testnet: ${testnet},\n      currentUrl: \"${currentUrl}\",\n      config: {\n        chainConfig: ${JSON.stringify(config)},\n      }\n    };\n    console.log('Payment details initialized:', window.x402.paymentDetails);\n  </script>`;\n  return PAYWALL_TEMPLATE.replace(\"</head>\", `${configScript}\n</head>`);\n}\n\n// src/shared/base64.ts\nfunction safeBase64Encode(data) {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.btoa === \"function\") {\n    return globalThis.btoa(data);\n  }\n  return Buffer.from(data).toString(\"base64\");\n}\nfunction safeBase64Decode(data) {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.atob === \"function\") {\n    return globalThis.atob(data);\n  }\n  return Buffer.from(data, \"base64\").toString(\"utf-8\");\n}\n\n// src/types/shared/money.ts\nvar import_zod = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/index.cjs\");\nvar moneySchema = import_zod.z.union([import_zod.z.string().transform((x) => x.replace(/[^0-9.-]+/g, \"\")), import_zod.z.number()]).pipe(import_zod.z.coerce.number().min(1e-4).max(999999999));\n\n// src/types/shared/network.ts\nvar import_zod2 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/index.cjs\");\nvar NetworkSchema = import_zod2.z.enum([\n  \"base-sepolia\",\n  \"base\",\n  \"avalanche-fuji\",\n  \"avalanche\",\n  \"iotex\"\n]);\nvar SupportedEVMNetworks = [\n  \"base-sepolia\",\n  \"base\",\n  \"avalanche-fuji\",\n  \"avalanche\",\n  \"iotex\"\n];\nvar EvmNetworkToChainId = /* @__PURE__ */ new Map([\n  [\"base-sepolia\", 84532],\n  [\"base\", 8453],\n  [\"avalanche-fuji\", 43113],\n  [\"avalanche\", 43114],\n  [\"iotex\", 4689]\n]);\nvar ChainIdToNetwork = Object.fromEntries(\n  SupportedEVMNetworks.map((network) => [EvmNetworkToChainId.get(network), network])\n);\n\n// src/types/shared/evm/wallet.ts\nvar import_viem = __webpack_require__(/*! viem */ \"(rsc)/./node_modules/viem/_cjs/index.js\");\nvar import_chains = __webpack_require__(/*! viem/chains */ \"(rsc)/./node_modules/viem/_cjs/chains/index.js\");\nvar import_accounts = __webpack_require__(/*! viem/accounts */ \"(rsc)/./node_modules/viem/_cjs/accounts/index.js\");\n\n// src/shared/network.ts\nfunction getNetworkId(network) {\n  if (EvmNetworkToChainId.has(network)) {\n    return EvmNetworkToChainId.get(network);\n  }\n  throw new Error(`Unsupported network: ${network}`);\n}\n\n// src/types/verify/x402Specs.ts\nvar import_zod3 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/index.cjs\");\nvar EvmMaxAtomicUnits = 18;\nvar EvmAddressRegex = /^0x[0-9a-fA-F]{40}$/;\nvar MixedAddressRegex = /^0x[a-fA-F0-9]{40}|[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$/;\nvar HexEncoded64ByteRegex = /^0x[0-9a-fA-F]{64}$/;\nvar EvmSignatureRegex = /^0x[0-9a-fA-F]{130}$/;\nvar schemes = [\"exact\"];\nvar x402Versions = [1];\nvar ErrorReasons = [\n  \"insufficient_funds\",\n  \"invalid_exact_evm_payload_authorization_valid_after\",\n  \"invalid_exact_evm_payload_authorization_valid_before\",\n  \"invalid_exact_evm_payload_authorization_value\",\n  \"invalid_exact_evm_payload_signature\",\n  \"invalid_exact_evm_payload_recipient_mismatch\",\n  \"invalid_network\",\n  \"invalid_payload\",\n  \"invalid_payment_requirements\",\n  \"invalid_scheme\",\n  \"unsupported_scheme\",\n  \"invalid_x402_version\",\n  \"invalid_transaction_state\",\n  \"unexpected_verify_error\",\n  \"unexpected_settle_error\"\n];\nvar isInteger = (value) => Number.isInteger(Number(value)) && Number(value) >= 0;\nvar hasMaxLength = (maxLength) => (value) => value.length <= maxLength;\nvar PaymentRequirementsSchema = import_zod3.z.object({\n  scheme: import_zod3.z.enum(schemes),\n  network: NetworkSchema,\n  maxAmountRequired: import_zod3.z.string().refine(isInteger),\n  resource: import_zod3.z.string().url(),\n  description: import_zod3.z.string(),\n  mimeType: import_zod3.z.string(),\n  outputSchema: import_zod3.z.record(import_zod3.z.any()).optional(),\n  payTo: import_zod3.z.string().regex(MixedAddressRegex),\n  maxTimeoutSeconds: import_zod3.z.number().int(),\n  asset: import_zod3.z.string().regex(MixedAddressRegex),\n  extra: import_zod3.z.record(import_zod3.z.any()).optional()\n});\nvar ExactEvmPayloadAuthorizationSchema = import_zod3.z.object({\n  from: import_zod3.z.string().regex(EvmAddressRegex),\n  to: import_zod3.z.string().regex(EvmAddressRegex),\n  value: import_zod3.z.string().refine(isInteger).refine(hasMaxLength(EvmMaxAtomicUnits)),\n  validAfter: import_zod3.z.string().refine(isInteger),\n  validBefore: import_zod3.z.string().refine(isInteger),\n  nonce: import_zod3.z.string().regex(HexEncoded64ByteRegex)\n});\nvar ExactEvmPayloadSchema = import_zod3.z.object({\n  signature: import_zod3.z.string().regex(EvmSignatureRegex),\n  authorization: ExactEvmPayloadAuthorizationSchema\n});\nvar PaymentPayloadSchema = import_zod3.z.object({\n  x402Version: import_zod3.z.number().refine((val) => x402Versions.includes(val)),\n  scheme: import_zod3.z.enum(schemes),\n  network: NetworkSchema,\n  payload: ExactEvmPayloadSchema\n});\nvar VerifyResponseSchema = import_zod3.z.object({\n  isValid: import_zod3.z.boolean(),\n  invalidReason: import_zod3.z.enum(ErrorReasons).optional(),\n  payer: import_zod3.z.string().regex(MixedAddressRegex).optional()\n});\nvar SettleResponseSchema = import_zod3.z.object({\n  success: import_zod3.z.boolean(),\n  errorReason: import_zod3.z.enum(ErrorReasons).optional(),\n  payer: import_zod3.z.string().regex(MixedAddressRegex).optional(),\n  transaction: import_zod3.z.string().regex(MixedAddressRegex),\n  network: NetworkSchema\n});\nvar SupportedPaymentKindSchema = import_zod3.z.object({\n  x402Version: import_zod3.z.number().refine((val) => x402Versions.includes(val)),\n  scheme: import_zod3.z.enum(schemes),\n  network: NetworkSchema\n});\nvar SupportedPaymentKindsResponseSchema = import_zod3.z.object({\n  kinds: import_zod3.z.array(SupportedPaymentKindSchema)\n});\n\n// src/types/verify/facilitator.ts\nvar import_zod4 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/index.cjs\");\nvar facilitatorRequestSchema = import_zod4.z.object({\n  paymentHeader: import_zod4.z.string(),\n  paymentRequirements: PaymentRequirementsSchema\n});\n\n// src/shared/evm/usdc.ts\nfunction getUsdcAddressForChain(chainId) {\n  return config[chainId.toString()].usdcAddress;\n}\n\n// src/shared/middleware.ts\nfunction computeRoutePatterns(routes) {\n  const normalizedRoutes = Object.fromEntries(\n    Object.entries(routes).map(([pattern, value]) => [\n      pattern,\n      typeof value === \"string\" || typeof value === \"number\" ? { price: value, network: \"base-sepolia\" } : value\n    ])\n  );\n  return Object.entries(normalizedRoutes).map(([pattern, routeConfig]) => {\n    const [verb, path] = pattern.includes(\" \") ? pattern.split(/\\s+/) : [\"*\", pattern];\n    if (!path) {\n      throw new Error(`Invalid route pattern: ${pattern}`);\n    }\n    return {\n      verb: verb.toUpperCase(),\n      pattern: new RegExp(\n        `^${path.replace(/\\*/g, \".*?\").replace(/\\[([^\\]]+)\\]/g, \"[^/]+\").replace(/\\//g, \"\\\\/\")}$`,\n        \"i\"\n      ),\n      config: routeConfig\n    };\n  });\n}\nfunction findMatchingRoute(routePatterns, path, method) {\n  const matchingRoutes = routePatterns.filter(({ pattern, verb }) => {\n    const matchesPath = pattern.test(path);\n    const matchesVerb = verb === \"*\" || verb === method.toUpperCase();\n    return matchesPath && matchesVerb;\n  });\n  if (matchingRoutes.length === 0) {\n    return void 0;\n  }\n  const matchingRoute = matchingRoutes.reduce(\n    (a, b) => b.pattern.source.length > a.pattern.source.length ? b : a\n  );\n  return matchingRoute;\n}\nfunction getDefaultAsset(network) {\n  return {\n    address: getUsdcAddressForChain(getNetworkId(network)),\n    decimals: 6,\n    eip712: {\n      name: network === \"base\" ? \"USD Coin\" : network === \"iotex\" ? \"Bridged USDC\" : \"USDC\",\n      version: \"2\"\n    }\n  };\n}\nfunction processPriceToAtomicAmount(price, network) {\n  let maxAmountRequired;\n  let asset;\n  if (typeof price === \"string\" || typeof price === \"number\") {\n    const parsedAmount = moneySchema.safeParse(price);\n    if (!parsedAmount.success) {\n      return {\n        error: `Invalid price (price: ${price}). Must be in the form \"$3.10\", 0.10, \"0.001\", ${parsedAmount.error}`\n      };\n    }\n    const parsedUsdAmount = parsedAmount.data;\n    asset = getDefaultAsset(network);\n    maxAmountRequired = (parsedUsdAmount * 10 ** asset.decimals).toString();\n  } else {\n    maxAmountRequired = price.amount;\n    asset = price.asset;\n  }\n  return {\n    maxAmountRequired,\n    asset\n  };\n}\nfunction findMatchingPaymentRequirements(paymentRequirements, payment) {\n  return paymentRequirements.find(\n    (value) => value.scheme === payment.scheme && value.network === payment.network\n  );\n}\nfunction decodeXPaymentResponse(header) {\n  const decoded = safeBase64Decode(header);\n  return JSON.parse(decoded);\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveDQwMi1heGlvcy9ub2RlX21vZHVsZXMveDQwMi9kaXN0L2Nqcy9zaGFyZWQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlSQUFpUiwyQkFBMkIsY0FBYyxlQUFlLEdBQUcsUUFBUSxxQkFBcUIsd0NBQXdDLEdBQUcsd0NBQXdDLG1CQUFtQixvQkFBb0IsR0FBRyxzQ0FBc0Msa0JBQWtCLEdBQUcsbUNBQW1DLDhCQUE4QixHQUFHLFNBQVMsZ0NBQWdDLHdDQUF3QywwQkFBMEIsbUNBQW1DLHVDQUF1Qyx3Q0FBd0Msa0NBQWtDLG9DQUFvQywwQ0FBMEMsc0NBQXNDLDRDQUE0QyxHQUFHLFFBQVEsc0JBQXNCLDhDQUE4QyxxRUFBcUUsR0FBRyxjQUFjLHFCQUFxQixzQkFBc0Isb0JBQW9CLHdEQUF3RCwyQkFBMkIsc0ZBQXNGLEdBQUcsV0FBVyxrQkFBa0IsMkJBQTJCLGNBQWMsd0JBQXdCLHdCQUF3Qix1QkFBdUIsR0FBRyxVQUFVLHNCQUFzQixxQkFBcUIsNkJBQTZCLDBCQUEwQixHQUFHLGFBQWEsc0NBQXNDLEdBQUcsaUJBQWlCLHNCQUFzQiwwQ0FBMEMsdUJBQXVCLEdBQUcsWUFBWSxrQkFBa0IsMkJBQTJCLGNBQWMsR0FBRyxXQUFX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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHdDQUF3QztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1GQUFtRjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsaURBQWlELGVBQWU7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE1BQU0saURBQWlELG1CQUFtQjtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FZTDtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb25jaGFpbi1hZ2VudC8uL25vZGVfbW9kdWxlcy94NDAyLWF4aW9zL25vZGVfbW9kdWxlcy94NDAyL2Rpc3QvY2pzL3NoYXJlZC9pbmRleC5qcz8yM2U1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcblxuLy8gc3JjL3NoYXJlZC9pbmRleC50c1xudmFyIHNoYXJlZF9leHBvcnRzID0ge307XG5fX2V4cG9ydChzaGFyZWRfZXhwb3J0cywge1xuICBjb21wdXRlUm91dGVQYXR0ZXJuczogKCkgPT4gY29tcHV0ZVJvdXRlUGF0dGVybnMsXG4gIGRlY29kZVhQYXltZW50UmVzcG9uc2U6ICgpID0+IGRlY29kZVhQYXltZW50UmVzcG9uc2UsXG4gIGZpbmRNYXRjaGluZ1BheW1lbnRSZXF1aXJlbWVudHM6ICgpID0+IGZpbmRNYXRjaGluZ1BheW1lbnRSZXF1aXJlbWVudHMsXG4gIGZpbmRNYXRjaGluZ1JvdXRlOiAoKSA9PiBmaW5kTWF0Y2hpbmdSb3V0ZSxcbiAgZ2V0RGVmYXVsdEFzc2V0OiAoKSA9PiBnZXREZWZhdWx0QXNzZXQsXG4gIGdldE5ldHdvcmtJZDogKCkgPT4gZ2V0TmV0d29ya0lkLFxuICBnZXRQYXl3YWxsSHRtbDogKCkgPT4gZ2V0UGF5d2FsbEh0bWwsXG4gIHByb2Nlc3NQcmljZVRvQXRvbWljQW1vdW50OiAoKSA9PiBwcm9jZXNzUHJpY2VUb0F0b21pY0Ftb3VudCxcbiAgc2FmZUJhc2U2NERlY29kZTogKCkgPT4gc2FmZUJhc2U2NERlY29kZSxcbiAgc2FmZUJhc2U2NEVuY29kZTogKCkgPT4gc2FmZUJhc2U2NEVuY29kZSxcbiAgdG9Kc29uU2FmZTogKCkgPT4gdG9Kc29uU2FmZVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhzaGFyZWRfZXhwb3J0cyk7XG5cbi8vIHNyYy9zaGFyZWQvanNvbi50c1xuZnVuY3Rpb24gdG9Kc29uU2FmZShkYXRhKSB7XG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgfVxuICBmdW5jdGlvbiBjb252ZXJ0KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXModmFsdWUpLm1hcCgoW2tleSwgdmFsXSkgPT4gW2tleSwgY29udmVydCh2YWwpXSkpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5tYXAoY29udmVydCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGNvbnZlcnQoZGF0YSk7XG59XG5cbi8vIHNyYy9wYXl3YWxsL2dlbi90ZW1wbGF0ZS50c1xudmFyIFBBWVdBTExfVEVNUExBVEUgPSAnPCFET0NUWVBFIGh0bWw+PGh0bWwgbGFuZz1cImVuXCI+PGhlYWQ+XFxuICAgICAgICA8bWV0YSBjaGFyc2V0PVwiVVRGLThcIj5cXG4gICAgICAgIDxtZXRhIG5hbWU9XCJ2aWV3cG9ydFwiIGNvbnRlbnQ9XCJ3aWR0aD1kZXZpY2Utd2lkdGgsIGluaXRpYWwtc2NhbGU9MS4wXCI+XFxuICAgIDx0aXRsZT5QYXltZW50IFJlcXVpcmVkPC90aXRsZT48c3R5bGU+Lyogc3JjL3BheXdhbGwvc3R5bGVzLmNzcyAqL1xcbiosXFxuKjo6YmVmb3JlLFxcbio6OmFmdGVyIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG5ib2R5IHtcXG4gIGxpbmUtaGVpZ2h0OiAxLjU7XFxuICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcXG59XFxuaW1nLFxcbnBpY3R1cmUsXFxudmlkZW8sXFxuY2FudmFzLFxcbnN2ZyB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIG1heC13aWR0aDogMTAwJTtcXG59XFxuaW5wdXQsXFxuYnV0dG9uLFxcbnRleHRhcmVhLFxcbnNlbGVjdCB7XFxuICBmb250OiBpbmhlcml0O1xcbn1cXG5wLFxcbmgxLFxcbmgyLFxcbmgzLFxcbmg0LFxcbmg1LFxcbmg2IHtcXG4gIG92ZXJmbG93LXdyYXA6IGJyZWFrLXdvcmQ7XFxufVxcbjpyb290IHtcXG4gIC0tYmFja2dyb3VuZC1jb2xvcjogI2Y5ZmFmYjtcXG4gIC0tY29udGFpbmVyLWJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcbiAgLS10ZXh0LWNvbG9yOiAjMTExODI3O1xcbiAgLS1zdWJ0aXRsZS10ZXh0LWNvbG9yOiAjNGI1NTYzO1xcbiAgLS1pbnN0cnVjdGlvbnMtdGV4dC1jb2xvcjogIzRiNTU2MztcXG4gIC0tZGV0YWlscy1iYWNrZ3JvdW5kLWNvbG9yOiAjZjlmYWZiO1xcbiAgLS1kZXRhaWxzLXRleHQtY29sb3I6ICMxMTE4Mjc7XFxuICAtLWJ1dHRvbi1wcmltYXJ5LWNvbG9yOiAjMjU2M2ViO1xcbiAgLS1idXR0b24tcHJpbWFyeS1ob3Zlci1jb2xvcjogIzFkNGVkODtcXG4gIC0tYnV0dG9uLXNlY29uZGFyeS1jb2xvcjogIzA1OTY2OTtcXG4gIC0tYnV0dG9uLXNlY29uZGFyeS1ob3Zlci1jb2xvcjogIzA0Nzg1NztcXG59XFxuYm9keSB7XFxuICBtaW4taGVpZ2h0OiAxMDB2aDtcXG4gIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWJhY2tncm91bmQtY29sb3IpO1xcbiAgZm9udC1mYW1pbHk6XFxuICAgIHN5c3RlbS11aSxcXG4gICAgLWFwcGxlLXN5c3RlbSxcXG4gICAgc2Fucy1zZXJpZjtcXG59XFxuLmNvbnRhaW5lciB7XFxuICBtYXgtd2lkdGg6IDMycmVtO1xcbiAgbWFyZ2luOiA0cmVtIGF1dG87XFxuICBwYWRkaW5nOiAxLjVyZW07XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb250YWluZXItYmFja2dyb3VuZC1jb2xvcik7XFxuICBib3JkZXItcmFkaXVzOiAwLjc1cmVtO1xcbiAgYm94LXNoYWRvdzogMCA0cHggNnB4IC0xcHggcmdiYSgwLCAwLCAwLCAwLjEpLCAwIDJweCA0cHggLTFweCByZ2JhKDAsIDAsIDAsIDAuMDYpO1xcbn1cXG4uaGVhZGVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgZ2FwOiAxcmVtO1xcbiAgbWFyZ2luLWJvdHRvbTogMnJlbTtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcbi50aXRsZSB7XFxuICBmb250LXNpemU6IDEuNXJlbTtcXG4gIGZvbnQtd2VpZ2h0OiA3MDA7XFxuICBjb2xvcjogdmFyKC0tdGV4dC1jb2xvcik7XFxuICBtYXJnaW4tYm90dG9tOiAwLjVyZW07XFxufVxcbi5zdWJ0aXRsZSB7XFxuICBjb2xvcjogdmFyKC0tc3VidGl0bGUtdGV4dC1jb2xvcik7XFxufVxcbi5pbnN0cnVjdGlvbnMge1xcbiAgZm9udC1zaXplOiAwLjlyZW07XFxuICBjb2xvcjogdmFyKC0taW5zdHJ1Y3Rpb25zLXRleHQtY29sb3IpO1xcbiAgZm9udC1zdHlsZTogaXRhbGljO1xcbn1cXG4uY29udGVudCB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIGdhcDogMXJlbTtcXG59XFxuLmJ1dHRvbiB7XFxuICB3aWR0aDogMTAwJTtcXG4gIHBhZGRpbmc6IDAuNXJlbSAxcmVtO1xcbiAgYm9yZGVyLXJhZGl1czogMC41cmVtO1xcbiAgZm9udC13ZWlnaHQ6IDYwMDtcXG4gIGJvcmRlcjogbm9uZTtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMTUwbXM7XFxufVxcbi5idXR0b246Zm9jdXMge1xcbiAgb3V0bGluZTogbm9uZTtcXG59XFxuLmJ1dHRvbi1wcmltYXJ5IHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWJ1dHRvbi1wcmltYXJ5LWNvbG9yKTtcXG4gIGNvbG9yOiB3aGl0ZTtcXG59XFxuLmJ1dHRvbi1wcmltYXJ5OmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWJ1dHRvbi1wcmltYXJ5LWhvdmVyLWNvbG9yKTtcXG59XFxuLmJ1dHRvbi1wcmltYXJ5LmNvbm5lY3RlZCxcXG4uYnV0dG9uLXByaW1hcnkuY29ubmVjdGVkOmhvdmVyIHtcXG4gIG9wYWNpdHk6IDAuMztcXG4gIGN1cnNvcjogZGVmYXVsdDtcXG59XFxuLmJ1dHRvbi1zZWNvbmRhcnkge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYnV0dG9uLXNlY29uZGFyeS1jb2xvcik7XFxuICBjb2xvcjogd2hpdGU7XFxufVxcbi5idXR0b24tc2Vjb25kYXJ5OmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWJ1dHRvbi1zZWNvbmRhcnktaG92ZXItY29sb3IpO1xcbn1cXG4ucGF5bWVudC1kZXRhaWxzIHtcXG4gIHBhZGRpbmc6IDFyZW07XFxuICBtYXJnaW4tYm90dG9tOiAxcmVtO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tZGV0YWlscy1iYWNrZ3JvdW5kLWNvbG9yKTtcXG4gIGJvcmRlci1yYWRpdXM6IDAuNXJlbTtcXG59XFxuLnBheW1lbnQtcm93IHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICBmb250LXNpemU6IDAuODc1cmVtO1xcbiAgbWFyZ2luLWJvdHRvbTogMC41cmVtO1xcbn1cXG4ucGF5bWVudC1yb3c6bGFzdC1jaGlsZCB7XFxuICBtYXJnaW4tYm90dG9tOiAwO1xcbn1cXG4ucGF5bWVudC1sYWJlbCB7XFxuICBjb2xvcjogdmFyKC0tZGV0YWlscy10ZXh0LWNvbG9yKTtcXG59XFxuLnBheW1lbnQtdmFsdWUge1xcbiAgZm9udC13ZWlnaHQ6IDUwMDtcXG59XFxuLmhpZGRlbiB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG4uc3RhdHVzIHtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGZvbnQtc2l6ZTogMC44NzVyZW07XFxufVxcbjwvc3R5bGU+PC9oZWFkPlxcbiAgICA8Ym9keT5cXG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb250YWluZXJcIj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cImhlYWRlclwiPlxcbiAgICAgICAgICAgIDxoMSBjbGFzcz1cInRpdGxlXCI+UGF5bWVudCBSZXF1aXJlZDwvaDE+XFxuICAgICAgICAgICAgPHAgY2xhc3M9XCJzdWJ0aXRsZVwiIGlkPVwicGF5bWVudC1kZXNjcmlwdGlvblwiPkxvYWRpbmcgcGF5bWVudCBkZXRhaWxzLi4uPC9wPlxcbiAgICAgICAgICAgIDxwIGNsYXNzPVwiaW5zdHJ1Y3Rpb25zXCIgaWQ9XCJpbnN0cnVjdGlvbnNcIiBzdHlsZT1cImRpc3BsYXk6IG5vbmU7XCI+TmVlZCBCYXNlIFNlcG9saWEgVVNEQz8gPGEgaHJlZj1cImh0dHBzOi8vZmF1Y2V0LmNpcmNsZS5jb20vXCIgdGFyZ2V0PVwiX2JsYW5rXCIgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiPkdldCBzb21lIGhlcmUuPC9hPjwvcD5cXG4gICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250ZW50XCI+XFxuICAgICAgICAgICAgPGRpdiBpZD1cImNvbm5lY3Qtc2VjdGlvblwiPlxcbiAgICAgICAgICAgICAgPGJ1dHRvbiBpZD1cImNvbm5lY3Qtd2FsbGV0XCIgY2xhc3M9XCJidXR0b24gYnV0dG9uLXByaW1hcnlcIj5cXG4gICAgICAgICAgICAgICAgICBDb25uZWN0IHdhbGxldFxcbiAgICAgICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgICAgPGRpdiBpZD1cInBheW1lbnQtc2VjdGlvblwiIGNsYXNzPVwiaGlkZGVuXCI+XFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicGF5bWVudC1kZXRhaWxzXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwYXltZW50LXJvd1wiPlxcbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwicGF5bWVudC1sYWJlbFwiPldhbGxldDo8L3NwYW4+XFxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJwYXltZW50LXZhbHVlXCIgaWQ9XCJwYXltZW50LWFjY291bnRcIj5Mb2FkaW5nLi4uPC9zcGFuPlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBheW1lbnQtcm93XCI+XFxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJwYXltZW50LWxhYmVsXCI+QW1vdW50Ojwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInBheW1lbnQtdmFsdWVcIiBpZD1cInBheW1lbnQtYW1vdW50XCI+TG9hZGluZy4uLjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwYXltZW50LXJvd1wiPlxcbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwicGF5bWVudC1sYWJlbFwiPk5ldHdvcms6PC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwicGF5bWVudC12YWx1ZVwiIGlkPVwicGF5bWVudC1uZXR3b3JrXCI+TG9hZGluZy4uLjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICAgIDxidXR0b24gaWQ9XCJwYXktYnV0dG9uXCIgY2xhc3M9XCJidXR0b24gYnV0dG9uLXNlY29uZGFyeVwiPlxcbiAgICAgICAgICAgICAgICAgIFBheSBOb3dcXG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgaWQ9XCJzdGF0dXNcIiBjbGFzcz1cInN0YXR1c1wiPjwvZGl2PlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICBcXG4gICAgXFxuICA8c2NyaXB0IHR5cGU9XCJtb2R1bGVcIj5cInVzZSBzdHJpY3RcIjtcXG4oKCkgPT4ge1xcbiAgdmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcXG4gIHZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xcbiAgdmFyIF9fcmVxdWlyZSA9IC8qIEBfX1BVUkVfXyAqLyAoKHgpID0+IHR5cGVvZiByZXF1aXJlICE9PSBcInVuZGVmaW5lZFwiID8gcmVxdWlyZSA6IHR5cGVvZiBQcm94eSAhPT0gXCJ1bmRlZmluZWRcIiA/IG5ldyBQcm94eSh4LCB7XFxuICAgIGdldDogKGEsIGIpID0+ICh0eXBlb2YgcmVxdWlyZSAhPT0gXCJ1bmRlZmluZWRcIiA/IHJlcXVpcmUgOiBhKVtiXVxcbiAgfSkgOiB4KShmdW5jdGlvbih4KSB7XFxuICAgIGlmICh0eXBlb2YgcmVxdWlyZSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIHJlcXVpcmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgdGhyb3cgRXJyb3IoXFwnRHluYW1pYyByZXF1aXJlIG9mIFwiXFwnICsgeCArIFxcJ1wiIGlzIG5vdCBzdXBwb3J0ZWRcXCcpO1xcbiAgfSk7XFxuICB2YXIgX19lc20gPSAoZm4sIHJlcykgPT4gZnVuY3Rpb24gX19pbml0KCkge1xcbiAgICByZXR1cm4gZm4gJiYgKHJlcyA9ICgwLCBmbltfX2dldE93blByb3BOYW1lcyhmbilbMF1dKShmbiA9IDApKSwgcmVzO1xcbiAgfTtcXG4gIHZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xcbiAgICBmb3IgKHZhciBuYW1lIGluIGFsbClcXG4gICAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xcbiAgfTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL2FiaXR5cGVAMS4wLjhfdHlwZXNjcmlwdEA1LjguM196b2RAMy4yNC4zL25vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvZXNtL3ZlcnNpb24uanNcXG4gIHZhciB2ZXJzaW9uO1xcbiAgdmFyIGluaXRfdmVyc2lvbiA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS9hYml0eXBlQDEuMC44X3R5cGVzY3JpcHRANS44LjNfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS92ZXJzaW9uLmpzXCIoKSB7XFxuICAgICAgdmVyc2lvbiA9IFwiMS4wLjhcIjtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS9hYml0eXBlQDEuMC44X3R5cGVzY3JpcHRANS44LjNfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9lcnJvcnMuanNcXG4gIHZhciBCYXNlRXJyb3I7XFxuICB2YXIgaW5pdF9lcnJvcnMgPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vYWJpdHlwZUAxLjAuOF90eXBlc2NyaXB0QDUuOC4zX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vZXJyb3JzLmpzXCIoKSB7XFxuICAgICAgaW5pdF92ZXJzaW9uKCk7XFxuICAgICAgQmFzZUVycm9yID0gY2xhc3MgX0Jhc2VFcnJvciBleHRlbmRzIEVycm9yIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKHNob3J0TWVzc2FnZSwgYXJncyA9IHt9KSB7XFxuICAgICAgICAgIGNvbnN0IGRldGFpbHMgPSBhcmdzLmNhdXNlIGluc3RhbmNlb2YgX0Jhc2VFcnJvciA/IGFyZ3MuY2F1c2UuZGV0YWlscyA6IGFyZ3MuY2F1c2U/Lm1lc3NhZ2UgPyBhcmdzLmNhdXNlLm1lc3NhZ2UgOiBhcmdzLmRldGFpbHM7XFxuICAgICAgICAgIGNvbnN0IGRvY3NQYXRoOCA9IGFyZ3MuY2F1c2UgaW5zdGFuY2VvZiBfQmFzZUVycm9yID8gYXJncy5jYXVzZS5kb2NzUGF0aCB8fCBhcmdzLmRvY3NQYXRoIDogYXJncy5kb2NzUGF0aDtcXG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9IFtcXG4gICAgICAgICAgICBzaG9ydE1lc3NhZ2UgfHwgXCJBbiBlcnJvciBvY2N1cnJlZC5cIixcXG4gICAgICAgICAgICBcIlwiLFxcbiAgICAgICAgICAgIC4uLmFyZ3MubWV0YU1lc3NhZ2VzID8gWy4uLmFyZ3MubWV0YU1lc3NhZ2VzLCBcIlwiXSA6IFtdLFxcbiAgICAgICAgICAgIC4uLmRvY3NQYXRoOCA/IFtgRG9jczogaHR0cHM6Ly9hYml0eXBlLmRldiR7ZG9jc1BhdGg4fWBdIDogW10sXFxuICAgICAgICAgICAgLi4uZGV0YWlscyA/IFtgRGV0YWlsczogJHtkZXRhaWxzfWBdIDogW10sXFxuICAgICAgICAgICAgYFZlcnNpb246IGFiaXR5cGVAJHt2ZXJzaW9ufWBcXG4gICAgICAgICAgXS5qb2luKFwiXFxcXG5cIik7XFxuICAgICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZXRhaWxzXCIsIHtcXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkb2NzUGF0aFwiLCB7XFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWV0YU1lc3NhZ2VzXCIsIHtcXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaG9ydE1lc3NhZ2VcIiwge1xcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHZhbHVlOiBcIkFiaVR5cGVFcnJvclwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBpZiAoYXJncy5jYXVzZSlcXG4gICAgICAgICAgICB0aGlzLmNhdXNlID0gYXJncy5jYXVzZTtcXG4gICAgICAgICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcXG4gICAgICAgICAgdGhpcy5kb2NzUGF0aCA9IGRvY3NQYXRoODtcXG4gICAgICAgICAgdGhpcy5tZXRhTWVzc2FnZXMgPSBhcmdzLm1ldGFNZXNzYWdlcztcXG4gICAgICAgICAgdGhpcy5zaG9ydE1lc3NhZ2UgPSBzaG9ydE1lc3NhZ2U7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS9hYml0eXBlQDEuMC44X3R5cGVzY3JpcHRANS44LjNfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9yZWdleC5qc1xcbiAgZnVuY3Rpb24gZXhlY1R5cGVkKHJlZ2V4LCBzdHJpbmcpIHtcXG4gICAgY29uc3QgbWF0Y2ggPSByZWdleC5leGVjKHN0cmluZyk7XFxuICAgIHJldHVybiBtYXRjaD8uZ3JvdXBzO1xcbiAgfVxcbiAgdmFyIGJ5dGVzUmVnZXgsIGludGVnZXJSZWdleCwgaXNUdXBsZVJlZ2V4O1xcbiAgdmFyIGluaXRfcmVnZXggPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vYWJpdHlwZUAxLjAuOF90eXBlc2NyaXB0QDUuOC4zX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vcmVnZXguanNcIigpIHtcXG4gICAgICBieXRlc1JlZ2V4ID0gL15ieXRlcyhbMS05XXwxWzAtOV18MlswLTldfDNbMC0yXSk/JC87XFxuICAgICAgaW50ZWdlclJlZ2V4ID0gL151P2ludCg4fDE2fDI0fDMyfDQwfDQ4fDU2fDY0fDcyfDgwfDg4fDk2fDEwNHwxMTJ8MTIwfDEyOHwxMzZ8MTQ0fDE1MnwxNjB8MTY4fDE3NnwxODR8MTkyfDIwMHwyMDh8MjE2fDIyNHwyMzJ8MjQwfDI0OHwyNTYpPyQvO1xcbiAgICAgIGlzVHVwbGVSZWdleCA9IC9eXFxcXCguKz9cXFxcKS4qPyQvO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL2FiaXR5cGVAMS4wLjhfdHlwZXNjcmlwdEA1LjguM196b2RAMy4yNC4zL25vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvZXNtL2h1bWFuLXJlYWRhYmxlL2Zvcm1hdEFiaVBhcmFtZXRlci5qc1xcbiAgZnVuY3Rpb24gZm9ybWF0QWJpUGFyYW1ldGVyKGFiaVBhcmFtZXRlcikge1xcbiAgICBsZXQgdHlwZSA9IGFiaVBhcmFtZXRlci50eXBlO1xcbiAgICBpZiAodHVwbGVSZWdleC50ZXN0KGFiaVBhcmFtZXRlci50eXBlKSAmJiBcImNvbXBvbmVudHNcIiBpbiBhYmlQYXJhbWV0ZXIpIHtcXG4gICAgICB0eXBlID0gXCIoXCI7XFxuICAgICAgY29uc3QgbGVuZ3RoID0gYWJpUGFyYW1ldGVyLmNvbXBvbmVudHMubGVuZ3RoO1xcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGFiaVBhcmFtZXRlci5jb21wb25lbnRzW2ldO1xcbiAgICAgICAgdHlwZSArPSBmb3JtYXRBYmlQYXJhbWV0ZXIoY29tcG9uZW50KTtcXG4gICAgICAgIGlmIChpIDwgbGVuZ3RoIC0gMSlcXG4gICAgICAgICAgdHlwZSArPSBcIiwgXCI7XFxuICAgICAgfVxcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGV4ZWNUeXBlZCh0dXBsZVJlZ2V4LCBhYmlQYXJhbWV0ZXIudHlwZSk7XFxuICAgICAgdHlwZSArPSBgKSR7cmVzdWx0Py5hcnJheSA/PyBcIlwifWA7XFxuICAgICAgcmV0dXJuIGZvcm1hdEFiaVBhcmFtZXRlcih7XFxuICAgICAgICAuLi5hYmlQYXJhbWV0ZXIsXFxuICAgICAgICB0eXBlXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgaWYgKFwiaW5kZXhlZFwiIGluIGFiaVBhcmFtZXRlciAmJiBhYmlQYXJhbWV0ZXIuaW5kZXhlZClcXG4gICAgICB0eXBlID0gYCR7dHlwZX0gaW5kZXhlZGA7XFxuICAgIGlmIChhYmlQYXJhbWV0ZXIubmFtZSlcXG4gICAgICByZXR1cm4gYCR7dHlwZX0gJHthYmlQYXJhbWV0ZXIubmFtZX1gO1xcbiAgICByZXR1cm4gdHlwZTtcXG4gIH1cXG4gIHZhciB0dXBsZVJlZ2V4O1xcbiAgdmFyIGluaXRfZm9ybWF0QWJpUGFyYW1ldGVyID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL2FiaXR5cGVAMS4wLjhfdHlwZXNjcmlwdEA1LjguM196b2RAMy4yNC4zL25vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvZXNtL2h1bWFuLXJlYWRhYmxlL2Zvcm1hdEFiaVBhcmFtZXRlci5qc1wiKCkge1xcbiAgICAgIGluaXRfcmVnZXgoKTtcXG4gICAgICB0dXBsZVJlZ2V4ID0gL150dXBsZSg/PGFycmF5PihcXFxcWyhcXFxcZCopXFxcXF0pKikkLztcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS9hYml0eXBlQDEuMC44X3R5cGVzY3JpcHRANS44LjNfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9mb3JtYXRBYmlQYXJhbWV0ZXJzLmpzXFxuICBmdW5jdGlvbiBmb3JtYXRBYmlQYXJhbWV0ZXJzKGFiaVBhcmFtZXRlcnMpIHtcXG4gICAgbGV0IHBhcmFtcyA9IFwiXCI7XFxuICAgIGNvbnN0IGxlbmd0aCA9IGFiaVBhcmFtZXRlcnMubGVuZ3RoO1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XFxuICAgICAgY29uc3QgYWJpUGFyYW1ldGVyID0gYWJpUGFyYW1ldGVyc1tpXTtcXG4gICAgICBwYXJhbXMgKz0gZm9ybWF0QWJpUGFyYW1ldGVyKGFiaVBhcmFtZXRlcik7XFxuICAgICAgaWYgKGkgIT09IGxlbmd0aCAtIDEpXFxuICAgICAgICBwYXJhbXMgKz0gXCIsIFwiO1xcbiAgICB9XFxuICAgIHJldHVybiBwYXJhbXM7XFxuICB9XFxuICB2YXIgaW5pdF9mb3JtYXRBYmlQYXJhbWV0ZXJzID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL2FiaXR5cGVAMS4wLjhfdHlwZXNjcmlwdEA1LjguM196b2RAMy4yNC4zL25vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvZXNtL2h1bWFuLXJlYWRhYmxlL2Zvcm1hdEFiaVBhcmFtZXRlcnMuanNcIigpIHtcXG4gICAgICBpbml0X2Zvcm1hdEFiaVBhcmFtZXRlcigpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL2FiaXR5cGVAMS4wLjhfdHlwZXNjcmlwdEA1LjguM196b2RAMy4yNC4zL25vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvZXNtL2h1bWFuLXJlYWRhYmxlL2Zvcm1hdEFiaUl0ZW0uanNcXG4gIGZ1bmN0aW9uIGZvcm1hdEFiaUl0ZW0oYWJpSXRlbSkge1xcbiAgICBpZiAoYWJpSXRlbS50eXBlID09PSBcImZ1bmN0aW9uXCIpXFxuICAgICAgcmV0dXJuIGBmdW5jdGlvbiAke2FiaUl0ZW0ubmFtZX0oJHtmb3JtYXRBYmlQYXJhbWV0ZXJzKGFiaUl0ZW0uaW5wdXRzKX0pJHthYmlJdGVtLnN0YXRlTXV0YWJpbGl0eSAmJiBhYmlJdGVtLnN0YXRlTXV0YWJpbGl0eSAhPT0gXCJub25wYXlhYmxlXCIgPyBgICR7YWJpSXRlbS5zdGF0ZU11dGFiaWxpdHl9YCA6IFwiXCJ9JHthYmlJdGVtLm91dHB1dHM/Lmxlbmd0aCA/IGAgcmV0dXJucyAoJHtmb3JtYXRBYmlQYXJhbWV0ZXJzKGFiaUl0ZW0ub3V0cHV0cyl9KWAgOiBcIlwifWA7XFxuICAgIGlmIChhYmlJdGVtLnR5cGUgPT09IFwiZXZlbnRcIilcXG4gICAgICByZXR1cm4gYGV2ZW50ICR7YWJpSXRlbS5uYW1lfSgke2Zvcm1hdEFiaVBhcmFtZXRlcnMoYWJpSXRlbS5pbnB1dHMpfSlgO1xcbiAgICBpZiAoYWJpSXRlbS50eXBlID09PSBcImVycm9yXCIpXFxuICAgICAgcmV0dXJuIGBlcnJvciAke2FiaUl0ZW0ubmFtZX0oJHtmb3JtYXRBYmlQYXJhbWV0ZXJzKGFiaUl0ZW0uaW5wdXRzKX0pYDtcXG4gICAgaWYgKGFiaUl0ZW0udHlwZSA9PT0gXCJjb25zdHJ1Y3RvclwiKVxcbiAgICAgIHJldHVybiBgY29uc3RydWN0b3IoJHtmb3JtYXRBYmlQYXJhbWV0ZXJzKGFiaUl0ZW0uaW5wdXRzKX0pJHthYmlJdGVtLnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJwYXlhYmxlXCIgPyBcIiBwYXlhYmxlXCIgOiBcIlwifWA7XFxuICAgIGlmIChhYmlJdGVtLnR5cGUgPT09IFwiZmFsbGJhY2tcIilcXG4gICAgICByZXR1cm4gYGZhbGxiYWNrKCkgZXh0ZXJuYWwke2FiaUl0ZW0uc3RhdGVNdXRhYmlsaXR5ID09PSBcInBheWFibGVcIiA/IFwiIHBheWFibGVcIiA6IFwiXCJ9YDtcXG4gICAgcmV0dXJuIFwicmVjZWl2ZSgpIGV4dGVybmFsIHBheWFibGVcIjtcXG4gIH1cXG4gIHZhciBpbml0X2Zvcm1hdEFiaUl0ZW0gPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vYWJpdHlwZUAxLjAuOF90eXBlc2NyaXB0QDUuOC4zX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vaHVtYW4tcmVhZGFibGUvZm9ybWF0QWJpSXRlbS5qc1wiKCkge1xcbiAgICAgIGluaXRfZm9ybWF0QWJpUGFyYW1ldGVycygpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL2FiaXR5cGVAMS4wLjhfdHlwZXNjcmlwdEA1LjguM196b2RAMy4yNC4zL25vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvZXNtL2h1bWFuLXJlYWRhYmxlL3J1bnRpbWUvc2lnbmF0dXJlcy5qc1xcbiAgZnVuY3Rpb24gaXNFcnJvclNpZ25hdHVyZShzaWduYXR1cmUpIHtcXG4gICAgcmV0dXJuIGVycm9yU2lnbmF0dXJlUmVnZXgudGVzdChzaWduYXR1cmUpO1xcbiAgfVxcbiAgZnVuY3Rpb24gZXhlY0Vycm9yU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xcbiAgICByZXR1cm4gZXhlY1R5cGVkKGVycm9yU2lnbmF0dXJlUmVnZXgsIHNpZ25hdHVyZSk7XFxuICB9XFxuICBmdW5jdGlvbiBpc0V2ZW50U2lnbmF0dXJlKHNpZ25hdHVyZSkge1xcbiAgICByZXR1cm4gZXZlbnRTaWduYXR1cmVSZWdleC50ZXN0KHNpZ25hdHVyZSk7XFxuICB9XFxuICBmdW5jdGlvbiBleGVjRXZlbnRTaWduYXR1cmUoc2lnbmF0dXJlKSB7XFxuICAgIHJldHVybiBleGVjVHlwZWQoZXZlbnRTaWduYXR1cmVSZWdleCwgc2lnbmF0dXJlKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGlzRnVuY3Rpb25TaWduYXR1cmUoc2lnbmF0dXJlKSB7XFxuICAgIHJldHVybiBmdW5jdGlvblNpZ25hdHVyZVJlZ2V4LnRlc3Qoc2lnbmF0dXJlKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGV4ZWNGdW5jdGlvblNpZ25hdHVyZShzaWduYXR1cmUpIHtcXG4gICAgcmV0dXJuIGV4ZWNUeXBlZChmdW5jdGlvblNpZ25hdHVyZVJlZ2V4LCBzaWduYXR1cmUpO1xcbiAgfVxcbiAgZnVuY3Rpb24gaXNTdHJ1Y3RTaWduYXR1cmUoc2lnbmF0dXJlKSB7XFxuICAgIHJldHVybiBzdHJ1Y3RTaWduYXR1cmVSZWdleC50ZXN0KHNpZ25hdHVyZSk7XFxuICB9XFxuICBmdW5jdGlvbiBleGVjU3RydWN0U2lnbmF0dXJlKHNpZ25hdHVyZSkge1xcbiAgICByZXR1cm4gZXhlY1R5cGVkKHN0cnVjdFNpZ25hdHVyZVJlZ2V4LCBzaWduYXR1cmUpO1xcbiAgfVxcbiAgZnVuY3Rpb24gaXNDb25zdHJ1Y3RvclNpZ25hdHVyZShzaWduYXR1cmUpIHtcXG4gICAgcmV0dXJuIGNvbnN0cnVjdG9yU2lnbmF0dXJlUmVnZXgudGVzdChzaWduYXR1cmUpO1xcbiAgfVxcbiAgZnVuY3Rpb24gZXhlY0NvbnN0cnVjdG9yU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xcbiAgICByZXR1cm4gZXhlY1R5cGVkKGNvbnN0cnVjdG9yU2lnbmF0dXJlUmVnZXgsIHNpZ25hdHVyZSk7XFxuICB9XFxuICBmdW5jdGlvbiBpc0ZhbGxiYWNrU2lnbmF0dXJlKHNpZ25hdHVyZSkge1xcbiAgICByZXR1cm4gZmFsbGJhY2tTaWduYXR1cmVSZWdleC50ZXN0KHNpZ25hdHVyZSk7XFxuICB9XFxuICBmdW5jdGlvbiBleGVjRmFsbGJhY2tTaWduYXR1cmUoc2lnbmF0dXJlKSB7XFxuICAgIHJldHVybiBleGVjVHlwZWQoZmFsbGJhY2tTaWduYXR1cmVSZWdleCwgc2lnbmF0dXJlKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGlzUmVjZWl2ZVNpZ25hdHVyZShzaWduYXR1cmUpIHtcXG4gICAgcmV0dXJuIHJlY2VpdmVTaWduYXR1cmVSZWdleC50ZXN0KHNpZ25hdHVyZSk7XFxuICB9XFxuICB2YXIgZXJyb3JTaWduYXR1cmVSZWdleCwgZXZlbnRTaWduYXR1cmVSZWdleCwgZnVuY3Rpb25TaWduYXR1cmVSZWdleCwgc3RydWN0U2lnbmF0dXJlUmVnZXgsIGNvbnN0cnVjdG9yU2lnbmF0dXJlUmVnZXgsIGZhbGxiYWNrU2lnbmF0dXJlUmVnZXgsIHJlY2VpdmVTaWduYXR1cmVSZWdleCwgZXZlbnRNb2RpZmllcnMsIGZ1bmN0aW9uTW9kaWZpZXJzO1xcbiAgdmFyIGluaXRfc2lnbmF0dXJlcyA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS9hYml0eXBlQDEuMC44X3R5cGVzY3JpcHRANS44LjNfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9ydW50aW1lL3NpZ25hdHVyZXMuanNcIigpIHtcXG4gICAgICBpbml0X3JlZ2V4KCk7XFxuICAgICAgZXJyb3JTaWduYXR1cmVSZWdleCA9IC9eZXJyb3IgKD88bmFtZT5bYS16QS1aJF9dW2EtekEtWjAtOSRfXSopXFxcXCgoPzxwYXJhbWV0ZXJzPi4qPylcXFxcKSQvO1xcbiAgICAgIGV2ZW50U2lnbmF0dXJlUmVnZXggPSAvXmV2ZW50ICg/PG5hbWU+W2EtekEtWiRfXVthLXpBLVowLTkkX10qKVxcXFwoKD88cGFyYW1ldGVycz4uKj8pXFxcXCkkLztcXG4gICAgICBmdW5jdGlvblNpZ25hdHVyZVJlZ2V4ID0gL15mdW5jdGlvbiAoPzxuYW1lPlthLXpBLVokX11bYS16QS1aMC05JF9dKilcXFxcKCg/PHBhcmFtZXRlcnM+Lio/KVxcXFwpKD86ICg/PHNjb3BlPmV4dGVybmFsfHB1YmxpY3sxfSkpPyg/OiAoPzxzdGF0ZU11dGFiaWxpdHk+cHVyZXx2aWV3fG5vbnBheWFibGV8cGF5YWJsZXsxfSkpPyg/OiByZXR1cm5zXFxcXHM/XFxcXCgoPzxyZXR1cm5zPi4qPylcXFxcKSk/JC87XFxuICAgICAgc3RydWN0U2lnbmF0dXJlUmVnZXggPSAvXnN0cnVjdCAoPzxuYW1lPlthLXpBLVokX11bYS16QS1aMC05JF9dKikgXFxcXHsoPzxwcm9wZXJ0aWVzPi4qPylcXFxcfSQvO1xcbiAgICAgIGNvbnN0cnVjdG9yU2lnbmF0dXJlUmVnZXggPSAvXmNvbnN0cnVjdG9yXFxcXCgoPzxwYXJhbWV0ZXJzPi4qPylcXFxcKSg/OlxcXFxzKD88c3RhdGVNdXRhYmlsaXR5PnBheWFibGV7MX0pKT8kLztcXG4gICAgICBmYWxsYmFja1NpZ25hdHVyZVJlZ2V4ID0gL15mYWxsYmFja1xcXFwoXFxcXCkgZXh0ZXJuYWwoPzpcXFxccyg/PHN0YXRlTXV0YWJpbGl0eT5wYXlhYmxlezF9KSk/JC87XFxuICAgICAgcmVjZWl2ZVNpZ25hdHVyZVJlZ2V4ID0gL15yZWNlaXZlXFxcXChcXFxcKSBleHRlcm5hbCBwYXlhYmxlJC87XFxuICAgICAgZXZlbnRNb2RpZmllcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJpbmRleGVkXCJdKTtcXG4gICAgICBmdW5jdGlvbk1vZGlmaWVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcXG4gICAgICAgIFwiY2FsbGRhdGFcIixcXG4gICAgICAgIFwibWVtb3J5XCIsXFxuICAgICAgICBcInN0b3JhZ2VcIlxcbiAgICAgIF0pO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL2FiaXR5cGVAMS4wLjhfdHlwZXNjcmlwdEA1LjguM196b2RAMy4yNC4zL25vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvZXNtL2h1bWFuLXJlYWRhYmxlL2Vycm9ycy9hYmlJdGVtLmpzXFxuICB2YXIgSW52YWxpZEFiaUl0ZW1FcnJvciwgVW5rbm93blR5cGVFcnJvciwgVW5rbm93blNvbGlkaXR5VHlwZUVycm9yO1xcbiAgdmFyIGluaXRfYWJpSXRlbSA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS9hYml0eXBlQDEuMC44X3R5cGVzY3JpcHRANS44LjNfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9lcnJvcnMvYWJpSXRlbS5qc1wiKCkge1xcbiAgICAgIGluaXRfZXJyb3JzKCk7XFxuICAgICAgSW52YWxpZEFiaUl0ZW1FcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKHsgc2lnbmF0dXJlIH0pIHtcXG4gICAgICAgICAgc3VwZXIoXCJGYWlsZWQgdG8gcGFyc2UgQUJJIGl0ZW0uXCIsIHtcXG4gICAgICAgICAgICBkZXRhaWxzOiBgcGFyc2VBYmlJdGVtKCR7SlNPTi5zdHJpbmdpZnkoc2lnbmF0dXJlLCBudWxsLCAyKX0pYCxcXG4gICAgICAgICAgICBkb2NzUGF0aDogXCIvYXBpL2h1bWFuI3BhcnNlYWJpaXRlbS0xXCJcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHZhbHVlOiBcIkludmFsaWRBYmlJdGVtRXJyb3JcIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIFVua25vd25UeXBlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvciB7XFxuICAgICAgICBjb25zdHJ1Y3Rvcih7IHR5cGUgfSkge1xcbiAgICAgICAgICBzdXBlcihcIlVua25vd24gdHlwZS5cIiwge1xcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xcbiAgICAgICAgICAgICAgYFR5cGUgXCIke3R5cGV9XCIgaXMgbm90IGEgdmFsaWQgQUJJIHR5cGUuIFBlcmhhcHMgeW91IGZvcmdvdCB0byBpbmNsdWRlIGEgc3RydWN0IHNpZ25hdHVyZT9gXFxuICAgICAgICAgICAgXVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICAgICAgdmFsdWU6IFwiVW5rbm93blR5cGVFcnJvclwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgVW5rbm93blNvbGlkaXR5VHlwZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3Ige1xcbiAgICAgICAgY29uc3RydWN0b3IoeyB0eXBlIH0pIHtcXG4gICAgICAgICAgc3VwZXIoXCJVbmtub3duIHR5cGUuXCIsIHtcXG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtgVHlwZSBcIiR7dHlwZX1cIiBpcyBub3QgYSB2YWxpZCBBQkkgdHlwZS5gXVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICAgICAgdmFsdWU6IFwiVW5rbm93blNvbGlkaXR5VHlwZUVycm9yXCJcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS9hYml0eXBlQDEuMC44X3R5cGVzY3JpcHRANS44LjNfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9lcnJvcnMvYWJpUGFyYW1ldGVyLmpzXFxuICB2YXIgSW52YWxpZFBhcmFtZXRlckVycm9yLCBTb2xpZGl0eVByb3RlY3RlZEtleXdvcmRFcnJvciwgSW52YWxpZE1vZGlmaWVyRXJyb3IsIEludmFsaWRGdW5jdGlvbk1vZGlmaWVyRXJyb3IsIEludmFsaWRBYmlUeXBlUGFyYW1ldGVyRXJyb3I7XFxuICB2YXIgaW5pdF9hYmlQYXJhbWV0ZXIgPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vYWJpdHlwZUAxLjAuOF90eXBlc2NyaXB0QDUuOC4zX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vaHVtYW4tcmVhZGFibGUvZXJyb3JzL2FiaVBhcmFtZXRlci5qc1wiKCkge1xcbiAgICAgIGluaXRfZXJyb3JzKCk7XFxuICAgICAgSW52YWxpZFBhcmFtZXRlckVycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3Ige1xcbiAgICAgICAgY29uc3RydWN0b3IoeyBwYXJhbSB9KSB7XFxuICAgICAgICAgIHN1cGVyKFwiSW52YWxpZCBBQkkgcGFyYW1ldGVyLlwiLCB7XFxuICAgICAgICAgICAgZGV0YWlsczogcGFyYW1cXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHZhbHVlOiBcIkludmFsaWRQYXJhbWV0ZXJFcnJvclwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgU29saWRpdHlQcm90ZWN0ZWRLZXl3b3JkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvciB7XFxuICAgICAgICBjb25zdHJ1Y3Rvcih7IHBhcmFtLCBuYW1lIH0pIHtcXG4gICAgICAgICAgc3VwZXIoXCJJbnZhbGlkIEFCSSBwYXJhbWV0ZXIuXCIsIHtcXG4gICAgICAgICAgICBkZXRhaWxzOiBwYXJhbSxcXG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcXG4gICAgICAgICAgICAgIGBcIiR7bmFtZX1cIiBpcyBhIHByb3RlY3RlZCBTb2xpZGl0eSBrZXl3b3JkLiBNb3JlIGluZm86IGh0dHBzOi8vZG9jcy5zb2xpZGl0eWxhbmcub3JnL2VuL2xhdGVzdC9jaGVhdHNoZWV0Lmh0bWxgXFxuICAgICAgICAgICAgXVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICAgICAgdmFsdWU6IFwiU29saWRpdHlQcm90ZWN0ZWRLZXl3b3JkRXJyb3JcIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIEludmFsaWRNb2RpZmllckVycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3Ige1xcbiAgICAgICAgY29uc3RydWN0b3IoeyBwYXJhbSwgdHlwZSwgbW9kaWZpZXIgfSkge1xcbiAgICAgICAgICBzdXBlcihcIkludmFsaWQgQUJJIHBhcmFtZXRlci5cIiwge1xcbiAgICAgICAgICAgIGRldGFpbHM6IHBhcmFtLFxcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xcbiAgICAgICAgICAgICAgYE1vZGlmaWVyIFwiJHttb2RpZmllcn1cIiBub3QgYWxsb3dlZCR7dHlwZSA/IGAgaW4gXCIke3R5cGV9XCIgdHlwZWAgOiBcIlwifS5gXFxuICAgICAgICAgICAgXVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICAgICAgdmFsdWU6IFwiSW52YWxpZE1vZGlmaWVyRXJyb3JcIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIEludmFsaWRGdW5jdGlvbk1vZGlmaWVyRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvciB7XFxuICAgICAgICBjb25zdHJ1Y3Rvcih7IHBhcmFtLCB0eXBlLCBtb2RpZmllciB9KSB7XFxuICAgICAgICAgIHN1cGVyKFwiSW52YWxpZCBBQkkgcGFyYW1ldGVyLlwiLCB7XFxuICAgICAgICAgICAgZGV0YWlsczogcGFyYW0sXFxuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXFxuICAgICAgICAgICAgICBgTW9kaWZpZXIgXCIke21vZGlmaWVyfVwiIG5vdCBhbGxvd2VkJHt0eXBlID8gYCBpbiBcIiR7dHlwZX1cIiB0eXBlYCA6IFwiXCJ9LmAsXFxuICAgICAgICAgICAgICBgRGF0YSBsb2NhdGlvbiBjYW4gb25seSBiZSBzcGVjaWZpZWQgZm9yIGFycmF5LCBzdHJ1Y3QsIG9yIG1hcHBpbmcgdHlwZXMsIGJ1dCBcIiR7bW9kaWZpZXJ9XCIgd2FzIGdpdmVuLmBcXG4gICAgICAgICAgICBdXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB2YWx1ZTogXCJJbnZhbGlkRnVuY3Rpb25Nb2RpZmllckVycm9yXCJcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICBJbnZhbGlkQWJpVHlwZVBhcmFtZXRlckVycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3Ige1xcbiAgICAgICAgY29uc3RydWN0b3IoeyBhYmlQYXJhbWV0ZXIgfSkge1xcbiAgICAgICAgICBzdXBlcihcIkludmFsaWQgQUJJIHBhcmFtZXRlci5cIiwge1xcbiAgICAgICAgICAgIGRldGFpbHM6IEpTT04uc3RyaW5naWZ5KGFiaVBhcmFtZXRlciwgbnVsbCwgMiksXFxuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXCJBQkkgcGFyYW1ldGVyIHR5cGUgaXMgaW52YWxpZC5cIl1cXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHZhbHVlOiBcIkludmFsaWRBYmlUeXBlUGFyYW1ldGVyRXJyb3JcIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL2FiaXR5cGVAMS4wLjhfdHlwZXNjcmlwdEA1LjguM196b2RAMy4yNC4zL25vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvZXNtL2h1bWFuLXJlYWRhYmxlL2Vycm9ycy9zaWduYXR1cmUuanNcXG4gIHZhciBJbnZhbGlkU2lnbmF0dXJlRXJyb3IsIFVua25vd25TaWduYXR1cmVFcnJvciwgSW52YWxpZFN0cnVjdFNpZ25hdHVyZUVycm9yO1xcbiAgdmFyIGluaXRfc2lnbmF0dXJlID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL2FiaXR5cGVAMS4wLjhfdHlwZXNjcmlwdEA1LjguM196b2RAMy4yNC4zL25vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvZXNtL2h1bWFuLXJlYWRhYmxlL2Vycm9ycy9zaWduYXR1cmUuanNcIigpIHtcXG4gICAgICBpbml0X2Vycm9ycygpO1xcbiAgICAgIEludmFsaWRTaWduYXR1cmVFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKHsgc2lnbmF0dXJlLCB0eXBlIH0pIHtcXG4gICAgICAgICAgc3VwZXIoYEludmFsaWQgJHt0eXBlfSBzaWduYXR1cmUuYCwge1xcbiAgICAgICAgICAgIGRldGFpbHM6IHNpZ25hdHVyZVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICAgICAgdmFsdWU6IFwiSW52YWxpZFNpZ25hdHVyZUVycm9yXCJcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICBVbmtub3duU2lnbmF0dXJlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvciB7XFxuICAgICAgICBjb25zdHJ1Y3Rvcih7IHNpZ25hdHVyZSB9KSB7XFxuICAgICAgICAgIHN1cGVyKFwiVW5rbm93biBzaWduYXR1cmUuXCIsIHtcXG4gICAgICAgICAgICBkZXRhaWxzOiBzaWduYXR1cmVcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHZhbHVlOiBcIlVua25vd25TaWduYXR1cmVFcnJvclwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgSW52YWxpZFN0cnVjdFNpZ25hdHVyZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3Ige1xcbiAgICAgICAgY29uc3RydWN0b3IoeyBzaWduYXR1cmUgfSkge1xcbiAgICAgICAgICBzdXBlcihcIkludmFsaWQgc3RydWN0IHNpZ25hdHVyZS5cIiwge1xcbiAgICAgICAgICAgIGRldGFpbHM6IHNpZ25hdHVyZSxcXG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcIk5vIHByb3BlcnRpZXMgZXhpc3QuXCJdXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB2YWx1ZTogXCJJbnZhbGlkU3RydWN0U2lnbmF0dXJlRXJyb3JcIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL2FiaXR5cGVAMS4wLjhfdHlwZXNjcmlwdEA1LjguM196b2RAMy4yNC4zL25vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvZXNtL2h1bWFuLXJlYWRhYmxlL2Vycm9ycy9zdHJ1Y3QuanNcXG4gIHZhciBDaXJjdWxhclJlZmVyZW5jZUVycm9yO1xcbiAgdmFyIGluaXRfc3RydWN0ID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL2FiaXR5cGVAMS4wLjhfdHlwZXNjcmlwdEA1LjguM196b2RAMy4yNC4zL25vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvZXNtL2h1bWFuLXJlYWRhYmxlL2Vycm9ycy9zdHJ1Y3QuanNcIigpIHtcXG4gICAgICBpbml0X2Vycm9ycygpO1xcbiAgICAgIENpcmN1bGFyUmVmZXJlbmNlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvciB7XFxuICAgICAgICBjb25zdHJ1Y3Rvcih7IHR5cGUgfSkge1xcbiAgICAgICAgICBzdXBlcihcIkNpcmN1bGFyIHJlZmVyZW5jZSBkZXRlY3RlZC5cIiwge1xcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW2BTdHJ1Y3QgXCIke3R5cGV9XCIgaXMgYSBjaXJjdWxhciByZWZlcmVuY2UuYF1cXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHZhbHVlOiBcIkNpcmN1bGFyUmVmZXJlbmNlRXJyb3JcIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL2FiaXR5cGVAMS4wLjhfdHlwZXNjcmlwdEA1LjguM196b2RAMy4yNC4zL25vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvZXNtL2h1bWFuLXJlYWRhYmxlL2Vycm9ycy9zcGxpdFBhcmFtZXRlcnMuanNcXG4gIHZhciBJbnZhbGlkUGFyZW50aGVzaXNFcnJvcjtcXG4gIHZhciBpbml0X3NwbGl0UGFyYW1ldGVycyA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS9hYml0eXBlQDEuMC44X3R5cGVzY3JpcHRANS44LjNfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9lcnJvcnMvc3BsaXRQYXJhbWV0ZXJzLmpzXCIoKSB7XFxuICAgICAgaW5pdF9lcnJvcnMoKTtcXG4gICAgICBJbnZhbGlkUGFyZW50aGVzaXNFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKHsgY3VycmVudCwgZGVwdGggfSkge1xcbiAgICAgICAgICBzdXBlcihcIlVuYmFsYW5jZWQgcGFyZW50aGVzZXMuXCIsIHtcXG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcXG4gICAgICAgICAgICAgIGBcIiR7Y3VycmVudC50cmltKCl9XCIgaGFzIHRvbyBtYW55ICR7ZGVwdGggPiAwID8gXCJvcGVuaW5nXCIgOiBcImNsb3NpbmdcIn0gcGFyZW50aGVzZXMuYFxcbiAgICAgICAgICAgIF0sXFxuICAgICAgICAgICAgZGV0YWlsczogYERlcHRoIFwiJHtkZXB0aH1cImBcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHZhbHVlOiBcIkludmFsaWRQYXJlbnRoZXNpc0Vycm9yXCJcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS9hYml0eXBlQDEuMC44X3R5cGVzY3JpcHRANS44LjNfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9ydW50aW1lL2NhY2hlLmpzXFxuICBmdW5jdGlvbiBnZXRQYXJhbWV0ZXJDYWNoZUtleShwYXJhbSwgdHlwZSwgc3RydWN0cykge1xcbiAgICBsZXQgc3RydWN0S2V5ID0gXCJcIjtcXG4gICAgaWYgKHN0cnVjdHMpXFxuICAgICAgZm9yIChjb25zdCBzdHJ1Y3Qgb2YgT2JqZWN0LmVudHJpZXMoc3RydWN0cykpIHtcXG4gICAgICAgIGlmICghc3RydWN0KVxcbiAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgIGxldCBwcm9wZXJ0eUtleSA9IFwiXCI7XFxuICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHN0cnVjdFsxXSkge1xcbiAgICAgICAgICBwcm9wZXJ0eUtleSArPSBgWyR7cHJvcGVydHkudHlwZX0ke3Byb3BlcnR5Lm5hbWUgPyBgOiR7cHJvcGVydHkubmFtZX1gIDogXCJcIn1dYDtcXG4gICAgICAgIH1cXG4gICAgICAgIHN0cnVjdEtleSArPSBgKCR7c3RydWN0WzBdfXske3Byb3BlcnR5S2V5fX0pYDtcXG4gICAgICB9XFxuICAgIGlmICh0eXBlKVxcbiAgICAgIHJldHVybiBgJHt0eXBlfToke3BhcmFtfSR7c3RydWN0S2V5fWA7XFxuICAgIHJldHVybiBwYXJhbTtcXG4gIH1cXG4gIHZhciBwYXJhbWV0ZXJDYWNoZTtcXG4gIHZhciBpbml0X2NhY2hlID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL2FiaXR5cGVAMS4wLjhfdHlwZXNjcmlwdEA1LjguM196b2RAMy4yNC4zL25vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvZXNtL2h1bWFuLXJlYWRhYmxlL3J1bnRpbWUvY2FjaGUuanNcIigpIHtcXG4gICAgICBwYXJhbWV0ZXJDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcXG4gICAgICAgIC8vIFVubmFtZWRcXG4gICAgICAgIFtcImFkZHJlc3NcIiwgeyB0eXBlOiBcImFkZHJlc3NcIiB9XSxcXG4gICAgICAgIFtcImJvb2xcIiwgeyB0eXBlOiBcImJvb2xcIiB9XSxcXG4gICAgICAgIFtcImJ5dGVzXCIsIHsgdHlwZTogXCJieXRlc1wiIH1dLFxcbiAgICAgICAgW1wiYnl0ZXMzMlwiLCB7IHR5cGU6IFwiYnl0ZXMzMlwiIH1dLFxcbiAgICAgICAgW1wiaW50XCIsIHsgdHlwZTogXCJpbnQyNTZcIiB9XSxcXG4gICAgICAgIFtcImludDI1NlwiLCB7IHR5cGU6IFwiaW50MjU2XCIgfV0sXFxuICAgICAgICBbXCJzdHJpbmdcIiwgeyB0eXBlOiBcInN0cmluZ1wiIH1dLFxcbiAgICAgICAgW1widWludFwiLCB7IHR5cGU6IFwidWludDI1NlwiIH1dLFxcbiAgICAgICAgW1widWludDhcIiwgeyB0eXBlOiBcInVpbnQ4XCIgfV0sXFxuICAgICAgICBbXCJ1aW50MTZcIiwgeyB0eXBlOiBcInVpbnQxNlwiIH1dLFxcbiAgICAgICAgW1widWludDI0XCIsIHsgdHlwZTogXCJ1aW50MjRcIiB9XSxcXG4gICAgICAgIFtcInVpbnQzMlwiLCB7IHR5cGU6IFwidWludDMyXCIgfV0sXFxuICAgICAgICBbXCJ1aW50NjRcIiwgeyB0eXBlOiBcInVpbnQ2NFwiIH1dLFxcbiAgICAgICAgW1widWludDk2XCIsIHsgdHlwZTogXCJ1aW50OTZcIiB9XSxcXG4gICAgICAgIFtcInVpbnQxMTJcIiwgeyB0eXBlOiBcInVpbnQxMTJcIiB9XSxcXG4gICAgICAgIFtcInVpbnQxNjBcIiwgeyB0eXBlOiBcInVpbnQxNjBcIiB9XSxcXG4gICAgICAgIFtcInVpbnQxOTJcIiwgeyB0eXBlOiBcInVpbnQxOTJcIiB9XSxcXG4gICAgICAgIFtcInVpbnQyNTZcIiwgeyB0eXBlOiBcInVpbnQyNTZcIiB9XSxcXG4gICAgICAgIC8vIE5hbWVkXFxuICAgICAgICBbXCJhZGRyZXNzIG93bmVyXCIsIHsgdHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwib3duZXJcIiB9XSxcXG4gICAgICAgIFtcImFkZHJlc3MgdG9cIiwgeyB0eXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJ0b1wiIH1dLFxcbiAgICAgICAgW1wiYm9vbCBhcHByb3ZlZFwiLCB7IHR5cGU6IFwiYm9vbFwiLCBuYW1lOiBcImFwcHJvdmVkXCIgfV0sXFxuICAgICAgICBbXCJieXRlcyBfZGF0YVwiLCB7IHR5cGU6IFwiYnl0ZXNcIiwgbmFtZTogXCJfZGF0YVwiIH1dLFxcbiAgICAgICAgW1wiYnl0ZXMgZGF0YVwiLCB7IHR5cGU6IFwiYnl0ZXNcIiwgbmFtZTogXCJkYXRhXCIgfV0sXFxuICAgICAgICBbXCJieXRlcyBzaWduYXR1cmVcIiwgeyB0eXBlOiBcImJ5dGVzXCIsIG5hbWU6IFwic2lnbmF0dXJlXCIgfV0sXFxuICAgICAgICBbXCJieXRlczMyIGhhc2hcIiwgeyB0eXBlOiBcImJ5dGVzMzJcIiwgbmFtZTogXCJoYXNoXCIgfV0sXFxuICAgICAgICBbXCJieXRlczMyIHJcIiwgeyB0eXBlOiBcImJ5dGVzMzJcIiwgbmFtZTogXCJyXCIgfV0sXFxuICAgICAgICBbXCJieXRlczMyIHJvb3RcIiwgeyB0eXBlOiBcImJ5dGVzMzJcIiwgbmFtZTogXCJyb290XCIgfV0sXFxuICAgICAgICBbXCJieXRlczMyIHNcIiwgeyB0eXBlOiBcImJ5dGVzMzJcIiwgbmFtZTogXCJzXCIgfV0sXFxuICAgICAgICBbXCJzdHJpbmcgbmFtZVwiLCB7IHR5cGU6IFwic3RyaW5nXCIsIG5hbWU6IFwibmFtZVwiIH1dLFxcbiAgICAgICAgW1wic3RyaW5nIHN5bWJvbFwiLCB7IHR5cGU6IFwic3RyaW5nXCIsIG5hbWU6IFwic3ltYm9sXCIgfV0sXFxuICAgICAgICBbXCJzdHJpbmcgdG9rZW5VUklcIiwgeyB0eXBlOiBcInN0cmluZ1wiLCBuYW1lOiBcInRva2VuVVJJXCIgfV0sXFxuICAgICAgICBbXCJ1aW50IHRva2VuSWRcIiwgeyB0eXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJ0b2tlbklkXCIgfV0sXFxuICAgICAgICBbXCJ1aW50OCB2XCIsIHsgdHlwZTogXCJ1aW50OFwiLCBuYW1lOiBcInZcIiB9XSxcXG4gICAgICAgIFtcInVpbnQyNTYgYmFsYW5jZVwiLCB7IHR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcImJhbGFuY2VcIiB9XSxcXG4gICAgICAgIFtcInVpbnQyNTYgdG9rZW5JZFwiLCB7IHR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcInRva2VuSWRcIiB9XSxcXG4gICAgICAgIFtcInVpbnQyNTYgdmFsdWVcIiwgeyB0eXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJ2YWx1ZVwiIH1dLFxcbiAgICAgICAgLy8gSW5kZXhlZFxcbiAgICAgICAgW1xcbiAgICAgICAgICBcImV2ZW50OmFkZHJlc3MgaW5kZXhlZCBmcm9tXCIsXFxuICAgICAgICAgIHsgdHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiZnJvbVwiLCBpbmRleGVkOiB0cnVlIH1cXG4gICAgICAgIF0sXFxuICAgICAgICBbXCJldmVudDphZGRyZXNzIGluZGV4ZWQgdG9cIiwgeyB0eXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJ0b1wiLCBpbmRleGVkOiB0cnVlIH1dLFxcbiAgICAgICAgW1xcbiAgICAgICAgICBcImV2ZW50OnVpbnQgaW5kZXhlZCB0b2tlbklkXCIsXFxuICAgICAgICAgIHsgdHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwidG9rZW5JZFwiLCBpbmRleGVkOiB0cnVlIH1cXG4gICAgICAgIF0sXFxuICAgICAgICBbXFxuICAgICAgICAgIFwiZXZlbnQ6dWludDI1NiBpbmRleGVkIHRva2VuSWRcIixcXG4gICAgICAgICAgeyB0eXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJ0b2tlbklkXCIsIGluZGV4ZWQ6IHRydWUgfVxcbiAgICAgICAgXVxcbiAgICAgIF0pO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL2FiaXR5cGVAMS4wLjhfdHlwZXNjcmlwdEA1LjguM196b2RAMy4yNC4zL25vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvZXNtL2h1bWFuLXJlYWRhYmxlL3J1bnRpbWUvdXRpbHMuanNcXG4gIGZ1bmN0aW9uIHBhcnNlU2lnbmF0dXJlKHNpZ25hdHVyZSwgc3RydWN0cyA9IHt9KSB7XFxuICAgIGlmIChpc0Z1bmN0aW9uU2lnbmF0dXJlKHNpZ25hdHVyZSkpXFxuICAgICAgcmV0dXJuIHBhcnNlRnVuY3Rpb25TaWduYXR1cmUoc2lnbmF0dXJlLCBzdHJ1Y3RzKTtcXG4gICAgaWYgKGlzRXZlbnRTaWduYXR1cmUoc2lnbmF0dXJlKSlcXG4gICAgICByZXR1cm4gcGFyc2VFdmVudFNpZ25hdHVyZShzaWduYXR1cmUsIHN0cnVjdHMpO1xcbiAgICBpZiAoaXNFcnJvclNpZ25hdHVyZShzaWduYXR1cmUpKVxcbiAgICAgIHJldHVybiBwYXJzZUVycm9yU2lnbmF0dXJlKHNpZ25hdHVyZSwgc3RydWN0cyk7XFxuICAgIGlmIChpc0NvbnN0cnVjdG9yU2lnbmF0dXJlKHNpZ25hdHVyZSkpXFxuICAgICAgcmV0dXJuIHBhcnNlQ29uc3RydWN0b3JTaWduYXR1cmUoc2lnbmF0dXJlLCBzdHJ1Y3RzKTtcXG4gICAgaWYgKGlzRmFsbGJhY2tTaWduYXR1cmUoc2lnbmF0dXJlKSlcXG4gICAgICByZXR1cm4gcGFyc2VGYWxsYmFja1NpZ25hdHVyZShzaWduYXR1cmUpO1xcbiAgICBpZiAoaXNSZWNlaXZlU2lnbmF0dXJlKHNpZ25hdHVyZSkpXFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIHR5cGU6IFwicmVjZWl2ZVwiLFxcbiAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInBheWFibGVcIlxcbiAgICAgIH07XFxuICAgIHRocm93IG5ldyBVbmtub3duU2lnbmF0dXJlRXJyb3IoeyBzaWduYXR1cmUgfSk7XFxuICB9XFxuICBmdW5jdGlvbiBwYXJzZUZ1bmN0aW9uU2lnbmF0dXJlKHNpZ25hdHVyZSwgc3RydWN0cyA9IHt9KSB7XFxuICAgIGNvbnN0IG1hdGNoID0gZXhlY0Z1bmN0aW9uU2lnbmF0dXJlKHNpZ25hdHVyZSk7XFxuICAgIGlmICghbWF0Y2gpXFxuICAgICAgdGhyb3cgbmV3IEludmFsaWRTaWduYXR1cmVFcnJvcih7IHNpZ25hdHVyZSwgdHlwZTogXCJmdW5jdGlvblwiIH0pO1xcbiAgICBjb25zdCBpbnB1dFBhcmFtcyA9IHNwbGl0UGFyYW1ldGVycyhtYXRjaC5wYXJhbWV0ZXJzKTtcXG4gICAgY29uc3QgaW5wdXRzID0gW107XFxuICAgIGNvbnN0IGlucHV0TGVuZ3RoID0gaW5wdXRQYXJhbXMubGVuZ3RoO1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0TGVuZ3RoOyBpKyspIHtcXG4gICAgICBpbnB1dHMucHVzaChwYXJzZUFiaVBhcmFtZXRlcihpbnB1dFBhcmFtc1tpXSwge1xcbiAgICAgICAgbW9kaWZpZXJzOiBmdW5jdGlvbk1vZGlmaWVycyxcXG4gICAgICAgIHN0cnVjdHMsXFxuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCJcXG4gICAgICB9KSk7XFxuICAgIH1cXG4gICAgY29uc3Qgb3V0cHV0cyA9IFtdO1xcbiAgICBpZiAobWF0Y2gucmV0dXJucykge1xcbiAgICAgIGNvbnN0IG91dHB1dFBhcmFtcyA9IHNwbGl0UGFyYW1ldGVycyhtYXRjaC5yZXR1cm5zKTtcXG4gICAgICBjb25zdCBvdXRwdXRMZW5ndGggPSBvdXRwdXRQYXJhbXMubGVuZ3RoO1xcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0TGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIG91dHB1dHMucHVzaChwYXJzZUFiaVBhcmFtZXRlcihvdXRwdXRQYXJhbXNbaV0sIHtcXG4gICAgICAgICAgbW9kaWZpZXJzOiBmdW5jdGlvbk1vZGlmaWVycyxcXG4gICAgICAgICAgc3RydWN0cyxcXG4gICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiXFxuICAgICAgICB9KSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiB7XFxuICAgICAgbmFtZTogbWF0Y2gubmFtZSxcXG4gICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXFxuICAgICAgc3RhdGVNdXRhYmlsaXR5OiBtYXRjaC5zdGF0ZU11dGFiaWxpdHkgPz8gXCJub25wYXlhYmxlXCIsXFxuICAgICAgaW5wdXRzLFxcbiAgICAgIG91dHB1dHNcXG4gICAgfTtcXG4gIH1cXG4gIGZ1bmN0aW9uIHBhcnNlRXZlbnRTaWduYXR1cmUoc2lnbmF0dXJlLCBzdHJ1Y3RzID0ge30pIHtcXG4gICAgY29uc3QgbWF0Y2ggPSBleGVjRXZlbnRTaWduYXR1cmUoc2lnbmF0dXJlKTtcXG4gICAgaWYgKCFtYXRjaClcXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFNpZ25hdHVyZUVycm9yKHsgc2lnbmF0dXJlLCB0eXBlOiBcImV2ZW50XCIgfSk7XFxuICAgIGNvbnN0IHBhcmFtcyA9IHNwbGl0UGFyYW1ldGVycyhtYXRjaC5wYXJhbWV0ZXJzKTtcXG4gICAgY29uc3QgYWJpUGFyYW1ldGVycyA9IFtdO1xcbiAgICBjb25zdCBsZW5ndGggPSBwYXJhbXMubGVuZ3RoO1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxcbiAgICAgIGFiaVBhcmFtZXRlcnMucHVzaChwYXJzZUFiaVBhcmFtZXRlcihwYXJhbXNbaV0sIHtcXG4gICAgICAgIG1vZGlmaWVyczogZXZlbnRNb2RpZmllcnMsXFxuICAgICAgICBzdHJ1Y3RzLFxcbiAgICAgICAgdHlwZTogXCJldmVudFwiXFxuICAgICAgfSkpO1xcbiAgICByZXR1cm4geyBuYW1lOiBtYXRjaC5uYW1lLCB0eXBlOiBcImV2ZW50XCIsIGlucHV0czogYWJpUGFyYW1ldGVycyB9O1xcbiAgfVxcbiAgZnVuY3Rpb24gcGFyc2VFcnJvclNpZ25hdHVyZShzaWduYXR1cmUsIHN0cnVjdHMgPSB7fSkge1xcbiAgICBjb25zdCBtYXRjaCA9IGV4ZWNFcnJvclNpZ25hdHVyZShzaWduYXR1cmUpO1xcbiAgICBpZiAoIW1hdGNoKVxcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkU2lnbmF0dXJlRXJyb3IoeyBzaWduYXR1cmUsIHR5cGU6IFwiZXJyb3JcIiB9KTtcXG4gICAgY29uc3QgcGFyYW1zID0gc3BsaXRQYXJhbWV0ZXJzKG1hdGNoLnBhcmFtZXRlcnMpO1xcbiAgICBjb25zdCBhYmlQYXJhbWV0ZXJzID0gW107XFxuICAgIGNvbnN0IGxlbmd0aCA9IHBhcmFtcy5sZW5ndGg7XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXFxuICAgICAgYWJpUGFyYW1ldGVycy5wdXNoKHBhcnNlQWJpUGFyYW1ldGVyKHBhcmFtc1tpXSwgeyBzdHJ1Y3RzLCB0eXBlOiBcImVycm9yXCIgfSkpO1xcbiAgICByZXR1cm4geyBuYW1lOiBtYXRjaC5uYW1lLCB0eXBlOiBcImVycm9yXCIsIGlucHV0czogYWJpUGFyYW1ldGVycyB9O1xcbiAgfVxcbiAgZnVuY3Rpb24gcGFyc2VDb25zdHJ1Y3RvclNpZ25hdHVyZShzaWduYXR1cmUsIHN0cnVjdHMgPSB7fSkge1xcbiAgICBjb25zdCBtYXRjaCA9IGV4ZWNDb25zdHJ1Y3RvclNpZ25hdHVyZShzaWduYXR1cmUpO1xcbiAgICBpZiAoIW1hdGNoKVxcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkU2lnbmF0dXJlRXJyb3IoeyBzaWduYXR1cmUsIHR5cGU6IFwiY29uc3RydWN0b3JcIiB9KTtcXG4gICAgY29uc3QgcGFyYW1zID0gc3BsaXRQYXJhbWV0ZXJzKG1hdGNoLnBhcmFtZXRlcnMpO1xcbiAgICBjb25zdCBhYmlQYXJhbWV0ZXJzID0gW107XFxuICAgIGNvbnN0IGxlbmd0aCA9IHBhcmFtcy5sZW5ndGg7XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXFxuICAgICAgYWJpUGFyYW1ldGVycy5wdXNoKHBhcnNlQWJpUGFyYW1ldGVyKHBhcmFtc1tpXSwgeyBzdHJ1Y3RzLCB0eXBlOiBcImNvbnN0cnVjdG9yXCIgfSkpO1xcbiAgICByZXR1cm4ge1xcbiAgICAgIHR5cGU6IFwiY29uc3RydWN0b3JcIixcXG4gICAgICBzdGF0ZU11dGFiaWxpdHk6IG1hdGNoLnN0YXRlTXV0YWJpbGl0eSA/PyBcIm5vbnBheWFibGVcIixcXG4gICAgICBpbnB1dHM6IGFiaVBhcmFtZXRlcnNcXG4gICAgfTtcXG4gIH1cXG4gIGZ1bmN0aW9uIHBhcnNlRmFsbGJhY2tTaWduYXR1cmUoc2lnbmF0dXJlKSB7XFxuICAgIGNvbnN0IG1hdGNoID0gZXhlY0ZhbGxiYWNrU2lnbmF0dXJlKHNpZ25hdHVyZSk7XFxuICAgIGlmICghbWF0Y2gpXFxuICAgICAgdGhyb3cgbmV3IEludmFsaWRTaWduYXR1cmVFcnJvcih7IHNpZ25hdHVyZSwgdHlwZTogXCJmYWxsYmFja1wiIH0pO1xcbiAgICByZXR1cm4ge1xcbiAgICAgIHR5cGU6IFwiZmFsbGJhY2tcIixcXG4gICAgICBzdGF0ZU11dGFiaWxpdHk6IG1hdGNoLnN0YXRlTXV0YWJpbGl0eSA/PyBcIm5vbnBheWFibGVcIlxcbiAgICB9O1xcbiAgfVxcbiAgZnVuY3Rpb24gcGFyc2VBYmlQYXJhbWV0ZXIocGFyYW0sIG9wdGlvbnMpIHtcXG4gICAgY29uc3QgcGFyYW1ldGVyQ2FjaGVLZXkgPSBnZXRQYXJhbWV0ZXJDYWNoZUtleShwYXJhbSwgb3B0aW9ucz8udHlwZSwgb3B0aW9ucz8uc3RydWN0cyk7XFxuICAgIGlmIChwYXJhbWV0ZXJDYWNoZS5oYXMocGFyYW1ldGVyQ2FjaGVLZXkpKVxcbiAgICAgIHJldHVybiBwYXJhbWV0ZXJDYWNoZS5nZXQocGFyYW1ldGVyQ2FjaGVLZXkpO1xcbiAgICBjb25zdCBpc1R1cGxlID0gaXNUdXBsZVJlZ2V4LnRlc3QocGFyYW0pO1xcbiAgICBjb25zdCBtYXRjaCA9IGV4ZWNUeXBlZChpc1R1cGxlID8gYWJpUGFyYW1ldGVyV2l0aFR1cGxlUmVnZXggOiBhYmlQYXJhbWV0ZXJXaXRob3V0VHVwbGVSZWdleCwgcGFyYW0pO1xcbiAgICBpZiAoIW1hdGNoKVxcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkUGFyYW1ldGVyRXJyb3IoeyBwYXJhbSB9KTtcXG4gICAgaWYgKG1hdGNoLm5hbWUgJiYgaXNTb2xpZGl0eUtleXdvcmQobWF0Y2gubmFtZSkpXFxuICAgICAgdGhyb3cgbmV3IFNvbGlkaXR5UHJvdGVjdGVkS2V5d29yZEVycm9yKHsgcGFyYW0sIG5hbWU6IG1hdGNoLm5hbWUgfSk7XFxuICAgIGNvbnN0IG5hbWUgPSBtYXRjaC5uYW1lID8geyBuYW1lOiBtYXRjaC5uYW1lIH0gOiB7fTtcXG4gICAgY29uc3QgaW5kZXhlZCA9IG1hdGNoLm1vZGlmaWVyID09PSBcImluZGV4ZWRcIiA/IHsgaW5kZXhlZDogdHJ1ZSB9IDoge307XFxuICAgIGNvbnN0IHN0cnVjdHMgPSBvcHRpb25zPy5zdHJ1Y3RzID8/IHt9O1xcbiAgICBsZXQgdHlwZTtcXG4gICAgbGV0IGNvbXBvbmVudHMgPSB7fTtcXG4gICAgaWYgKGlzVHVwbGUpIHtcXG4gICAgICB0eXBlID0gXCJ0dXBsZVwiO1xcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHNwbGl0UGFyYW1ldGVycyhtYXRjaC50eXBlKTtcXG4gICAgICBjb25zdCBjb21wb25lbnRzXyA9IFtdO1xcbiAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcmFtcy5sZW5ndGg7XFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xcbiAgICAgICAgY29tcG9uZW50c18ucHVzaChwYXJzZUFiaVBhcmFtZXRlcihwYXJhbXNbaV0sIHsgc3RydWN0cyB9KSk7XFxuICAgICAgfVxcbiAgICAgIGNvbXBvbmVudHMgPSB7IGNvbXBvbmVudHM6IGNvbXBvbmVudHNfIH07XFxuICAgIH0gZWxzZSBpZiAobWF0Y2gudHlwZSBpbiBzdHJ1Y3RzKSB7XFxuICAgICAgdHlwZSA9IFwidHVwbGVcIjtcXG4gICAgICBjb21wb25lbnRzID0geyBjb21wb25lbnRzOiBzdHJ1Y3RzW21hdGNoLnR5cGVdIH07XFxuICAgIH0gZWxzZSBpZiAoZHluYW1pY0ludGVnZXJSZWdleC50ZXN0KG1hdGNoLnR5cGUpKSB7XFxuICAgICAgdHlwZSA9IGAke21hdGNoLnR5cGV9MjU2YDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0eXBlID0gbWF0Y2gudHlwZTtcXG4gICAgICBpZiAoIShvcHRpb25zPy50eXBlID09PSBcInN0cnVjdFwiKSAmJiAhaXNTb2xpZGl0eVR5cGUodHlwZSkpXFxuICAgICAgICB0aHJvdyBuZXcgVW5rbm93blNvbGlkaXR5VHlwZUVycm9yKHsgdHlwZSB9KTtcXG4gICAgfVxcbiAgICBpZiAobWF0Y2gubW9kaWZpZXIpIHtcXG4gICAgICBpZiAoIW9wdGlvbnM/Lm1vZGlmaWVycz8uaGFzPy4obWF0Y2gubW9kaWZpZXIpKVxcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRNb2RpZmllckVycm9yKHtcXG4gICAgICAgICAgcGFyYW0sXFxuICAgICAgICAgIHR5cGU6IG9wdGlvbnM/LnR5cGUsXFxuICAgICAgICAgIG1vZGlmaWVyOiBtYXRjaC5tb2RpZmllclxcbiAgICAgICAgfSk7XFxuICAgICAgaWYgKGZ1bmN0aW9uTW9kaWZpZXJzLmhhcyhtYXRjaC5tb2RpZmllcikgJiYgIWlzVmFsaWREYXRhTG9jYXRpb24odHlwZSwgISFtYXRjaC5hcnJheSkpXFxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEZ1bmN0aW9uTW9kaWZpZXJFcnJvcih7XFxuICAgICAgICAgIHBhcmFtLFxcbiAgICAgICAgICB0eXBlOiBvcHRpb25zPy50eXBlLFxcbiAgICAgICAgICBtb2RpZmllcjogbWF0Y2gubW9kaWZpZXJcXG4gICAgICAgIH0pO1xcbiAgICB9XFxuICAgIGNvbnN0IGFiaVBhcmFtZXRlciA9IHtcXG4gICAgICB0eXBlOiBgJHt0eXBlfSR7bWF0Y2guYXJyYXkgPz8gXCJcIn1gLFxcbiAgICAgIC4uLm5hbWUsXFxuICAgICAgLi4uaW5kZXhlZCxcXG4gICAgICAuLi5jb21wb25lbnRzXFxuICAgIH07XFxuICAgIHBhcmFtZXRlckNhY2hlLnNldChwYXJhbWV0ZXJDYWNoZUtleSwgYWJpUGFyYW1ldGVyKTtcXG4gICAgcmV0dXJuIGFiaVBhcmFtZXRlcjtcXG4gIH1cXG4gIGZ1bmN0aW9uIHNwbGl0UGFyYW1ldGVycyhwYXJhbXMsIHJlc3VsdCA9IFtdLCBjdXJyZW50ID0gXCJcIiwgZGVwdGggPSAwKSB7XFxuICAgIGNvbnN0IGxlbmd0aCA9IHBhcmFtcy50cmltKCkubGVuZ3RoO1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XFxuICAgICAgY29uc3QgY2hhciA9IHBhcmFtc1tpXTtcXG4gICAgICBjb25zdCB0YWlsID0gcGFyYW1zLnNsaWNlKGkgKyAxKTtcXG4gICAgICBzd2l0Y2ggKGNoYXIpIHtcXG4gICAgICAgIGNhc2UgXCIsXCI6XFxuICAgICAgICAgIHJldHVybiBkZXB0aCA9PT0gMCA/IHNwbGl0UGFyYW1ldGVycyh0YWlsLCBbLi4ucmVzdWx0LCBjdXJyZW50LnRyaW0oKV0pIDogc3BsaXRQYXJhbWV0ZXJzKHRhaWwsIHJlc3VsdCwgYCR7Y3VycmVudH0ke2NoYXJ9YCwgZGVwdGgpO1xcbiAgICAgICAgY2FzZSBcIihcIjpcXG4gICAgICAgICAgcmV0dXJuIHNwbGl0UGFyYW1ldGVycyh0YWlsLCByZXN1bHQsIGAke2N1cnJlbnR9JHtjaGFyfWAsIGRlcHRoICsgMSk7XFxuICAgICAgICBjYXNlIFwiKVwiOlxcbiAgICAgICAgICByZXR1cm4gc3BsaXRQYXJhbWV0ZXJzKHRhaWwsIHJlc3VsdCwgYCR7Y3VycmVudH0ke2NoYXJ9YCwgZGVwdGggLSAxKTtcXG4gICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgIHJldHVybiBzcGxpdFBhcmFtZXRlcnModGFpbCwgcmVzdWx0LCBgJHtjdXJyZW50fSR7Y2hhcn1gLCBkZXB0aCk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmIChjdXJyZW50ID09PSBcIlwiKVxcbiAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgIGlmIChkZXB0aCAhPT0gMClcXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFBhcmVudGhlc2lzRXJyb3IoeyBjdXJyZW50LCBkZXB0aCB9KTtcXG4gICAgcmVzdWx0LnB1c2goY3VycmVudC50cmltKCkpO1xcbiAgICByZXR1cm4gcmVzdWx0O1xcbiAgfVxcbiAgZnVuY3Rpb24gaXNTb2xpZGl0eVR5cGUodHlwZSkge1xcbiAgICByZXR1cm4gdHlwZSA9PT0gXCJhZGRyZXNzXCIgfHwgdHlwZSA9PT0gXCJib29sXCIgfHwgdHlwZSA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgfHwgYnl0ZXNSZWdleC50ZXN0KHR5cGUpIHx8IGludGVnZXJSZWdleC50ZXN0KHR5cGUpO1xcbiAgfVxcbiAgZnVuY3Rpb24gaXNTb2xpZGl0eUtleXdvcmQobmFtZSkge1xcbiAgICByZXR1cm4gbmFtZSA9PT0gXCJhZGRyZXNzXCIgfHwgbmFtZSA9PT0gXCJib29sXCIgfHwgbmFtZSA9PT0gXCJmdW5jdGlvblwiIHx8IG5hbWUgPT09IFwic3RyaW5nXCIgfHwgbmFtZSA9PT0gXCJ0dXBsZVwiIHx8IGJ5dGVzUmVnZXgudGVzdChuYW1lKSB8fCBpbnRlZ2VyUmVnZXgudGVzdChuYW1lKSB8fCBwcm90ZWN0ZWRLZXl3b3Jkc1JlZ2V4LnRlc3QobmFtZSk7XFxuICB9XFxuICBmdW5jdGlvbiBpc1ZhbGlkRGF0YUxvY2F0aW9uKHR5cGUsIGlzQXJyYXkpIHtcXG4gICAgcmV0dXJuIGlzQXJyYXkgfHwgdHlwZSA9PT0gXCJieXRlc1wiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZSA9PT0gXCJ0dXBsZVwiO1xcbiAgfVxcbiAgdmFyIGFiaVBhcmFtZXRlcldpdGhvdXRUdXBsZVJlZ2V4LCBhYmlQYXJhbWV0ZXJXaXRoVHVwbGVSZWdleCwgZHluYW1pY0ludGVnZXJSZWdleCwgcHJvdGVjdGVkS2V5d29yZHNSZWdleDtcXG4gIHZhciBpbml0X3V0aWxzID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL2FiaXR5cGVAMS4wLjhfdHlwZXNjcmlwdEA1LjguM196b2RAMy4yNC4zL25vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvZXNtL2h1bWFuLXJlYWRhYmxlL3J1bnRpbWUvdXRpbHMuanNcIigpIHtcXG4gICAgICBpbml0X3JlZ2V4KCk7XFxuICAgICAgaW5pdF9hYmlJdGVtKCk7XFxuICAgICAgaW5pdF9hYmlQYXJhbWV0ZXIoKTtcXG4gICAgICBpbml0X3NpZ25hdHVyZSgpO1xcbiAgICAgIGluaXRfc3BsaXRQYXJhbWV0ZXJzKCk7XFxuICAgICAgaW5pdF9jYWNoZSgpO1xcbiAgICAgIGluaXRfc2lnbmF0dXJlcygpO1xcbiAgICAgIGFiaVBhcmFtZXRlcldpdGhvdXRUdXBsZVJlZ2V4ID0gL14oPzx0eXBlPlthLXpBLVokX11bYS16QS1aMC05JF9dKikoPzxhcnJheT4oPzpcXFxcW1xcXFxkKj9cXFxcXSkrPyk/KD86XFxcXHMoPzxtb2RpZmllcj5jYWxsZGF0YXxpbmRleGVkfG1lbW9yeXxzdG9yYWdlezF9KSk/KD86XFxcXHMoPzxuYW1lPlthLXpBLVokX11bYS16QS1aMC05JF9dKikpPyQvO1xcbiAgICAgIGFiaVBhcmFtZXRlcldpdGhUdXBsZVJlZ2V4ID0gL15cXFxcKCg/PHR5cGU+Lis/KVxcXFwpKD88YXJyYXk+KD86XFxcXFtcXFxcZCo/XFxcXF0pKz8pPyg/OlxcXFxzKD88bW9kaWZpZXI+Y2FsbGRhdGF8aW5kZXhlZHxtZW1vcnl8c3RvcmFnZXsxfSkpPyg/OlxcXFxzKD88bmFtZT5bYS16QS1aJF9dW2EtekEtWjAtOSRfXSopKT8kLztcXG4gICAgICBkeW5hbWljSW50ZWdlclJlZ2V4ID0gL151P2ludCQvO1xcbiAgICAgIHByb3RlY3RlZEtleXdvcmRzUmVnZXggPSAvXig/OmFmdGVyfGFsaWFzfGFub255bW91c3xhcHBseXxhdXRvfGJ5dGV8Y2FsbGRhdGF8Y2FzZXxjYXRjaHxjb25zdGFudHxjb3B5b2Z8ZGVmYXVsdHxkZWZpbmVkfGVycm9yfGV2ZW50fGV4dGVybmFsfGZhbHNlfGZpbmFsfGZ1bmN0aW9ufGltbXV0YWJsZXxpbXBsZW1lbnRzfGlufGluZGV4ZWR8aW5saW5lfGludGVybmFsfGxldHxtYXBwaW5nfG1hdGNofG1lbW9yeXxtdXRhYmxlfG51bGx8b2Z8b3ZlcnJpZGV8cGFydGlhbHxwcml2YXRlfHByb21pc2V8cHVibGljfHB1cmV8cmVmZXJlbmNlfHJlbG9jYXRhYmxlfHJldHVybnxyZXR1cm5zfHNpemVvZnxzdGF0aWN8c3RvcmFnZXxzdHJ1Y3R8c3VwZXJ8c3VwcG9ydHN8c3dpdGNofHRoaXN8dHJ1ZXx0cnl8dHlwZWRlZnx0eXBlb2Z8dmFyfHZpZXd8dmlydHVhbCkkLztcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS9hYml0eXBlQDEuMC44X3R5cGVzY3JpcHRANS44LjNfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9ydW50aW1lL3N0cnVjdHMuanNcXG4gIGZ1bmN0aW9uIHBhcnNlU3RydWN0cyhzaWduYXR1cmVzKSB7XFxuICAgIGNvbnN0IHNoYWxsb3dTdHJ1Y3RzID0ge307XFxuICAgIGNvbnN0IHNpZ25hdHVyZXNMZW5ndGggPSBzaWduYXR1cmVzLmxlbmd0aDtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWduYXR1cmVzTGVuZ3RoOyBpKyspIHtcXG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBzaWduYXR1cmVzW2ldO1xcbiAgICAgIGlmICghaXNTdHJ1Y3RTaWduYXR1cmUoc2lnbmF0dXJlKSlcXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICAgIGNvbnN0IG1hdGNoID0gZXhlY1N0cnVjdFNpZ25hdHVyZShzaWduYXR1cmUpO1xcbiAgICAgIGlmICghbWF0Y2gpXFxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFNpZ25hdHVyZUVycm9yKHsgc2lnbmF0dXJlLCB0eXBlOiBcInN0cnVjdFwiIH0pO1xcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBtYXRjaC5wcm9wZXJ0aWVzLnNwbGl0KFwiO1wiKTtcXG4gICAgICBjb25zdCBjb21wb25lbnRzID0gW107XFxuICAgICAgY29uc3QgcHJvcGVydGllc0xlbmd0aCA9IHByb3BlcnRpZXMubGVuZ3RoO1xcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcHJvcGVydGllc0xlbmd0aDsgaysrKSB7XFxuICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IHByb3BlcnRpZXNba107XFxuICAgICAgICBjb25zdCB0cmltbWVkID0gcHJvcGVydHkudHJpbSgpO1xcbiAgICAgICAgaWYgKCF0cmltbWVkKVxcbiAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgIGNvbnN0IGFiaVBhcmFtZXRlciA9IHBhcnNlQWJpUGFyYW1ldGVyKHRyaW1tZWQsIHtcXG4gICAgICAgICAgdHlwZTogXCJzdHJ1Y3RcIlxcbiAgICAgICAgfSk7XFxuICAgICAgICBjb21wb25lbnRzLnB1c2goYWJpUGFyYW1ldGVyKTtcXG4gICAgICB9XFxuICAgICAgaWYgKCFjb21wb25lbnRzLmxlbmd0aClcXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkU3RydWN0U2lnbmF0dXJlRXJyb3IoeyBzaWduYXR1cmUgfSk7XFxuICAgICAgc2hhbGxvd1N0cnVjdHNbbWF0Y2gubmFtZV0gPSBjb21wb25lbnRzO1xcbiAgICB9XFxuICAgIGNvbnN0IHJlc29sdmVkU3RydWN0cyA9IHt9O1xcbiAgICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoc2hhbGxvd1N0cnVjdHMpO1xcbiAgICBjb25zdCBlbnRyaWVzTGVuZ3RoID0gZW50cmllcy5sZW5ndGg7XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW50cmllc0xlbmd0aDsgaSsrKSB7XFxuICAgICAgY29uc3QgW25hbWUsIHBhcmFtZXRlcnNdID0gZW50cmllc1tpXTtcXG4gICAgICByZXNvbHZlZFN0cnVjdHNbbmFtZV0gPSByZXNvbHZlU3RydWN0cyhwYXJhbWV0ZXJzLCBzaGFsbG93U3RydWN0cyk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHJlc29sdmVkU3RydWN0cztcXG4gIH1cXG4gIGZ1bmN0aW9uIHJlc29sdmVTdHJ1Y3RzKGFiaVBhcmFtZXRlcnMsIHN0cnVjdHMsIGFuY2VzdG9ycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpIHtcXG4gICAgY29uc3QgY29tcG9uZW50cyA9IFtdO1xcbiAgICBjb25zdCBsZW5ndGggPSBhYmlQYXJhbWV0ZXJzLmxlbmd0aDtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xcbiAgICAgIGNvbnN0IGFiaVBhcmFtZXRlciA9IGFiaVBhcmFtZXRlcnNbaV07XFxuICAgICAgY29uc3QgaXNUdXBsZSA9IGlzVHVwbGVSZWdleC50ZXN0KGFiaVBhcmFtZXRlci50eXBlKTtcXG4gICAgICBpZiAoaXNUdXBsZSlcXG4gICAgICAgIGNvbXBvbmVudHMucHVzaChhYmlQYXJhbWV0ZXIpO1xcbiAgICAgIGVsc2Uge1xcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBleGVjVHlwZWQodHlwZVdpdGhvdXRUdXBsZVJlZ2V4LCBhYmlQYXJhbWV0ZXIudHlwZSk7XFxuICAgICAgICBpZiAoIW1hdGNoPy50eXBlKVxcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFiaVR5cGVQYXJhbWV0ZXJFcnJvcih7IGFiaVBhcmFtZXRlciB9KTtcXG4gICAgICAgIGNvbnN0IHsgYXJyYXksIHR5cGUgfSA9IG1hdGNoO1xcbiAgICAgICAgaWYgKHR5cGUgaW4gc3RydWN0cykge1xcbiAgICAgICAgICBpZiAoYW5jZXN0b3JzLmhhcyh0eXBlKSlcXG4gICAgICAgICAgICB0aHJvdyBuZXcgQ2lyY3VsYXJSZWZlcmVuY2VFcnJvcih7IHR5cGUgfSk7XFxuICAgICAgICAgIGNvbXBvbmVudHMucHVzaCh7XFxuICAgICAgICAgICAgLi4uYWJpUGFyYW1ldGVyLFxcbiAgICAgICAgICAgIHR5cGU6IGB0dXBsZSR7YXJyYXkgPz8gXCJcIn1gLFxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IHJlc29sdmVTdHJ1Y3RzKHN0cnVjdHNbdHlwZV0gPz8gW10sIHN0cnVjdHMsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFsuLi5hbmNlc3RvcnMsIHR5cGVdKSlcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBpZiAoaXNTb2xpZGl0eVR5cGUodHlwZSkpXFxuICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKGFiaVBhcmFtZXRlcik7XFxuICAgICAgICAgIGVsc2VcXG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5rbm93blR5cGVFcnJvcih7IHR5cGUgfSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBjb21wb25lbnRzO1xcbiAgfVxcbiAgdmFyIHR5cGVXaXRob3V0VHVwbGVSZWdleDtcXG4gIHZhciBpbml0X3N0cnVjdHMgPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vYWJpdHlwZUAxLjAuOF90eXBlc2NyaXB0QDUuOC4zX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vaHVtYW4tcmVhZGFibGUvcnVudGltZS9zdHJ1Y3RzLmpzXCIoKSB7XFxuICAgICAgaW5pdF9yZWdleCgpO1xcbiAgICAgIGluaXRfYWJpSXRlbSgpO1xcbiAgICAgIGluaXRfYWJpUGFyYW1ldGVyKCk7XFxuICAgICAgaW5pdF9zaWduYXR1cmUoKTtcXG4gICAgICBpbml0X3N0cnVjdCgpO1xcbiAgICAgIGluaXRfc2lnbmF0dXJlcygpO1xcbiAgICAgIGluaXRfdXRpbHMoKTtcXG4gICAgICB0eXBlV2l0aG91dFR1cGxlUmVnZXggPSAvXig/PHR5cGU+W2EtekEtWiRfXVthLXpBLVowLTkkX10qKSg/PGFycmF5Pig/OlxcXFxbXFxcXGQqP1xcXFxdKSs/KT8kLztcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS9hYml0eXBlQDEuMC44X3R5cGVzY3JpcHRANS44LjNfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvYWJpdHlwZS9kaXN0L2VzbS9odW1hbi1yZWFkYWJsZS9wYXJzZUFiaS5qc1xcbiAgZnVuY3Rpb24gcGFyc2VBYmkoc2lnbmF0dXJlcykge1xcbiAgICBjb25zdCBzdHJ1Y3RzID0gcGFyc2VTdHJ1Y3RzKHNpZ25hdHVyZXMpO1xcbiAgICBjb25zdCBhYmkyID0gW107XFxuICAgIGNvbnN0IGxlbmd0aCA9IHNpZ25hdHVyZXMubGVuZ3RoO1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XFxuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gc2lnbmF0dXJlc1tpXTtcXG4gICAgICBpZiAoaXNTdHJ1Y3RTaWduYXR1cmUoc2lnbmF0dXJlKSlcXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICAgIGFiaTIucHVzaChwYXJzZVNpZ25hdHVyZShzaWduYXR1cmUsIHN0cnVjdHMpKTtcXG4gICAgfVxcbiAgICByZXR1cm4gYWJpMjtcXG4gIH1cXG4gIHZhciBpbml0X3BhcnNlQWJpID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL2FiaXR5cGVAMS4wLjhfdHlwZXNjcmlwdEA1LjguM196b2RAMy4yNC4zL25vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvZXNtL2h1bWFuLXJlYWRhYmxlL3BhcnNlQWJpLmpzXCIoKSB7XFxuICAgICAgaW5pdF9zaWduYXR1cmVzKCk7XFxuICAgICAgaW5pdF9zdHJ1Y3RzKCk7XFxuICAgICAgaW5pdF91dGlscygpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL2FiaXR5cGVAMS4wLjhfdHlwZXNjcmlwdEA1LjguM196b2RAMy4yNC4zL25vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvZXNtL2h1bWFuLXJlYWRhYmxlL3BhcnNlQWJpSXRlbS5qc1xcbiAgZnVuY3Rpb24gcGFyc2VBYmlJdGVtKHNpZ25hdHVyZSkge1xcbiAgICBsZXQgYWJpSXRlbTtcXG4gICAgaWYgKHR5cGVvZiBzaWduYXR1cmUgPT09IFwic3RyaW5nXCIpXFxuICAgICAgYWJpSXRlbSA9IHBhcnNlU2lnbmF0dXJlKHNpZ25hdHVyZSk7XFxuICAgIGVsc2Uge1xcbiAgICAgIGNvbnN0IHN0cnVjdHMgPSBwYXJzZVN0cnVjdHMoc2lnbmF0dXJlKTtcXG4gICAgICBjb25zdCBsZW5ndGggPSBzaWduYXR1cmUubGVuZ3RoO1xcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZV8gPSBzaWduYXR1cmVbaV07XFxuICAgICAgICBpZiAoaXNTdHJ1Y3RTaWduYXR1cmUoc2lnbmF0dXJlXykpXFxuICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgYWJpSXRlbSA9IHBhcnNlU2lnbmF0dXJlKHNpZ25hdHVyZV8sIHN0cnVjdHMpO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmICghYWJpSXRlbSlcXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFiaUl0ZW1FcnJvcih7IHNpZ25hdHVyZSB9KTtcXG4gICAgcmV0dXJuIGFiaUl0ZW07XFxuICB9XFxuICB2YXIgaW5pdF9wYXJzZUFiaUl0ZW0gPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vYWJpdHlwZUAxLjAuOF90eXBlc2NyaXB0QDUuOC4zX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vaHVtYW4tcmVhZGFibGUvcGFyc2VBYmlJdGVtLmpzXCIoKSB7XFxuICAgICAgaW5pdF9hYmlJdGVtKCk7XFxuICAgICAgaW5pdF9zaWduYXR1cmVzKCk7XFxuICAgICAgaW5pdF9zdHJ1Y3RzKCk7XFxuICAgICAgaW5pdF91dGlscygpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL2FiaXR5cGVAMS4wLjhfdHlwZXNjcmlwdEA1LjguM196b2RAMy4yNC4zL25vZGVfbW9kdWxlcy9hYml0eXBlL2Rpc3QvZXNtL2V4cG9ydHMvaW5kZXguanNcXG4gIHZhciBpbml0X2V4cG9ydHMgPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vYWJpdHlwZUAxLjAuOF90eXBlc2NyaXB0QDUuOC4zX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL2FiaXR5cGUvZGlzdC9lc20vZXhwb3J0cy9pbmRleC5qc1wiKCkge1xcbiAgICAgIGluaXRfZm9ybWF0QWJpSXRlbSgpO1xcbiAgICAgIGluaXRfcGFyc2VBYmkoKTtcXG4gICAgICBpbml0X3BhcnNlQWJpSXRlbSgpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2FiaS9mb3JtYXRBYmlJdGVtLmpzXFxuICBmdW5jdGlvbiBmb3JtYXRBYmlJdGVtMihhYmlJdGVtLCB7IGluY2x1ZGVOYW1lID0gZmFsc2UgfSA9IHt9KSB7XFxuICAgIGlmIChhYmlJdGVtLnR5cGUgIT09IFwiZnVuY3Rpb25cIiAmJiBhYmlJdGVtLnR5cGUgIT09IFwiZXZlbnRcIiAmJiBhYmlJdGVtLnR5cGUgIT09IFwiZXJyb3JcIilcXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZERlZmluaXRpb25UeXBlRXJyb3IoYWJpSXRlbS50eXBlKTtcXG4gICAgcmV0dXJuIGAke2FiaUl0ZW0ubmFtZX0oJHtmb3JtYXRBYmlQYXJhbXMoYWJpSXRlbS5pbnB1dHMsIHsgaW5jbHVkZU5hbWUgfSl9KWA7XFxuICB9XFxuICBmdW5jdGlvbiBmb3JtYXRBYmlQYXJhbXMocGFyYW1zLCB7IGluY2x1ZGVOYW1lID0gZmFsc2UgfSA9IHt9KSB7XFxuICAgIGlmICghcGFyYW1zKVxcbiAgICAgIHJldHVybiBcIlwiO1xcbiAgICByZXR1cm4gcGFyYW1zLm1hcCgocGFyYW0pID0+IGZvcm1hdEFiaVBhcmFtKHBhcmFtLCB7IGluY2x1ZGVOYW1lIH0pKS5qb2luKGluY2x1ZGVOYW1lID8gXCIsIFwiIDogXCIsXCIpO1xcbiAgfVxcbiAgZnVuY3Rpb24gZm9ybWF0QWJpUGFyYW0ocGFyYW0sIHsgaW5jbHVkZU5hbWUgfSkge1xcbiAgICBpZiAocGFyYW0udHlwZS5zdGFydHNXaXRoKFwidHVwbGVcIikpIHtcXG4gICAgICByZXR1cm4gYCgke2Zvcm1hdEFiaVBhcmFtcyhwYXJhbS5jb21wb25lbnRzLCB7IGluY2x1ZGVOYW1lIH0pfSkke3BhcmFtLnR5cGUuc2xpY2UoXCJ0dXBsZVwiLmxlbmd0aCl9YDtcXG4gICAgfVxcbiAgICByZXR1cm4gcGFyYW0udHlwZSArIChpbmNsdWRlTmFtZSAmJiBwYXJhbS5uYW1lID8gYCAke3BhcmFtLm5hbWV9YCA6IFwiXCIpO1xcbiAgfVxcbiAgdmFyIGluaXRfZm9ybWF0QWJpSXRlbTIgPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvYWJpL2Zvcm1hdEFiaUl0ZW0uanNcIigpIHtcXG4gICAgICBpbml0X2FiaSgpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2RhdGEvaXNIZXguanNcXG4gIGZ1bmN0aW9uIGlzSGV4KHZhbHVlLCB7IHN0cmljdCA9IHRydWUgfSA9IHt9KSB7XFxuICAgIGlmICghdmFsdWUpXFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKVxcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgcmV0dXJuIHN0cmljdCA/IC9eMHhbMC05YS1mQS1GXSokLy50ZXN0KHZhbHVlKSA6IHZhbHVlLnN0YXJ0c1dpdGgoXCIweFwiKTtcXG4gIH1cXG4gIHZhciBpbml0X2lzSGV4ID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2RhdGEvaXNIZXguanNcIigpIHtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9kYXRhL3NpemUuanNcXG4gIGZ1bmN0aW9uIHNpemUodmFsdWUpIHtcXG4gICAgaWYgKGlzSGV4KHZhbHVlLCB7IHN0cmljdDogZmFsc2UgfSkpXFxuICAgICAgcmV0dXJuIE1hdGguY2VpbCgodmFsdWUubGVuZ3RoIC0gMikgLyAyKTtcXG4gICAgcmV0dXJuIHZhbHVlLmxlbmd0aDtcXG4gIH1cXG4gIHZhciBpbml0X3NpemUgPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvZGF0YS9zaXplLmpzXCIoKSB7XFxuICAgICAgaW5pdF9pc0hleCgpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2Vycm9ycy92ZXJzaW9uLmpzXFxuICB2YXIgdmVyc2lvbjI7XFxuICB2YXIgaW5pdF92ZXJzaW9uMiA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9lcnJvcnMvdmVyc2lvbi5qc1wiKCkge1xcbiAgICAgIHZlcnNpb24yID0gXCIyLjI3LjJcIjtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9lcnJvcnMvYmFzZS5qc1xcbiAgZnVuY3Rpb24gd2FsayhlcnIsIGZuKSB7XFxuICAgIGlmIChmbj8uKGVycikpXFxuICAgICAgcmV0dXJuIGVycjtcXG4gICAgaWYgKGVyciAmJiB0eXBlb2YgZXJyID09PSBcIm9iamVjdFwiICYmIFwiY2F1c2VcIiBpbiBlcnIgJiYgZXJyLmNhdXNlICE9PSB2b2lkIDApXFxuICAgICAgcmV0dXJuIHdhbGsoZXJyLmNhdXNlLCBmbik7XFxuICAgIHJldHVybiBmbiA/IG51bGwgOiBlcnI7XFxuICB9XFxuICB2YXIgZXJyb3JDb25maWcsIEJhc2VFcnJvcjI7XFxuICB2YXIgaW5pdF9iYXNlID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2Vycm9ycy9iYXNlLmpzXCIoKSB7XFxuICAgICAgaW5pdF92ZXJzaW9uMigpO1xcbiAgICAgIGVycm9yQ29uZmlnID0ge1xcbiAgICAgICAgZ2V0RG9jc1VybDogKHsgZG9jc0Jhc2VVcmwsIGRvY3NQYXRoOiBkb2NzUGF0aDggPSBcIlwiLCBkb2NzU2x1ZyB9KSA9PiBkb2NzUGF0aDggPyBgJHtkb2NzQmFzZVVybCA/PyBcImh0dHBzOi8vdmllbS5zaFwifSR7ZG9jc1BhdGg4fSR7ZG9jc1NsdWcgPyBgIyR7ZG9jc1NsdWd9YCA6IFwiXCJ9YCA6IHZvaWQgMCxcXG4gICAgICAgIHZlcnNpb246IGB2aWVtQCR7dmVyc2lvbjJ9YFxcbiAgICAgIH07XFxuICAgICAgQmFzZUVycm9yMiA9IGNsYXNzIF9CYXNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XFxuICAgICAgICBjb25zdHJ1Y3RvcihzaG9ydE1lc3NhZ2UsIGFyZ3MgPSB7fSkge1xcbiAgICAgICAgICBjb25zdCBkZXRhaWxzID0gKCgpID0+IHtcXG4gICAgICAgICAgICBpZiAoYXJncy5jYXVzZSBpbnN0YW5jZW9mIF9CYXNlRXJyb3IpXFxuICAgICAgICAgICAgICByZXR1cm4gYXJncy5jYXVzZS5kZXRhaWxzO1xcbiAgICAgICAgICAgIGlmIChhcmdzLmNhdXNlPy5tZXNzYWdlKVxcbiAgICAgICAgICAgICAgcmV0dXJuIGFyZ3MuY2F1c2UubWVzc2FnZTtcXG4gICAgICAgICAgICByZXR1cm4gYXJncy5kZXRhaWxzO1xcbiAgICAgICAgICB9KSgpO1xcbiAgICAgICAgICBjb25zdCBkb2NzUGF0aDggPSAoKCkgPT4ge1xcbiAgICAgICAgICAgIGlmIChhcmdzLmNhdXNlIGluc3RhbmNlb2YgX0Jhc2VFcnJvcilcXG4gICAgICAgICAgICAgIHJldHVybiBhcmdzLmNhdXNlLmRvY3NQYXRoIHx8IGFyZ3MuZG9jc1BhdGg7XFxuICAgICAgICAgICAgcmV0dXJuIGFyZ3MuZG9jc1BhdGg7XFxuICAgICAgICAgIH0pKCk7XFxuICAgICAgICAgIGNvbnN0IGRvY3NVcmwgPSBlcnJvckNvbmZpZy5nZXREb2NzVXJsPy4oeyAuLi5hcmdzLCBkb2NzUGF0aDogZG9jc1BhdGg4IH0pO1xcbiAgICAgICAgICBjb25zdCBtZXNzYWdlID0gW1xcbiAgICAgICAgICAgIHNob3J0TWVzc2FnZSB8fCBcIkFuIGVycm9yIG9jY3VycmVkLlwiLFxcbiAgICAgICAgICAgIFwiXCIsXFxuICAgICAgICAgICAgLi4uYXJncy5tZXRhTWVzc2FnZXMgPyBbLi4uYXJncy5tZXRhTWVzc2FnZXMsIFwiXCJdIDogW10sXFxuICAgICAgICAgICAgLi4uZG9jc1VybCA/IFtgRG9jczogJHtkb2NzVXJsfWBdIDogW10sXFxuICAgICAgICAgICAgLi4uZGV0YWlscyA/IFtgRGV0YWlsczogJHtkZXRhaWxzfWBdIDogW10sXFxuICAgICAgICAgICAgLi4uZXJyb3JDb25maWcudmVyc2lvbiA/IFtgVmVyc2lvbjogJHtlcnJvckNvbmZpZy52ZXJzaW9ufWBdIDogW11cXG4gICAgICAgICAgXS5qb2luKFwiXFxcXG5cIik7XFxuICAgICAgICAgIHN1cGVyKG1lc3NhZ2UsIGFyZ3MuY2F1c2UgPyB7IGNhdXNlOiBhcmdzLmNhdXNlIH0gOiB2b2lkIDApO1xcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZXRhaWxzXCIsIHtcXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkb2NzUGF0aFwiLCB7XFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWV0YU1lc3NhZ2VzXCIsIHtcXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaG9ydE1lc3NhZ2VcIiwge1xcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZlcnNpb25cIiwge1xcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHZhbHVlOiBcIkJhc2VFcnJvclwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xcbiAgICAgICAgICB0aGlzLmRvY3NQYXRoID0gZG9jc1BhdGg4O1xcbiAgICAgICAgICB0aGlzLm1ldGFNZXNzYWdlcyA9IGFyZ3MubWV0YU1lc3NhZ2VzO1xcbiAgICAgICAgICB0aGlzLm5hbWUgPSBhcmdzLm5hbWUgPz8gdGhpcy5uYW1lO1xcbiAgICAgICAgICB0aGlzLnNob3J0TWVzc2FnZSA9IHNob3J0TWVzc2FnZTtcXG4gICAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjI7XFxuICAgICAgICB9XFxuICAgICAgICB3YWxrKGZuKSB7XFxuICAgICAgICAgIHJldHVybiB3YWxrKHRoaXMsIGZuKTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2Vycm9ycy9hYmkuanNcXG4gIHZhciBBYmlDb25zdHJ1Y3Rvck5vdEZvdW5kRXJyb3IsIEFiaUNvbnN0cnVjdG9yUGFyYW1zTm90Rm91bmRFcnJvciwgQWJpRGVjb2RpbmdEYXRhU2l6ZVRvb1NtYWxsRXJyb3IsIEFiaURlY29kaW5nWmVyb0RhdGFFcnJvciwgQWJpRW5jb2RpbmdBcnJheUxlbmd0aE1pc21hdGNoRXJyb3IsIEFiaUVuY29kaW5nQnl0ZXNTaXplTWlzbWF0Y2hFcnJvciwgQWJpRW5jb2RpbmdMZW5ndGhNaXNtYXRjaEVycm9yLCBBYmlFcnJvcklucHV0c05vdEZvdW5kRXJyb3IsIEFiaUVycm9yTm90Rm91bmRFcnJvciwgQWJpRXJyb3JTaWduYXR1cmVOb3RGb3VuZEVycm9yLCBBYmlFdmVudFNpZ25hdHVyZUVtcHR5VG9waWNzRXJyb3IsIEFiaUV2ZW50U2lnbmF0dXJlTm90Rm91bmRFcnJvciwgQWJpRXZlbnROb3RGb3VuZEVycm9yLCBBYmlGdW5jdGlvbk5vdEZvdW5kRXJyb3IsIEFiaUZ1bmN0aW9uT3V0cHV0c05vdEZvdW5kRXJyb3IsIEFiaUZ1bmN0aW9uU2lnbmF0dXJlTm90Rm91bmRFcnJvciwgQWJpSXRlbUFtYmlndWl0eUVycm9yLCBCeXRlc1NpemVNaXNtYXRjaEVycm9yLCBEZWNvZGVMb2dEYXRhTWlzbWF0Y2gsIERlY29kZUxvZ1RvcGljc01pc21hdGNoLCBJbnZhbGlkQWJpRW5jb2RpbmdUeXBlRXJyb3IsIEludmFsaWRBYmlEZWNvZGluZ1R5cGVFcnJvciwgSW52YWxpZEFycmF5RXJyb3IsIEludmFsaWREZWZpbml0aW9uVHlwZUVycm9yO1xcbiAgdmFyIGluaXRfYWJpID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2Vycm9ycy9hYmkuanNcIigpIHtcXG4gICAgICBpbml0X2Zvcm1hdEFiaUl0ZW0yKCk7XFxuICAgICAgaW5pdF9zaXplKCk7XFxuICAgICAgaW5pdF9iYXNlKCk7XFxuICAgICAgQWJpQ29uc3RydWN0b3JOb3RGb3VuZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IyIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKHsgZG9jc1BhdGg6IGRvY3NQYXRoOCB9KSB7XFxuICAgICAgICAgIHN1cGVyKFtcXG4gICAgICAgICAgICBcIkEgY29uc3RydWN0b3Igd2FzIG5vdCBmb3VuZCBvbiB0aGUgQUJJLlwiLFxcbiAgICAgICAgICAgIFwiTWFrZSBzdXJlIHlvdSBhcmUgdXNpbmcgdGhlIGNvcnJlY3QgQUJJIGFuZCB0aGF0IHRoZSBjb25zdHJ1Y3RvciBleGlzdHMgb24gaXQuXCJcXG4gICAgICAgICAgXS5qb2luKFwiXFxcXG5cIiksIHtcXG4gICAgICAgICAgICBkb2NzUGF0aDogZG9jc1BhdGg4LFxcbiAgICAgICAgICAgIG5hbWU6IFwiQWJpQ29uc3RydWN0b3JOb3RGb3VuZEVycm9yXCJcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICBBYmlDb25zdHJ1Y3RvclBhcmFtc05vdEZvdW5kRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjIge1xcbiAgICAgICAgY29uc3RydWN0b3IoeyBkb2NzUGF0aDogZG9jc1BhdGg4IH0pIHtcXG4gICAgICAgICAgc3VwZXIoW1xcbiAgICAgICAgICAgIFwiQ29uc3RydWN0b3IgYXJndW1lbnRzIHdlcmUgcHJvdmlkZWQgKGBhcmdzYCksIGJ1dCBhIGNvbnN0cnVjdG9yIHBhcmFtZXRlcnMgKGBpbnB1dHNgKSB3ZXJlIG5vdCBmb3VuZCBvbiB0aGUgQUJJLlwiLFxcbiAgICAgICAgICAgIFwiTWFrZSBzdXJlIHlvdSBhcmUgdXNpbmcgdGhlIGNvcnJlY3QgQUJJLCBhbmQgdGhhdCB0aGUgYGlucHV0c2AgYXR0cmlidXRlIG9uIHRoZSBjb25zdHJ1Y3RvciBleGlzdHMuXCJcXG4gICAgICAgICAgXS5qb2luKFwiXFxcXG5cIiksIHtcXG4gICAgICAgICAgICBkb2NzUGF0aDogZG9jc1BhdGg4LFxcbiAgICAgICAgICAgIG5hbWU6IFwiQWJpQ29uc3RydWN0b3JQYXJhbXNOb3RGb3VuZEVycm9yXCJcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICBBYmlEZWNvZGluZ0RhdGFTaXplVG9vU21hbGxFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgICAgICBjb25zdHJ1Y3Rvcih7IGRhdGEsIHBhcmFtcywgc2l6ZTogc2l6ZTUgfSkge1xcbiAgICAgICAgICBzdXBlcihbYERhdGEgc2l6ZSBvZiAke3NpemU1fSBieXRlcyBpcyB0b28gc21hbGwgZm9yIGdpdmVuIHBhcmFtZXRlcnMuYF0uam9pbihcIlxcXFxuXCIpLCB7XFxuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXFxuICAgICAgICAgICAgICBgUGFyYW1zOiAoJHtmb3JtYXRBYmlQYXJhbXMocGFyYW1zLCB7IGluY2x1ZGVOYW1lOiB0cnVlIH0pfSlgLFxcbiAgICAgICAgICAgICAgYERhdGE6ICAgJHtkYXRhfSAoJHtzaXplNX0gYnl0ZXMpYFxcbiAgICAgICAgICAgIF0sXFxuICAgICAgICAgICAgbmFtZTogXCJBYmlEZWNvZGluZ0RhdGFTaXplVG9vU21hbGxFcnJvclwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkYXRhXCIsIHtcXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwYXJhbXNcIiwge1xcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNpemVcIiwge1xcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XFxuICAgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xcbiAgICAgICAgICB0aGlzLnNpemUgPSBzaXplNTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIEFiaURlY29kaW5nWmVyb0RhdGFFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcXG4gICAgICAgICAgc3VwZXIoXFwnQ2Fubm90IGRlY29kZSB6ZXJvIGRhdGEgKFwiMHhcIikgd2l0aCBBQkkgcGFyYW1ldGVycy5cXCcsIHtcXG4gICAgICAgICAgICBuYW1lOiBcIkFiaURlY29kaW5nWmVyb0RhdGFFcnJvclwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgQWJpRW5jb2RpbmdBcnJheUxlbmd0aE1pc21hdGNoRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjIge1xcbiAgICAgICAgY29uc3RydWN0b3IoeyBleHBlY3RlZExlbmd0aCwgZ2l2ZW5MZW5ndGgsIHR5cGUgfSkge1xcbiAgICAgICAgICBzdXBlcihbXFxuICAgICAgICAgICAgYEFCSSBlbmNvZGluZyBhcnJheSBsZW5ndGggbWlzbWF0Y2ggZm9yIHR5cGUgJHt0eXBlfS5gLFxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBsZW5ndGg6ICR7ZXhwZWN0ZWRMZW5ndGh9YCxcXG4gICAgICAgICAgICBgR2l2ZW4gbGVuZ3RoOiAke2dpdmVuTGVuZ3RofWBcXG4gICAgICAgICAgXS5qb2luKFwiXFxcXG5cIiksIHsgbmFtZTogXCJBYmlFbmNvZGluZ0FycmF5TGVuZ3RoTWlzbWF0Y2hFcnJvclwiIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgQWJpRW5jb2RpbmdCeXRlc1NpemVNaXNtYXRjaEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IyIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKHsgZXhwZWN0ZWRTaXplLCB2YWx1ZSB9KSB7XFxuICAgICAgICAgIHN1cGVyKGBTaXplIG9mIGJ5dGVzIFwiJHt2YWx1ZX1cIiAoYnl0ZXMke3NpemUodmFsdWUpfSkgZG9lcyBub3QgbWF0Y2ggZXhwZWN0ZWQgc2l6ZSAoYnl0ZXMke2V4cGVjdGVkU2l6ZX0pLmAsIHsgbmFtZTogXCJBYmlFbmNvZGluZ0J5dGVzU2l6ZU1pc21hdGNoRXJyb3JcIiB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIEFiaUVuY29kaW5nTGVuZ3RoTWlzbWF0Y2hFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgICAgICBjb25zdHJ1Y3Rvcih7IGV4cGVjdGVkTGVuZ3RoLCBnaXZlbkxlbmd0aCB9KSB7XFxuICAgICAgICAgIHN1cGVyKFtcXG4gICAgICAgICAgICBcIkFCSSBlbmNvZGluZyBwYXJhbXMvdmFsdWVzIGxlbmd0aCBtaXNtYXRjaC5cIixcXG4gICAgICAgICAgICBgRXhwZWN0ZWQgbGVuZ3RoIChwYXJhbXMpOiAke2V4cGVjdGVkTGVuZ3RofWAsXFxuICAgICAgICAgICAgYEdpdmVuIGxlbmd0aCAodmFsdWVzKTogJHtnaXZlbkxlbmd0aH1gXFxuICAgICAgICAgIF0uam9pbihcIlxcXFxuXCIpLCB7IG5hbWU6IFwiQWJpRW5jb2RpbmdMZW5ndGhNaXNtYXRjaEVycm9yXCIgfSk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICBBYmlFcnJvcklucHV0c05vdEZvdW5kRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjIge1xcbiAgICAgICAgY29uc3RydWN0b3IoZXJyb3JOYW1lLCB7IGRvY3NQYXRoOiBkb2NzUGF0aDggfSkge1xcbiAgICAgICAgICBzdXBlcihbXFxuICAgICAgICAgICAgYEFyZ3VtZW50cyAoXFxcXGBhcmdzXFxcXGApIHdlcmUgcHJvdmlkZWQgdG8gXCIke2Vycm9yTmFtZX1cIiwgYnV0IFwiJHtlcnJvck5hbWV9XCIgb24gdGhlIEFCSSBkb2VzIG5vdCBjb250YWluIGFueSBwYXJhbWV0ZXJzIChcXFxcYGlucHV0c1xcXFxgKS5gLFxcbiAgICAgICAgICAgIFwiQ2Fubm90IGVuY29kZSBlcnJvciByZXN1bHQgd2l0aG91dCBrbm93aW5nIHdoYXQgdGhlIHBhcmFtZXRlciB0eXBlcyBhcmUuXCIsXFxuICAgICAgICAgICAgXCJNYWtlIHN1cmUgeW91IGFyZSB1c2luZyB0aGUgY29ycmVjdCBBQkkgYW5kIHRoYXQgdGhlIGlucHV0cyBleGlzdCBvbiBpdC5cIlxcbiAgICAgICAgICBdLmpvaW4oXCJcXFxcblwiKSwge1xcbiAgICAgICAgICAgIGRvY3NQYXRoOiBkb2NzUGF0aDgsXFxuICAgICAgICAgICAgbmFtZTogXCJBYmlFcnJvcklucHV0c05vdEZvdW5kRXJyb3JcIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIEFiaUVycm9yTm90Rm91bmRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgICAgICBjb25zdHJ1Y3RvcihlcnJvck5hbWUsIHsgZG9jc1BhdGg6IGRvY3NQYXRoOCB9ID0ge30pIHtcXG4gICAgICAgICAgc3VwZXIoW1xcbiAgICAgICAgICAgIGBFcnJvciAke2Vycm9yTmFtZSA/IGBcIiR7ZXJyb3JOYW1lfVwiIGAgOiBcIlwifW5vdCBmb3VuZCBvbiBBQkkuYCxcXG4gICAgICAgICAgICBcIk1ha2Ugc3VyZSB5b3UgYXJlIHVzaW5nIHRoZSBjb3JyZWN0IEFCSSBhbmQgdGhhdCB0aGUgZXJyb3IgZXhpc3RzIG9uIGl0LlwiXFxuICAgICAgICAgIF0uam9pbihcIlxcXFxuXCIpLCB7XFxuICAgICAgICAgICAgZG9jc1BhdGg6IGRvY3NQYXRoOCxcXG4gICAgICAgICAgICBuYW1lOiBcIkFiaUVycm9yTm90Rm91bmRFcnJvclwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgQWJpRXJyb3JTaWduYXR1cmVOb3RGb3VuZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IyIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKHNpZ25hdHVyZSwgeyBkb2NzUGF0aDogZG9jc1BhdGg4IH0pIHtcXG4gICAgICAgICAgc3VwZXIoW1xcbiAgICAgICAgICAgIGBFbmNvZGVkIGVycm9yIHNpZ25hdHVyZSBcIiR7c2lnbmF0dXJlfVwiIG5vdCBmb3VuZCBvbiBBQkkuYCxcXG4gICAgICAgICAgICBcIk1ha2Ugc3VyZSB5b3UgYXJlIHVzaW5nIHRoZSBjb3JyZWN0IEFCSSBhbmQgdGhhdCB0aGUgZXJyb3IgZXhpc3RzIG9uIGl0LlwiLFxcbiAgICAgICAgICAgIGBZb3UgY2FuIGxvb2sgdXAgdGhlIGRlY29kZWQgc2lnbmF0dXJlIGhlcmU6IGh0dHBzOi8vb3BlbmNoYWluLnh5ei9zaWduYXR1cmVzP3F1ZXJ5PSR7c2lnbmF0dXJlfS5gXFxuICAgICAgICAgIF0uam9pbihcIlxcXFxuXCIpLCB7XFxuICAgICAgICAgICAgZG9jc1BhdGg6IGRvY3NQYXRoOCxcXG4gICAgICAgICAgICBuYW1lOiBcIkFiaUVycm9yU2lnbmF0dXJlTm90Rm91bmRFcnJvclwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaWduYXR1cmVcIiwge1xcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIHRoaXMuc2lnbmF0dXJlID0gc2lnbmF0dXJlO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgQWJpRXZlbnRTaWduYXR1cmVFbXB0eVRvcGljc0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IyIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKHsgZG9jc1BhdGg6IGRvY3NQYXRoOCB9KSB7XFxuICAgICAgICAgIHN1cGVyKFwiQ2Fubm90IGV4dHJhY3QgZXZlbnQgc2lnbmF0dXJlIGZyb20gZW1wdHkgdG9waWNzLlwiLCB7XFxuICAgICAgICAgICAgZG9jc1BhdGg6IGRvY3NQYXRoOCxcXG4gICAgICAgICAgICBuYW1lOiBcIkFiaUV2ZW50U2lnbmF0dXJlRW1wdHlUb3BpY3NFcnJvclwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgQWJpRXZlbnRTaWduYXR1cmVOb3RGb3VuZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IyIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKHNpZ25hdHVyZSwgeyBkb2NzUGF0aDogZG9jc1BhdGg4IH0pIHtcXG4gICAgICAgICAgc3VwZXIoW1xcbiAgICAgICAgICAgIGBFbmNvZGVkIGV2ZW50IHNpZ25hdHVyZSBcIiR7c2lnbmF0dXJlfVwiIG5vdCBmb3VuZCBvbiBBQkkuYCxcXG4gICAgICAgICAgICBcIk1ha2Ugc3VyZSB5b3UgYXJlIHVzaW5nIHRoZSBjb3JyZWN0IEFCSSBhbmQgdGhhdCB0aGUgZXZlbnQgZXhpc3RzIG9uIGl0LlwiLFxcbiAgICAgICAgICAgIGBZb3UgY2FuIGxvb2sgdXAgdGhlIHNpZ25hdHVyZSBoZXJlOiBodHRwczovL29wZW5jaGFpbi54eXovc2lnbmF0dXJlcz9xdWVyeT0ke3NpZ25hdHVyZX0uYFxcbiAgICAgICAgICBdLmpvaW4oXCJcXFxcblwiKSwge1xcbiAgICAgICAgICAgIGRvY3NQYXRoOiBkb2NzUGF0aDgsXFxuICAgICAgICAgICAgbmFtZTogXCJBYmlFdmVudFNpZ25hdHVyZU5vdEZvdW5kRXJyb3JcIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIEFiaUV2ZW50Tm90Rm91bmRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgICAgICBjb25zdHJ1Y3RvcihldmVudE5hbWUsIHsgZG9jc1BhdGg6IGRvY3NQYXRoOCB9ID0ge30pIHtcXG4gICAgICAgICAgc3VwZXIoW1xcbiAgICAgICAgICAgIGBFdmVudCAke2V2ZW50TmFtZSA/IGBcIiR7ZXZlbnROYW1lfVwiIGAgOiBcIlwifW5vdCBmb3VuZCBvbiBBQkkuYCxcXG4gICAgICAgICAgICBcIk1ha2Ugc3VyZSB5b3UgYXJlIHVzaW5nIHRoZSBjb3JyZWN0IEFCSSBhbmQgdGhhdCB0aGUgZXZlbnQgZXhpc3RzIG9uIGl0LlwiXFxuICAgICAgICAgIF0uam9pbihcIlxcXFxuXCIpLCB7XFxuICAgICAgICAgICAgZG9jc1BhdGg6IGRvY3NQYXRoOCxcXG4gICAgICAgICAgICBuYW1lOiBcIkFiaUV2ZW50Tm90Rm91bmRFcnJvclwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgQWJpRnVuY3Rpb25Ob3RGb3VuZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IyIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKGZ1bmN0aW9uTmFtZSwgeyBkb2NzUGF0aDogZG9jc1BhdGg4IH0gPSB7fSkge1xcbiAgICAgICAgICBzdXBlcihbXFxuICAgICAgICAgICAgYEZ1bmN0aW9uICR7ZnVuY3Rpb25OYW1lID8gYFwiJHtmdW5jdGlvbk5hbWV9XCIgYCA6IFwiXCJ9bm90IGZvdW5kIG9uIEFCSS5gLFxcbiAgICAgICAgICAgIFwiTWFrZSBzdXJlIHlvdSBhcmUgdXNpbmcgdGhlIGNvcnJlY3QgQUJJIGFuZCB0aGF0IHRoZSBmdW5jdGlvbiBleGlzdHMgb24gaXQuXCJcXG4gICAgICAgICAgXS5qb2luKFwiXFxcXG5cIiksIHtcXG4gICAgICAgICAgICBkb2NzUGF0aDogZG9jc1BhdGg4LFxcbiAgICAgICAgICAgIG5hbWU6IFwiQWJpRnVuY3Rpb25Ob3RGb3VuZEVycm9yXCJcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICBBYmlGdW5jdGlvbk91dHB1dHNOb3RGb3VuZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IyIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKGZ1bmN0aW9uTmFtZSwgeyBkb2NzUGF0aDogZG9jc1BhdGg4IH0pIHtcXG4gICAgICAgICAgc3VwZXIoW1xcbiAgICAgICAgICAgIGBGdW5jdGlvbiBcIiR7ZnVuY3Rpb25OYW1lfVwiIGRvZXMgbm90IGNvbnRhaW4gYW55IFxcXFxgb3V0cHV0c1xcXFxgIG9uIEFCSS5gLFxcbiAgICAgICAgICAgIFwiQ2Fubm90IGRlY29kZSBmdW5jdGlvbiByZXN1bHQgd2l0aG91dCBrbm93aW5nIHdoYXQgdGhlIHBhcmFtZXRlciB0eXBlcyBhcmUuXCIsXFxuICAgICAgICAgICAgXCJNYWtlIHN1cmUgeW91IGFyZSB1c2luZyB0aGUgY29ycmVjdCBBQkkgYW5kIHRoYXQgdGhlIGZ1bmN0aW9uIGV4aXN0cyBvbiBpdC5cIlxcbiAgICAgICAgICBdLmpvaW4oXCJcXFxcblwiKSwge1xcbiAgICAgICAgICAgIGRvY3NQYXRoOiBkb2NzUGF0aDgsXFxuICAgICAgICAgICAgbmFtZTogXCJBYmlGdW5jdGlvbk91dHB1dHNOb3RGb3VuZEVycm9yXCJcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICBBYmlGdW5jdGlvblNpZ25hdHVyZU5vdEZvdW5kRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjIge1xcbiAgICAgICAgY29uc3RydWN0b3Ioc2lnbmF0dXJlLCB7IGRvY3NQYXRoOiBkb2NzUGF0aDggfSkge1xcbiAgICAgICAgICBzdXBlcihbXFxuICAgICAgICAgICAgYEVuY29kZWQgZnVuY3Rpb24gc2lnbmF0dXJlIFwiJHtzaWduYXR1cmV9XCIgbm90IGZvdW5kIG9uIEFCSS5gLFxcbiAgICAgICAgICAgIFwiTWFrZSBzdXJlIHlvdSBhcmUgdXNpbmcgdGhlIGNvcnJlY3QgQUJJIGFuZCB0aGF0IHRoZSBmdW5jdGlvbiBleGlzdHMgb24gaXQuXCIsXFxuICAgICAgICAgICAgYFlvdSBjYW4gbG9vayB1cCB0aGUgc2lnbmF0dXJlIGhlcmU6IGh0dHBzOi8vb3BlbmNoYWluLnh5ei9zaWduYXR1cmVzP3F1ZXJ5PSR7c2lnbmF0dXJlfS5gXFxuICAgICAgICAgIF0uam9pbihcIlxcXFxuXCIpLCB7XFxuICAgICAgICAgICAgZG9jc1BhdGg6IGRvY3NQYXRoOCxcXG4gICAgICAgICAgICBuYW1lOiBcIkFiaUZ1bmN0aW9uU2lnbmF0dXJlTm90Rm91bmRFcnJvclwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgQWJpSXRlbUFtYmlndWl0eUVycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IyIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKHgsIHkpIHtcXG4gICAgICAgICAgc3VwZXIoXCJGb3VuZCBhbWJpZ3VvdXMgdHlwZXMgaW4gb3ZlcmxvYWRlZCBBQkkgaXRlbXMuXCIsIHtcXG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcXG4gICAgICAgICAgICAgIGBcXFxcYCR7eC50eXBlfVxcXFxgIGluIFxcXFxgJHtmb3JtYXRBYmlJdGVtMih4LmFiaUl0ZW0pfVxcXFxgLCBhbmRgLFxcbiAgICAgICAgICAgICAgYFxcXFxgJHt5LnR5cGV9XFxcXGAgaW4gXFxcXGAke2Zvcm1hdEFiaUl0ZW0yKHkuYWJpSXRlbSl9XFxcXGBgLFxcbiAgICAgICAgICAgICAgXCJcIixcXG4gICAgICAgICAgICAgIFwiVGhlc2UgdHlwZXMgZW5jb2RlIGRpZmZlcmVudGx5IGFuZCBjYW5ub3QgYmUgZGlzdGluZ3Vpc2hlZCBhdCBydW50aW1lLlwiLFxcbiAgICAgICAgICAgICAgXCJSZW1vdmUgb25lIG9mIHRoZSBhbWJpZ3VvdXMgaXRlbXMgaW4gdGhlIEFCSS5cIlxcbiAgICAgICAgICAgIF0sXFxuICAgICAgICAgICAgbmFtZTogXCJBYmlJdGVtQW1iaWd1aXR5RXJyb3JcIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIEJ5dGVzU2l6ZU1pc21hdGNoRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjIge1xcbiAgICAgICAgY29uc3RydWN0b3IoeyBleHBlY3RlZFNpemUsIGdpdmVuU2l6ZSB9KSB7XFxuICAgICAgICAgIHN1cGVyKGBFeHBlY3RlZCBieXRlcyR7ZXhwZWN0ZWRTaXplfSwgZ290IGJ5dGVzJHtnaXZlblNpemV9LmAsIHtcXG4gICAgICAgICAgICBuYW1lOiBcIkJ5dGVzU2l6ZU1pc21hdGNoRXJyb3JcIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIERlY29kZUxvZ0RhdGFNaXNtYXRjaCA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgICAgICBjb25zdHJ1Y3Rvcih7IGFiaUl0ZW0sIGRhdGEsIHBhcmFtcywgc2l6ZTogc2l6ZTUgfSkge1xcbiAgICAgICAgICBzdXBlcihbXFxuICAgICAgICAgICAgYERhdGEgc2l6ZSBvZiAke3NpemU1fSBieXRlcyBpcyB0b28gc21hbGwgZm9yIG5vbi1pbmRleGVkIGV2ZW50IHBhcmFtZXRlcnMuYFxcbiAgICAgICAgICBdLmpvaW4oXCJcXFxcblwiKSwge1xcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xcbiAgICAgICAgICAgICAgYFBhcmFtczogKCR7Zm9ybWF0QWJpUGFyYW1zKHBhcmFtcywgeyBpbmNsdWRlTmFtZTogdHJ1ZSB9KX0pYCxcXG4gICAgICAgICAgICAgIGBEYXRhOiAgICR7ZGF0YX0gKCR7c2l6ZTV9IGJ5dGVzKWBcXG4gICAgICAgICAgICBdLFxcbiAgICAgICAgICAgIG5hbWU6IFwiRGVjb2RlTG9nRGF0YU1pc21hdGNoXCJcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFiaUl0ZW1cIiwge1xcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRhdGFcIiwge1xcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBhcmFtc1wiLCB7XFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2l6ZVwiLCB7XFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgdGhpcy5hYmlJdGVtID0gYWJpSXRlbTtcXG4gICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcXG4gICAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XFxuICAgICAgICAgIHRoaXMuc2l6ZSA9IHNpemU1O1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgRGVjb2RlTG9nVG9waWNzTWlzbWF0Y2ggPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjIge1xcbiAgICAgICAgY29uc3RydWN0b3IoeyBhYmlJdGVtLCBwYXJhbSB9KSB7XFxuICAgICAgICAgIHN1cGVyKFtcXG4gICAgICAgICAgICBgRXhwZWN0ZWQgYSB0b3BpYyBmb3IgaW5kZXhlZCBldmVudCBwYXJhbWV0ZXIke3BhcmFtLm5hbWUgPyBgIFwiJHtwYXJhbS5uYW1lfVwiYCA6IFwiXCJ9IG9uIGV2ZW50IFwiJHtmb3JtYXRBYmlJdGVtMihhYmlJdGVtLCB7IGluY2x1ZGVOYW1lOiB0cnVlIH0pfVwiLmBcXG4gICAgICAgICAgXS5qb2luKFwiXFxcXG5cIiksIHsgbmFtZTogXCJEZWNvZGVMb2dUb3BpY3NNaXNtYXRjaFwiIH0pO1xcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhYmlJdGVtXCIsIHtcXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICB0aGlzLmFiaUl0ZW0gPSBhYmlJdGVtO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgSW52YWxpZEFiaUVuY29kaW5nVHlwZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IyIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKHR5cGUsIHsgZG9jc1BhdGg6IGRvY3NQYXRoOCB9KSB7XFxuICAgICAgICAgIHN1cGVyKFtcXG4gICAgICAgICAgICBgVHlwZSBcIiR7dHlwZX1cIiBpcyBub3QgYSB2YWxpZCBlbmNvZGluZyB0eXBlLmAsXFxuICAgICAgICAgICAgXCJQbGVhc2UgcHJvdmlkZSBhIHZhbGlkIEFCSSB0eXBlLlwiXFxuICAgICAgICAgIF0uam9pbihcIlxcXFxuXCIpLCB7IGRvY3NQYXRoOiBkb2NzUGF0aDgsIG5hbWU6IFwiSW52YWxpZEFiaUVuY29kaW5nVHlwZVwiIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgSW52YWxpZEFiaURlY29kaW5nVHlwZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IyIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKHR5cGUsIHsgZG9jc1BhdGg6IGRvY3NQYXRoOCB9KSB7XFxuICAgICAgICAgIHN1cGVyKFtcXG4gICAgICAgICAgICBgVHlwZSBcIiR7dHlwZX1cIiBpcyBub3QgYSB2YWxpZCBkZWNvZGluZyB0eXBlLmAsXFxuICAgICAgICAgICAgXCJQbGVhc2UgcHJvdmlkZSBhIHZhbGlkIEFCSSB0eXBlLlwiXFxuICAgICAgICAgIF0uam9pbihcIlxcXFxuXCIpLCB7IGRvY3NQYXRoOiBkb2NzUGF0aDgsIG5hbWU6IFwiSW52YWxpZEFiaURlY29kaW5nVHlwZVwiIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgSW52YWxpZEFycmF5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjIge1xcbiAgICAgICAgY29uc3RydWN0b3IodmFsdWUpIHtcXG4gICAgICAgICAgc3VwZXIoW2BWYWx1ZSBcIiR7dmFsdWV9XCIgaXMgbm90IGEgdmFsaWQgYXJyYXkuYF0uam9pbihcIlxcXFxuXCIpLCB7XFxuICAgICAgICAgICAgbmFtZTogXCJJbnZhbGlkQXJyYXlFcnJvclwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgSW52YWxpZERlZmluaXRpb25UeXBlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjIge1xcbiAgICAgICAgY29uc3RydWN0b3IodHlwZSkge1xcbiAgICAgICAgICBzdXBlcihbXFxuICAgICAgICAgICAgYFwiJHt0eXBlfVwiIGlzIG5vdCBhIHZhbGlkIGRlZmluaXRpb24gdHlwZS5gLFxcbiAgICAgICAgICAgIFxcJ1ZhbGlkIHR5cGVzOiBcImZ1bmN0aW9uXCIsIFwiZXZlbnRcIiwgXCJlcnJvclwiXFwnXFxuICAgICAgICAgIF0uam9pbihcIlxcXFxuXCIpLCB7IG5hbWU6IFwiSW52YWxpZERlZmluaXRpb25UeXBlRXJyb3JcIiB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2Vycm9ycy9kYXRhLmpzXFxuICB2YXIgU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yLCBTaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3IsIEludmFsaWRCeXRlc0xlbmd0aEVycm9yO1xcbiAgdmFyIGluaXRfZGF0YSA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9lcnJvcnMvZGF0YS5qc1wiKCkge1xcbiAgICAgIGluaXRfYmFzZSgpO1xcbiAgICAgIFNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgICAgICBjb25zdHJ1Y3Rvcih7IG9mZnNldCwgcG9zaXRpb24sIHNpemU6IHNpemU1IH0pIHtcXG4gICAgICAgICAgc3VwZXIoYFNsaWNlICR7cG9zaXRpb24gPT09IFwic3RhcnRcIiA/IFwic3RhcnRpbmdcIiA6IFwiZW5kaW5nXCJ9IGF0IG9mZnNldCBcIiR7b2Zmc2V0fVwiIGlzIG91dC1vZi1ib3VuZHMgKHNpemU6ICR7c2l6ZTV9KS5gLCB7IG5hbWU6IFwiU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yXCIgfSk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICBTaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjIge1xcbiAgICAgICAgY29uc3RydWN0b3IoeyBzaXplOiBzaXplNSwgdGFyZ2V0U2l6ZSwgdHlwZSB9KSB7XFxuICAgICAgICAgIHN1cGVyKGAke3R5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCl9JHt0eXBlLnNsaWNlKDEpLnRvTG93ZXJDYXNlKCl9IHNpemUgKCR7c2l6ZTV9KSBleGNlZWRzIHBhZGRpbmcgc2l6ZSAoJHt0YXJnZXRTaXplfSkuYCwgeyBuYW1lOiBcIlNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvclwiIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgSW52YWxpZEJ5dGVzTGVuZ3RoRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjIge1xcbiAgICAgICAgY29uc3RydWN0b3IoeyBzaXplOiBzaXplNSwgdGFyZ2V0U2l6ZSwgdHlwZSB9KSB7XFxuICAgICAgICAgIHN1cGVyKGAke3R5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCl9JHt0eXBlLnNsaWNlKDEpLnRvTG93ZXJDYXNlKCl9IGlzIGV4cGVjdGVkIHRvIGJlICR7dGFyZ2V0U2l6ZX0gJHt0eXBlfSBsb25nLCBidXQgaXMgJHtzaXplNX0gJHt0eXBlfSBsb25nLmAsIHsgbmFtZTogXCJJbnZhbGlkQnl0ZXNMZW5ndGhFcnJvclwiIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvZGF0YS9wYWQuanNcXG4gIGZ1bmN0aW9uIHBhZChoZXhPckJ5dGVzLCB7IGRpciwgc2l6ZTogc2l6ZTUgPSAzMiB9ID0ge30pIHtcXG4gICAgaWYgKHR5cGVvZiBoZXhPckJ5dGVzID09PSBcInN0cmluZ1wiKVxcbiAgICAgIHJldHVybiBwYWRIZXgoaGV4T3JCeXRlcywgeyBkaXIsIHNpemU6IHNpemU1IH0pO1xcbiAgICByZXR1cm4gcGFkQnl0ZXMoaGV4T3JCeXRlcywgeyBkaXIsIHNpemU6IHNpemU1IH0pO1xcbiAgfVxcbiAgZnVuY3Rpb24gcGFkSGV4KGhleF8sIHsgZGlyLCBzaXplOiBzaXplNSA9IDMyIH0gPSB7fSkge1xcbiAgICBpZiAoc2l6ZTUgPT09IG51bGwpXFxuICAgICAgcmV0dXJuIGhleF87XFxuICAgIGNvbnN0IGhleCA9IGhleF8ucmVwbGFjZShcIjB4XCIsIFwiXCIpO1xcbiAgICBpZiAoaGV4Lmxlbmd0aCA+IHNpemU1ICogMilcXG4gICAgICB0aHJvdyBuZXcgU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yKHtcXG4gICAgICAgIHNpemU6IE1hdGguY2VpbChoZXgubGVuZ3RoIC8gMiksXFxuICAgICAgICB0YXJnZXRTaXplOiBzaXplNSxcXG4gICAgICAgIHR5cGU6IFwiaGV4XCJcXG4gICAgICB9KTtcXG4gICAgcmV0dXJuIGAweCR7aGV4W2RpciA9PT0gXCJyaWdodFwiID8gXCJwYWRFbmRcIiA6IFwicGFkU3RhcnRcIl0oc2l6ZTUgKiAyLCBcIjBcIil9YDtcXG4gIH1cXG4gIGZ1bmN0aW9uIHBhZEJ5dGVzKGJ5dGVzLCB7IGRpciwgc2l6ZTogc2l6ZTUgPSAzMiB9ID0ge30pIHtcXG4gICAgaWYgKHNpemU1ID09PSBudWxsKVxcbiAgICAgIHJldHVybiBieXRlcztcXG4gICAgaWYgKGJ5dGVzLmxlbmd0aCA+IHNpemU1KVxcbiAgICAgIHRocm93IG5ldyBTaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3Ioe1xcbiAgICAgICAgc2l6ZTogYnl0ZXMubGVuZ3RoLFxcbiAgICAgICAgdGFyZ2V0U2l6ZTogc2l6ZTUsXFxuICAgICAgICB0eXBlOiBcImJ5dGVzXCJcXG4gICAgICB9KTtcXG4gICAgY29uc3QgcGFkZGVkQnl0ZXMgPSBuZXcgVWludDhBcnJheShzaXplNSk7XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTU7IGkrKykge1xcbiAgICAgIGNvbnN0IHBhZEVuZCA9IGRpciA9PT0gXCJyaWdodFwiO1xcbiAgICAgIHBhZGRlZEJ5dGVzW3BhZEVuZCA/IGkgOiBzaXplNSAtIGkgLSAxXSA9IGJ5dGVzW3BhZEVuZCA/IGkgOiBieXRlcy5sZW5ndGggLSBpIC0gMV07XFxuICAgIH1cXG4gICAgcmV0dXJuIHBhZGRlZEJ5dGVzO1xcbiAgfVxcbiAgdmFyIGluaXRfcGFkID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2RhdGEvcGFkLmpzXCIoKSB7XFxuICAgICAgaW5pdF9kYXRhKCk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vZXJyb3JzL2VuY29kaW5nLmpzXFxuICB2YXIgSW50ZWdlck91dE9mUmFuZ2VFcnJvciwgSW52YWxpZEJ5dGVzQm9vbGVhbkVycm9yLCBJbnZhbGlkSGV4Qm9vbGVhbkVycm9yLCBTaXplT3ZlcmZsb3dFcnJvcjtcXG4gIHZhciBpbml0X2VuY29kaW5nID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2Vycm9ycy9lbmNvZGluZy5qc1wiKCkge1xcbiAgICAgIGluaXRfYmFzZSgpO1xcbiAgICAgIEludGVnZXJPdXRPZlJhbmdlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjIge1xcbiAgICAgICAgY29uc3RydWN0b3IoeyBtYXgsIG1pbiwgc2lnbmVkLCBzaXplOiBzaXplNSwgdmFsdWUgfSkge1xcbiAgICAgICAgICBzdXBlcihgTnVtYmVyIFwiJHt2YWx1ZX1cIiBpcyBub3QgaW4gc2FmZSAke3NpemU1ID8gYCR7c2l6ZTUgKiA4fS1iaXQgJHtzaWduZWQgPyBcInNpZ25lZFwiIDogXCJ1bnNpZ25lZFwifSBgIDogXCJcIn1pbnRlZ2VyIHJhbmdlICR7bWF4ID8gYCgke21pbn0gdG8gJHttYXh9KWAgOiBgKGFib3ZlICR7bWlufSlgfWAsIHsgbmFtZTogXCJJbnRlZ2VyT3V0T2ZSYW5nZUVycm9yXCIgfSk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICBJbnZhbGlkQnl0ZXNCb29sZWFuRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjIge1xcbiAgICAgICAgY29uc3RydWN0b3IoYnl0ZXMpIHtcXG4gICAgICAgICAgc3VwZXIoYEJ5dGVzIHZhbHVlIFwiJHtieXRlc31cIiBpcyBub3QgYSB2YWxpZCBib29sZWFuLiBUaGUgYnl0ZXMgYXJyYXkgbXVzdCBjb250YWluIGEgc2luZ2xlIGJ5dGUgb2YgZWl0aGVyIGEgMCBvciAxIHZhbHVlLmAsIHtcXG4gICAgICAgICAgICBuYW1lOiBcIkludmFsaWRCeXRlc0Jvb2xlYW5FcnJvclwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgSW52YWxpZEhleEJvb2xlYW5FcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgICAgICBjb25zdHJ1Y3RvcihoZXgpIHtcXG4gICAgICAgICAgc3VwZXIoYEhleCB2YWx1ZSBcIiR7aGV4fVwiIGlzIG5vdCBhIHZhbGlkIGJvb2xlYW4uIFRoZSBoZXggdmFsdWUgbXVzdCBiZSBcIjB4MFwiIChmYWxzZSkgb3IgXCIweDFcIiAodHJ1ZSkuYCwgeyBuYW1lOiBcIkludmFsaWRIZXhCb29sZWFuRXJyb3JcIiB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIFNpemVPdmVyZmxvd0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IyIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKHsgZ2l2ZW5TaXplLCBtYXhTaXplIH0pIHtcXG4gICAgICAgICAgc3VwZXIoYFNpemUgY2Fubm90IGV4Y2VlZCAke21heFNpemV9IGJ5dGVzLiBHaXZlbiBzaXplOiAke2dpdmVuU2l6ZX0gYnl0ZXMuYCwgeyBuYW1lOiBcIlNpemVPdmVyZmxvd0Vycm9yXCIgfSk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9kYXRhL3RyaW0uanNcXG4gIGZ1bmN0aW9uIHRyaW0oaGV4T3JCeXRlcywgeyBkaXIgPSBcImxlZnRcIiB9ID0ge30pIHtcXG4gICAgbGV0IGRhdGEgPSB0eXBlb2YgaGV4T3JCeXRlcyA9PT0gXCJzdHJpbmdcIiA/IGhleE9yQnl0ZXMucmVwbGFjZShcIjB4XCIsIFwiXCIpIDogaGV4T3JCeXRlcztcXG4gICAgbGV0IHNsaWNlTGVuZ3RoID0gMDtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAtIDE7IGkrKykge1xcbiAgICAgIGlmIChkYXRhW2RpciA9PT0gXCJsZWZ0XCIgPyBpIDogZGF0YS5sZW5ndGggLSBpIC0gMV0udG9TdHJpbmcoKSA9PT0gXCIwXCIpXFxuICAgICAgICBzbGljZUxlbmd0aCsrO1xcbiAgICAgIGVsc2VcXG4gICAgICAgIGJyZWFrO1xcbiAgICB9XFxuICAgIGRhdGEgPSBkaXIgPT09IFwibGVmdFwiID8gZGF0YS5zbGljZShzbGljZUxlbmd0aCkgOiBkYXRhLnNsaWNlKDAsIGRhdGEubGVuZ3RoIC0gc2xpY2VMZW5ndGgpO1xcbiAgICBpZiAodHlwZW9mIGhleE9yQnl0ZXMgPT09IFwic3RyaW5nXCIpIHtcXG4gICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDEgJiYgZGlyID09PSBcInJpZ2h0XCIpXFxuICAgICAgICBkYXRhID0gYCR7ZGF0YX0wYDtcXG4gICAgICByZXR1cm4gYDB4JHtkYXRhLmxlbmd0aCAlIDIgPT09IDEgPyBgMCR7ZGF0YX1gIDogZGF0YX1gO1xcbiAgICB9XFxuICAgIHJldHVybiBkYXRhO1xcbiAgfVxcbiAgdmFyIGluaXRfdHJpbSA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9kYXRhL3RyaW0uanNcIigpIHtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9lbmNvZGluZy9mcm9tSGV4LmpzXFxuICBmdW5jdGlvbiBhc3NlcnRTaXplKGhleE9yQnl0ZXMsIHsgc2l6ZTogc2l6ZTUgfSkge1xcbiAgICBpZiAoc2l6ZShoZXhPckJ5dGVzKSA+IHNpemU1KVxcbiAgICAgIHRocm93IG5ldyBTaXplT3ZlcmZsb3dFcnJvcih7XFxuICAgICAgICBnaXZlblNpemU6IHNpemUoaGV4T3JCeXRlcyksXFxuICAgICAgICBtYXhTaXplOiBzaXplNVxcbiAgICAgIH0pO1xcbiAgfVxcbiAgZnVuY3Rpb24gaGV4VG9CaWdJbnQoaGV4LCBvcHRzID0ge30pIHtcXG4gICAgY29uc3QgeyBzaWduZWQgfSA9IG9wdHM7XFxuICAgIGlmIChvcHRzLnNpemUpXFxuICAgICAgYXNzZXJ0U2l6ZShoZXgsIHsgc2l6ZTogb3B0cy5zaXplIH0pO1xcbiAgICBjb25zdCB2YWx1ZSA9IEJpZ0ludChoZXgpO1xcbiAgICBpZiAoIXNpZ25lZClcXG4gICAgICByZXR1cm4gdmFsdWU7XFxuICAgIGNvbnN0IHNpemU1ID0gKGhleC5sZW5ndGggLSAyKSAvIDI7XFxuICAgIGNvbnN0IG1heCA9ICgxbiA8PCBCaWdJbnQoc2l6ZTUpICogOG4gLSAxbikgLSAxbjtcXG4gICAgaWYgKHZhbHVlIDw9IG1heClcXG4gICAgICByZXR1cm4gdmFsdWU7XFxuICAgIHJldHVybiB2YWx1ZSAtIEJpZ0ludChgMHgke1wiZlwiLnBhZFN0YXJ0KHNpemU1ICogMiwgXCJmXCIpfWApIC0gMW47XFxuICB9XFxuICBmdW5jdGlvbiBoZXhUb0Jvb2woaGV4Xywgb3B0cyA9IHt9KSB7XFxuICAgIGxldCBoZXggPSBoZXhfO1xcbiAgICBpZiAob3B0cy5zaXplKSB7XFxuICAgICAgYXNzZXJ0U2l6ZShoZXgsIHsgc2l6ZTogb3B0cy5zaXplIH0pO1xcbiAgICAgIGhleCA9IHRyaW0oaGV4KTtcXG4gICAgfVxcbiAgICBpZiAodHJpbShoZXgpID09PSBcIjB4MDBcIilcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIGlmICh0cmltKGhleCkgPT09IFwiMHgwMVwiKVxcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB0aHJvdyBuZXcgSW52YWxpZEhleEJvb2xlYW5FcnJvcihoZXgpO1xcbiAgfVxcbiAgZnVuY3Rpb24gaGV4VG9OdW1iZXIoaGV4LCBvcHRzID0ge30pIHtcXG4gICAgcmV0dXJuIE51bWJlcihoZXhUb0JpZ0ludChoZXgsIG9wdHMpKTtcXG4gIH1cXG4gIHZhciBpbml0X2Zyb21IZXggPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvZW5jb2RpbmcvZnJvbUhleC5qc1wiKCkge1xcbiAgICAgIGluaXRfZW5jb2RpbmcoKTtcXG4gICAgICBpbml0X3NpemUoKTtcXG4gICAgICBpbml0X3RyaW0oKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9lbmNvZGluZy90b0hleC5qc1xcbiAgZnVuY3Rpb24gdG9IZXgodmFsdWUsIG9wdHMgPSB7fSkge1xcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIilcXG4gICAgICByZXR1cm4gbnVtYmVyVG9IZXgodmFsdWUsIG9wdHMpO1xcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XFxuICAgICAgcmV0dXJuIHN0cmluZ1RvSGV4KHZhbHVlLCBvcHRzKTtcXG4gICAgfVxcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIilcXG4gICAgICByZXR1cm4gYm9vbFRvSGV4KHZhbHVlLCBvcHRzKTtcXG4gICAgcmV0dXJuIGJ5dGVzVG9IZXgodmFsdWUsIG9wdHMpO1xcbiAgfVxcbiAgZnVuY3Rpb24gYm9vbFRvSGV4KHZhbHVlLCBvcHRzID0ge30pIHtcXG4gICAgY29uc3QgaGV4ID0gYDB4JHtOdW1iZXIodmFsdWUpfWA7XFxuICAgIGlmICh0eXBlb2Ygb3B0cy5zaXplID09PSBcIm51bWJlclwiKSB7XFxuICAgICAgYXNzZXJ0U2l6ZShoZXgsIHsgc2l6ZTogb3B0cy5zaXplIH0pO1xcbiAgICAgIHJldHVybiBwYWQoaGV4LCB7IHNpemU6IG9wdHMuc2l6ZSB9KTtcXG4gICAgfVxcbiAgICByZXR1cm4gaGV4O1xcbiAgfVxcbiAgZnVuY3Rpb24gYnl0ZXNUb0hleCh2YWx1ZSwgb3B0cyA9IHt9KSB7XFxuICAgIGxldCBzdHJpbmcgPSBcIlwiO1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgc3RyaW5nICs9IGhleGVzW3ZhbHVlW2ldXTtcXG4gICAgfVxcbiAgICBjb25zdCBoZXggPSBgMHgke3N0cmluZ31gO1xcbiAgICBpZiAodHlwZW9mIG9wdHMuc2l6ZSA9PT0gXCJudW1iZXJcIikge1xcbiAgICAgIGFzc2VydFNpemUoaGV4LCB7IHNpemU6IG9wdHMuc2l6ZSB9KTtcXG4gICAgICByZXR1cm4gcGFkKGhleCwgeyBkaXI6IFwicmlnaHRcIiwgc2l6ZTogb3B0cy5zaXplIH0pO1xcbiAgICB9XFxuICAgIHJldHVybiBoZXg7XFxuICB9XFxuICBmdW5jdGlvbiBudW1iZXJUb0hleCh2YWx1ZV8sIG9wdHMgPSB7fSkge1xcbiAgICBjb25zdCB7IHNpZ25lZCwgc2l6ZTogc2l6ZTUgfSA9IG9wdHM7XFxuICAgIGNvbnN0IHZhbHVlID0gQmlnSW50KHZhbHVlXyk7XFxuICAgIGxldCBtYXhWYWx1ZTtcXG4gICAgaWYgKHNpemU1KSB7XFxuICAgICAgaWYgKHNpZ25lZClcXG4gICAgICAgIG1heFZhbHVlID0gKDFuIDw8IEJpZ0ludChzaXplNSkgKiA4biAtIDFuKSAtIDFuO1xcbiAgICAgIGVsc2VcXG4gICAgICAgIG1heFZhbHVlID0gMm4gKiogKEJpZ0ludChzaXplNSkgKiA4bikgLSAxbjtcXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWVfID09PSBcIm51bWJlclwiKSB7XFxuICAgICAgbWF4VmFsdWUgPSBCaWdJbnQoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO1xcbiAgICB9XFxuICAgIGNvbnN0IG1pblZhbHVlID0gdHlwZW9mIG1heFZhbHVlID09PSBcImJpZ2ludFwiICYmIHNpZ25lZCA/IC1tYXhWYWx1ZSAtIDFuIDogMDtcXG4gICAgaWYgKG1heFZhbHVlICYmIHZhbHVlID4gbWF4VmFsdWUgfHwgdmFsdWUgPCBtaW5WYWx1ZSkge1xcbiAgICAgIGNvbnN0IHN1ZmZpeCA9IHR5cGVvZiB2YWx1ZV8gPT09IFwiYmlnaW50XCIgPyBcIm5cIiA6IFwiXCI7XFxuICAgICAgdGhyb3cgbmV3IEludGVnZXJPdXRPZlJhbmdlRXJyb3Ioe1xcbiAgICAgICAgbWF4OiBtYXhWYWx1ZSA/IGAke21heFZhbHVlfSR7c3VmZml4fWAgOiB2b2lkIDAsXFxuICAgICAgICBtaW46IGAke21pblZhbHVlfSR7c3VmZml4fWAsXFxuICAgICAgICBzaWduZWQsXFxuICAgICAgICBzaXplOiBzaXplNSxcXG4gICAgICAgIHZhbHVlOiBgJHt2YWx1ZV99JHtzdWZmaXh9YFxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIGNvbnN0IGhleCA9IGAweCR7KHNpZ25lZCAmJiB2YWx1ZSA8IDAgPyAoMW4gPDwgQmlnSW50KHNpemU1ICogOCkpICsgQmlnSW50KHZhbHVlKSA6IHZhbHVlKS50b1N0cmluZygxNil9YDtcXG4gICAgaWYgKHNpemU1KVxcbiAgICAgIHJldHVybiBwYWQoaGV4LCB7IHNpemU6IHNpemU1IH0pO1xcbiAgICByZXR1cm4gaGV4O1xcbiAgfVxcbiAgZnVuY3Rpb24gc3RyaW5nVG9IZXgodmFsdWVfLCBvcHRzID0ge30pIHtcXG4gICAgY29uc3QgdmFsdWUgPSBlbmNvZGVyLmVuY29kZSh2YWx1ZV8pO1xcbiAgICByZXR1cm4gYnl0ZXNUb0hleCh2YWx1ZSwgb3B0cyk7XFxuICB9XFxuICB2YXIgaGV4ZXMsIGVuY29kZXI7XFxuICB2YXIgaW5pdF90b0hleCA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9lbmNvZGluZy90b0hleC5qc1wiKCkge1xcbiAgICAgIGluaXRfZW5jb2RpbmcoKTtcXG4gICAgICBpbml0X3BhZCgpO1xcbiAgICAgIGluaXRfZnJvbUhleCgpO1xcbiAgICAgIGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoX3YsIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSk7XFxuICAgICAgZW5jb2RlciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVGV4dEVuY29kZXIoKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9lbmNvZGluZy90b0J5dGVzLmpzXFxuICBmdW5jdGlvbiB0b0J5dGVzKHZhbHVlLCBvcHRzID0ge30pIHtcXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIpXFxuICAgICAgcmV0dXJuIG51bWJlclRvQnl0ZXModmFsdWUsIG9wdHMpO1xcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIilcXG4gICAgICByZXR1cm4gYm9vbFRvQnl0ZXModmFsdWUsIG9wdHMpO1xcbiAgICBpZiAoaXNIZXgodmFsdWUpKVxcbiAgICAgIHJldHVybiBoZXhUb0J5dGVzKHZhbHVlLCBvcHRzKTtcXG4gICAgcmV0dXJuIHN0cmluZ1RvQnl0ZXModmFsdWUsIG9wdHMpO1xcbiAgfVxcbiAgZnVuY3Rpb24gYm9vbFRvQnl0ZXModmFsdWUsIG9wdHMgPSB7fSkge1xcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KDEpO1xcbiAgICBieXRlc1swXSA9IE51bWJlcih2YWx1ZSk7XFxuICAgIGlmICh0eXBlb2Ygb3B0cy5zaXplID09PSBcIm51bWJlclwiKSB7XFxuICAgICAgYXNzZXJ0U2l6ZShieXRlcywgeyBzaXplOiBvcHRzLnNpemUgfSk7XFxuICAgICAgcmV0dXJuIHBhZChieXRlcywgeyBzaXplOiBvcHRzLnNpemUgfSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIGJ5dGVzO1xcbiAgfVxcbiAgZnVuY3Rpb24gY2hhckNvZGVUb0Jhc2UxNihjaGFyKSB7XFxuICAgIGlmIChjaGFyID49IGNoYXJDb2RlTWFwLnplcm8gJiYgY2hhciA8PSBjaGFyQ29kZU1hcC5uaW5lKVxcbiAgICAgIHJldHVybiBjaGFyIC0gY2hhckNvZGVNYXAuemVybztcXG4gICAgaWYgKGNoYXIgPj0gY2hhckNvZGVNYXAuQSAmJiBjaGFyIDw9IGNoYXJDb2RlTWFwLkYpXFxuICAgICAgcmV0dXJuIGNoYXIgLSAoY2hhckNvZGVNYXAuQSAtIDEwKTtcXG4gICAgaWYgKGNoYXIgPj0gY2hhckNvZGVNYXAuYSAmJiBjaGFyIDw9IGNoYXJDb2RlTWFwLmYpXFxuICAgICAgcmV0dXJuIGNoYXIgLSAoY2hhckNvZGVNYXAuYSAtIDEwKTtcXG4gICAgcmV0dXJuIHZvaWQgMDtcXG4gIH1cXG4gIGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4Xywgb3B0cyA9IHt9KSB7XFxuICAgIGxldCBoZXggPSBoZXhfO1xcbiAgICBpZiAob3B0cy5zaXplKSB7XFxuICAgICAgYXNzZXJ0U2l6ZShoZXgsIHsgc2l6ZTogb3B0cy5zaXplIH0pO1xcbiAgICAgIGhleCA9IHBhZChoZXgsIHsgZGlyOiBcInJpZ2h0XCIsIHNpemU6IG9wdHMuc2l6ZSB9KTtcXG4gICAgfVxcbiAgICBsZXQgaGV4U3RyaW5nID0gaGV4LnNsaWNlKDIpO1xcbiAgICBpZiAoaGV4U3RyaW5nLmxlbmd0aCAlIDIpXFxuICAgICAgaGV4U3RyaW5nID0gYDAke2hleFN0cmluZ31gO1xcbiAgICBjb25zdCBsZW5ndGggPSBoZXhTdHJpbmcubGVuZ3RoIC8gMjtcXG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xcbiAgICBmb3IgKGxldCBpbmRleDIgPSAwLCBqID0gMDsgaW5kZXgyIDwgbGVuZ3RoOyBpbmRleDIrKykge1xcbiAgICAgIGNvbnN0IG5pYmJsZUxlZnQgPSBjaGFyQ29kZVRvQmFzZTE2KGhleFN0cmluZy5jaGFyQ29kZUF0KGorKykpO1xcbiAgICAgIGNvbnN0IG5pYmJsZVJpZ2h0ID0gY2hhckNvZGVUb0Jhc2UxNihoZXhTdHJpbmcuY2hhckNvZGVBdChqKyspKTtcXG4gICAgICBpZiAobmliYmxlTGVmdCA9PT0gdm9pZCAwIHx8IG5pYmJsZVJpZ2h0ID09PSB2b2lkIDApIHtcXG4gICAgICAgIHRocm93IG5ldyBCYXNlRXJyb3IyKGBJbnZhbGlkIGJ5dGUgc2VxdWVuY2UgKFwiJHtoZXhTdHJpbmdbaiAtIDJdfSR7aGV4U3RyaW5nW2ogLSAxXX1cIiBpbiBcIiR7aGV4U3RyaW5nfVwiKS5gKTtcXG4gICAgICB9XFxuICAgICAgYnl0ZXNbaW5kZXgyXSA9IG5pYmJsZUxlZnQgKiAxNiArIG5pYmJsZVJpZ2h0O1xcbiAgICB9XFxuICAgIHJldHVybiBieXRlcztcXG4gIH1cXG4gIGZ1bmN0aW9uIG51bWJlclRvQnl0ZXModmFsdWUsIG9wdHMpIHtcXG4gICAgY29uc3QgaGV4ID0gbnVtYmVyVG9IZXgodmFsdWUsIG9wdHMpO1xcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhoZXgpO1xcbiAgfVxcbiAgZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyh2YWx1ZSwgb3B0cyA9IHt9KSB7XFxuICAgIGNvbnN0IGJ5dGVzID0gZW5jb2RlcjIuZW5jb2RlKHZhbHVlKTtcXG4gICAgaWYgKHR5cGVvZiBvcHRzLnNpemUgPT09IFwibnVtYmVyXCIpIHtcXG4gICAgICBhc3NlcnRTaXplKGJ5dGVzLCB7IHNpemU6IG9wdHMuc2l6ZSB9KTtcXG4gICAgICByZXR1cm4gcGFkKGJ5dGVzLCB7IGRpcjogXCJyaWdodFwiLCBzaXplOiBvcHRzLnNpemUgfSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIGJ5dGVzO1xcbiAgfVxcbiAgdmFyIGVuY29kZXIyLCBjaGFyQ29kZU1hcDtcXG4gIHZhciBpbml0X3RvQnl0ZXMgPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvZW5jb2RpbmcvdG9CeXRlcy5qc1wiKCkge1xcbiAgICAgIGluaXRfYmFzZSgpO1xcbiAgICAgIGluaXRfaXNIZXgoKTtcXG4gICAgICBpbml0X3BhZCgpO1xcbiAgICAgIGluaXRfZnJvbUhleCgpO1xcbiAgICAgIGluaXRfdG9IZXgoKTtcXG4gICAgICBlbmNvZGVyMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVGV4dEVuY29kZXIoKTtcXG4gICAgICBjaGFyQ29kZU1hcCA9IHtcXG4gICAgICAgIHplcm86IDQ4LFxcbiAgICAgICAgbmluZTogNTcsXFxuICAgICAgICBBOiA2NSxcXG4gICAgICAgIEY6IDcwLFxcbiAgICAgICAgYTogOTcsXFxuICAgICAgICBmOiAxMDJcXG4gICAgICB9O1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStoYXNoZXNAMS43LjEvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanNcXG4gIGZ1bmN0aW9uIGFudW1iZXIobikge1xcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInBvc2l0aXZlIGludGVnZXIgZXhwZWN0ZWQsIGdvdCBcIiArIG4pO1xcbiAgfVxcbiAgZnVuY3Rpb24gaXNCeXRlcyhhKSB7XFxuICAgIHJldHVybiBhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIlVpbnQ4QXJyYXlcIjtcXG4gIH1cXG4gIGZ1bmN0aW9uIGFieXRlcyhiLCAuLi5sZW5ndGhzKSB7XFxuICAgIGlmICghaXNCeXRlcyhiKSlcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVaW50OEFycmF5IGV4cGVjdGVkXCIpO1xcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVaW50OEFycmF5IGV4cGVjdGVkIG9mIGxlbmd0aCBcIiArIGxlbmd0aHMgKyBcIiwgZ290IGxlbmd0aD1cIiArIGIubGVuZ3RoKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGFoYXNoKGgpIHtcXG4gICAgaWYgKHR5cGVvZiBoICE9PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIGguY3JlYXRlICE9PSBcImZ1bmN0aW9uXCIpXFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3JcIik7XFxuICAgIGFudW1iZXIoaC5vdXRwdXRMZW4pO1xcbiAgICBhbnVtYmVyKGguYmxvY2tMZW4pO1xcbiAgfVxcbiAgZnVuY3Rpb24gYWV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcXG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZFwiKTtcXG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZFwiKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGFvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xcbiAgICBhYnl0ZXMob3V0KTtcXG4gICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0IFwiICsgbWluKTtcXG4gICAgfVxcbiAgfVxcbiAgdmFyIGluaXRfYXNzZXJ0ID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStoYXNoZXNAMS43LjEvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanNcIigpIHtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS9Abm9ibGUraGFzaGVzQDEuNy4xL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fdTY0LmpzXFxuICBmdW5jdGlvbiBmcm9tQmlnKG4sIGxlID0gZmFsc2UpIHtcXG4gICAgaWYgKGxlKVxcbiAgICAgIHJldHVybiB7IGg6IE51bWJlcihuICYgVTMyX01BU0s2NCksIGw6IE51bWJlcihuID4+IF8zMm4gJiBVMzJfTUFTSzY0KSB9O1xcbiAgICByZXR1cm4geyBoOiBOdW1iZXIobiA+PiBfMzJuICYgVTMyX01BU0s2NCkgfCAwLCBsOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpIHwgMCB9O1xcbiAgfVxcbiAgZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XFxuICAgIGxldCBBaCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcXG4gICAgbGV0IEFsID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKykge1xcbiAgICAgIGNvbnN0IHsgaCwgbCB9ID0gZnJvbUJpZyhsc3RbaV0sIGxlKTtcXG4gICAgICBbQWhbaV0sIEFsW2ldXSA9IFtoLCBsXTtcXG4gICAgfVxcbiAgICByZXR1cm4gW0FoLCBBbF07XFxuICB9XFxuICB2YXIgVTMyX01BU0s2NCwgXzMybiwgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMO1xcbiAgdmFyIGluaXRfdTY0ID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStoYXNoZXNAMS43LjEvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL191NjQuanNcIigpIHtcXG4gICAgICBVMzJfTUFTSzY0ID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyICoqIDMyIC0gMSk7XFxuICAgICAgXzMybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMzIpO1xcbiAgICAgIHJvdGxTSCA9IChoLCBsLCBzKSA9PiBoIDw8IHMgfCBsID4+PiAzMiAtIHM7XFxuICAgICAgcm90bFNMID0gKGgsIGwsIHMpID0+IGwgPDwgcyB8IGggPj4+IDMyIC0gcztcXG4gICAgICByb3RsQkggPSAoaCwgbCwgcykgPT4gbCA8PCBzIC0gMzIgfCBoID4+PiA2NCAtIHM7XFxuICAgICAgcm90bEJMID0gKGgsIGwsIHMpID0+IGggPDwgcyAtIDMyIHwgbCA+Pj4gNjQgLSBzO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStoYXNoZXNAMS43LjEvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0by5qc1xcbiAgdmFyIGNyeXB0bzI7XFxuICB2YXIgaW5pdF9jcnlwdG8gPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2hhc2hlc0AxLjcuMS9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvLmpzXCIoKSB7XFxuICAgICAgY3J5cHRvMiA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiICYmIFwiY3J5cHRvXCIgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuY3J5cHRvIDogdm9pZCAwO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStoYXNoZXNAMS43LjEvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzXFxuICBmdW5jdGlvbiB1MzIoYXJyKSB7XFxuICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XFxuICB9XFxuICBmdW5jdGlvbiBjcmVhdGVWaWV3KGFycikge1xcbiAgICByZXR1cm4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XFxuICB9XFxuICBmdW5jdGlvbiByb3RyKHdvcmQsIHNoaWZ0KSB7XFxuICAgIHJldHVybiB3b3JkIDw8IDMyIC0gc2hpZnQgfCB3b3JkID4+PiBzaGlmdDtcXG4gIH1cXG4gIGZ1bmN0aW9uIGJ5dGVTd2FwKHdvcmQpIHtcXG4gICAgcmV0dXJuIHdvcmQgPDwgMjQgJiA0Mjc4MTkwMDgwIHwgd29yZCA8PCA4ICYgMTY3MTE2ODAgfCB3b3JkID4+PiA4ICYgNjUyODAgfCB3b3JkID4+PiAyNCAmIDI1NTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGJ5dGVTd2FwMzIoYXJyKSB7XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgYXJyW2ldID0gYnl0ZVN3YXAoYXJyW2ldKTtcXG4gICAgfVxcbiAgfVxcbiAgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XFxuICAgIGlmICh0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiKVxcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290IFwiICsgdHlwZW9mIHN0cik7XFxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7XFxuICB9XFxuICBmdW5jdGlvbiB0b0J5dGVzMihkYXRhKSB7XFxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIilcXG4gICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XFxuICAgIGFieXRlcyhkYXRhKTtcXG4gICAgcmV0dXJuIGRhdGE7XFxuICB9XFxuICBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcXG4gICAgbGV0IHN1bSA9IDA7XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcXG4gICAgICBhYnl0ZXMoYSk7XFxuICAgICAgc3VtICs9IGEubGVuZ3RoO1xcbiAgICB9XFxuICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHN1bSk7XFxuICAgIGZvciAobGV0IGkgPSAwLCBwYWQ0ID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xcbiAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XFxuICAgICAgcmVzLnNldChhLCBwYWQ0KTtcXG4gICAgICBwYWQ0ICs9IGEubGVuZ3RoO1xcbiAgICB9XFxuICAgIHJldHVybiByZXM7XFxuICB9XFxuICBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IoaGFzaENvbnMpIHtcXG4gICAgY29uc3QgaGFzaEMgPSAobXNnKSA9PiBoYXNoQ29ucygpLnVwZGF0ZSh0b0J5dGVzMihtc2cpKS5kaWdlc3QoKTtcXG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoKTtcXG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcXG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XFxuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zKCk7XFxuICAgIHJldHVybiBoYXNoQztcXG4gIH1cXG4gIGZ1bmN0aW9uIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XFxuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMyKG1zZykpLmRpZ2VzdCgpO1xcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XFxuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XFxuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XFxuICAgIHJldHVybiBoYXNoQztcXG4gIH1cXG4gIGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcXG4gICAgaWYgKGNyeXB0bzIgJiYgdHlwZW9mIGNyeXB0bzIuZ2V0UmFuZG9tVmFsdWVzID09PSBcImZ1bmN0aW9uXCIpIHtcXG4gICAgICByZXR1cm4gY3J5cHRvMi5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcXG4gICAgfVxcbiAgICBpZiAoY3J5cHRvMiAmJiB0eXBlb2YgY3J5cHRvMi5yYW5kb21CeXRlcyA9PT0gXCJmdW5jdGlvblwiKSB7XFxuICAgICAgcmV0dXJuIGNyeXB0bzIucmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGgpO1xcbiAgICB9XFxuICAgIHRocm93IG5ldyBFcnJvcihcImNyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkXCIpO1xcbiAgfVxcbiAgdmFyIGlzTEUsIEhhc2g7XFxuICB2YXIgaW5pdF91dGlsczIgPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2hhc2hlc0AxLjcuMS9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanNcIigpIHtcXG4gICAgICBpbml0X2NyeXB0bygpO1xcbiAgICAgIGluaXRfYXNzZXJ0KCk7XFxuICAgICAgaXNMRSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsyODc0NTQwMjBdKS5idWZmZXIpWzBdID09PSA2OCkoKTtcXG4gICAgICBIYXNoID0gY2xhc3Mge1xcbiAgICAgICAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXFxuICAgICAgICBjbG9uZSgpIHtcXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2hhc2hlc0AxLjcuMS9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMy5qc1xcbiAgZnVuY3Rpb24ga2VjY2FrUChzLCByb3VuZHMgPSAyNCkge1xcbiAgICBjb25zdCBCID0gbmV3IFVpbnQzMkFycmF5KDUgKiAyKTtcXG4gICAgZm9yIChsZXQgcm91bmQgPSAyNCAtIHJvdW5kczsgcm91bmQgPCAyNDsgcm91bmQrKykge1xcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcXG4gICAgICAgIEJbeF0gPSBzW3hdIF4gc1t4ICsgMTBdIF4gc1t4ICsgMjBdIF4gc1t4ICsgMzBdIF4gc1t4ICsgNDBdO1xcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHggKz0gMikge1xcbiAgICAgICAgY29uc3QgaWR4MSA9ICh4ICsgOCkgJSAxMDtcXG4gICAgICAgIGNvbnN0IGlkeDAgPSAoeCArIDIpICUgMTA7XFxuICAgICAgICBjb25zdCBCMCA9IEJbaWR4MF07XFxuICAgICAgICBjb25zdCBCMSA9IEJbaWR4MCArIDFdO1xcbiAgICAgICAgY29uc3QgVGggPSByb3RsSChCMCwgQjEsIDEpIF4gQltpZHgxXTtcXG4gICAgICAgIGNvbnN0IFRsID0gcm90bEwoQjAsIEIxLCAxKSBeIEJbaWR4MSArIDFdO1xcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1MDsgeSArPSAxMCkge1xcbiAgICAgICAgICBzW3ggKyB5XSBePSBUaDtcXG4gICAgICAgICAgc1t4ICsgeSArIDFdIF49IFRsO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBsZXQgY3VySCA9IHNbMl07XFxuICAgICAgbGV0IGN1ckwgPSBzWzNdO1xcbiAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgMjQ7IHQrKykge1xcbiAgICAgICAgY29uc3Qgc2hpZnQgPSBTSEEzX1JPVExbdF07XFxuICAgICAgICBjb25zdCBUaCA9IHJvdGxIKGN1ckgsIGN1ckwsIHNoaWZ0KTtcXG4gICAgICAgIGNvbnN0IFRsID0gcm90bEwoY3VySCwgY3VyTCwgc2hpZnQpO1xcbiAgICAgICAgY29uc3QgUEkgPSBTSEEzX1BJW3RdO1xcbiAgICAgICAgY3VySCA9IHNbUEldO1xcbiAgICAgICAgY3VyTCA9IHNbUEkgKyAxXTtcXG4gICAgICAgIHNbUEldID0gVGg7XFxuICAgICAgICBzW1BJICsgMV0gPSBUbDtcXG4gICAgICB9XFxuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1MDsgeSArPSAxMCkge1xcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxcbiAgICAgICAgICBCW3hdID0gc1t5ICsgeF07XFxuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXFxuICAgICAgICAgIHNbeSArIHhdIF49IH5CWyh4ICsgMikgJSAxMF0gJiBCWyh4ICsgNCkgJSAxMF07XFxuICAgICAgfVxcbiAgICAgIHNbMF0gXj0gU0hBM19JT1RBX0hbcm91bmRdO1xcbiAgICAgIHNbMV0gXj0gU0hBM19JT1RBX0xbcm91bmRdO1xcbiAgICB9XFxuICAgIEIuZmlsbCgwKTtcXG4gIH1cXG4gIHZhciBTSEEzX1BJLCBTSEEzX1JPVEwsIF9TSEEzX0lPVEEsIF8wbiwgXzFuLCBfMm4sIF83biwgXzI1Nm4sIF8weDcxbiwgU0hBM19JT1RBX0gsIFNIQTNfSU9UQV9MLCByb3RsSCwgcm90bEwsIEtlY2NhaywgZ2VuLCBzaGEzXzIyNCwgc2hhM18yNTYsIHNoYTNfMzg0LCBzaGEzXzUxMiwga2VjY2FrXzIyNCwga2VjY2FrXzI1Niwga2VjY2FrXzM4NCwga2VjY2FrXzUxMiwgZ2VuU2hha2UsIHNoYWtlMTI4LCBzaGFrZTI1NjtcXG4gIHZhciBpbml0X3NoYTMgPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2hhc2hlc0AxLjcuMS9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMy5qc1wiKCkge1xcbiAgICAgIGluaXRfYXNzZXJ0KCk7XFxuICAgICAgaW5pdF91NjQoKTtcXG4gICAgICBpbml0X3V0aWxzMigpO1xcbiAgICAgIFNIQTNfUEkgPSBbXTtcXG4gICAgICBTSEEzX1JPVEwgPSBbXTtcXG4gICAgICBfU0hBM19JT1RBID0gW107XFxuICAgICAgXzBuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgwKTtcXG4gICAgICBfMW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDEpO1xcbiAgICAgIF8ybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMik7XFxuICAgICAgXzduID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg3KTtcXG4gICAgICBfMjU2biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMjU2KTtcXG4gICAgICBfMHg3MW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDExMyk7XFxuICAgICAgZm9yIChsZXQgcm91bmQgPSAwLCBSID0gXzFuLCB4ID0gMSwgeSA9IDA7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcXG4gICAgICAgIFt4LCB5XSA9IFt5LCAoMiAqIHggKyAzICogeSkgJSA1XTtcXG4gICAgICAgIFNIQTNfUEkucHVzaCgyICogKDUgKiB5ICsgeCkpO1xcbiAgICAgICAgU0hBM19ST1RMLnB1c2goKHJvdW5kICsgMSkgKiAocm91bmQgKyAyKSAvIDIgJSA2NCk7XFxuICAgICAgICBsZXQgdCA9IF8wbjtcXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNzsgaisrKSB7XFxuICAgICAgICAgIFIgPSAoUiA8PCBfMW4gXiAoUiA+PiBfN24pICogXzB4NzFuKSAlIF8yNTZuO1xcbiAgICAgICAgICBpZiAoUiAmIF8ybilcXG4gICAgICAgICAgICB0IF49IF8xbiA8PCAoXzFuIDw8IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoaikpIC0gXzFuO1xcbiAgICAgICAgfVxcbiAgICAgICAgX1NIQTNfSU9UQS5wdXNoKHQpO1xcbiAgICAgIH1cXG4gICAgICBbU0hBM19JT1RBX0gsIFNIQTNfSU9UQV9MXSA9IC8qIEBfX1BVUkVfXyAqLyBzcGxpdChfU0hBM19JT1RBLCB0cnVlKTtcXG4gICAgICByb3RsSCA9IChoLCBsLCBzKSA9PiBzID4gMzIgPyByb3RsQkgoaCwgbCwgcykgOiByb3RsU0goaCwgbCwgcyk7XFxuICAgICAgcm90bEwgPSAoaCwgbCwgcykgPT4gcyA+IDMyID8gcm90bEJMKGgsIGwsIHMpIDogcm90bFNMKGgsIGwsIHMpO1xcbiAgICAgIEtlY2NhayA9IGNsYXNzIF9LZWNjYWsgZXh0ZW5kcyBIYXNoIHtcXG4gICAgICAgIC8vIE5PVEU6IHdlIGFjY2VwdCBhcmd1bWVudHMgaW4gYnl0ZXMgaW5zdGVhZCBvZiBiaXRzIGhlcmUuXFxuICAgICAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiA9IGZhbHNlLCByb3VuZHMgPSAyNCkge1xcbiAgICAgICAgICBzdXBlcigpO1xcbiAgICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XFxuICAgICAgICAgIHRoaXMuc3VmZml4ID0gc3VmZml4O1xcbiAgICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcXG4gICAgICAgICAgdGhpcy5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XFxuICAgICAgICAgIHRoaXMucm91bmRzID0gcm91bmRzO1xcbiAgICAgICAgICB0aGlzLnBvcyA9IDA7XFxuICAgICAgICAgIHRoaXMucG9zT3V0ID0gMDtcXG4gICAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xcbiAgICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xcbiAgICAgICAgICBhbnVtYmVyKG91dHB1dExlbik7XFxuICAgICAgICAgIGlmICgwID49IHRoaXMuYmxvY2tMZW4gfHwgdGhpcy5ibG9ja0xlbiA+PSAyMDApXFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2hhMyBzdXBwb3J0cyBvbmx5IGtlY2Nhay1mMTYwMCBmdW5jdGlvblwiKTtcXG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IG5ldyBVaW50OEFycmF5KDIwMCk7XFxuICAgICAgICAgIHRoaXMuc3RhdGUzMiA9IHUzMih0aGlzLnN0YXRlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGtlY2NhaygpIHtcXG4gICAgICAgICAgaWYgKCFpc0xFKVxcbiAgICAgICAgICAgIGJ5dGVTd2FwMzIodGhpcy5zdGF0ZTMyKTtcXG4gICAgICAgICAga2VjY2FrUCh0aGlzLnN0YXRlMzIsIHRoaXMucm91bmRzKTtcXG4gICAgICAgICAgaWYgKCFpc0xFKVxcbiAgICAgICAgICAgIGJ5dGVTd2FwMzIodGhpcy5zdGF0ZTMyKTtcXG4gICAgICAgICAgdGhpcy5wb3NPdXQgPSAwO1xcbiAgICAgICAgICB0aGlzLnBvcyA9IDA7XFxuICAgICAgICB9XFxuICAgICAgICB1cGRhdGUoZGF0YSkge1xcbiAgICAgICAgICBhZXhpc3RzKHRoaXMpO1xcbiAgICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdGF0ZSB9ID0gdGhpcztcXG4gICAgICAgICAgZGF0YSA9IHRvQnl0ZXMyKGRhdGEpO1xcbiAgICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcXG4gICAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOyApIHtcXG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRha2U7IGkrKylcXG4gICAgICAgICAgICAgIHN0YXRlW3RoaXMucG9zKytdIF49IGRhdGFbcG9zKytdO1xcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pXFxuICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHJldHVybiB0aGlzO1xcbiAgICAgICAgfVxcbiAgICAgICAgZmluaXNoKCkge1xcbiAgICAgICAgICBpZiAodGhpcy5maW5pc2hlZClcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xcbiAgICAgICAgICBjb25zdCB7IHN0YXRlLCBzdWZmaXgsIHBvcywgYmxvY2tMZW4gfSA9IHRoaXM7XFxuICAgICAgICAgIHN0YXRlW3Bvc10gXj0gc3VmZml4O1xcbiAgICAgICAgICBpZiAoKHN1ZmZpeCAmIDEyOCkgIT09IDAgJiYgcG9zID09PSBibG9ja0xlbiAtIDEpXFxuICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcXG4gICAgICAgICAgc3RhdGVbYmxvY2tMZW4gLSAxXSBePSAxMjg7XFxuICAgICAgICAgIHRoaXMua2VjY2FrKCk7XFxuICAgICAgICB9XFxuICAgICAgICB3cml0ZUludG8ob3V0KSB7XFxuICAgICAgICAgIGFleGlzdHModGhpcywgZmFsc2UpO1xcbiAgICAgICAgICBhYnl0ZXMob3V0KTtcXG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcXG4gICAgICAgICAgY29uc3QgYnVmZmVyT3V0ID0gdGhpcy5zdGF0ZTtcXG4gICAgICAgICAgY29uc3QgeyBibG9ja0xlbiB9ID0gdGhpcztcXG4gICAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgbGVuID0gb3V0Lmxlbmd0aDsgcG9zIDwgbGVuOyApIHtcXG4gICAgICAgICAgICBpZiAodGhpcy5wb3NPdXQgPj0gYmxvY2tMZW4pXFxuICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zT3V0LCBsZW4gLSBwb3MpO1xcbiAgICAgICAgICAgIG91dC5zZXQoYnVmZmVyT3V0LnN1YmFycmF5KHRoaXMucG9zT3V0LCB0aGlzLnBvc091dCArIHRha2UpLCBwb3MpO1xcbiAgICAgICAgICAgIHRoaXMucG9zT3V0ICs9IHRha2U7XFxuICAgICAgICAgICAgcG9zICs9IHRha2U7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgcmV0dXJuIG91dDtcXG4gICAgICAgIH1cXG4gICAgICAgIHhvZkludG8ob3V0KSB7XFxuICAgICAgICAgIGlmICghdGhpcy5lbmFibGVYT0YpXFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWE9GIGlzIG5vdCBwb3NzaWJsZSBmb3IgdGhpcyBpbnN0YW5jZVwiKTtcXG4gICAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVJbnRvKG91dCk7XFxuICAgICAgICB9XFxuICAgICAgICB4b2YoYnl0ZXMpIHtcXG4gICAgICAgICAgYW51bWJlcihieXRlcyk7XFxuICAgICAgICAgIHJldHVybiB0aGlzLnhvZkludG8obmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGRpZ2VzdEludG8ob3V0KSB7XFxuICAgICAgICAgIGFvdXRwdXQob3V0LCB0aGlzKTtcXG4gICAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlnZXN0KCkgd2FzIGFscmVhZHkgY2FsbGVkXCIpO1xcbiAgICAgICAgICB0aGlzLndyaXRlSW50byhvdXQpO1xcbiAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcXG4gICAgICAgICAgcmV0dXJuIG91dDtcXG4gICAgICAgIH1cXG4gICAgICAgIGRpZ2VzdCgpIHtcXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGlnZXN0SW50byhuZXcgVWludDhBcnJheSh0aGlzLm91dHB1dExlbikpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZGVzdHJveSgpIHtcXG4gICAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xcbiAgICAgICAgICB0aGlzLnN0YXRlLmZpbGwoMCk7XFxuICAgICAgICB9XFxuICAgICAgICBfY2xvbmVJbnRvKHRvKSB7XFxuICAgICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCByb3VuZHMsIGVuYWJsZVhPRiB9ID0gdGhpcztcXG4gICAgICAgICAgdG8gfHwgKHRvID0gbmV3IF9LZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YsIHJvdW5kcykpO1xcbiAgICAgICAgICB0by5zdGF0ZTMyLnNldCh0aGlzLnN0YXRlMzIpO1xcbiAgICAgICAgICB0by5wb3MgPSB0aGlzLnBvcztcXG4gICAgICAgICAgdG8ucG9zT3V0ID0gdGhpcy5wb3NPdXQ7XFxuICAgICAgICAgIHRvLmZpbmlzaGVkID0gdGhpcy5maW5pc2hlZDtcXG4gICAgICAgICAgdG8ucm91bmRzID0gcm91bmRzO1xcbiAgICAgICAgICB0by5zdWZmaXggPSBzdWZmaXg7XFxuICAgICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcXG4gICAgICAgICAgdG8uZW5hYmxlWE9GID0gZW5hYmxlWE9GO1xcbiAgICAgICAgICB0by5kZXN0cm95ZWQgPSB0aGlzLmRlc3Ryb3llZDtcXG4gICAgICAgICAgcmV0dXJuIHRvO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgZ2VuID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuKSk7XFxuICAgICAgc2hhM18yMjQgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDYsIDE0NCwgMjI0IC8gOCk7XFxuICAgICAgc2hhM18yNTYgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDYsIDEzNiwgMjU2IC8gOCk7XFxuICAgICAgc2hhM18zODQgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDYsIDEwNCwgMzg0IC8gOCk7XFxuICAgICAgc2hhM181MTIgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDYsIDcyLCA1MTIgLyA4KTtcXG4gICAgICBrZWNjYWtfMjI0ID0gLyogQF9fUFVSRV9fICovIGdlbigxLCAxNDQsIDIyNCAvIDgpO1xcbiAgICAgIGtlY2Nha18yNTYgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDEsIDEzNiwgMjU2IC8gOCk7XFxuICAgICAga2VjY2FrXzM4NCA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMSwgMTA0LCAzODQgLyA4KTtcXG4gICAgICBrZWNjYWtfNTEyID0gLyogQF9fUFVSRV9fICovIGdlbigxLCA3MiwgNTEyIC8gOCk7XFxuICAgICAgZ2VuU2hha2UgPSAoc3VmZml4LCBibG9ja0xlbiwgb3V0cHV0TGVuKSA9PiB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cygob3B0cyA9IHt9KSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG9wdHMuZGtMZW4gPT09IHZvaWQgMCA/IG91dHB1dExlbiA6IG9wdHMuZGtMZW4sIHRydWUpKTtcXG4gICAgICBzaGFrZTEyOCA9IC8qIEBfX1BVUkVfXyAqLyBnZW5TaGFrZSgzMSwgMTY4LCAxMjggLyA4KTtcXG4gICAgICBzaGFrZTI1NiA9IC8qIEBfX1BVUkVfXyAqLyBnZW5TaGFrZSgzMSwgMTM2LCAyNTYgLyA4KTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9oYXNoL2tlY2NhazI1Ni5qc1xcbiAgZnVuY3Rpb24ga2VjY2FrMjU2KHZhbHVlLCB0b18pIHtcXG4gICAgY29uc3QgdG8gPSB0b18gfHwgXCJoZXhcIjtcXG4gICAgY29uc3QgYnl0ZXMgPSBrZWNjYWtfMjU2KGlzSGV4KHZhbHVlLCB7IHN0cmljdDogZmFsc2UgfSkgPyB0b0J5dGVzKHZhbHVlKSA6IHZhbHVlKTtcXG4gICAgaWYgKHRvID09PSBcImJ5dGVzXCIpXFxuICAgICAgcmV0dXJuIGJ5dGVzO1xcbiAgICByZXR1cm4gdG9IZXgoYnl0ZXMpO1xcbiAgfVxcbiAgdmFyIGluaXRfa2VjY2FrMjU2ID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2hhc2gva2VjY2FrMjU2LmpzXCIoKSB7XFxuICAgICAgaW5pdF9zaGEzKCk7XFxuICAgICAgaW5pdF9pc0hleCgpO1xcbiAgICAgIGluaXRfdG9CeXRlcygpO1xcbiAgICAgIGluaXRfdG9IZXgoKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9oYXNoL2hhc2hTaWduYXR1cmUuanNcXG4gIGZ1bmN0aW9uIGhhc2hTaWduYXR1cmUoc2lnKSB7XFxuICAgIHJldHVybiBoYXNoKHNpZyk7XFxuICB9XFxuICB2YXIgaGFzaDtcXG4gIHZhciBpbml0X2hhc2hTaWduYXR1cmUgPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvaGFzaC9oYXNoU2lnbmF0dXJlLmpzXCIoKSB7XFxuICAgICAgaW5pdF90b0J5dGVzKCk7XFxuICAgICAgaW5pdF9rZWNjYWsyNTYoKTtcXG4gICAgICBoYXNoID0gKHZhbHVlKSA9PiBrZWNjYWsyNTYodG9CeXRlcyh2YWx1ZSkpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2hhc2gvbm9ybWFsaXplU2lnbmF0dXJlLmpzXFxuICBmdW5jdGlvbiBub3JtYWxpemVTaWduYXR1cmUoc2lnbmF0dXJlKSB7XFxuICAgIGxldCBhY3RpdmUgPSB0cnVlO1xcbiAgICBsZXQgY3VycmVudCA9IFwiXCI7XFxuICAgIGxldCBsZXZlbCA9IDA7XFxuICAgIGxldCByZXN1bHQgPSBcIlwiO1xcbiAgICBsZXQgdmFsaWQgPSBmYWxzZTtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWduYXR1cmUubGVuZ3RoOyBpKyspIHtcXG4gICAgICBjb25zdCBjaGFyID0gc2lnbmF0dXJlW2ldO1xcbiAgICAgIGlmIChbXCIoXCIsIFwiKVwiLCBcIixcIl0uaW5jbHVkZXMoY2hhcikpXFxuICAgICAgICBhY3RpdmUgPSB0cnVlO1xcbiAgICAgIGlmIChjaGFyID09PSBcIihcIilcXG4gICAgICAgIGxldmVsKys7XFxuICAgICAgaWYgKGNoYXIgPT09IFwiKVwiKVxcbiAgICAgICAgbGV2ZWwtLTtcXG4gICAgICBpZiAoIWFjdGl2ZSlcXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICAgIGlmIChsZXZlbCA9PT0gMCkge1xcbiAgICAgICAgaWYgKGNoYXIgPT09IFwiIFwiICYmIFtcImV2ZW50XCIsIFwiZnVuY3Rpb25cIiwgXCJcIl0uaW5jbHVkZXMocmVzdWx0KSlcXG4gICAgICAgICAgcmVzdWx0ID0gXCJcIjtcXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICByZXN1bHQgKz0gY2hhcjtcXG4gICAgICAgICAgaWYgKGNoYXIgPT09IFwiKVwiKSB7XFxuICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBjb250aW51ZTtcXG4gICAgICB9XFxuICAgICAgaWYgKGNoYXIgPT09IFwiIFwiKSB7XFxuICAgICAgICBpZiAoc2lnbmF0dXJlW2kgLSAxXSAhPT0gXCIsXCIgJiYgY3VycmVudCAhPT0gXCIsXCIgJiYgY3VycmVudCAhPT0gXCIsKFwiKSB7XFxuICAgICAgICAgIGN1cnJlbnQgPSBcIlwiO1xcbiAgICAgICAgICBhY3RpdmUgPSBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICAgIH1cXG4gICAgICByZXN1bHQgKz0gY2hhcjtcXG4gICAgICBjdXJyZW50ICs9IGNoYXI7XFxuICAgIH1cXG4gICAgaWYgKCF2YWxpZClcXG4gICAgICB0aHJvdyBuZXcgQmFzZUVycm9yMihcIlVuYWJsZSB0byBub3JtYWxpemUgc2lnbmF0dXJlLlwiKTtcXG4gICAgcmV0dXJuIHJlc3VsdDtcXG4gIH1cXG4gIHZhciBpbml0X25vcm1hbGl6ZVNpZ25hdHVyZSA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9oYXNoL25vcm1hbGl6ZVNpZ25hdHVyZS5qc1wiKCkge1xcbiAgICAgIGluaXRfYmFzZSgpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2hhc2gvdG9TaWduYXR1cmUuanNcXG4gIHZhciB0b1NpZ25hdHVyZTtcXG4gIHZhciBpbml0X3RvU2lnbmF0dXJlID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2hhc2gvdG9TaWduYXR1cmUuanNcIigpIHtcXG4gICAgICBpbml0X2V4cG9ydHMoKTtcXG4gICAgICBpbml0X25vcm1hbGl6ZVNpZ25hdHVyZSgpO1xcbiAgICAgIHRvU2lnbmF0dXJlID0gKGRlZikgPT4ge1xcbiAgICAgICAgY29uc3QgZGVmXyA9ICgoKSA9PiB7XFxuICAgICAgICAgIGlmICh0eXBlb2YgZGVmID09PSBcInN0cmluZ1wiKVxcbiAgICAgICAgICAgIHJldHVybiBkZWY7XFxuICAgICAgICAgIHJldHVybiBmb3JtYXRBYmlJdGVtKGRlZik7XFxuICAgICAgICB9KSgpO1xcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVNpZ25hdHVyZShkZWZfKTtcXG4gICAgICB9O1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2hhc2gvdG9TaWduYXR1cmVIYXNoLmpzXFxuICBmdW5jdGlvbiB0b1NpZ25hdHVyZUhhc2goZm4pIHtcXG4gICAgcmV0dXJuIGhhc2hTaWduYXR1cmUodG9TaWduYXR1cmUoZm4pKTtcXG4gIH1cXG4gIHZhciBpbml0X3RvU2lnbmF0dXJlSGFzaCA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9oYXNoL3RvU2lnbmF0dXJlSGFzaC5qc1wiKCkge1xcbiAgICAgIGluaXRfaGFzaFNpZ25hdHVyZSgpO1xcbiAgICAgIGluaXRfdG9TaWduYXR1cmUoKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9oYXNoL3RvRXZlbnRTZWxlY3Rvci5qc1xcbiAgdmFyIHRvRXZlbnRTZWxlY3RvcjtcXG4gIHZhciBpbml0X3RvRXZlbnRTZWxlY3RvciA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9oYXNoL3RvRXZlbnRTZWxlY3Rvci5qc1wiKCkge1xcbiAgICAgIGluaXRfdG9TaWduYXR1cmVIYXNoKCk7XFxuICAgICAgdG9FdmVudFNlbGVjdG9yID0gdG9TaWduYXR1cmVIYXNoO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2Vycm9ycy9hZGRyZXNzLmpzXFxuICB2YXIgSW52YWxpZEFkZHJlc3NFcnJvcjtcXG4gIHZhciBpbml0X2FkZHJlc3MgPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vZXJyb3JzL2FkZHJlc3MuanNcIigpIHtcXG4gICAgICBpbml0X2Jhc2UoKTtcXG4gICAgICBJbnZhbGlkQWRkcmVzc0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IyIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKHsgYWRkcmVzcyB9KSB7XFxuICAgICAgICAgIHN1cGVyKGBBZGRyZXNzIFwiJHthZGRyZXNzfVwiIGlzIGludmFsaWQuYCwge1xcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xcbiAgICAgICAgICAgICAgXCItIEFkZHJlc3MgbXVzdCBiZSBhIGhleCB2YWx1ZSBvZiAyMCBieXRlcyAoNDAgaGV4IGNoYXJhY3RlcnMpLlwiLFxcbiAgICAgICAgICAgICAgXCItIEFkZHJlc3MgbXVzdCBtYXRjaCBpdHMgY2hlY2tzdW0gY291bnRlcnBhcnQuXCJcXG4gICAgICAgICAgICBdLFxcbiAgICAgICAgICAgIG5hbWU6IFwiSW52YWxpZEFkZHJlc3NFcnJvclwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvbHJ1LmpzXFxuICB2YXIgTHJ1TWFwO1xcbiAgdmFyIGluaXRfbHJ1ID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2xydS5qc1wiKCkge1xcbiAgICAgIExydU1hcCA9IGNsYXNzIGV4dGVuZHMgTWFwIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKHNpemU1KSB7XFxuICAgICAgICAgIHN1cGVyKCk7XFxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heFNpemVcIiwge1xcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIHRoaXMubWF4U2l6ZSA9IHNpemU1O1xcbiAgICAgICAgfVxcbiAgICAgICAgZ2V0KGtleSkge1xcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHN1cGVyLmdldChrZXkpO1xcbiAgICAgICAgICBpZiAoc3VwZXIuaGFzKGtleSkgJiYgdmFsdWUgIT09IHZvaWQgMCkge1xcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlKGtleSk7XFxuICAgICAgICAgICAgc3VwZXIuc2V0KGtleSwgdmFsdWUpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHNldChrZXksIHZhbHVlKSB7XFxuICAgICAgICAgIHN1cGVyLnNldChrZXksIHZhbHVlKTtcXG4gICAgICAgICAgaWYgKHRoaXMubWF4U2l6ZSAmJiB0aGlzLnNpemUgPiB0aGlzLm1heFNpemUpIHtcXG4gICAgICAgICAgICBjb25zdCBmaXJzdEtleSA9IHRoaXMua2V5cygpLm5leHQoKS52YWx1ZTtcXG4gICAgICAgICAgICBpZiAoZmlyc3RLZXkpXFxuICAgICAgICAgICAgICB0aGlzLmRlbGV0ZShmaXJzdEtleSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9hZGRyZXNzL2dldEFkZHJlc3MuanNcXG4gIGZ1bmN0aW9uIGNoZWNrc3VtQWRkcmVzcyhhZGRyZXNzXywgY2hhaW5JZCkge1xcbiAgICBpZiAoY2hlY2tzdW1BZGRyZXNzQ2FjaGUuaGFzKGAke2FkZHJlc3NffS4ke2NoYWluSWR9YCkpXFxuICAgICAgcmV0dXJuIGNoZWNrc3VtQWRkcmVzc0NhY2hlLmdldChgJHthZGRyZXNzX30uJHtjaGFpbklkfWApO1xcbiAgICBjb25zdCBoZXhBZGRyZXNzID0gY2hhaW5JZCA/IGAke2NoYWluSWR9JHthZGRyZXNzXy50b0xvd2VyQ2FzZSgpfWAgOiBhZGRyZXNzXy5zdWJzdHJpbmcoMikudG9Mb3dlckNhc2UoKTtcXG4gICAgY29uc3QgaGFzaDIgPSBrZWNjYWsyNTYoc3RyaW5nVG9CeXRlcyhoZXhBZGRyZXNzKSwgXCJieXRlc1wiKTtcXG4gICAgY29uc3QgYWRkcmVzcyA9IChjaGFpbklkID8gaGV4QWRkcmVzcy5zdWJzdHJpbmcoYCR7Y2hhaW5JZH0weGAubGVuZ3RoKSA6IGhleEFkZHJlc3MpLnNwbGl0KFwiXCIpO1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQwOyBpICs9IDIpIHtcXG4gICAgICBpZiAoaGFzaDJbaSA+PiAxXSA+PiA0ID49IDggJiYgYWRkcmVzc1tpXSkge1xcbiAgICAgICAgYWRkcmVzc1tpXSA9IGFkZHJlc3NbaV0udG9VcHBlckNhc2UoKTtcXG4gICAgICB9XFxuICAgICAgaWYgKChoYXNoMltpID4+IDFdICYgMTUpID49IDggJiYgYWRkcmVzc1tpICsgMV0pIHtcXG4gICAgICAgIGFkZHJlc3NbaSArIDFdID0gYWRkcmVzc1tpICsgMV0udG9VcHBlckNhc2UoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgY29uc3QgcmVzdWx0ID0gYDB4JHthZGRyZXNzLmpvaW4oXCJcIil9YDtcXG4gICAgY2hlY2tzdW1BZGRyZXNzQ2FjaGUuc2V0KGAke2FkZHJlc3NffS4ke2NoYWluSWR9YCwgcmVzdWx0KTtcXG4gICAgcmV0dXJuIHJlc3VsdDtcXG4gIH1cXG4gIGZ1bmN0aW9uIGdldEFkZHJlc3MoYWRkcmVzcywgY2hhaW5JZCkge1xcbiAgICBpZiAoIWlzQWRkcmVzcyhhZGRyZXNzLCB7IHN0cmljdDogZmFsc2UgfSkpXFxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoeyBhZGRyZXNzIH0pO1xcbiAgICByZXR1cm4gY2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MsIGNoYWluSWQpO1xcbiAgfVxcbiAgdmFyIGNoZWNrc3VtQWRkcmVzc0NhY2hlO1xcbiAgdmFyIGluaXRfZ2V0QWRkcmVzcyA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9hZGRyZXNzL2dldEFkZHJlc3MuanNcIigpIHtcXG4gICAgICBpbml0X2FkZHJlc3MoKTtcXG4gICAgICBpbml0X3RvQnl0ZXMoKTtcXG4gICAgICBpbml0X2tlY2NhazI1NigpO1xcbiAgICAgIGluaXRfbHJ1KCk7XFxuICAgICAgaW5pdF9pc0FkZHJlc3MoKTtcXG4gICAgICBjaGVja3N1bUFkZHJlc3NDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTHJ1TWFwKDgxOTIpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2FkZHJlc3MvaXNBZGRyZXNzLmpzXFxuICBmdW5jdGlvbiBpc0FkZHJlc3MoYWRkcmVzcywgb3B0aW9ucykge1xcbiAgICBjb25zdCB7IHN0cmljdCA9IHRydWUgfSA9IG9wdGlvbnMgPz8ge307XFxuICAgIGNvbnN0IGNhY2hlS2V5MiA9IGAke2FkZHJlc3N9LiR7c3RyaWN0fWA7XFxuICAgIGlmIChpc0FkZHJlc3NDYWNoZS5oYXMoY2FjaGVLZXkyKSlcXG4gICAgICByZXR1cm4gaXNBZGRyZXNzQ2FjaGUuZ2V0KGNhY2hlS2V5Mik7XFxuICAgIGNvbnN0IHJlc3VsdCA9ICgoKSA9PiB7XFxuICAgICAgaWYgKCFhZGRyZXNzUmVnZXgudGVzdChhZGRyZXNzKSlcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICBpZiAoYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzKVxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgaWYgKHN0cmljdClcXG4gICAgICAgIHJldHVybiBjaGVja3N1bUFkZHJlc3MoYWRkcmVzcykgPT09IGFkZHJlc3M7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH0pKCk7XFxuICAgIGlzQWRkcmVzc0NhY2hlLnNldChjYWNoZUtleTIsIHJlc3VsdCk7XFxuICAgIHJldHVybiByZXN1bHQ7XFxuICB9XFxuICB2YXIgYWRkcmVzc1JlZ2V4LCBpc0FkZHJlc3NDYWNoZTtcXG4gIHZhciBpbml0X2lzQWRkcmVzcyA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9hZGRyZXNzL2lzQWRkcmVzcy5qc1wiKCkge1xcbiAgICAgIGluaXRfbHJ1KCk7XFxuICAgICAgaW5pdF9nZXRBZGRyZXNzKCk7XFxuICAgICAgYWRkcmVzc1JlZ2V4ID0gL14weFthLWZBLUYwLTldezQwfSQvO1xcbiAgICAgIGlzQWRkcmVzc0NhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBMcnVNYXAoODE5Mik7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvZGF0YS9jb25jYXQuanNcXG4gIGZ1bmN0aW9uIGNvbmNhdCh2YWx1ZXMpIHtcXG4gICAgaWYgKHR5cGVvZiB2YWx1ZXNbMF0gPT09IFwic3RyaW5nXCIpXFxuICAgICAgcmV0dXJuIGNvbmNhdEhleCh2YWx1ZXMpO1xcbiAgICByZXR1cm4gY29uY2F0Qnl0ZXMyKHZhbHVlcyk7XFxuICB9XFxuICBmdW5jdGlvbiBjb25jYXRCeXRlczIodmFsdWVzKSB7XFxuICAgIGxldCBsZW5ndGggPSAwO1xcbiAgICBmb3IgKGNvbnN0IGFyciBvZiB2YWx1ZXMpIHtcXG4gICAgICBsZW5ndGggKz0gYXJyLmxlbmd0aDtcXG4gICAgfVxcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xcbiAgICBsZXQgb2Zmc2V0ID0gMDtcXG4gICAgZm9yIChjb25zdCBhcnIgb2YgdmFsdWVzKSB7XFxuICAgICAgcmVzdWx0LnNldChhcnIsIG9mZnNldCk7XFxuICAgICAgb2Zmc2V0ICs9IGFyci5sZW5ndGg7XFxuICAgIH1cXG4gICAgcmV0dXJuIHJlc3VsdDtcXG4gIH1cXG4gIGZ1bmN0aW9uIGNvbmNhdEhleCh2YWx1ZXMpIHtcXG4gICAgcmV0dXJuIGAweCR7dmFsdWVzLnJlZHVjZSgoYWNjLCB4KSA9PiBhY2MgKyB4LnJlcGxhY2UoXCIweFwiLCBcIlwiKSwgXCJcIil9YDtcXG4gIH1cXG4gIHZhciBpbml0X2NvbmNhdCA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9kYXRhL2NvbmNhdC5qc1wiKCkge1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2RhdGEvc2xpY2UuanNcXG4gIGZ1bmN0aW9uIHNsaWNlKHZhbHVlLCBzdGFydCwgZW5kLCB7IHN0cmljdCB9ID0ge30pIHtcXG4gICAgaWYgKGlzSGV4KHZhbHVlLCB7IHN0cmljdDogZmFsc2UgfSkpXFxuICAgICAgcmV0dXJuIHNsaWNlSGV4KHZhbHVlLCBzdGFydCwgZW5kLCB7XFxuICAgICAgICBzdHJpY3RcXG4gICAgICB9KTtcXG4gICAgcmV0dXJuIHNsaWNlQnl0ZXModmFsdWUsIHN0YXJ0LCBlbmQsIHtcXG4gICAgICBzdHJpY3RcXG4gICAgfSk7XFxuICB9XFxuICBmdW5jdGlvbiBhc3NlcnRTdGFydE9mZnNldCh2YWx1ZSwgc3RhcnQpIHtcXG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gXCJudW1iZXJcIiAmJiBzdGFydCA+IDAgJiYgc3RhcnQgPiBzaXplKHZhbHVlKSAtIDEpXFxuICAgICAgdGhyb3cgbmV3IFNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcih7XFxuICAgICAgICBvZmZzZXQ6IHN0YXJ0LFxcbiAgICAgICAgcG9zaXRpb246IFwic3RhcnRcIixcXG4gICAgICAgIHNpemU6IHNpemUodmFsdWUpXFxuICAgICAgfSk7XFxuICB9XFxuICBmdW5jdGlvbiBhc3NlcnRFbmRPZmZzZXQodmFsdWUsIHN0YXJ0LCBlbmQpIHtcXG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgZW5kID09PSBcIm51bWJlclwiICYmIHNpemUodmFsdWUpICE9PSBlbmQgLSBzdGFydCkge1xcbiAgICAgIHRocm93IG5ldyBTbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3Ioe1xcbiAgICAgICAgb2Zmc2V0OiBlbmQsXFxuICAgICAgICBwb3NpdGlvbjogXCJlbmRcIixcXG4gICAgICAgIHNpemU6IHNpemUodmFsdWUpXFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH1cXG4gIGZ1bmN0aW9uIHNsaWNlQnl0ZXModmFsdWVfLCBzdGFydCwgZW5kLCB7IHN0cmljdCB9ID0ge30pIHtcXG4gICAgYXNzZXJ0U3RhcnRPZmZzZXQodmFsdWVfLCBzdGFydCk7XFxuICAgIGNvbnN0IHZhbHVlID0gdmFsdWVfLnNsaWNlKHN0YXJ0LCBlbmQpO1xcbiAgICBpZiAoc3RyaWN0KVxcbiAgICAgIGFzc2VydEVuZE9mZnNldCh2YWx1ZSwgc3RhcnQsIGVuZCk7XFxuICAgIHJldHVybiB2YWx1ZTtcXG4gIH1cXG4gIGZ1bmN0aW9uIHNsaWNlSGV4KHZhbHVlXywgc3RhcnQsIGVuZCwgeyBzdHJpY3QgfSA9IHt9KSB7XFxuICAgIGFzc2VydFN0YXJ0T2Zmc2V0KHZhbHVlXywgc3RhcnQpO1xcbiAgICBjb25zdCB2YWx1ZSA9IGAweCR7dmFsdWVfLnJlcGxhY2UoXCIweFwiLCBcIlwiKS5zbGljZSgoc3RhcnQgPz8gMCkgKiAyLCAoZW5kID8/IHZhbHVlXy5sZW5ndGgpICogMil9YDtcXG4gICAgaWYgKHN0cmljdClcXG4gICAgICBhc3NlcnRFbmRPZmZzZXQodmFsdWUsIHN0YXJ0LCBlbmQpO1xcbiAgICByZXR1cm4gdmFsdWU7XFxuICB9XFxuICB2YXIgaW5pdF9zbGljZSA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9kYXRhL3NsaWNlLmpzXCIoKSB7XFxuICAgICAgaW5pdF9kYXRhKCk7XFxuICAgICAgaW5pdF9pc0hleCgpO1xcbiAgICAgIGluaXRfc2l6ZSgpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL3JlZ2V4LmpzXFxuICB2YXIgYnl0ZXNSZWdleDIsIGludGVnZXJSZWdleDI7XFxuICB2YXIgaW5pdF9yZWdleDIgPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvcmVnZXguanNcIigpIHtcXG4gICAgICBieXRlc1JlZ2V4MiA9IC9eYnl0ZXMoWzEtOV18MVswLTldfDJbMC05XXwzWzAtMl0pPyQvO1xcbiAgICAgIGludGVnZXJSZWdleDIgPSAvXih1P2ludCkoOHwxNnwyNHwzMnw0MHw0OHw1Nnw2NHw3Mnw4MHw4OHw5NnwxMDR8MTEyfDEyMHwxMjh8MTM2fDE0NHwxNTJ8MTYwfDE2OHwxNzZ8MTg0fDE5MnwyMDB8MjA4fDIxNnwyMjR8MjMyfDI0MHwyNDh8MjU2KT8kLztcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9hYmkvZW5jb2RlQWJpUGFyYW1ldGVycy5qc1xcbiAgZnVuY3Rpb24gZW5jb2RlQWJpUGFyYW1ldGVycyhwYXJhbXMsIHZhbHVlcykge1xcbiAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aClcXG4gICAgICB0aHJvdyBuZXcgQWJpRW5jb2RpbmdMZW5ndGhNaXNtYXRjaEVycm9yKHtcXG4gICAgICAgIGV4cGVjdGVkTGVuZ3RoOiBwYXJhbXMubGVuZ3RoLFxcbiAgICAgICAgZ2l2ZW5MZW5ndGg6IHZhbHVlcy5sZW5ndGhcXG4gICAgICB9KTtcXG4gICAgY29uc3QgcHJlcGFyZWRQYXJhbXMgPSBwcmVwYXJlUGFyYW1zKHtcXG4gICAgICBwYXJhbXMsXFxuICAgICAgdmFsdWVzXFxuICAgIH0pO1xcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlUGFyYW1zKHByZXBhcmVkUGFyYW1zKTtcXG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKVxcbiAgICAgIHJldHVybiBcIjB4XCI7XFxuICAgIHJldHVybiBkYXRhO1xcbiAgfVxcbiAgZnVuY3Rpb24gcHJlcGFyZVBhcmFtcyh7IHBhcmFtcywgdmFsdWVzIH0pIHtcXG4gICAgY29uc3QgcHJlcGFyZWRQYXJhbXMgPSBbXTtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICBwcmVwYXJlZFBhcmFtcy5wdXNoKHByZXBhcmVQYXJhbSh7IHBhcmFtOiBwYXJhbXNbaV0sIHZhbHVlOiB2YWx1ZXNbaV0gfSkpO1xcbiAgICB9XFxuICAgIHJldHVybiBwcmVwYXJlZFBhcmFtcztcXG4gIH1cXG4gIGZ1bmN0aW9uIHByZXBhcmVQYXJhbSh7IHBhcmFtLCB2YWx1ZSB9KSB7XFxuICAgIGNvbnN0IGFycmF5Q29tcG9uZW50cyA9IGdldEFycmF5Q29tcG9uZW50cyhwYXJhbS50eXBlKTtcXG4gICAgaWYgKGFycmF5Q29tcG9uZW50cykge1xcbiAgICAgIGNvbnN0IFtsZW5ndGgsIHR5cGVdID0gYXJyYXlDb21wb25lbnRzO1xcbiAgICAgIHJldHVybiBlbmNvZGVBcnJheSh2YWx1ZSwgeyBsZW5ndGgsIHBhcmFtOiB7IC4uLnBhcmFtLCB0eXBlIH0gfSk7XFxuICAgIH1cXG4gICAgaWYgKHBhcmFtLnR5cGUgPT09IFwidHVwbGVcIikge1xcbiAgICAgIHJldHVybiBlbmNvZGVUdXBsZSh2YWx1ZSwge1xcbiAgICAgICAgcGFyYW1cXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJhZGRyZXNzXCIpIHtcXG4gICAgICByZXR1cm4gZW5jb2RlQWRkcmVzcyh2YWx1ZSk7XFxuICAgIH1cXG4gICAgaWYgKHBhcmFtLnR5cGUgPT09IFwiYm9vbFwiKSB7XFxuICAgICAgcmV0dXJuIGVuY29kZUJvb2wodmFsdWUpO1xcbiAgICB9XFxuICAgIGlmIChwYXJhbS50eXBlLnN0YXJ0c1dpdGgoXCJ1aW50XCIpIHx8IHBhcmFtLnR5cGUuc3RhcnRzV2l0aChcImludFwiKSkge1xcbiAgICAgIGNvbnN0IHNpZ25lZCA9IHBhcmFtLnR5cGUuc3RhcnRzV2l0aChcImludFwiKTtcXG4gICAgICBjb25zdCBbLCAsIHNpemU1ID0gXCIyNTZcIl0gPSBpbnRlZ2VyUmVnZXgyLmV4ZWMocGFyYW0udHlwZSkgPz8gW107XFxuICAgICAgcmV0dXJuIGVuY29kZU51bWJlcih2YWx1ZSwge1xcbiAgICAgICAgc2lnbmVkLFxcbiAgICAgICAgc2l6ZTogTnVtYmVyKHNpemU1KVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIGlmIChwYXJhbS50eXBlLnN0YXJ0c1dpdGgoXCJieXRlc1wiKSkge1xcbiAgICAgIHJldHVybiBlbmNvZGVCeXRlcyh2YWx1ZSwgeyBwYXJhbSB9KTtcXG4gICAgfVxcbiAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIikge1xcbiAgICAgIHJldHVybiBlbmNvZGVTdHJpbmcodmFsdWUpO1xcbiAgICB9XFxuICAgIHRocm93IG5ldyBJbnZhbGlkQWJpRW5jb2RpbmdUeXBlRXJyb3IocGFyYW0udHlwZSwge1xcbiAgICAgIGRvY3NQYXRoOiBcIi9kb2NzL2NvbnRyYWN0L2VuY29kZUFiaVBhcmFtZXRlcnNcIlxcbiAgICB9KTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGVuY29kZVBhcmFtcyhwcmVwYXJlZFBhcmFtcykge1xcbiAgICBsZXQgc3RhdGljU2l6ZSA9IDA7XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlcGFyZWRQYXJhbXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICBjb25zdCB7IGR5bmFtaWMsIGVuY29kZWQgfSA9IHByZXBhcmVkUGFyYW1zW2ldO1xcbiAgICAgIGlmIChkeW5hbWljKVxcbiAgICAgICAgc3RhdGljU2l6ZSArPSAzMjtcXG4gICAgICBlbHNlXFxuICAgICAgICBzdGF0aWNTaXplICs9IHNpemUoZW5jb2RlZCk7XFxuICAgIH1cXG4gICAgY29uc3Qgc3RhdGljUGFyYW1zID0gW107XFxuICAgIGNvbnN0IGR5bmFtaWNQYXJhbXMgPSBbXTtcXG4gICAgbGV0IGR5bmFtaWNTaXplID0gMDtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVwYXJlZFBhcmFtcy5sZW5ndGg7IGkrKykge1xcbiAgICAgIGNvbnN0IHsgZHluYW1pYywgZW5jb2RlZCB9ID0gcHJlcGFyZWRQYXJhbXNbaV07XFxuICAgICAgaWYgKGR5bmFtaWMpIHtcXG4gICAgICAgIHN0YXRpY1BhcmFtcy5wdXNoKG51bWJlclRvSGV4KHN0YXRpY1NpemUgKyBkeW5hbWljU2l6ZSwgeyBzaXplOiAzMiB9KSk7XFxuICAgICAgICBkeW5hbWljUGFyYW1zLnB1c2goZW5jb2RlZCk7XFxuICAgICAgICBkeW5hbWljU2l6ZSArPSBzaXplKGVuY29kZWQpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzdGF0aWNQYXJhbXMucHVzaChlbmNvZGVkKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIGNvbmNhdChbLi4uc3RhdGljUGFyYW1zLCAuLi5keW5hbWljUGFyYW1zXSk7XFxuICB9XFxuICBmdW5jdGlvbiBlbmNvZGVBZGRyZXNzKHZhbHVlKSB7XFxuICAgIGlmICghaXNBZGRyZXNzKHZhbHVlKSlcXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcih7IGFkZHJlc3M6IHZhbHVlIH0pO1xcbiAgICByZXR1cm4geyBkeW5hbWljOiBmYWxzZSwgZW5jb2RlZDogcGFkSGV4KHZhbHVlLnRvTG93ZXJDYXNlKCkpIH07XFxuICB9XFxuICBmdW5jdGlvbiBlbmNvZGVBcnJheSh2YWx1ZSwgeyBsZW5ndGgsIHBhcmFtIH0pIHtcXG4gICAgY29uc3QgZHluYW1pYyA9IGxlbmd0aCA9PT0gbnVsbDtcXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSlcXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFycmF5RXJyb3IodmFsdWUpO1xcbiAgICBpZiAoIWR5bmFtaWMgJiYgdmFsdWUubGVuZ3RoICE9PSBsZW5ndGgpXFxuICAgICAgdGhyb3cgbmV3IEFiaUVuY29kaW5nQXJyYXlMZW5ndGhNaXNtYXRjaEVycm9yKHtcXG4gICAgICAgIGV4cGVjdGVkTGVuZ3RoOiBsZW5ndGgsXFxuICAgICAgICBnaXZlbkxlbmd0aDogdmFsdWUubGVuZ3RoLFxcbiAgICAgICAgdHlwZTogYCR7cGFyYW0udHlwZX1bJHtsZW5ndGh9XWBcXG4gICAgICB9KTtcXG4gICAgbGV0IGR5bmFtaWNDaGlsZCA9IGZhbHNlO1xcbiAgICBjb25zdCBwcmVwYXJlZFBhcmFtcyA9IFtdO1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgY29uc3QgcHJlcGFyZWRQYXJhbSA9IHByZXBhcmVQYXJhbSh7IHBhcmFtLCB2YWx1ZTogdmFsdWVbaV0gfSk7XFxuICAgICAgaWYgKHByZXBhcmVkUGFyYW0uZHluYW1pYylcXG4gICAgICAgIGR5bmFtaWNDaGlsZCA9IHRydWU7XFxuICAgICAgcHJlcGFyZWRQYXJhbXMucHVzaChwcmVwYXJlZFBhcmFtKTtcXG4gICAgfVxcbiAgICBpZiAoZHluYW1pYyB8fCBkeW5hbWljQ2hpbGQpIHtcXG4gICAgICBjb25zdCBkYXRhID0gZW5jb2RlUGFyYW1zKHByZXBhcmVkUGFyYW1zKTtcXG4gICAgICBpZiAoZHluYW1pYykge1xcbiAgICAgICAgY29uc3QgbGVuZ3RoMiA9IG51bWJlclRvSGV4KHByZXBhcmVkUGFyYW1zLmxlbmd0aCwgeyBzaXplOiAzMiB9KTtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIGR5bmFtaWM6IHRydWUsXFxuICAgICAgICAgIGVuY29kZWQ6IHByZXBhcmVkUGFyYW1zLmxlbmd0aCA+IDAgPyBjb25jYXQoW2xlbmd0aDIsIGRhdGFdKSA6IGxlbmd0aDJcXG4gICAgICAgIH07XFxuICAgICAgfVxcbiAgICAgIGlmIChkeW5hbWljQ2hpbGQpXFxuICAgICAgICByZXR1cm4geyBkeW5hbWljOiB0cnVlLCBlbmNvZGVkOiBkYXRhIH07XFxuICAgIH1cXG4gICAgcmV0dXJuIHtcXG4gICAgICBkeW5hbWljOiBmYWxzZSxcXG4gICAgICBlbmNvZGVkOiBjb25jYXQocHJlcGFyZWRQYXJhbXMubWFwKCh7IGVuY29kZWQgfSkgPT4gZW5jb2RlZCkpXFxuICAgIH07XFxuICB9XFxuICBmdW5jdGlvbiBlbmNvZGVCeXRlcyh2YWx1ZSwgeyBwYXJhbSB9KSB7XFxuICAgIGNvbnN0IFssIHBhcmFtU2l6ZV0gPSBwYXJhbS50eXBlLnNwbGl0KFwiYnl0ZXNcIik7XFxuICAgIGNvbnN0IGJ5dGVzU2l6ZSA9IHNpemUodmFsdWUpO1xcbiAgICBpZiAoIXBhcmFtU2l6ZSkge1xcbiAgICAgIGxldCB2YWx1ZV8gPSB2YWx1ZTtcXG4gICAgICBpZiAoYnl0ZXNTaXplICUgMzIgIT09IDApXFxuICAgICAgICB2YWx1ZV8gPSBwYWRIZXgodmFsdWVfLCB7XFxuICAgICAgICAgIGRpcjogXCJyaWdodFwiLFxcbiAgICAgICAgICBzaXplOiBNYXRoLmNlaWwoKHZhbHVlLmxlbmd0aCAtIDIpIC8gMiAvIDMyKSAqIDMyXFxuICAgICAgICB9KTtcXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgZHluYW1pYzogdHJ1ZSxcXG4gICAgICAgIGVuY29kZWQ6IGNvbmNhdChbcGFkSGV4KG51bWJlclRvSGV4KGJ5dGVzU2l6ZSwgeyBzaXplOiAzMiB9KSksIHZhbHVlX10pXFxuICAgICAgfTtcXG4gICAgfVxcbiAgICBpZiAoYnl0ZXNTaXplICE9PSBOdW1iZXIucGFyc2VJbnQocGFyYW1TaXplKSlcXG4gICAgICB0aHJvdyBuZXcgQWJpRW5jb2RpbmdCeXRlc1NpemVNaXNtYXRjaEVycm9yKHtcXG4gICAgICAgIGV4cGVjdGVkU2l6ZTogTnVtYmVyLnBhcnNlSW50KHBhcmFtU2l6ZSksXFxuICAgICAgICB2YWx1ZVxcbiAgICAgIH0pO1xcbiAgICByZXR1cm4geyBkeW5hbWljOiBmYWxzZSwgZW5jb2RlZDogcGFkSGV4KHZhbHVlLCB7IGRpcjogXCJyaWdodFwiIH0pIH07XFxuICB9XFxuICBmdW5jdGlvbiBlbmNvZGVCb29sKHZhbHVlKSB7XFxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiYm9vbGVhblwiKVxcbiAgICAgIHRocm93IG5ldyBCYXNlRXJyb3IyKGBJbnZhbGlkIGJvb2xlYW4gdmFsdWU6IFwiJHt2YWx1ZX1cIiAodHlwZTogJHt0eXBlb2YgdmFsdWV9KS4gRXhwZWN0ZWQ6IFxcXFxgdHJ1ZVxcXFxgIG9yIFxcXFxgZmFsc2VcXFxcYC5gKTtcXG4gICAgcmV0dXJuIHsgZHluYW1pYzogZmFsc2UsIGVuY29kZWQ6IHBhZEhleChib29sVG9IZXgodmFsdWUpKSB9O1xcbiAgfVxcbiAgZnVuY3Rpb24gZW5jb2RlTnVtYmVyKHZhbHVlLCB7IHNpZ25lZCwgc2l6ZTogc2l6ZTUgPSAyNTYgfSkge1xcbiAgICBpZiAodHlwZW9mIHNpemU1ID09PSBcIm51bWJlclwiKSB7XFxuICAgICAgY29uc3QgbWF4ID0gMm4gKiogKEJpZ0ludChzaXplNSkgLSAoc2lnbmVkID8gMW4gOiAwbikpIC0gMW47XFxuICAgICAgY29uc3QgbWluID0gc2lnbmVkID8gLW1heCAtIDFuIDogMG47XFxuICAgICAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKVxcbiAgICAgICAgdGhyb3cgbmV3IEludGVnZXJPdXRPZlJhbmdlRXJyb3Ioe1xcbiAgICAgICAgICBtYXg6IG1heC50b1N0cmluZygpLFxcbiAgICAgICAgICBtaW46IG1pbi50b1N0cmluZygpLFxcbiAgICAgICAgICBzaWduZWQsXFxuICAgICAgICAgIHNpemU6IHNpemU1IC8gOCxcXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLnRvU3RyaW5nKClcXG4gICAgICAgIH0pO1xcbiAgICB9XFxuICAgIHJldHVybiB7XFxuICAgICAgZHluYW1pYzogZmFsc2UsXFxuICAgICAgZW5jb2RlZDogbnVtYmVyVG9IZXgodmFsdWUsIHtcXG4gICAgICAgIHNpemU6IDMyLFxcbiAgICAgICAgc2lnbmVkXFxuICAgICAgfSlcXG4gICAgfTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGVuY29kZVN0cmluZyh2YWx1ZSkge1xcbiAgICBjb25zdCBoZXhWYWx1ZSA9IHN0cmluZ1RvSGV4KHZhbHVlKTtcXG4gICAgY29uc3QgcGFydHNMZW5ndGggPSBNYXRoLmNlaWwoc2l6ZShoZXhWYWx1ZSkgLyAzMik7XFxuICAgIGNvbnN0IHBhcnRzID0gW107XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHNMZW5ndGg7IGkrKykge1xcbiAgICAgIHBhcnRzLnB1c2gocGFkSGV4KHNsaWNlKGhleFZhbHVlLCBpICogMzIsIChpICsgMSkgKiAzMiksIHtcXG4gICAgICAgIGRpcjogXCJyaWdodFwiXFxuICAgICAgfSkpO1xcbiAgICB9XFxuICAgIHJldHVybiB7XFxuICAgICAgZHluYW1pYzogdHJ1ZSxcXG4gICAgICBlbmNvZGVkOiBjb25jYXQoW1xcbiAgICAgICAgcGFkSGV4KG51bWJlclRvSGV4KHNpemUoaGV4VmFsdWUpLCB7IHNpemU6IDMyIH0pKSxcXG4gICAgICAgIC4uLnBhcnRzXFxuICAgICAgXSlcXG4gICAgfTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGVuY29kZVR1cGxlKHZhbHVlLCB7IHBhcmFtIH0pIHtcXG4gICAgbGV0IGR5bmFtaWMgPSBmYWxzZTtcXG4gICAgY29uc3QgcHJlcGFyZWRQYXJhbXMgPSBbXTtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbS5jb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgY29uc3QgcGFyYW1fID0gcGFyYW0uY29tcG9uZW50c1tpXTtcXG4gICAgICBjb25zdCBpbmRleDIgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IGkgOiBwYXJhbV8ubmFtZTtcXG4gICAgICBjb25zdCBwcmVwYXJlZFBhcmFtID0gcHJlcGFyZVBhcmFtKHtcXG4gICAgICAgIHBhcmFtOiBwYXJhbV8sXFxuICAgICAgICB2YWx1ZTogdmFsdWVbaW5kZXgyXVxcbiAgICAgIH0pO1xcbiAgICAgIHByZXBhcmVkUGFyYW1zLnB1c2gocHJlcGFyZWRQYXJhbSk7XFxuICAgICAgaWYgKHByZXBhcmVkUGFyYW0uZHluYW1pYylcXG4gICAgICAgIGR5bmFtaWMgPSB0cnVlO1xcbiAgICB9XFxuICAgIHJldHVybiB7XFxuICAgICAgZHluYW1pYyxcXG4gICAgICBlbmNvZGVkOiBkeW5hbWljID8gZW5jb2RlUGFyYW1zKHByZXBhcmVkUGFyYW1zKSA6IGNvbmNhdChwcmVwYXJlZFBhcmFtcy5tYXAoKHsgZW5jb2RlZCB9KSA9PiBlbmNvZGVkKSlcXG4gICAgfTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGdldEFycmF5Q29tcG9uZW50cyh0eXBlKSB7XFxuICAgIGNvbnN0IG1hdGNoZXMgPSB0eXBlLm1hdGNoKC9eKC4qKVxcXFxbKFxcXFxkKyk/XFxcXF0kLyk7XFxuICAgIHJldHVybiBtYXRjaGVzID8gKFxcbiAgICAgIC8vIFJldHVybiBgbnVsbGAgaWYgdGhlIGFycmF5IGlzIGR5bmFtaWMuXFxuICAgICAgW21hdGNoZXNbMl0gPyBOdW1iZXIobWF0Y2hlc1syXSkgOiBudWxsLCBtYXRjaGVzWzFdXVxcbiAgICApIDogdm9pZCAwO1xcbiAgfVxcbiAgdmFyIGluaXRfZW5jb2RlQWJpUGFyYW1ldGVycyA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9hYmkvZW5jb2RlQWJpUGFyYW1ldGVycy5qc1wiKCkge1xcbiAgICAgIGluaXRfYWJpKCk7XFxuICAgICAgaW5pdF9hZGRyZXNzKCk7XFxuICAgICAgaW5pdF9iYXNlKCk7XFxuICAgICAgaW5pdF9lbmNvZGluZygpO1xcbiAgICAgIGluaXRfaXNBZGRyZXNzKCk7XFxuICAgICAgaW5pdF9jb25jYXQoKTtcXG4gICAgICBpbml0X3BhZCgpO1xcbiAgICAgIGluaXRfc2l6ZSgpO1xcbiAgICAgIGluaXRfc2xpY2UoKTtcXG4gICAgICBpbml0X3RvSGV4KCk7XFxuICAgICAgaW5pdF9yZWdleDIoKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9oYXNoL3RvRnVuY3Rpb25TZWxlY3Rvci5qc1xcbiAgdmFyIHRvRnVuY3Rpb25TZWxlY3RvcjtcXG4gIHZhciBpbml0X3RvRnVuY3Rpb25TZWxlY3RvciA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9oYXNoL3RvRnVuY3Rpb25TZWxlY3Rvci5qc1wiKCkge1xcbiAgICAgIGluaXRfc2xpY2UoKTtcXG4gICAgICBpbml0X3RvU2lnbmF0dXJlSGFzaCgpO1xcbiAgICAgIHRvRnVuY3Rpb25TZWxlY3RvciA9IChmbikgPT4gc2xpY2UodG9TaWduYXR1cmVIYXNoKGZuKSwgMCwgNCk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvYWJpL2dldEFiaUl0ZW0uanNcXG4gIGZ1bmN0aW9uIGdldEFiaUl0ZW0ocGFyYW1ldGVycykge1xcbiAgICBjb25zdCB7IGFiaTogYWJpMiwgYXJncyA9IFtdLCBuYW1lIH0gPSBwYXJhbWV0ZXJzO1xcbiAgICBjb25zdCBpc1NlbGVjdG9yID0gaXNIZXgobmFtZSwgeyBzdHJpY3Q6IGZhbHNlIH0pO1xcbiAgICBjb25zdCBhYmlJdGVtcyA9IGFiaTIuZmlsdGVyKChhYmlJdGVtKSA9PiB7XFxuICAgICAgaWYgKGlzU2VsZWN0b3IpIHtcXG4gICAgICAgIGlmIChhYmlJdGVtLnR5cGUgPT09IFwiZnVuY3Rpb25cIilcXG4gICAgICAgICAgcmV0dXJuIHRvRnVuY3Rpb25TZWxlY3RvcihhYmlJdGVtKSA9PT0gbmFtZTtcXG4gICAgICAgIGlmIChhYmlJdGVtLnR5cGUgPT09IFwiZXZlbnRcIilcXG4gICAgICAgICAgcmV0dXJuIHRvRXZlbnRTZWxlY3RvcihhYmlJdGVtKSA9PT0gbmFtZTtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIFwibmFtZVwiIGluIGFiaUl0ZW0gJiYgYWJpSXRlbS5uYW1lID09PSBuYW1lO1xcbiAgICB9KTtcXG4gICAgaWYgKGFiaUl0ZW1zLmxlbmd0aCA9PT0gMClcXG4gICAgICByZXR1cm4gdm9pZCAwO1xcbiAgICBpZiAoYWJpSXRlbXMubGVuZ3RoID09PSAxKVxcbiAgICAgIHJldHVybiBhYmlJdGVtc1swXTtcXG4gICAgbGV0IG1hdGNoZWRBYmlJdGVtID0gdm9pZCAwO1xcbiAgICBmb3IgKGNvbnN0IGFiaUl0ZW0gb2YgYWJpSXRlbXMpIHtcXG4gICAgICBpZiAoIShcImlucHV0c1wiIGluIGFiaUl0ZW0pKVxcbiAgICAgICAgY29udGludWU7XFxuICAgICAgaWYgKCFhcmdzIHx8IGFyZ3MubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICBpZiAoIWFiaUl0ZW0uaW5wdXRzIHx8IGFiaUl0ZW0uaW5wdXRzLmxlbmd0aCA9PT0gMClcXG4gICAgICAgICAgcmV0dXJuIGFiaUl0ZW07XFxuICAgICAgICBjb250aW51ZTtcXG4gICAgICB9XFxuICAgICAgaWYgKCFhYmlJdGVtLmlucHV0cylcXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICAgIGlmIChhYmlJdGVtLmlucHV0cy5sZW5ndGggPT09IDApXFxuICAgICAgICBjb250aW51ZTtcXG4gICAgICBpZiAoYWJpSXRlbS5pbnB1dHMubGVuZ3RoICE9PSBhcmdzLmxlbmd0aClcXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICAgIGNvbnN0IG1hdGNoZWQgPSBhcmdzLmV2ZXJ5KChhcmcsIGluZGV4MikgPT4ge1xcbiAgICAgICAgY29uc3QgYWJpUGFyYW1ldGVyID0gXCJpbnB1dHNcIiBpbiBhYmlJdGVtICYmIGFiaUl0ZW0uaW5wdXRzW2luZGV4Ml07XFxuICAgICAgICBpZiAoIWFiaVBhcmFtZXRlcilcXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgcmV0dXJuIGlzQXJnT2ZUeXBlKGFyZywgYWJpUGFyYW1ldGVyKTtcXG4gICAgICB9KTtcXG4gICAgICBpZiAobWF0Y2hlZCkge1xcbiAgICAgICAgaWYgKG1hdGNoZWRBYmlJdGVtICYmIFwiaW5wdXRzXCIgaW4gbWF0Y2hlZEFiaUl0ZW0gJiYgbWF0Y2hlZEFiaUl0ZW0uaW5wdXRzKSB7XFxuICAgICAgICAgIGNvbnN0IGFtYmlndW91c1R5cGVzID0gZ2V0QW1iaWd1b3VzVHlwZXMoYWJpSXRlbS5pbnB1dHMsIG1hdGNoZWRBYmlJdGVtLmlucHV0cywgYXJncyk7XFxuICAgICAgICAgIGlmIChhbWJpZ3VvdXNUeXBlcylcXG4gICAgICAgICAgICB0aHJvdyBuZXcgQWJpSXRlbUFtYmlndWl0eUVycm9yKHtcXG4gICAgICAgICAgICAgIGFiaUl0ZW0sXFxuICAgICAgICAgICAgICB0eXBlOiBhbWJpZ3VvdXNUeXBlc1swXVxcbiAgICAgICAgICAgIH0sIHtcXG4gICAgICAgICAgICAgIGFiaUl0ZW06IG1hdGNoZWRBYmlJdGVtLFxcbiAgICAgICAgICAgICAgdHlwZTogYW1iaWd1b3VzVHlwZXNbMV1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICAgIG1hdGNoZWRBYmlJdGVtID0gYWJpSXRlbTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKG1hdGNoZWRBYmlJdGVtKVxcbiAgICAgIHJldHVybiBtYXRjaGVkQWJpSXRlbTtcXG4gICAgcmV0dXJuIGFiaUl0ZW1zWzBdO1xcbiAgfVxcbiAgZnVuY3Rpb24gaXNBcmdPZlR5cGUoYXJnLCBhYmlQYXJhbWV0ZXIpIHtcXG4gICAgY29uc3QgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XFxuICAgIGNvbnN0IGFiaVBhcmFtZXRlclR5cGUgPSBhYmlQYXJhbWV0ZXIudHlwZTtcXG4gICAgc3dpdGNoIChhYmlQYXJhbWV0ZXJUeXBlKSB7XFxuICAgICAgY2FzZSBcImFkZHJlc3NcIjpcXG4gICAgICAgIHJldHVybiBpc0FkZHJlc3MoYXJnLCB7IHN0cmljdDogZmFsc2UgfSk7XFxuICAgICAgY2FzZSBcImJvb2xcIjpcXG4gICAgICAgIHJldHVybiBhcmdUeXBlID09PSBcImJvb2xlYW5cIjtcXG4gICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcXG4gICAgICAgIHJldHVybiBhcmdUeXBlID09PSBcInN0cmluZ1wiO1xcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcXG4gICAgICAgIHJldHVybiBhcmdUeXBlID09PSBcInN0cmluZ1wiO1xcbiAgICAgIGRlZmF1bHQ6IHtcXG4gICAgICAgIGlmIChhYmlQYXJhbWV0ZXJUeXBlID09PSBcInR1cGxlXCIgJiYgXCJjb21wb25lbnRzXCIgaW4gYWJpUGFyYW1ldGVyKVxcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhhYmlQYXJhbWV0ZXIuY29tcG9uZW50cykuZXZlcnkoKGNvbXBvbmVudCwgaW5kZXgyKSA9PiB7XFxuICAgICAgICAgICAgcmV0dXJuIGlzQXJnT2ZUeXBlKE9iamVjdC52YWx1ZXMoYXJnKVtpbmRleDJdLCBjb21wb25lbnQpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIGlmICgvXnU/aW50KDh8MTZ8MjR8MzJ8NDB8NDh8NTZ8NjR8NzJ8ODB8ODh8OTZ8MTA0fDExMnwxMjB8MTI4fDEzNnwxNDR8MTUyfDE2MHwxNjh8MTc2fDE4NHwxOTJ8MjAwfDIwOHwyMTZ8MjI0fDIzMnwyNDB8MjQ4fDI1Nik/JC8udGVzdChhYmlQYXJhbWV0ZXJUeXBlKSlcXG4gICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT09IFwibnVtYmVyXCIgfHwgYXJnVHlwZSA9PT0gXCJiaWdpbnRcIjtcXG4gICAgICAgIGlmICgvXmJ5dGVzKFsxLTldfDFbMC05XXwyWzAtOV18M1swLTJdKT8kLy50ZXN0KGFiaVBhcmFtZXRlclR5cGUpKVxcbiAgICAgICAgICByZXR1cm4gYXJnVHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBhcmcgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xcbiAgICAgICAgaWYgKC9bYS16XStbMS05XXswLDN9KFxcXFxbWzAtOV17MCx9XFxcXF0pKyQvLnRlc3QoYWJpUGFyYW1ldGVyVHlwZSkpIHtcXG4gICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKSAmJiBhcmcuZXZlcnkoKHgpID0+IGlzQXJnT2ZUeXBlKHgsIHtcXG4gICAgICAgICAgICAuLi5hYmlQYXJhbWV0ZXIsXFxuICAgICAgICAgICAgLy8gUG9wIG9mZiBgW11gIG9yIGBbTV1gIGZyb20gZW5kIG9mIHR5cGVcXG4gICAgICAgICAgICB0eXBlOiBhYmlQYXJhbWV0ZXJUeXBlLnJlcGxhY2UoLyhcXFxcW1swLTldezAsfVxcXFxdKSQvLCBcIlwiKVxcbiAgICAgICAgICB9KSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuICBmdW5jdGlvbiBnZXRBbWJpZ3VvdXNUeXBlcyhzb3VyY2VQYXJhbWV0ZXJzLCB0YXJnZXRQYXJhbWV0ZXJzLCBhcmdzKSB7XFxuICAgIGZvciAoY29uc3QgcGFyYW1ldGVySW5kZXggaW4gc291cmNlUGFyYW1ldGVycykge1xcbiAgICAgIGNvbnN0IHNvdXJjZVBhcmFtZXRlciA9IHNvdXJjZVBhcmFtZXRlcnNbcGFyYW1ldGVySW5kZXhdO1xcbiAgICAgIGNvbnN0IHRhcmdldFBhcmFtZXRlciA9IHRhcmdldFBhcmFtZXRlcnNbcGFyYW1ldGVySW5kZXhdO1xcbiAgICAgIGlmIChzb3VyY2VQYXJhbWV0ZXIudHlwZSA9PT0gXCJ0dXBsZVwiICYmIHRhcmdldFBhcmFtZXRlci50eXBlID09PSBcInR1cGxlXCIgJiYgXCJjb21wb25lbnRzXCIgaW4gc291cmNlUGFyYW1ldGVyICYmIFwiY29tcG9uZW50c1wiIGluIHRhcmdldFBhcmFtZXRlcilcXG4gICAgICAgIHJldHVybiBnZXRBbWJpZ3VvdXNUeXBlcyhzb3VyY2VQYXJhbWV0ZXIuY29tcG9uZW50cywgdGFyZ2V0UGFyYW1ldGVyLmNvbXBvbmVudHMsIGFyZ3NbcGFyYW1ldGVySW5kZXhdKTtcXG4gICAgICBjb25zdCB0eXBlcyA9IFtzb3VyY2VQYXJhbWV0ZXIudHlwZSwgdGFyZ2V0UGFyYW1ldGVyLnR5cGVdO1xcbiAgICAgIGNvbnN0IGFtYmlndW91cyA9ICgoKSA9PiB7XFxuICAgICAgICBpZiAodHlwZXMuaW5jbHVkZXMoXCJhZGRyZXNzXCIpICYmIHR5cGVzLmluY2x1ZGVzKFwiYnl0ZXMyMFwiKSlcXG4gICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICBpZiAodHlwZXMuaW5jbHVkZXMoXCJhZGRyZXNzXCIpICYmIHR5cGVzLmluY2x1ZGVzKFwic3RyaW5nXCIpKVxcbiAgICAgICAgICByZXR1cm4gaXNBZGRyZXNzKGFyZ3NbcGFyYW1ldGVySW5kZXhdLCB7IHN0cmljdDogZmFsc2UgfSk7XFxuICAgICAgICBpZiAodHlwZXMuaW5jbHVkZXMoXCJhZGRyZXNzXCIpICYmIHR5cGVzLmluY2x1ZGVzKFwiYnl0ZXNcIikpXFxuICAgICAgICAgIHJldHVybiBpc0FkZHJlc3MoYXJnc1twYXJhbWV0ZXJJbmRleF0sIHsgc3RyaWN0OiBmYWxzZSB9KTtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9KSgpO1xcbiAgICAgIGlmIChhbWJpZ3VvdXMpXFxuICAgICAgICByZXR1cm4gdHlwZXM7XFxuICAgIH1cXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgdmFyIGluaXRfZ2V0QWJpSXRlbSA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9hYmkvZ2V0QWJpSXRlbS5qc1wiKCkge1xcbiAgICAgIGluaXRfYWJpKCk7XFxuICAgICAgaW5pdF9pc0hleCgpO1xcbiAgICAgIGluaXRfaXNBZGRyZXNzKCk7XFxuICAgICAgaW5pdF90b0V2ZW50U2VsZWN0b3IoKTtcXG4gICAgICBpbml0X3RvRnVuY3Rpb25TZWxlY3RvcigpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjY291bnRzL3V0aWxzL3BhcnNlQWNjb3VudC5qc1xcbiAgZnVuY3Rpb24gcGFyc2VBY2NvdW50KGFjY291bnQpIHtcXG4gICAgaWYgKHR5cGVvZiBhY2NvdW50ID09PSBcInN0cmluZ1wiKVxcbiAgICAgIHJldHVybiB7IGFkZHJlc3M6IGFjY291bnQsIHR5cGU6IFwianNvbi1ycGNcIiB9O1xcbiAgICByZXR1cm4gYWNjb3VudDtcXG4gIH1cXG4gIHZhciBpbml0X3BhcnNlQWNjb3VudCA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY2NvdW50cy91dGlscy9wYXJzZUFjY291bnQuanNcIigpIHtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9hYmkvcHJlcGFyZUVuY29kZUZ1bmN0aW9uRGF0YS5qc1xcbiAgZnVuY3Rpb24gcHJlcGFyZUVuY29kZUZ1bmN0aW9uRGF0YShwYXJhbWV0ZXJzKSB7XFxuICAgIGNvbnN0IHsgYWJpOiBhYmkyLCBhcmdzLCBmdW5jdGlvbk5hbWUgfSA9IHBhcmFtZXRlcnM7XFxuICAgIGxldCBhYmlJdGVtID0gYWJpMlswXTtcXG4gICAgaWYgKGZ1bmN0aW9uTmFtZSkge1xcbiAgICAgIGNvbnN0IGl0ZW0gPSBnZXRBYmlJdGVtKHtcXG4gICAgICAgIGFiaTogYWJpMixcXG4gICAgICAgIGFyZ3MsXFxuICAgICAgICBuYW1lOiBmdW5jdGlvbk5hbWVcXG4gICAgICB9KTtcXG4gICAgICBpZiAoIWl0ZW0pXFxuICAgICAgICB0aHJvdyBuZXcgQWJpRnVuY3Rpb25Ob3RGb3VuZEVycm9yKGZ1bmN0aW9uTmFtZSwgeyBkb2NzUGF0aDogZG9jc1BhdGgyIH0pO1xcbiAgICAgIGFiaUl0ZW0gPSBpdGVtO1xcbiAgICB9XFxuICAgIGlmIChhYmlJdGVtLnR5cGUgIT09IFwiZnVuY3Rpb25cIilcXG4gICAgICB0aHJvdyBuZXcgQWJpRnVuY3Rpb25Ob3RGb3VuZEVycm9yKHZvaWQgMCwgeyBkb2NzUGF0aDogZG9jc1BhdGgyIH0pO1xcbiAgICByZXR1cm4ge1xcbiAgICAgIGFiaTogW2FiaUl0ZW1dLFxcbiAgICAgIGZ1bmN0aW9uTmFtZTogdG9GdW5jdGlvblNlbGVjdG9yKGZvcm1hdEFiaUl0ZW0yKGFiaUl0ZW0pKVxcbiAgICB9O1xcbiAgfVxcbiAgdmFyIGRvY3NQYXRoMjtcXG4gIHZhciBpbml0X3ByZXBhcmVFbmNvZGVGdW5jdGlvbkRhdGEgPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvYWJpL3ByZXBhcmVFbmNvZGVGdW5jdGlvbkRhdGEuanNcIigpIHtcXG4gICAgICBpbml0X2FiaSgpO1xcbiAgICAgIGluaXRfdG9GdW5jdGlvblNlbGVjdG9yKCk7XFxuICAgICAgaW5pdF9mb3JtYXRBYmlJdGVtMigpO1xcbiAgICAgIGluaXRfZ2V0QWJpSXRlbSgpO1xcbiAgICAgIGRvY3NQYXRoMiA9IFwiL2RvY3MvY29udHJhY3QvZW5jb2RlRnVuY3Rpb25EYXRhXCI7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvYWJpL2VuY29kZUZ1bmN0aW9uRGF0YS5qc1xcbiAgZnVuY3Rpb24gZW5jb2RlRnVuY3Rpb25EYXRhKHBhcmFtZXRlcnMpIHtcXG4gICAgY29uc3QgeyBhcmdzIH0gPSBwYXJhbWV0ZXJzO1xcbiAgICBjb25zdCB7IGFiaTogYWJpMiwgZnVuY3Rpb25OYW1lIH0gPSAoKCkgPT4ge1xcbiAgICAgIGlmIChwYXJhbWV0ZXJzLmFiaS5sZW5ndGggPT09IDEgJiYgcGFyYW1ldGVycy5mdW5jdGlvbk5hbWU/LnN0YXJ0c1dpdGgoXCIweFwiKSlcXG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzO1xcbiAgICAgIHJldHVybiBwcmVwYXJlRW5jb2RlRnVuY3Rpb25EYXRhKHBhcmFtZXRlcnMpO1xcbiAgICB9KSgpO1xcbiAgICBjb25zdCBhYmlJdGVtID0gYWJpMlswXTtcXG4gICAgY29uc3Qgc2lnbmF0dXJlID0gZnVuY3Rpb25OYW1lO1xcbiAgICBjb25zdCBkYXRhID0gXCJpbnB1dHNcIiBpbiBhYmlJdGVtICYmIGFiaUl0ZW0uaW5wdXRzID8gZW5jb2RlQWJpUGFyYW1ldGVycyhhYmlJdGVtLmlucHV0cywgYXJncyA/PyBbXSkgOiB2b2lkIDA7XFxuICAgIHJldHVybiBjb25jYXRIZXgoW3NpZ25hdHVyZSwgZGF0YSA/PyBcIjB4XCJdKTtcXG4gIH1cXG4gIHZhciBpbml0X2VuY29kZUZ1bmN0aW9uRGF0YSA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9hYmkvZW5jb2RlRnVuY3Rpb25EYXRhLmpzXCIoKSB7XFxuICAgICAgaW5pdF9jb25jYXQoKTtcXG4gICAgICBpbml0X2VuY29kZUFiaVBhcmFtZXRlcnMoKTtcXG4gICAgICBpbml0X3ByZXBhcmVFbmNvZGVGdW5jdGlvbkRhdGEoKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9jb25zdGFudHMvc29saWRpdHkuanNcXG4gIHZhciBwYW5pY1JlYXNvbnMsIHNvbGlkaXR5RXJyb3IsIHNvbGlkaXR5UGFuaWM7XFxuICB2YXIgaW5pdF9zb2xpZGl0eSA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9jb25zdGFudHMvc29saWRpdHkuanNcIigpIHtcXG4gICAgICBwYW5pY1JlYXNvbnMgPSB7XFxuICAgICAgICAxOiBcIkFuIGBhc3NlcnRgIGNvbmRpdGlvbiBmYWlsZWQuXCIsXFxuICAgICAgICAxNzogXCJBcml0aG1ldGljIG9wZXJhdGlvbiByZXN1bHRlZCBpbiB1bmRlcmZsb3cgb3Igb3ZlcmZsb3cuXCIsXFxuICAgICAgICAxODogXCJEaXZpc2lvbiBvciBtb2R1bG8gYnkgemVybyAoZS5nLiBgNSAvIDBgIG9yIGAyMyAlIDBgKS5cIixcXG4gICAgICAgIDMzOiBcIkF0dGVtcHRlZCB0byBjb252ZXJ0IHRvIGFuIGludmFsaWQgdHlwZS5cIixcXG4gICAgICAgIDM0OiBcIkF0dGVtcHRlZCB0byBhY2Nlc3MgYSBzdG9yYWdlIGJ5dGUgYXJyYXkgdGhhdCBpcyBpbmNvcnJlY3RseSBlbmNvZGVkLlwiLFxcbiAgICAgICAgNDk6IFwiUGVyZm9ybWVkIGAucG9wKClgIG9uIGFuIGVtcHR5IGFycmF5XCIsXFxuICAgICAgICA1MDogXCJBcnJheSBpbmRleCBpcyBvdXQgb2YgYm91bmRzLlwiLFxcbiAgICAgICAgNjU6IFwiQWxsb2NhdGVkIHRvbyBtdWNoIG1lbW9yeSBvciBjcmVhdGVkIGFuIGFycmF5IHdoaWNoIGlzIHRvbyBsYXJnZS5cIixcXG4gICAgICAgIDgxOiBcIkF0dGVtcHRlZCB0byBjYWxsIGEgemVyby1pbml0aWFsaXplZCB2YXJpYWJsZSBvZiBpbnRlcm5hbCBmdW5jdGlvbiB0eXBlLlwiXFxuICAgICAgfTtcXG4gICAgICBzb2xpZGl0eUVycm9yID0ge1xcbiAgICAgICAgaW5wdXRzOiBbXFxuICAgICAgICAgIHtcXG4gICAgICAgICAgICBuYW1lOiBcIm1lc3NhZ2VcIixcXG4gICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXFxuICAgICAgICAgIH1cXG4gICAgICAgIF0sXFxuICAgICAgICBuYW1lOiBcIkVycm9yXCIsXFxuICAgICAgICB0eXBlOiBcImVycm9yXCJcXG4gICAgICB9O1xcbiAgICAgIHNvbGlkaXR5UGFuaWMgPSB7XFxuICAgICAgICBpbnB1dHM6IFtcXG4gICAgICAgICAge1xcbiAgICAgICAgICAgIG5hbWU6IFwicmVhc29uXCIsXFxuICAgICAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcXG4gICAgICAgICAgfVxcbiAgICAgICAgXSxcXG4gICAgICAgIG5hbWU6IFwiUGFuaWNcIixcXG4gICAgICAgIHR5cGU6IFwiZXJyb3JcIlxcbiAgICAgIH07XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vZXJyb3JzL2N1cnNvci5qc1xcbiAgdmFyIE5lZ2F0aXZlT2Zmc2V0RXJyb3IsIFBvc2l0aW9uT3V0T2ZCb3VuZHNFcnJvciwgUmVjdXJzaXZlUmVhZExpbWl0RXhjZWVkZWRFcnJvcjtcXG4gIHZhciBpbml0X2N1cnNvciA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9lcnJvcnMvY3Vyc29yLmpzXCIoKSB7XFxuICAgICAgaW5pdF9iYXNlKCk7XFxuICAgICAgTmVnYXRpdmVPZmZzZXRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgICAgICBjb25zdHJ1Y3Rvcih7IG9mZnNldCB9KSB7XFxuICAgICAgICAgIHN1cGVyKGBPZmZzZXQgXFxcXGAke29mZnNldH1cXFxcYCBjYW5ub3QgYmUgbmVnYXRpdmUuYCwge1xcbiAgICAgICAgICAgIG5hbWU6IFwiTmVnYXRpdmVPZmZzZXRFcnJvclwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgUG9zaXRpb25PdXRPZkJvdW5kc0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IyIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKHsgbGVuZ3RoLCBwb3NpdGlvbiB9KSB7XFxuICAgICAgICAgIHN1cGVyKGBQb3NpdGlvbiBcXFxcYCR7cG9zaXRpb259XFxcXGAgaXMgb3V0IG9mIGJvdW5kcyAoXFxcXGAwIDwgcG9zaXRpb24gPCAke2xlbmd0aH1cXFxcYCkuYCwgeyBuYW1lOiBcIlBvc2l0aW9uT3V0T2ZCb3VuZHNFcnJvclwiIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgUmVjdXJzaXZlUmVhZExpbWl0RXhjZWVkZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgICAgICBjb25zdHJ1Y3Rvcih7IGNvdW50LCBsaW1pdCB9KSB7XFxuICAgICAgICAgIHN1cGVyKGBSZWN1cnNpdmUgcmVhZCBsaW1pdCBvZiBcXFxcYCR7bGltaXR9XFxcXGAgZXhjZWVkZWQgKHJlY3Vyc2l2ZSByZWFkIGNvdW50OiBcXFxcYCR7Y291bnR9XFxcXGApLmAsIHsgbmFtZTogXCJSZWN1cnNpdmVSZWFkTGltaXRFeGNlZWRlZEVycm9yXCIgfSk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9jdXJzb3IuanNcXG4gIGZ1bmN0aW9uIGNyZWF0ZUN1cnNvcihieXRlcywgeyByZWN1cnNpdmVSZWFkTGltaXQgPSA4MTkyIH0gPSB7fSkge1xcbiAgICBjb25zdCBjdXJzb3IgPSBPYmplY3QuY3JlYXRlKHN0YXRpY0N1cnNvcik7XFxuICAgIGN1cnNvci5ieXRlcyA9IGJ5dGVzO1xcbiAgICBjdXJzb3IuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnl0ZXMuYnVmZmVyLCBieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlTGVuZ3RoKTtcXG4gICAgY3Vyc29yLnBvc2l0aW9uUmVhZENvdW50ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcXG4gICAgY3Vyc29yLnJlY3Vyc2l2ZVJlYWRMaW1pdCA9IHJlY3Vyc2l2ZVJlYWRMaW1pdDtcXG4gICAgcmV0dXJuIGN1cnNvcjtcXG4gIH1cXG4gIHZhciBzdGF0aWNDdXJzb3I7XFxuICB2YXIgaW5pdF9jdXJzb3IyID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2N1cnNvci5qc1wiKCkge1xcbiAgICAgIGluaXRfY3Vyc29yKCk7XFxuICAgICAgc3RhdGljQ3Vyc29yID0ge1xcbiAgICAgICAgYnl0ZXM6IG5ldyBVaW50OEFycmF5KCksXFxuICAgICAgICBkYXRhVmlldzogbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigwKSksXFxuICAgICAgICBwb3NpdGlvbjogMCxcXG4gICAgICAgIHBvc2l0aW9uUmVhZENvdW50OiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxcbiAgICAgICAgcmVjdXJzaXZlUmVhZENvdW50OiAwLFxcbiAgICAgICAgcmVjdXJzaXZlUmVhZExpbWl0OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXFxuICAgICAgICBhc3NlcnRSZWFkTGltaXQoKSB7XFxuICAgICAgICAgIGlmICh0aGlzLnJlY3Vyc2l2ZVJlYWRDb3VudCA+PSB0aGlzLnJlY3Vyc2l2ZVJlYWRMaW1pdClcXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVjdXJzaXZlUmVhZExpbWl0RXhjZWVkZWRFcnJvcih7XFxuICAgICAgICAgICAgICBjb3VudDogdGhpcy5yZWN1cnNpdmVSZWFkQ291bnQgKyAxLFxcbiAgICAgICAgICAgICAgbGltaXQ6IHRoaXMucmVjdXJzaXZlUmVhZExpbWl0XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9LFxcbiAgICAgICAgYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24pIHtcXG4gICAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCB8fCBwb3NpdGlvbiA+IHRoaXMuYnl0ZXMubGVuZ3RoIC0gMSlcXG4gICAgICAgICAgICB0aHJvdyBuZXcgUG9zaXRpb25PdXRPZkJvdW5kc0Vycm9yKHtcXG4gICAgICAgICAgICAgIGxlbmd0aDogdGhpcy5ieXRlcy5sZW5ndGgsXFxuICAgICAgICAgICAgICBwb3NpdGlvblxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGRlY3JlbWVudFBvc2l0aW9uKG9mZnNldCkge1xcbiAgICAgICAgICBpZiAob2Zmc2V0IDwgMClcXG4gICAgICAgICAgICB0aHJvdyBuZXcgTmVnYXRpdmVPZmZzZXRFcnJvcih7IG9mZnNldCB9KTtcXG4gICAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uIC0gb2Zmc2V0O1xcbiAgICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHBvc2l0aW9uKTtcXG4gICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGdldFJlYWRDb3VudChwb3NpdGlvbikge1xcbiAgICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvblJlYWRDb3VudC5nZXQocG9zaXRpb24gfHwgdGhpcy5wb3NpdGlvbikgfHwgMDtcXG4gICAgICAgIH0sXFxuICAgICAgICBpbmNyZW1lbnRQb3NpdGlvbihvZmZzZXQpIHtcXG4gICAgICAgICAgaWYgKG9mZnNldCA8IDApXFxuICAgICAgICAgICAgdGhyb3cgbmV3IE5lZ2F0aXZlT2Zmc2V0RXJyb3IoeyBvZmZzZXQgfSk7XFxuICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbiArIG9mZnNldDtcXG4gICAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbik7XFxuICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcXG4gICAgICAgIH0sXFxuICAgICAgICBpbnNwZWN0Qnl0ZShwb3NpdGlvbl8pIHtcXG4gICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbl8gPz8gdGhpcy5wb3NpdGlvbjtcXG4gICAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbik7XFxuICAgICAgICAgIHJldHVybiB0aGlzLmJ5dGVzW3Bvc2l0aW9uXTtcXG4gICAgICAgIH0sXFxuICAgICAgICBpbnNwZWN0Qnl0ZXMobGVuZ3RoLCBwb3NpdGlvbl8pIHtcXG4gICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbl8gPz8gdGhpcy5wb3NpdGlvbjtcXG4gICAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbiArIGxlbmd0aCAtIDEpO1xcbiAgICAgICAgICByZXR1cm4gdGhpcy5ieXRlcy5zdWJhcnJheShwb3NpdGlvbiwgcG9zaXRpb24gKyBsZW5ndGgpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGluc3BlY3RVaW50OChwb3NpdGlvbl8pIHtcXG4gICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbl8gPz8gdGhpcy5wb3NpdGlvbjtcXG4gICAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbik7XFxuICAgICAgICAgIHJldHVybiB0aGlzLmJ5dGVzW3Bvc2l0aW9uXTtcXG4gICAgICAgIH0sXFxuICAgICAgICBpbnNwZWN0VWludDE2KHBvc2l0aW9uXykge1xcbiAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uXyA/PyB0aGlzLnBvc2l0aW9uO1xcbiAgICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHBvc2l0aW9uICsgMSk7XFxuICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFWaWV3LmdldFVpbnQxNihwb3NpdGlvbik7XFxuICAgICAgICB9LFxcbiAgICAgICAgaW5zcGVjdFVpbnQyNChwb3NpdGlvbl8pIHtcXG4gICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbl8gPz8gdGhpcy5wb3NpdGlvbjtcXG4gICAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbiArIDIpO1xcbiAgICAgICAgICByZXR1cm4gKHRoaXMuZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uKSA8PCA4KSArIHRoaXMuZGF0YVZpZXcuZ2V0VWludDgocG9zaXRpb24gKyAyKTtcXG4gICAgICAgIH0sXFxuICAgICAgICBpbnNwZWN0VWludDMyKHBvc2l0aW9uXykge1xcbiAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uXyA/PyB0aGlzLnBvc2l0aW9uO1xcbiAgICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHBvc2l0aW9uICsgMyk7XFxuICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbik7XFxuICAgICAgICB9LFxcbiAgICAgICAgcHVzaEJ5dGUoYnl0ZSkge1xcbiAgICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHRoaXMucG9zaXRpb24pO1xcbiAgICAgICAgICB0aGlzLmJ5dGVzW3RoaXMucG9zaXRpb25dID0gYnl0ZTtcXG4gICAgICAgICAgdGhpcy5wb3NpdGlvbisrO1xcbiAgICAgICAgfSxcXG4gICAgICAgIHB1c2hCeXRlcyhieXRlcykge1xcbiAgICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHRoaXMucG9zaXRpb24gKyBieXRlcy5sZW5ndGggLSAxKTtcXG4gICAgICAgICAgdGhpcy5ieXRlcy5zZXQoYnl0ZXMsIHRoaXMucG9zaXRpb24pO1xcbiAgICAgICAgICB0aGlzLnBvc2l0aW9uICs9IGJ5dGVzLmxlbmd0aDtcXG4gICAgICAgIH0sXFxuICAgICAgICBwdXNoVWludDgodmFsdWUpIHtcXG4gICAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbih0aGlzLnBvc2l0aW9uKTtcXG4gICAgICAgICAgdGhpcy5ieXRlc1t0aGlzLnBvc2l0aW9uXSA9IHZhbHVlO1xcbiAgICAgICAgICB0aGlzLnBvc2l0aW9uKys7XFxuICAgICAgICB9LFxcbiAgICAgICAgcHVzaFVpbnQxNih2YWx1ZSkge1xcbiAgICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHRoaXMucG9zaXRpb24gKyAxKTtcXG4gICAgICAgICAgdGhpcy5kYXRhVmlldy5zZXRVaW50MTYodGhpcy5wb3NpdGlvbiwgdmFsdWUpO1xcbiAgICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDI7XFxuICAgICAgICB9LFxcbiAgICAgICAgcHVzaFVpbnQyNCh2YWx1ZSkge1xcbiAgICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHRoaXMucG9zaXRpb24gKyAyKTtcXG4gICAgICAgICAgdGhpcy5kYXRhVmlldy5zZXRVaW50MTYodGhpcy5wb3NpdGlvbiwgdmFsdWUgPj4gOCk7XFxuICAgICAgICAgIHRoaXMuZGF0YVZpZXcuc2V0VWludDgodGhpcy5wb3NpdGlvbiArIDIsIHZhbHVlICYgfjQyOTQ5NjcwNDApO1xcbiAgICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDM7XFxuICAgICAgICB9LFxcbiAgICAgICAgcHVzaFVpbnQzMih2YWx1ZSkge1xcbiAgICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHRoaXMucG9zaXRpb24gKyAzKTtcXG4gICAgICAgICAgdGhpcy5kYXRhVmlldy5zZXRVaW50MzIodGhpcy5wb3NpdGlvbiwgdmFsdWUpO1xcbiAgICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDQ7XFxuICAgICAgICB9LFxcbiAgICAgICAgcmVhZEJ5dGUoKSB7XFxuICAgICAgICAgIHRoaXMuYXNzZXJ0UmVhZExpbWl0KCk7XFxuICAgICAgICAgIHRoaXMuX3RvdWNoKCk7XFxuICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnNwZWN0Qnl0ZSgpO1xcbiAgICAgICAgICB0aGlzLnBvc2l0aW9uKys7XFxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICAgIH0sXFxuICAgICAgICByZWFkQnl0ZXMobGVuZ3RoLCBzaXplNSkge1xcbiAgICAgICAgICB0aGlzLmFzc2VydFJlYWRMaW1pdCgpO1xcbiAgICAgICAgICB0aGlzLl90b3VjaCgpO1xcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5zcGVjdEJ5dGVzKGxlbmd0aCk7XFxuICAgICAgICAgIHRoaXMucG9zaXRpb24gKz0gc2l6ZTUgPz8gbGVuZ3RoO1xcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgICB9LFxcbiAgICAgICAgcmVhZFVpbnQ4KCkge1xcbiAgICAgICAgICB0aGlzLmFzc2VydFJlYWRMaW1pdCgpO1xcbiAgICAgICAgICB0aGlzLl90b3VjaCgpO1xcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5zcGVjdFVpbnQ4KCk7XFxuICAgICAgICAgIHRoaXMucG9zaXRpb24gKz0gMTtcXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlYWRVaW50MTYoKSB7XFxuICAgICAgICAgIHRoaXMuYXNzZXJ0UmVhZExpbWl0KCk7XFxuICAgICAgICAgIHRoaXMuX3RvdWNoKCk7XFxuICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnNwZWN0VWludDE2KCk7XFxuICAgICAgICAgIHRoaXMucG9zaXRpb24gKz0gMjtcXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlYWRVaW50MjQoKSB7XFxuICAgICAgICAgIHRoaXMuYXNzZXJ0UmVhZExpbWl0KCk7XFxuICAgICAgICAgIHRoaXMuX3RvdWNoKCk7XFxuICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnNwZWN0VWludDI0KCk7XFxuICAgICAgICAgIHRoaXMucG9zaXRpb24gKz0gMztcXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgICAgfSxcXG4gICAgICAgIHJlYWRVaW50MzIoKSB7XFxuICAgICAgICAgIHRoaXMuYXNzZXJ0UmVhZExpbWl0KCk7XFxuICAgICAgICAgIHRoaXMuX3RvdWNoKCk7XFxuICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnNwZWN0VWludDMyKCk7XFxuICAgICAgICAgIHRoaXMucG9zaXRpb24gKz0gNDtcXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGdldCByZW1haW5pbmcoKSB7XFxuICAgICAgICAgIHJldHVybiB0aGlzLmJ5dGVzLmxlbmd0aCAtIHRoaXMucG9zaXRpb247XFxuICAgICAgICB9LFxcbiAgICAgICAgc2V0UG9zaXRpb24ocG9zaXRpb24pIHtcXG4gICAgICAgICAgY29uc3Qgb2xkUG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xcbiAgICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHBvc2l0aW9uKTtcXG4gICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xcbiAgICAgICAgICByZXR1cm4gKCkgPT4gdGhpcy5wb3NpdGlvbiA9IG9sZFBvc2l0aW9uO1xcbiAgICAgICAgfSxcXG4gICAgICAgIF90b3VjaCgpIHtcXG4gICAgICAgICAgaWYgKHRoaXMucmVjdXJzaXZlUmVhZExpbWl0ID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpXFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICBjb25zdCBjb3VudCA9IHRoaXMuZ2V0UmVhZENvdW50KCk7XFxuICAgICAgICAgIHRoaXMucG9zaXRpb25SZWFkQ291bnQuc2V0KHRoaXMucG9zaXRpb24sIGNvdW50ICsgMSk7XFxuICAgICAgICAgIGlmIChjb3VudCA+IDApXFxuICAgICAgICAgICAgdGhpcy5yZWN1cnNpdmVSZWFkQ291bnQrKztcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2VuY29kaW5nL2Zyb21CeXRlcy5qc1xcbiAgZnVuY3Rpb24gYnl0ZXNUb0JpZ0ludChieXRlcywgb3B0cyA9IHt9KSB7XFxuICAgIGlmICh0eXBlb2Ygb3B0cy5zaXplICE9PSBcInVuZGVmaW5lZFwiKVxcbiAgICAgIGFzc2VydFNpemUoYnl0ZXMsIHsgc2l6ZTogb3B0cy5zaXplIH0pO1xcbiAgICBjb25zdCBoZXggPSBieXRlc1RvSGV4KGJ5dGVzLCBvcHRzKTtcXG4gICAgcmV0dXJuIGhleFRvQmlnSW50KGhleCwgb3B0cyk7XFxuICB9XFxuICBmdW5jdGlvbiBieXRlc1RvQm9vbChieXRlc18sIG9wdHMgPSB7fSkge1xcbiAgICBsZXQgYnl0ZXMgPSBieXRlc187XFxuICAgIGlmICh0eXBlb2Ygb3B0cy5zaXplICE9PSBcInVuZGVmaW5lZFwiKSB7XFxuICAgICAgYXNzZXJ0U2l6ZShieXRlcywgeyBzaXplOiBvcHRzLnNpemUgfSk7XFxuICAgICAgYnl0ZXMgPSB0cmltKGJ5dGVzKTtcXG4gICAgfVxcbiAgICBpZiAoYnl0ZXMubGVuZ3RoID4gMSB8fCBieXRlc1swXSA+IDEpXFxuICAgICAgdGhyb3cgbmV3IEludmFsaWRCeXRlc0Jvb2xlYW5FcnJvcihieXRlcyk7XFxuICAgIHJldHVybiBCb29sZWFuKGJ5dGVzWzBdKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXIoYnl0ZXMsIG9wdHMgPSB7fSkge1xcbiAgICBpZiAodHlwZW9mIG9wdHMuc2l6ZSAhPT0gXCJ1bmRlZmluZWRcIilcXG4gICAgICBhc3NlcnRTaXplKGJ5dGVzLCB7IHNpemU6IG9wdHMuc2l6ZSB9KTtcXG4gICAgY29uc3QgaGV4ID0gYnl0ZXNUb0hleChieXRlcywgb3B0cyk7XFxuICAgIHJldHVybiBoZXhUb051bWJlcihoZXgsIG9wdHMpO1xcbiAgfVxcbiAgZnVuY3Rpb24gYnl0ZXNUb1N0cmluZyhieXRlc18sIG9wdHMgPSB7fSkge1xcbiAgICBsZXQgYnl0ZXMgPSBieXRlc187XFxuICAgIGlmICh0eXBlb2Ygb3B0cy5zaXplICE9PSBcInVuZGVmaW5lZFwiKSB7XFxuICAgICAgYXNzZXJ0U2l6ZShieXRlcywgeyBzaXplOiBvcHRzLnNpemUgfSk7XFxuICAgICAgYnl0ZXMgPSB0cmltKGJ5dGVzLCB7IGRpcjogXCJyaWdodFwiIH0pO1xcbiAgICB9XFxuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnl0ZXMpO1xcbiAgfVxcbiAgdmFyIGluaXRfZnJvbUJ5dGVzID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2VuY29kaW5nL2Zyb21CeXRlcy5qc1wiKCkge1xcbiAgICAgIGluaXRfZW5jb2RpbmcoKTtcXG4gICAgICBpbml0X3RyaW0oKTtcXG4gICAgICBpbml0X2Zyb21IZXgoKTtcXG4gICAgICBpbml0X3RvSGV4KCk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvYWJpL2RlY29kZUFiaVBhcmFtZXRlcnMuanNcXG4gIGZ1bmN0aW9uIGRlY29kZUFiaVBhcmFtZXRlcnMocGFyYW1zLCBkYXRhKSB7XFxuICAgIGNvbnN0IGJ5dGVzID0gdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgPyBoZXhUb0J5dGVzKGRhdGEpIDogZGF0YTtcXG4gICAgY29uc3QgY3Vyc29yID0gY3JlYXRlQ3Vyc29yKGJ5dGVzKTtcXG4gICAgaWYgKHNpemUoYnl0ZXMpID09PSAwICYmIHBhcmFtcy5sZW5ndGggPiAwKVxcbiAgICAgIHRocm93IG5ldyBBYmlEZWNvZGluZ1plcm9EYXRhRXJyb3IoKTtcXG4gICAgaWYgKHNpemUoZGF0YSkgJiYgc2l6ZShkYXRhKSA8IDMyKVxcbiAgICAgIHRocm93IG5ldyBBYmlEZWNvZGluZ0RhdGFTaXplVG9vU21hbGxFcnJvcih7XFxuICAgICAgICBkYXRhOiB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiA/IGRhdGEgOiBieXRlc1RvSGV4KGRhdGEpLFxcbiAgICAgICAgcGFyYW1zLFxcbiAgICAgICAgc2l6ZTogc2l6ZShkYXRhKVxcbiAgICAgIH0pO1xcbiAgICBsZXQgY29uc3VtZWQgPSAwO1xcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyArK2kpIHtcXG4gICAgICBjb25zdCBwYXJhbSA9IHBhcmFtc1tpXTtcXG4gICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oY29uc3VtZWQpO1xcbiAgICAgIGNvbnN0IFtkYXRhMiwgY29uc3VtZWRfXSA9IGRlY29kZVBhcmFtZXRlcihjdXJzb3IsIHBhcmFtLCB7XFxuICAgICAgICBzdGF0aWNQb3NpdGlvbjogMFxcbiAgICAgIH0pO1xcbiAgICAgIGNvbnN1bWVkICs9IGNvbnN1bWVkXztcXG4gICAgICB2YWx1ZXMucHVzaChkYXRhMik7XFxuICAgIH1cXG4gICAgcmV0dXJuIHZhbHVlcztcXG4gIH1cXG4gIGZ1bmN0aW9uIGRlY29kZVBhcmFtZXRlcihjdXJzb3IsIHBhcmFtLCB7IHN0YXRpY1Bvc2l0aW9uIH0pIHtcXG4gICAgY29uc3QgYXJyYXlDb21wb25lbnRzID0gZ2V0QXJyYXlDb21wb25lbnRzKHBhcmFtLnR5cGUpO1xcbiAgICBpZiAoYXJyYXlDb21wb25lbnRzKSB7XFxuICAgICAgY29uc3QgW2xlbmd0aCwgdHlwZV0gPSBhcnJheUNvbXBvbmVudHM7XFxuICAgICAgcmV0dXJuIGRlY29kZUFycmF5KGN1cnNvciwgeyAuLi5wYXJhbSwgdHlwZSB9LCB7IGxlbmd0aCwgc3RhdGljUG9zaXRpb24gfSk7XFxuICAgIH1cXG4gICAgaWYgKHBhcmFtLnR5cGUgPT09IFwidHVwbGVcIilcXG4gICAgICByZXR1cm4gZGVjb2RlVHVwbGUoY3Vyc29yLCBwYXJhbSwgeyBzdGF0aWNQb3NpdGlvbiB9KTtcXG4gICAgaWYgKHBhcmFtLnR5cGUgPT09IFwiYWRkcmVzc1wiKVxcbiAgICAgIHJldHVybiBkZWNvZGVBZGRyZXNzKGN1cnNvcik7XFxuICAgIGlmIChwYXJhbS50eXBlID09PSBcImJvb2xcIilcXG4gICAgICByZXR1cm4gZGVjb2RlQm9vbChjdXJzb3IpO1xcbiAgICBpZiAocGFyYW0udHlwZS5zdGFydHNXaXRoKFwiYnl0ZXNcIikpXFxuICAgICAgcmV0dXJuIGRlY29kZUJ5dGVzKGN1cnNvciwgcGFyYW0sIHsgc3RhdGljUG9zaXRpb24gfSk7XFxuICAgIGlmIChwYXJhbS50eXBlLnN0YXJ0c1dpdGgoXCJ1aW50XCIpIHx8IHBhcmFtLnR5cGUuc3RhcnRzV2l0aChcImludFwiKSlcXG4gICAgICByZXR1cm4gZGVjb2RlTnVtYmVyKGN1cnNvciwgcGFyYW0pO1xcbiAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIilcXG4gICAgICByZXR1cm4gZGVjb2RlU3RyaW5nKGN1cnNvciwgeyBzdGF0aWNQb3NpdGlvbiB9KTtcXG4gICAgdGhyb3cgbmV3IEludmFsaWRBYmlEZWNvZGluZ1R5cGVFcnJvcihwYXJhbS50eXBlLCB7XFxuICAgICAgZG9jc1BhdGg6IFwiL2RvY3MvY29udHJhY3QvZGVjb2RlQWJpUGFyYW1ldGVyc1wiXFxuICAgIH0pO1xcbiAgfVxcbiAgZnVuY3Rpb24gZGVjb2RlQWRkcmVzcyhjdXJzb3IpIHtcXG4gICAgY29uc3QgdmFsdWUgPSBjdXJzb3IucmVhZEJ5dGVzKDMyKTtcXG4gICAgcmV0dXJuIFtjaGVja3N1bUFkZHJlc3MoYnl0ZXNUb0hleChzbGljZUJ5dGVzKHZhbHVlLCAtMjApKSksIDMyXTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGRlY29kZUFycmF5KGN1cnNvciwgcGFyYW0sIHsgbGVuZ3RoLCBzdGF0aWNQb3NpdGlvbiB9KSB7XFxuICAgIGlmICghbGVuZ3RoKSB7XFxuICAgICAgY29uc3Qgb2Zmc2V0ID0gYnl0ZXNUb051bWJlcihjdXJzb3IucmVhZEJ5dGVzKHNpemVPZk9mZnNldCkpO1xcbiAgICAgIGNvbnN0IHN0YXJ0ID0gc3RhdGljUG9zaXRpb24gKyBvZmZzZXQ7XFxuICAgICAgY29uc3Qgc3RhcnRPZkRhdGEgPSBzdGFydCArIHNpemVPZkxlbmd0aDtcXG4gICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhcnQpO1xcbiAgICAgIGNvbnN0IGxlbmd0aDIgPSBieXRlc1RvTnVtYmVyKGN1cnNvci5yZWFkQnl0ZXMoc2l6ZU9mTGVuZ3RoKSk7XFxuICAgICAgY29uc3QgZHluYW1pY0NoaWxkID0gaGFzRHluYW1pY0NoaWxkKHBhcmFtKTtcXG4gICAgICBsZXQgY29uc3VtZWQyID0gMDtcXG4gICAgICBjb25zdCB2YWx1ZTIgPSBbXTtcXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDI7ICsraSkge1xcbiAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXJ0T2ZEYXRhICsgKGR5bmFtaWNDaGlsZCA/IGkgKiAzMiA6IGNvbnN1bWVkMikpO1xcbiAgICAgICAgY29uc3QgW2RhdGEsIGNvbnN1bWVkX10gPSBkZWNvZGVQYXJhbWV0ZXIoY3Vyc29yLCBwYXJhbSwge1xcbiAgICAgICAgICBzdGF0aWNQb3NpdGlvbjogc3RhcnRPZkRhdGFcXG4gICAgICAgIH0pO1xcbiAgICAgICAgY29uc3VtZWQyICs9IGNvbnN1bWVkXztcXG4gICAgICAgIHZhbHVlMi5wdXNoKGRhdGEpO1xcbiAgICAgIH1cXG4gICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhdGljUG9zaXRpb24gKyAzMik7XFxuICAgICAgcmV0dXJuIFt2YWx1ZTIsIDMyXTtcXG4gICAgfVxcbiAgICBpZiAoaGFzRHluYW1pY0NoaWxkKHBhcmFtKSkge1xcbiAgICAgIGNvbnN0IG9mZnNldCA9IGJ5dGVzVG9OdW1iZXIoY3Vyc29yLnJlYWRCeXRlcyhzaXplT2ZPZmZzZXQpKTtcXG4gICAgICBjb25zdCBzdGFydCA9IHN0YXRpY1Bvc2l0aW9uICsgb2Zmc2V0O1xcbiAgICAgIGNvbnN0IHZhbHVlMiA9IFtdO1xcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcXG4gICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGFydCArIGkgKiAzMik7XFxuICAgICAgICBjb25zdCBbZGF0YV0gPSBkZWNvZGVQYXJhbWV0ZXIoY3Vyc29yLCBwYXJhbSwge1xcbiAgICAgICAgICBzdGF0aWNQb3NpdGlvbjogc3RhcnRcXG4gICAgICAgIH0pO1xcbiAgICAgICAgdmFsdWUyLnB1c2goZGF0YSk7XFxuICAgICAgfVxcbiAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGF0aWNQb3NpdGlvbiArIDMyKTtcXG4gICAgICByZXR1cm4gW3ZhbHVlMiwgMzJdO1xcbiAgICB9XFxuICAgIGxldCBjb25zdW1lZCA9IDA7XFxuICAgIGNvbnN0IHZhbHVlID0gW107XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcXG4gICAgICBjb25zdCBbZGF0YSwgY29uc3VtZWRfXSA9IGRlY29kZVBhcmFtZXRlcihjdXJzb3IsIHBhcmFtLCB7XFxuICAgICAgICBzdGF0aWNQb3NpdGlvbjogc3RhdGljUG9zaXRpb24gKyBjb25zdW1lZFxcbiAgICAgIH0pO1xcbiAgICAgIGNvbnN1bWVkICs9IGNvbnN1bWVkXztcXG4gICAgICB2YWx1ZS5wdXNoKGRhdGEpO1xcbiAgICB9XFxuICAgIHJldHVybiBbdmFsdWUsIGNvbnN1bWVkXTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGRlY29kZUJvb2woY3Vyc29yKSB7XFxuICAgIHJldHVybiBbYnl0ZXNUb0Jvb2woY3Vyc29yLnJlYWRCeXRlcygzMiksIHsgc2l6ZTogMzIgfSksIDMyXTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGRlY29kZUJ5dGVzKGN1cnNvciwgcGFyYW0sIHsgc3RhdGljUG9zaXRpb24gfSkge1xcbiAgICBjb25zdCBbXywgc2l6ZTVdID0gcGFyYW0udHlwZS5zcGxpdChcImJ5dGVzXCIpO1xcbiAgICBpZiAoIXNpemU1KSB7XFxuICAgICAgY29uc3Qgb2Zmc2V0ID0gYnl0ZXNUb051bWJlcihjdXJzb3IucmVhZEJ5dGVzKDMyKSk7XFxuICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXRpY1Bvc2l0aW9uICsgb2Zmc2V0KTtcXG4gICAgICBjb25zdCBsZW5ndGggPSBieXRlc1RvTnVtYmVyKGN1cnNvci5yZWFkQnl0ZXMoMzIpKTtcXG4gICAgICBpZiAobGVuZ3RoID09PSAwKSB7XFxuICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhdGljUG9zaXRpb24gKyAzMik7XFxuICAgICAgICByZXR1cm4gW1wiMHhcIiwgMzJdO1xcbiAgICAgIH1cXG4gICAgICBjb25zdCBkYXRhID0gY3Vyc29yLnJlYWRCeXRlcyhsZW5ndGgpO1xcbiAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGF0aWNQb3NpdGlvbiArIDMyKTtcXG4gICAgICByZXR1cm4gW2J5dGVzVG9IZXgoZGF0YSksIDMyXTtcXG4gICAgfVxcbiAgICBjb25zdCB2YWx1ZSA9IGJ5dGVzVG9IZXgoY3Vyc29yLnJlYWRCeXRlcyhOdW1iZXIucGFyc2VJbnQoc2l6ZTUpLCAzMikpO1xcbiAgICByZXR1cm4gW3ZhbHVlLCAzMl07XFxuICB9XFxuICBmdW5jdGlvbiBkZWNvZGVOdW1iZXIoY3Vyc29yLCBwYXJhbSkge1xcbiAgICBjb25zdCBzaWduZWQgPSBwYXJhbS50eXBlLnN0YXJ0c1dpdGgoXCJpbnRcIik7XFxuICAgIGNvbnN0IHNpemU1ID0gTnVtYmVyLnBhcnNlSW50KHBhcmFtLnR5cGUuc3BsaXQoXCJpbnRcIilbMV0gfHwgXCIyNTZcIik7XFxuICAgIGNvbnN0IHZhbHVlID0gY3Vyc29yLnJlYWRCeXRlcygzMik7XFxuICAgIHJldHVybiBbXFxuICAgICAgc2l6ZTUgPiA0OCA/IGJ5dGVzVG9CaWdJbnQodmFsdWUsIHsgc2lnbmVkIH0pIDogYnl0ZXNUb051bWJlcih2YWx1ZSwgeyBzaWduZWQgfSksXFxuICAgICAgMzJcXG4gICAgXTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGRlY29kZVR1cGxlKGN1cnNvciwgcGFyYW0sIHsgc3RhdGljUG9zaXRpb24gfSkge1xcbiAgICBjb25zdCBoYXNVbm5hbWVkQ2hpbGQgPSBwYXJhbS5jb21wb25lbnRzLmxlbmd0aCA9PT0gMCB8fCBwYXJhbS5jb21wb25lbnRzLnNvbWUoKHsgbmFtZSB9KSA9PiAhbmFtZSk7XFxuICAgIGNvbnN0IHZhbHVlID0gaGFzVW5uYW1lZENoaWxkID8gW10gOiB7fTtcXG4gICAgbGV0IGNvbnN1bWVkID0gMDtcXG4gICAgaWYgKGhhc0R5bmFtaWNDaGlsZChwYXJhbSkpIHtcXG4gICAgICBjb25zdCBvZmZzZXQgPSBieXRlc1RvTnVtYmVyKGN1cnNvci5yZWFkQnl0ZXMoc2l6ZU9mT2Zmc2V0KSk7XFxuICAgICAgY29uc3Qgc3RhcnQgPSBzdGF0aWNQb3NpdGlvbiArIG9mZnNldDtcXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtLmNvbXBvbmVudHMubGVuZ3RoOyArK2kpIHtcXG4gICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHBhcmFtLmNvbXBvbmVudHNbaV07XFxuICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhcnQgKyBjb25zdW1lZCk7XFxuICAgICAgICBjb25zdCBbZGF0YSwgY29uc3VtZWRfXSA9IGRlY29kZVBhcmFtZXRlcihjdXJzb3IsIGNvbXBvbmVudCwge1xcbiAgICAgICAgICBzdGF0aWNQb3NpdGlvbjogc3RhcnRcXG4gICAgICAgIH0pO1xcbiAgICAgICAgY29uc3VtZWQgKz0gY29uc3VtZWRfO1xcbiAgICAgICAgdmFsdWVbaGFzVW5uYW1lZENoaWxkID8gaSA6IGNvbXBvbmVudD8ubmFtZV0gPSBkYXRhO1xcbiAgICAgIH1cXG4gICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhdGljUG9zaXRpb24gKyAzMik7XFxuICAgICAgcmV0dXJuIFt2YWx1ZSwgMzJdO1xcbiAgICB9XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW0uY29tcG9uZW50cy5sZW5ndGg7ICsraSkge1xcbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHBhcmFtLmNvbXBvbmVudHNbaV07XFxuICAgICAgY29uc3QgW2RhdGEsIGNvbnN1bWVkX10gPSBkZWNvZGVQYXJhbWV0ZXIoY3Vyc29yLCBjb21wb25lbnQsIHtcXG4gICAgICAgIHN0YXRpY1Bvc2l0aW9uXFxuICAgICAgfSk7XFxuICAgICAgdmFsdWVbaGFzVW5uYW1lZENoaWxkID8gaSA6IGNvbXBvbmVudD8ubmFtZV0gPSBkYXRhO1xcbiAgICAgIGNvbnN1bWVkICs9IGNvbnN1bWVkXztcXG4gICAgfVxcbiAgICByZXR1cm4gW3ZhbHVlLCBjb25zdW1lZF07XFxuICB9XFxuICBmdW5jdGlvbiBkZWNvZGVTdHJpbmcoY3Vyc29yLCB7IHN0YXRpY1Bvc2l0aW9uIH0pIHtcXG4gICAgY29uc3Qgb2Zmc2V0ID0gYnl0ZXNUb051bWJlcihjdXJzb3IucmVhZEJ5dGVzKDMyKSk7XFxuICAgIGNvbnN0IHN0YXJ0ID0gc3RhdGljUG9zaXRpb24gKyBvZmZzZXQ7XFxuICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGFydCk7XFxuICAgIGNvbnN0IGxlbmd0aCA9IGJ5dGVzVG9OdW1iZXIoY3Vyc29yLnJlYWRCeXRlcygzMikpO1xcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XFxuICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXRpY1Bvc2l0aW9uICsgMzIpO1xcbiAgICAgIHJldHVybiBbXCJcIiwgMzJdO1xcbiAgICB9XFxuICAgIGNvbnN0IGRhdGEgPSBjdXJzb3IucmVhZEJ5dGVzKGxlbmd0aCwgMzIpO1xcbiAgICBjb25zdCB2YWx1ZSA9IGJ5dGVzVG9TdHJpbmcodHJpbShkYXRhKSk7XFxuICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGF0aWNQb3NpdGlvbiArIDMyKTtcXG4gICAgcmV0dXJuIFt2YWx1ZSwgMzJdO1xcbiAgfVxcbiAgZnVuY3Rpb24gaGFzRHluYW1pY0NoaWxkKHBhcmFtKSB7XFxuICAgIGNvbnN0IHsgdHlwZSB9ID0gcGFyYW07XFxuICAgIGlmICh0eXBlID09PSBcInN0cmluZ1wiKVxcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICBpZiAodHlwZSA9PT0gXCJieXRlc1wiKVxcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICBpZiAodHlwZS5lbmRzV2l0aChcIltdXCIpKVxcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICBpZiAodHlwZSA9PT0gXCJ0dXBsZVwiKVxcbiAgICAgIHJldHVybiBwYXJhbS5jb21wb25lbnRzPy5zb21lKGhhc0R5bmFtaWNDaGlsZCk7XFxuICAgIGNvbnN0IGFycmF5Q29tcG9uZW50cyA9IGdldEFycmF5Q29tcG9uZW50cyhwYXJhbS50eXBlKTtcXG4gICAgaWYgKGFycmF5Q29tcG9uZW50cyAmJiBoYXNEeW5hbWljQ2hpbGQoeyAuLi5wYXJhbSwgdHlwZTogYXJyYXlDb21wb25lbnRzWzFdIH0pKVxcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuICB2YXIgc2l6ZU9mTGVuZ3RoLCBzaXplT2ZPZmZzZXQ7XFxuICB2YXIgaW5pdF9kZWNvZGVBYmlQYXJhbWV0ZXJzID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2FiaS9kZWNvZGVBYmlQYXJhbWV0ZXJzLmpzXCIoKSB7XFxuICAgICAgaW5pdF9hYmkoKTtcXG4gICAgICBpbml0X2dldEFkZHJlc3MoKTtcXG4gICAgICBpbml0X2N1cnNvcjIoKTtcXG4gICAgICBpbml0X3NpemUoKTtcXG4gICAgICBpbml0X3NsaWNlKCk7XFxuICAgICAgaW5pdF90cmltKCk7XFxuICAgICAgaW5pdF9mcm9tQnl0ZXMoKTtcXG4gICAgICBpbml0X3RvQnl0ZXMoKTtcXG4gICAgICBpbml0X3RvSGV4KCk7XFxuICAgICAgaW5pdF9lbmNvZGVBYmlQYXJhbWV0ZXJzKCk7XFxuICAgICAgc2l6ZU9mTGVuZ3RoID0gMzI7XFxuICAgICAgc2l6ZU9mT2Zmc2V0ID0gMzI7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvYWJpL2RlY29kZUVycm9yUmVzdWx0LmpzXFxuICBmdW5jdGlvbiBkZWNvZGVFcnJvclJlc3VsdChwYXJhbWV0ZXJzKSB7XFxuICAgIGNvbnN0IHsgYWJpOiBhYmkyLCBkYXRhIH0gPSBwYXJhbWV0ZXJzO1xcbiAgICBjb25zdCBzaWduYXR1cmUgPSBzbGljZShkYXRhLCAwLCA0KTtcXG4gICAgaWYgKHNpZ25hdHVyZSA9PT0gXCIweFwiKVxcbiAgICAgIHRocm93IG5ldyBBYmlEZWNvZGluZ1plcm9EYXRhRXJyb3IoKTtcXG4gICAgY29uc3QgYWJpXyA9IFsuLi5hYmkyIHx8IFtdLCBzb2xpZGl0eUVycm9yLCBzb2xpZGl0eVBhbmljXTtcXG4gICAgY29uc3QgYWJpSXRlbSA9IGFiaV8uZmluZCgoeCkgPT4geC50eXBlID09PSBcImVycm9yXCIgJiYgc2lnbmF0dXJlID09PSB0b0Z1bmN0aW9uU2VsZWN0b3IoZm9ybWF0QWJpSXRlbTIoeCkpKTtcXG4gICAgaWYgKCFhYmlJdGVtKVxcbiAgICAgIHRocm93IG5ldyBBYmlFcnJvclNpZ25hdHVyZU5vdEZvdW5kRXJyb3Ioc2lnbmF0dXJlLCB7XFxuICAgICAgICBkb2NzUGF0aDogXCIvZG9jcy9jb250cmFjdC9kZWNvZGVFcnJvclJlc3VsdFwiXFxuICAgICAgfSk7XFxuICAgIHJldHVybiB7XFxuICAgICAgYWJpSXRlbSxcXG4gICAgICBhcmdzOiBcImlucHV0c1wiIGluIGFiaUl0ZW0gJiYgYWJpSXRlbS5pbnB1dHMgJiYgYWJpSXRlbS5pbnB1dHMubGVuZ3RoID4gMCA/IGRlY29kZUFiaVBhcmFtZXRlcnMoYWJpSXRlbS5pbnB1dHMsIHNsaWNlKGRhdGEsIDQpKSA6IHZvaWQgMCxcXG4gICAgICBlcnJvck5hbWU6IGFiaUl0ZW0ubmFtZVxcbiAgICB9O1xcbiAgfVxcbiAgdmFyIGluaXRfZGVjb2RlRXJyb3JSZXN1bHQgPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvYWJpL2RlY29kZUVycm9yUmVzdWx0LmpzXCIoKSB7XFxuICAgICAgaW5pdF9zb2xpZGl0eSgpO1xcbiAgICAgIGluaXRfYWJpKCk7XFxuICAgICAgaW5pdF9zbGljZSgpO1xcbiAgICAgIGluaXRfdG9GdW5jdGlvblNlbGVjdG9yKCk7XFxuICAgICAgaW5pdF9kZWNvZGVBYmlQYXJhbWV0ZXJzKCk7XFxuICAgICAgaW5pdF9mb3JtYXRBYmlJdGVtMigpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL3N0cmluZ2lmeS5qc1xcbiAgdmFyIHN0cmluZ2lmeTtcXG4gIHZhciBpbml0X3N0cmluZ2lmeSA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9zdHJpbmdpZnkuanNcIigpIHtcXG4gICAgICBzdHJpbmdpZnkgPSAodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSkgPT4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIChrZXksIHZhbHVlXykgPT4ge1xcbiAgICAgICAgY29uc3QgdmFsdWUyID0gdHlwZW9mIHZhbHVlXyA9PT0gXCJiaWdpbnRcIiA/IHZhbHVlXy50b1N0cmluZygpIDogdmFsdWVfO1xcbiAgICAgICAgcmV0dXJuIHR5cGVvZiByZXBsYWNlciA9PT0gXCJmdW5jdGlvblwiID8gcmVwbGFjZXIoa2V5LCB2YWx1ZTIpIDogdmFsdWUyO1xcbiAgICAgIH0sIHNwYWNlKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9hYmkvZm9ybWF0QWJpSXRlbVdpdGhBcmdzLmpzXFxuICBmdW5jdGlvbiBmb3JtYXRBYmlJdGVtV2l0aEFyZ3MoeyBhYmlJdGVtLCBhcmdzLCBpbmNsdWRlRnVuY3Rpb25OYW1lID0gdHJ1ZSwgaW5jbHVkZU5hbWUgPSBmYWxzZSB9KSB7XFxuICAgIGlmICghKFwibmFtZVwiIGluIGFiaUl0ZW0pKVxcbiAgICAgIHJldHVybjtcXG4gICAgaWYgKCEoXCJpbnB1dHNcIiBpbiBhYmlJdGVtKSlcXG4gICAgICByZXR1cm47XFxuICAgIGlmICghYWJpSXRlbS5pbnB1dHMpXFxuICAgICAgcmV0dXJuO1xcbiAgICByZXR1cm4gYCR7aW5jbHVkZUZ1bmN0aW9uTmFtZSA/IGFiaUl0ZW0ubmFtZSA6IFwiXCJ9KCR7YWJpSXRlbS5pbnB1dHMubWFwKChpbnB1dCwgaSkgPT4gYCR7aW5jbHVkZU5hbWUgJiYgaW5wdXQubmFtZSA/IGAke2lucHV0Lm5hbWV9OiBgIDogXCJcIn0ke3R5cGVvZiBhcmdzW2ldID09PSBcIm9iamVjdFwiID8gc3RyaW5naWZ5KGFyZ3NbaV0pIDogYXJnc1tpXX1gKS5qb2luKFwiLCBcIil9KWA7XFxuICB9XFxuICB2YXIgaW5pdF9mb3JtYXRBYmlJdGVtV2l0aEFyZ3MgPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvYWJpL2Zvcm1hdEFiaUl0ZW1XaXRoQXJncy5qc1wiKCkge1xcbiAgICAgIGluaXRfc3RyaW5naWZ5KCk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vY29uc3RhbnRzL3VuaXQuanNcXG4gIHZhciBldGhlclVuaXRzLCBnd2VpVW5pdHM7XFxuICB2YXIgaW5pdF91bml0ID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2NvbnN0YW50cy91bml0LmpzXCIoKSB7XFxuICAgICAgZXRoZXJVbml0cyA9IHtcXG4gICAgICAgIGd3ZWk6IDksXFxuICAgICAgICB3ZWk6IDE4XFxuICAgICAgfTtcXG4gICAgICBnd2VpVW5pdHMgPSB7XFxuICAgICAgICBldGhlcjogLTksXFxuICAgICAgICB3ZWk6IDlcXG4gICAgICB9O1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL3VuaXQvZm9ybWF0VW5pdHMuanNcXG4gIGZ1bmN0aW9uIGZvcm1hdFVuaXRzKHZhbHVlLCBkZWNpbWFscykge1xcbiAgICBsZXQgZGlzcGxheSA9IHZhbHVlLnRvU3RyaW5nKCk7XFxuICAgIGNvbnN0IG5lZ2F0aXZlID0gZGlzcGxheS5zdGFydHNXaXRoKFwiLVwiKTtcXG4gICAgaWYgKG5lZ2F0aXZlKVxcbiAgICAgIGRpc3BsYXkgPSBkaXNwbGF5LnNsaWNlKDEpO1xcbiAgICBkaXNwbGF5ID0gZGlzcGxheS5wYWRTdGFydChkZWNpbWFscywgXCIwXCIpO1xcbiAgICBsZXQgW2ludGVnZXIsIGZyYWN0aW9uXSA9IFtcXG4gICAgICBkaXNwbGF5LnNsaWNlKDAsIGRpc3BsYXkubGVuZ3RoIC0gZGVjaW1hbHMpLFxcbiAgICAgIGRpc3BsYXkuc2xpY2UoZGlzcGxheS5sZW5ndGggLSBkZWNpbWFscylcXG4gICAgXTtcXG4gICAgZnJhY3Rpb24gPSBmcmFjdGlvbi5yZXBsYWNlKC8oMCspJC8sIFwiXCIpO1xcbiAgICByZXR1cm4gYCR7bmVnYXRpdmUgPyBcIi1cIiA6IFwiXCJ9JHtpbnRlZ2VyIHx8IFwiMFwifSR7ZnJhY3Rpb24gPyBgLiR7ZnJhY3Rpb259YCA6IFwiXCJ9YDtcXG4gIH1cXG4gIHZhciBpbml0X2Zvcm1hdFVuaXRzID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL3VuaXQvZm9ybWF0VW5pdHMuanNcIigpIHtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy91bml0L2Zvcm1hdEV0aGVyLmpzXFxuICBmdW5jdGlvbiBmb3JtYXRFdGhlcih3ZWksIHVuaXQgPSBcIndlaVwiKSB7XFxuICAgIHJldHVybiBmb3JtYXRVbml0cyh3ZWksIGV0aGVyVW5pdHNbdW5pdF0pO1xcbiAgfVxcbiAgdmFyIGluaXRfZm9ybWF0RXRoZXIgPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvdW5pdC9mb3JtYXRFdGhlci5qc1wiKCkge1xcbiAgICAgIGluaXRfdW5pdCgpO1xcbiAgICAgIGluaXRfZm9ybWF0VW5pdHMoKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy91bml0L2Zvcm1hdEd3ZWkuanNcXG4gIGZ1bmN0aW9uIGZvcm1hdEd3ZWkod2VpLCB1bml0ID0gXCJ3ZWlcIikge1xcbiAgICByZXR1cm4gZm9ybWF0VW5pdHMod2VpLCBnd2VpVW5pdHNbdW5pdF0pO1xcbiAgfVxcbiAgdmFyIGluaXRfZm9ybWF0R3dlaSA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy91bml0L2Zvcm1hdEd3ZWkuanNcIigpIHtcXG4gICAgICBpbml0X3VuaXQoKTtcXG4gICAgICBpbml0X2Zvcm1hdFVuaXRzKCk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vZXJyb3JzL3N0YXRlT3ZlcnJpZGUuanNcXG4gIGZ1bmN0aW9uIHByZXR0eVN0YXRlTWFwcGluZyhzdGF0ZU1hcHBpbmcpIHtcXG4gICAgcmV0dXJuIHN0YXRlTWFwcGluZy5yZWR1Y2UoKHByZXR0eSwgeyBzbG90LCB2YWx1ZSB9KSA9PiB7XFxuICAgICAgcmV0dXJuIGAke3ByZXR0eX0gICAgICAgICR7c2xvdH06ICR7dmFsdWV9XFxuYDtcXG4gICAgfSwgXCJcIik7XFxuICB9XFxuICBmdW5jdGlvbiBwcmV0dHlTdGF0ZU92ZXJyaWRlKHN0YXRlT3ZlcnJpZGUpIHtcXG4gICAgcmV0dXJuIHN0YXRlT3ZlcnJpZGUucmVkdWNlKChwcmV0dHksIHsgYWRkcmVzcywgLi4uc3RhdGUgfSkgPT4ge1xcbiAgICAgIGxldCB2YWwgPSBgJHtwcmV0dHl9ICAgICR7YWRkcmVzc306XFxuYDtcXG4gICAgICBpZiAoc3RhdGUubm9uY2UpXFxuICAgICAgICB2YWwgKz0gYCAgICAgIG5vbmNlOiAke3N0YXRlLm5vbmNlfVxcbmA7XFxuICAgICAgaWYgKHN0YXRlLmJhbGFuY2UpXFxuICAgICAgICB2YWwgKz0gYCAgICAgIGJhbGFuY2U6ICR7c3RhdGUuYmFsYW5jZX1cXG5gO1xcbiAgICAgIGlmIChzdGF0ZS5jb2RlKVxcbiAgICAgICAgdmFsICs9IGAgICAgICBjb2RlOiAke3N0YXRlLmNvZGV9XFxuYDtcXG4gICAgICBpZiAoc3RhdGUuc3RhdGUpIHtcXG4gICAgICAgIHZhbCArPSBcIiAgICAgIHN0YXRlOlxcXFxuXCI7XFxuICAgICAgICB2YWwgKz0gcHJldHR5U3RhdGVNYXBwaW5nKHN0YXRlLnN0YXRlKTtcXG4gICAgICB9XFxuICAgICAgaWYgKHN0YXRlLnN0YXRlRGlmZikge1xcbiAgICAgICAgdmFsICs9IFwiICAgICAgc3RhdGVEaWZmOlxcXFxuXCI7XFxuICAgICAgICB2YWwgKz0gcHJldHR5U3RhdGVNYXBwaW5nKHN0YXRlLnN0YXRlRGlmZik7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB2YWw7XFxuICAgIH0sIFwiICBTdGF0ZSBPdmVycmlkZTpcXFxcblwiKS5zbGljZSgwLCAtMSk7XFxuICB9XFxuICB2YXIgQWNjb3VudFN0YXRlQ29uZmxpY3RFcnJvciwgU3RhdGVBc3NpZ25tZW50Q29uZmxpY3RFcnJvcjtcXG4gIHZhciBpbml0X3N0YXRlT3ZlcnJpZGUgPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vZXJyb3JzL3N0YXRlT3ZlcnJpZGUuanNcIigpIHtcXG4gICAgICBpbml0X2Jhc2UoKTtcXG4gICAgICBBY2NvdW50U3RhdGVDb25mbGljdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IyIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKHsgYWRkcmVzcyB9KSB7XFxuICAgICAgICAgIHN1cGVyKGBTdGF0ZSBmb3IgYWNjb3VudCBcIiR7YWRkcmVzc31cIiBpcyBzZXQgbXVsdGlwbGUgdGltZXMuYCwge1xcbiAgICAgICAgICAgIG5hbWU6IFwiQWNjb3VudFN0YXRlQ29uZmxpY3RFcnJvclwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgU3RhdGVBc3NpZ25tZW50Q29uZmxpY3RFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcXG4gICAgICAgICAgc3VwZXIoXCJzdGF0ZSBhbmQgc3RhdGVEaWZmIGFyZSBzZXQgb24gdGhlIHNhbWUgYWNjb3VudC5cIiwge1xcbiAgICAgICAgICAgIG5hbWU6IFwiU3RhdGVBc3NpZ25tZW50Q29uZmxpY3RFcnJvclwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vZXJyb3JzL3RyYW5zYWN0aW9uLmpzXFxuICBmdW5jdGlvbiBwcmV0dHlQcmludChhcmdzKSB7XFxuICAgIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhhcmdzKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xcbiAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwIHx8IHZhbHVlID09PSBmYWxzZSlcXG4gICAgICAgIHJldHVybiBudWxsO1xcbiAgICAgIHJldHVybiBba2V5LCB2YWx1ZV07XFxuICAgIH0pLmZpbHRlcihCb29sZWFuKTtcXG4gICAgY29uc3QgbWF4TGVuZ3RoID0gZW50cmllcy5yZWR1Y2UoKGFjYywgW2tleV0pID0+IE1hdGgubWF4KGFjYywga2V5Lmxlbmd0aCksIDApO1xcbiAgICByZXR1cm4gZW50cmllcy5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCAgJHtgJHtrZXl9OmAucGFkRW5kKG1heExlbmd0aCArIDEpfSAgJHt2YWx1ZX1gKS5qb2luKFwiXFxcXG5cIik7XFxuICB9XFxuICB2YXIgRmVlQ29uZmxpY3RFcnJvciwgSW52YWxpZExlZ2FjeVZFcnJvciwgSW52YWxpZFNlcmlhbGl6YWJsZVRyYW5zYWN0aW9uRXJyb3IsIEludmFsaWRTdG9yYWdlS2V5U2l6ZUVycm9yLCBUcmFuc2FjdGlvbkV4ZWN1dGlvbkVycm9yLCBUcmFuc2FjdGlvbk5vdEZvdW5kRXJyb3IsIFRyYW5zYWN0aW9uUmVjZWlwdE5vdEZvdW5kRXJyb3IsIFdhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHRUaW1lb3V0RXJyb3I7XFxuICB2YXIgaW5pdF90cmFuc2FjdGlvbiA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9lcnJvcnMvdHJhbnNhY3Rpb24uanNcIigpIHtcXG4gICAgICBpbml0X2Zvcm1hdEV0aGVyKCk7XFxuICAgICAgaW5pdF9mb3JtYXRHd2VpKCk7XFxuICAgICAgaW5pdF9iYXNlKCk7XFxuICAgICAgRmVlQ29uZmxpY3RFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcXG4gICAgICAgICAgc3VwZXIoW1xcbiAgICAgICAgICAgIFwiQ2Fubm90IHNwZWNpZnkgYm90aCBhIGBnYXNQcmljZWAgYW5kIGEgYG1heEZlZVBlckdhc2AvYG1heFByaW9yaXR5RmVlUGVyR2FzYC5cIixcXG4gICAgICAgICAgICBcIlVzZSBgbWF4RmVlUGVyR2FzYC9gbWF4UHJpb3JpdHlGZWVQZXJHYXNgIGZvciBFSVAtMTU1OSBjb21wYXRpYmxlIG5ldHdvcmtzLCBhbmQgYGdhc1ByaWNlYCBmb3Igb3RoZXJzLlwiXFxuICAgICAgICAgIF0uam9pbihcIlxcXFxuXCIpLCB7IG5hbWU6IFwiRmVlQ29uZmxpY3RFcnJvclwiIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgSW52YWxpZExlZ2FjeVZFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgICAgICBjb25zdHJ1Y3Rvcih7IHYgfSkge1xcbiAgICAgICAgICBzdXBlcihgSW52YWxpZCBcXFxcYHZcXFxcYCB2YWx1ZSBcIiR7dn1cIi4gRXhwZWN0ZWQgMjcgb3IgMjguYCwge1xcbiAgICAgICAgICAgIG5hbWU6IFwiSW52YWxpZExlZ2FjeVZFcnJvclwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgSW52YWxpZFNlcmlhbGl6YWJsZVRyYW5zYWN0aW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjIge1xcbiAgICAgICAgY29uc3RydWN0b3IoeyB0cmFuc2FjdGlvbiB9KSB7XFxuICAgICAgICAgIHN1cGVyKFwiQ2Fubm90IGluZmVyIGEgdHJhbnNhY3Rpb24gdHlwZSBmcm9tIHByb3ZpZGVkIHRyYW5zYWN0aW9uLlwiLCB7XFxuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXFxuICAgICAgICAgICAgICBcIlByb3ZpZGVkIFRyYW5zYWN0aW9uOlwiLFxcbiAgICAgICAgICAgICAgXCJ7XCIsXFxuICAgICAgICAgICAgICBwcmV0dHlQcmludCh0cmFuc2FjdGlvbiksXFxuICAgICAgICAgICAgICBcIn1cIixcXG4gICAgICAgICAgICAgIFwiXCIsXFxuICAgICAgICAgICAgICBcIlRvIGluZmVyIHRoZSB0eXBlLCBlaXRoZXIgcHJvdmlkZTpcIixcXG4gICAgICAgICAgICAgIFwiLSBhIGB0eXBlYCB0byB0aGUgVHJhbnNhY3Rpb24sIG9yXCIsXFxuICAgICAgICAgICAgICBcIi0gYW4gRUlQLTE1NTkgVHJhbnNhY3Rpb24gd2l0aCBgbWF4RmVlUGVyR2FzYCwgb3JcIixcXG4gICAgICAgICAgICAgIFwiLSBhbiBFSVAtMjkzMCBUcmFuc2FjdGlvbiB3aXRoIGBnYXNQcmljZWAgJiBgYWNjZXNzTGlzdGAsIG9yXCIsXFxuICAgICAgICAgICAgICBcIi0gYW4gRUlQLTQ4NDQgVHJhbnNhY3Rpb24gd2l0aCBgYmxvYnNgLCBgYmxvYlZlcnNpb25lZEhhc2hlc2AsIGBzaWRlY2Fyc2AsIG9yXCIsXFxuICAgICAgICAgICAgICBcIi0gYW4gRUlQLTc3MDIgVHJhbnNhY3Rpb24gd2l0aCBgYXV0aG9yaXphdGlvbkxpc3RgLCBvclwiLFxcbiAgICAgICAgICAgICAgXCItIGEgTGVnYWN5IFRyYW5zYWN0aW9uIHdpdGggYGdhc1ByaWNlYFwiXFxuICAgICAgICAgICAgXSxcXG4gICAgICAgICAgICBuYW1lOiBcIkludmFsaWRTZXJpYWxpemFibGVUcmFuc2FjdGlvbkVycm9yXCJcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICBJbnZhbGlkU3RvcmFnZUtleVNpemVFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgICAgICBjb25zdHJ1Y3Rvcih7IHN0b3JhZ2VLZXkgfSkge1xcbiAgICAgICAgICBzdXBlcihgU2l6ZSBmb3Igc3RvcmFnZSBrZXkgXCIke3N0b3JhZ2VLZXl9XCIgaXMgaW52YWxpZC4gRXhwZWN0ZWQgMzIgYnl0ZXMuIEdvdCAke01hdGguZmxvb3IoKHN0b3JhZ2VLZXkubGVuZ3RoIC0gMikgLyAyKX0gYnl0ZXMuYCwgeyBuYW1lOiBcIkludmFsaWRTdG9yYWdlS2V5U2l6ZUVycm9yXCIgfSk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICBUcmFuc2FjdGlvbkV4ZWN1dGlvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IyIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKGNhdXNlLCB7IGFjY291bnQsIGRvY3NQYXRoOiBkb2NzUGF0aDgsIGNoYWluLCBkYXRhLCBnYXMsIGdhc1ByaWNlLCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzLCBub25jZSwgdG8sIHZhbHVlIH0pIHtcXG4gICAgICAgICAgY29uc3QgcHJldHR5QXJncyA9IHByZXR0eVByaW50KHtcXG4gICAgICAgICAgICBjaGFpbjogY2hhaW4gJiYgYCR7Y2hhaW4/Lm5hbWV9IChpZDogJHtjaGFpbj8uaWR9KWAsXFxuICAgICAgICAgICAgZnJvbTogYWNjb3VudD8uYWRkcmVzcyxcXG4gICAgICAgICAgICB0byxcXG4gICAgICAgICAgICB2YWx1ZTogdHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiICYmIGAke2Zvcm1hdEV0aGVyKHZhbHVlKX0gJHtjaGFpbj8ubmF0aXZlQ3VycmVuY3k/LnN5bWJvbCB8fCBcIkVUSFwifWAsXFxuICAgICAgICAgICAgZGF0YSxcXG4gICAgICAgICAgICBnYXMsXFxuICAgICAgICAgICAgZ2FzUHJpY2U6IHR5cGVvZiBnYXNQcmljZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBgJHtmb3JtYXRHd2VpKGdhc1ByaWNlKX0gZ3dlaWAsXFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiB0eXBlb2YgbWF4RmVlUGVyR2FzICE9PSBcInVuZGVmaW5lZFwiICYmIGAke2Zvcm1hdEd3ZWkobWF4RmVlUGVyR2FzKX0gZ3dlaWAsXFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHR5cGVvZiBtYXhQcmlvcml0eUZlZVBlckdhcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBgJHtmb3JtYXRHd2VpKG1heFByaW9yaXR5RmVlUGVyR2FzKX0gZ3dlaWAsXFxuICAgICAgICAgICAgbm9uY2VcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIHN1cGVyKGNhdXNlLnNob3J0TWVzc2FnZSwge1xcbiAgICAgICAgICAgIGNhdXNlLFxcbiAgICAgICAgICAgIGRvY3NQYXRoOiBkb2NzUGF0aDgsXFxuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXFxuICAgICAgICAgICAgICAuLi5jYXVzZS5tZXRhTWVzc2FnZXMgPyBbLi4uY2F1c2UubWV0YU1lc3NhZ2VzLCBcIiBcIl0gOiBbXSxcXG4gICAgICAgICAgICAgIFwiUmVxdWVzdCBBcmd1bWVudHM6XCIsXFxuICAgICAgICAgICAgICBwcmV0dHlBcmdzXFxuICAgICAgICAgICAgXS5maWx0ZXIoQm9vbGVhbiksXFxuICAgICAgICAgICAgbmFtZTogXCJUcmFuc2FjdGlvbkV4ZWN1dGlvbkVycm9yXCJcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhdXNlXCIsIHtcXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICB0aGlzLmNhdXNlID0gY2F1c2U7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICBUcmFuc2FjdGlvbk5vdEZvdW5kRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjIge1xcbiAgICAgICAgY29uc3RydWN0b3IoeyBibG9ja0hhc2gsIGJsb2NrTnVtYmVyLCBibG9ja1RhZywgaGFzaDogaGFzaDIsIGluZGV4OiBpbmRleDIgfSkge1xcbiAgICAgICAgICBsZXQgaWRlbnRpZmllciA9IFwiVHJhbnNhY3Rpb25cIjtcXG4gICAgICAgICAgaWYgKGJsb2NrVGFnICYmIGluZGV4MiAhPT0gdm9pZCAwKVxcbiAgICAgICAgICAgIGlkZW50aWZpZXIgPSBgVHJhbnNhY3Rpb24gYXQgYmxvY2sgdGltZSBcIiR7YmxvY2tUYWd9XCIgYXQgaW5kZXggXCIke2luZGV4Mn1cImA7XFxuICAgICAgICAgIGlmIChibG9ja0hhc2ggJiYgaW5kZXgyICE9PSB2b2lkIDApXFxuICAgICAgICAgICAgaWRlbnRpZmllciA9IGBUcmFuc2FjdGlvbiBhdCBibG9jayBoYXNoIFwiJHtibG9ja0hhc2h9XCIgYXQgaW5kZXggXCIke2luZGV4Mn1cImA7XFxuICAgICAgICAgIGlmIChibG9ja051bWJlciAmJiBpbmRleDIgIT09IHZvaWQgMClcXG4gICAgICAgICAgICBpZGVudGlmaWVyID0gYFRyYW5zYWN0aW9uIGF0IGJsb2NrIG51bWJlciBcIiR7YmxvY2tOdW1iZXJ9XCIgYXQgaW5kZXggXCIke2luZGV4Mn1cImA7XFxuICAgICAgICAgIGlmIChoYXNoMilcXG4gICAgICAgICAgICBpZGVudGlmaWVyID0gYFRyYW5zYWN0aW9uIHdpdGggaGFzaCBcIiR7aGFzaDJ9XCJgO1xcbiAgICAgICAgICBzdXBlcihgJHtpZGVudGlmaWVyfSBjb3VsZCBub3QgYmUgZm91bmQuYCwge1xcbiAgICAgICAgICAgIG5hbWU6IFwiVHJhbnNhY3Rpb25Ob3RGb3VuZEVycm9yXCJcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICBUcmFuc2FjdGlvblJlY2VpcHROb3RGb3VuZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IyIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKHsgaGFzaDogaGFzaDIgfSkge1xcbiAgICAgICAgICBzdXBlcihgVHJhbnNhY3Rpb24gcmVjZWlwdCB3aXRoIGhhc2ggXCIke2hhc2gyfVwiIGNvdWxkIG5vdCBiZSBmb3VuZC4gVGhlIFRyYW5zYWN0aW9uIG1heSBub3QgYmUgcHJvY2Vzc2VkIG9uIGEgYmxvY2sgeWV0LmAsIHtcXG4gICAgICAgICAgICBuYW1lOiBcIlRyYW5zYWN0aW9uUmVjZWlwdE5vdEZvdW5kRXJyb3JcIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIFdhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHRUaW1lb3V0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjIge1xcbiAgICAgICAgY29uc3RydWN0b3IoeyBoYXNoOiBoYXNoMiB9KSB7XFxuICAgICAgICAgIHN1cGVyKGBUaW1lZCBvdXQgd2hpbGUgd2FpdGluZyBmb3IgdHJhbnNhY3Rpb24gd2l0aCBoYXNoIFwiJHtoYXNoMn1cIiB0byBiZSBjb25maXJtZWQuYCwgeyBuYW1lOiBcIldhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHRUaW1lb3V0RXJyb3JcIiB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2Vycm9ycy91dGlscy5qc1xcbiAgdmFyIGdldENvbnRyYWN0QWRkcmVzcywgZ2V0VXJsO1xcbiAgdmFyIGluaXRfdXRpbHMzID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2Vycm9ycy91dGlscy5qc1wiKCkge1xcbiAgICAgIGdldENvbnRyYWN0QWRkcmVzcyA9IChhZGRyZXNzKSA9PiBhZGRyZXNzO1xcbiAgICAgIGdldFVybCA9ICh1cmwpID0+IHVybDtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9lcnJvcnMvY29udHJhY3QuanNcXG4gIHZhciBDYWxsRXhlY3V0aW9uRXJyb3IsIENvbnRyYWN0RnVuY3Rpb25FeGVjdXRpb25FcnJvciwgQ29udHJhY3RGdW5jdGlvblJldmVydGVkRXJyb3IsIENvbnRyYWN0RnVuY3Rpb25aZXJvRGF0YUVycm9yLCBDb3VudGVyZmFjdHVhbERlcGxveW1lbnRGYWlsZWRFcnJvciwgUmF3Q29udHJhY3RFcnJvcjtcXG4gIHZhciBpbml0X2NvbnRyYWN0ID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2Vycm9ycy9jb250cmFjdC5qc1wiKCkge1xcbiAgICAgIGluaXRfcGFyc2VBY2NvdW50KCk7XFxuICAgICAgaW5pdF9zb2xpZGl0eSgpO1xcbiAgICAgIGluaXRfZGVjb2RlRXJyb3JSZXN1bHQoKTtcXG4gICAgICBpbml0X2Zvcm1hdEFiaUl0ZW0yKCk7XFxuICAgICAgaW5pdF9mb3JtYXRBYmlJdGVtV2l0aEFyZ3MoKTtcXG4gICAgICBpbml0X2dldEFiaUl0ZW0oKTtcXG4gICAgICBpbml0X2Zvcm1hdEV0aGVyKCk7XFxuICAgICAgaW5pdF9mb3JtYXRHd2VpKCk7XFxuICAgICAgaW5pdF9hYmkoKTtcXG4gICAgICBpbml0X2Jhc2UoKTtcXG4gICAgICBpbml0X3N0YXRlT3ZlcnJpZGUoKTtcXG4gICAgICBpbml0X3RyYW5zYWN0aW9uKCk7XFxuICAgICAgaW5pdF91dGlsczMoKTtcXG4gICAgICBDYWxsRXhlY3V0aW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjIge1xcbiAgICAgICAgY29uc3RydWN0b3IoY2F1c2UsIHsgYWNjb3VudDogYWNjb3VudF8sIGRvY3NQYXRoOiBkb2NzUGF0aDgsIGNoYWluLCBkYXRhLCBnYXMsIGdhc1ByaWNlLCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzLCBub25jZSwgdG8sIHZhbHVlLCBzdGF0ZU92ZXJyaWRlIH0pIHtcXG4gICAgICAgICAgY29uc3QgYWNjb3VudCA9IGFjY291bnRfID8gcGFyc2VBY2NvdW50KGFjY291bnRfKSA6IHZvaWQgMDtcXG4gICAgICAgICAgbGV0IHByZXR0eUFyZ3MgPSBwcmV0dHlQcmludCh7XFxuICAgICAgICAgICAgZnJvbTogYWNjb3VudD8uYWRkcmVzcyxcXG4gICAgICAgICAgICB0byxcXG4gICAgICAgICAgICB2YWx1ZTogdHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiICYmIGAke2Zvcm1hdEV0aGVyKHZhbHVlKX0gJHtjaGFpbj8ubmF0aXZlQ3VycmVuY3k/LnN5bWJvbCB8fCBcIkVUSFwifWAsXFxuICAgICAgICAgICAgZGF0YSxcXG4gICAgICAgICAgICBnYXMsXFxuICAgICAgICAgICAgZ2FzUHJpY2U6IHR5cGVvZiBnYXNQcmljZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBgJHtmb3JtYXRHd2VpKGdhc1ByaWNlKX0gZ3dlaWAsXFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiB0eXBlb2YgbWF4RmVlUGVyR2FzICE9PSBcInVuZGVmaW5lZFwiICYmIGAke2Zvcm1hdEd3ZWkobWF4RmVlUGVyR2FzKX0gZ3dlaWAsXFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHR5cGVvZiBtYXhQcmlvcml0eUZlZVBlckdhcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBgJHtmb3JtYXRHd2VpKG1heFByaW9yaXR5RmVlUGVyR2FzKX0gZ3dlaWAsXFxuICAgICAgICAgICAgbm9uY2VcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIGlmIChzdGF0ZU92ZXJyaWRlKSB7XFxuICAgICAgICAgICAgcHJldHR5QXJncyArPSBgXFxuJHtwcmV0dHlTdGF0ZU92ZXJyaWRlKHN0YXRlT3ZlcnJpZGUpfWA7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgc3VwZXIoY2F1c2Uuc2hvcnRNZXNzYWdlLCB7XFxuICAgICAgICAgICAgY2F1c2UsXFxuICAgICAgICAgICAgZG9jc1BhdGg6IGRvY3NQYXRoOCxcXG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcXG4gICAgICAgICAgICAgIC4uLmNhdXNlLm1ldGFNZXNzYWdlcyA/IFsuLi5jYXVzZS5tZXRhTWVzc2FnZXMsIFwiIFwiXSA6IFtdLFxcbiAgICAgICAgICAgICAgXCJSYXcgQ2FsbCBBcmd1bWVudHM6XCIsXFxuICAgICAgICAgICAgICBwcmV0dHlBcmdzXFxuICAgICAgICAgICAgXS5maWx0ZXIoQm9vbGVhbiksXFxuICAgICAgICAgICAgbmFtZTogXCJDYWxsRXhlY3V0aW9uRXJyb3JcIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2F1c2VcIiwge1xcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIENvbnRyYWN0RnVuY3Rpb25FeGVjdXRpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgICAgICBjb25zdHJ1Y3RvcihjYXVzZSwgeyBhYmk6IGFiaTIsIGFyZ3MsIGNvbnRyYWN0QWRkcmVzcywgZG9jc1BhdGg6IGRvY3NQYXRoOCwgZnVuY3Rpb25OYW1lLCBzZW5kZXIgfSkge1xcbiAgICAgICAgICBjb25zdCBhYmlJdGVtID0gZ2V0QWJpSXRlbSh7IGFiaTogYWJpMiwgYXJncywgbmFtZTogZnVuY3Rpb25OYW1lIH0pO1xcbiAgICAgICAgICBjb25zdCBmb3JtYXR0ZWRBcmdzID0gYWJpSXRlbSA/IGZvcm1hdEFiaUl0ZW1XaXRoQXJncyh7XFxuICAgICAgICAgICAgYWJpSXRlbSxcXG4gICAgICAgICAgICBhcmdzLFxcbiAgICAgICAgICAgIGluY2x1ZGVGdW5jdGlvbk5hbWU6IGZhbHNlLFxcbiAgICAgICAgICAgIGluY2x1ZGVOYW1lOiBmYWxzZVxcbiAgICAgICAgICB9KSA6IHZvaWQgMDtcXG4gICAgICAgICAgY29uc3QgZnVuY3Rpb25XaXRoUGFyYW1zID0gYWJpSXRlbSA/IGZvcm1hdEFiaUl0ZW0yKGFiaUl0ZW0sIHsgaW5jbHVkZU5hbWU6IHRydWUgfSkgOiB2b2lkIDA7XFxuICAgICAgICAgIGNvbnN0IHByZXR0eUFyZ3MgPSBwcmV0dHlQcmludCh7XFxuICAgICAgICAgICAgYWRkcmVzczogY29udHJhY3RBZGRyZXNzICYmIGdldENvbnRyYWN0QWRkcmVzcyhjb250cmFjdEFkZHJlc3MpLFxcbiAgICAgICAgICAgIGZ1bmN0aW9uOiBmdW5jdGlvbldpdGhQYXJhbXMsXFxuICAgICAgICAgICAgYXJnczogZm9ybWF0dGVkQXJncyAmJiBmb3JtYXR0ZWRBcmdzICE9PSBcIigpXCIgJiYgYCR7Wy4uLkFycmF5KGZ1bmN0aW9uTmFtZT8ubGVuZ3RoID8/IDApLmtleXMoKV0ubWFwKCgpID0+IFwiIFwiKS5qb2luKFwiXCIpfSR7Zm9ybWF0dGVkQXJnc31gLFxcbiAgICAgICAgICAgIHNlbmRlclxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgc3VwZXIoY2F1c2Uuc2hvcnRNZXNzYWdlIHx8IGBBbiB1bmtub3duIGVycm9yIG9jY3VycmVkIHdoaWxlIGV4ZWN1dGluZyB0aGUgY29udHJhY3QgZnVuY3Rpb24gXCIke2Z1bmN0aW9uTmFtZX1cIi5gLCB7XFxuICAgICAgICAgICAgY2F1c2UsXFxuICAgICAgICAgICAgZG9jc1BhdGg6IGRvY3NQYXRoOCxcXG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcXG4gICAgICAgICAgICAgIC4uLmNhdXNlLm1ldGFNZXNzYWdlcyA/IFsuLi5jYXVzZS5tZXRhTWVzc2FnZXMsIFwiIFwiXSA6IFtdLFxcbiAgICAgICAgICAgICAgcHJldHR5QXJncyAmJiBcIkNvbnRyYWN0IENhbGw6XCIsXFxuICAgICAgICAgICAgICBwcmV0dHlBcmdzXFxuICAgICAgICAgICAgXS5maWx0ZXIoQm9vbGVhbiksXFxuICAgICAgICAgICAgbmFtZTogXCJDb250cmFjdEZ1bmN0aW9uRXhlY3V0aW9uRXJyb3JcIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYWJpXCIsIHtcXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcmdzXCIsIHtcXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYXVzZVwiLCB7XFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udHJhY3RBZGRyZXNzXCIsIHtcXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmb3JtYXR0ZWRBcmdzXCIsIHtcXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmdW5jdGlvbk5hbWVcIiwge1xcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlbmRlclwiLCB7XFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgdGhpcy5hYmkgPSBhYmkyO1xcbiAgICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xcbiAgICAgICAgICB0aGlzLmNhdXNlID0gY2F1c2U7XFxuICAgICAgICAgIHRoaXMuY29udHJhY3RBZGRyZXNzID0gY29udHJhY3RBZGRyZXNzO1xcbiAgICAgICAgICB0aGlzLmZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uTmFtZTtcXG4gICAgICAgICAgdGhpcy5zZW5kZXIgPSBzZW5kZXI7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICBDb250cmFjdEZ1bmN0aW9uUmV2ZXJ0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgICAgICBjb25zdHJ1Y3Rvcih7IGFiaTogYWJpMiwgZGF0YSwgZnVuY3Rpb25OYW1lLCBtZXNzYWdlIH0pIHtcXG4gICAgICAgICAgbGV0IGNhdXNlO1xcbiAgICAgICAgICBsZXQgZGVjb2RlZERhdGEgPSB2b2lkIDA7XFxuICAgICAgICAgIGxldCBtZXRhTWVzc2FnZXM7XFxuICAgICAgICAgIGxldCByZWFzb247XFxuICAgICAgICAgIGlmIChkYXRhICYmIGRhdGEgIT09IFwiMHhcIikge1xcbiAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICBkZWNvZGVkRGF0YSA9IGRlY29kZUVycm9yUmVzdWx0KHsgYWJpOiBhYmkyLCBkYXRhIH0pO1xcbiAgICAgICAgICAgICAgY29uc3QgeyBhYmlJdGVtLCBlcnJvck5hbWUsIGFyZ3M6IGVycm9yQXJncyB9ID0gZGVjb2RlZERhdGE7XFxuICAgICAgICAgICAgICBpZiAoZXJyb3JOYW1lID09PSBcIkVycm9yXCIpIHtcXG4gICAgICAgICAgICAgICAgcmVhc29uID0gZXJyb3JBcmdzWzBdO1xcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvck5hbWUgPT09IFwiUGFuaWNcIikge1xcbiAgICAgICAgICAgICAgICBjb25zdCBbZmlyc3RBcmddID0gZXJyb3JBcmdzO1xcbiAgICAgICAgICAgICAgICByZWFzb24gPSBwYW5pY1JlYXNvbnNbZmlyc3RBcmddO1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JXaXRoUGFyYW1zID0gYWJpSXRlbSA/IGZvcm1hdEFiaUl0ZW0yKGFiaUl0ZW0sIHsgaW5jbHVkZU5hbWU6IHRydWUgfSkgOiB2b2lkIDA7XFxuICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZEFyZ3MgPSBhYmlJdGVtICYmIGVycm9yQXJncyA/IGZvcm1hdEFiaUl0ZW1XaXRoQXJncyh7XFxuICAgICAgICAgICAgICAgICAgYWJpSXRlbSxcXG4gICAgICAgICAgICAgICAgICBhcmdzOiBlcnJvckFyZ3MsXFxuICAgICAgICAgICAgICAgICAgaW5jbHVkZUZ1bmN0aW9uTmFtZTogZmFsc2UsXFxuICAgICAgICAgICAgICAgICAgaW5jbHVkZU5hbWU6IGZhbHNlXFxuICAgICAgICAgICAgICAgIH0pIDogdm9pZCAwO1xcbiAgICAgICAgICAgICAgICBtZXRhTWVzc2FnZXMgPSBbXFxuICAgICAgICAgICAgICAgICAgZXJyb3JXaXRoUGFyYW1zID8gYEVycm9yOiAke2Vycm9yV2l0aFBhcmFtc31gIDogXCJcIixcXG4gICAgICAgICAgICAgICAgICBmb3JtYXR0ZWRBcmdzICYmIGZvcm1hdHRlZEFyZ3MgIT09IFwiKClcIiA/IGAgICAgICAgJHtbLi4uQXJyYXkoZXJyb3JOYW1lPy5sZW5ndGggPz8gMCkua2V5cygpXS5tYXAoKCkgPT4gXCIgXCIpLmpvaW4oXCJcIil9JHtmb3JtYXR0ZWRBcmdzfWAgOiBcIlwiXFxuICAgICAgICAgICAgICAgIF07XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICAgICAgICBjYXVzZSA9IGVycjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZSlcXG4gICAgICAgICAgICByZWFzb24gPSBtZXNzYWdlO1xcbiAgICAgICAgICBsZXQgc2lnbmF0dXJlO1xcbiAgICAgICAgICBpZiAoY2F1c2UgaW5zdGFuY2VvZiBBYmlFcnJvclNpZ25hdHVyZU5vdEZvdW5kRXJyb3IpIHtcXG4gICAgICAgICAgICBzaWduYXR1cmUgPSBjYXVzZS5zaWduYXR1cmU7XFxuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzID0gW1xcbiAgICAgICAgICAgICAgYFVuYWJsZSB0byBkZWNvZGUgc2lnbmF0dXJlIFwiJHtzaWduYXR1cmV9XCIgYXMgaXQgd2FzIG5vdCBmb3VuZCBvbiB0aGUgcHJvdmlkZWQgQUJJLmAsXFxuICAgICAgICAgICAgICBcIk1ha2Ugc3VyZSB5b3UgYXJlIHVzaW5nIHRoZSBjb3JyZWN0IEFCSSBhbmQgdGhhdCB0aGUgZXJyb3IgZXhpc3RzIG9uIGl0LlwiLFxcbiAgICAgICAgICAgICAgYFlvdSBjYW4gbG9vayB1cCB0aGUgZGVjb2RlZCBzaWduYXR1cmUgaGVyZTogaHR0cHM6Ly9vcGVuY2hhaW4ueHl6L3NpZ25hdHVyZXM/cXVlcnk9JHtzaWduYXR1cmV9LmBcXG4gICAgICAgICAgICBdO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHN1cGVyKHJlYXNvbiAmJiByZWFzb24gIT09IFwiZXhlY3V0aW9uIHJldmVydGVkXCIgfHwgc2lnbmF0dXJlID8gW1xcbiAgICAgICAgICAgIGBUaGUgY29udHJhY3QgZnVuY3Rpb24gXCIke2Z1bmN0aW9uTmFtZX1cIiByZXZlcnRlZCB3aXRoIHRoZSBmb2xsb3dpbmcgJHtzaWduYXR1cmUgPyBcInNpZ25hdHVyZVwiIDogXCJyZWFzb25cIn06YCxcXG4gICAgICAgICAgICByZWFzb24gfHwgc2lnbmF0dXJlXFxuICAgICAgICAgIF0uam9pbihcIlxcXFxuXCIpIDogYFRoZSBjb250cmFjdCBmdW5jdGlvbiBcIiR7ZnVuY3Rpb25OYW1lfVwiIHJldmVydGVkLmAsIHtcXG4gICAgICAgICAgICBjYXVzZSxcXG4gICAgICAgICAgICBtZXRhTWVzc2FnZXMsXFxuICAgICAgICAgICAgbmFtZTogXCJDb250cmFjdEZ1bmN0aW9uUmV2ZXJ0ZWRFcnJvclwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkYXRhXCIsIHtcXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyYXdcIiwge1xcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlYXNvblwiLCB7XFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2lnbmF0dXJlXCIsIHtcXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICB0aGlzLmRhdGEgPSBkZWNvZGVkRGF0YTtcXG4gICAgICAgICAgdGhpcy5yYXcgPSBkYXRhO1xcbiAgICAgICAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcXG4gICAgICAgICAgdGhpcy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICBDb250cmFjdEZ1bmN0aW9uWmVyb0RhdGFFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgICAgICBjb25zdHJ1Y3Rvcih7IGZ1bmN0aW9uTmFtZSB9KSB7XFxuICAgICAgICAgIHN1cGVyKGBUaGUgY29udHJhY3QgZnVuY3Rpb24gXCIke2Z1bmN0aW9uTmFtZX1cIiByZXR1cm5lZCBubyBkYXRhIChcIjB4XCIpLmAsIHtcXG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcXG4gICAgICAgICAgICAgIFwiVGhpcyBjb3VsZCBiZSBkdWUgdG8gYW55IG9mIHRoZSBmb2xsb3dpbmc6XCIsXFxuICAgICAgICAgICAgICBgICAtIFRoZSBjb250cmFjdCBkb2VzIG5vdCBoYXZlIHRoZSBmdW5jdGlvbiBcIiR7ZnVuY3Rpb25OYW1lfVwiLGAsXFxuICAgICAgICAgICAgICBcIiAgLSBUaGUgcGFyYW1ldGVycyBwYXNzZWQgdG8gdGhlIGNvbnRyYWN0IGZ1bmN0aW9uIG1heSBiZSBpbnZhbGlkLCBvclwiLFxcbiAgICAgICAgICAgICAgXCIgIC0gVGhlIGFkZHJlc3MgaXMgbm90IGEgY29udHJhY3QuXCJcXG4gICAgICAgICAgICBdLFxcbiAgICAgICAgICAgIG5hbWU6IFwiQ29udHJhY3RGdW5jdGlvblplcm9EYXRhRXJyb3JcIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIENvdW50ZXJmYWN0dWFsRGVwbG95bWVudEZhaWxlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IyIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKHsgZmFjdG9yeSB9KSB7XFxuICAgICAgICAgIHN1cGVyKGBEZXBsb3ltZW50IGZvciBjb3VudGVyZmFjdHVhbCBjb250cmFjdCBjYWxsIGZhaWxlZCR7ZmFjdG9yeSA/IGAgZm9yIGZhY3RvcnkgXCIke2ZhY3Rvcnl9XCIuYCA6IFwiXCJ9YCwge1xcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xcbiAgICAgICAgICAgICAgXCJQbGVhc2UgZW5zdXJlOlwiLFxcbiAgICAgICAgICAgICAgXCItIFRoZSBgZmFjdG9yeWAgaXMgYSB2YWxpZCBjb250cmFjdCBkZXBsb3ltZW50IGZhY3RvcnkgKGllLiBDcmVhdGUyIEZhY3RvcnksIEVSQy00MzM3IEZhY3RvcnksIGV0YykuXCIsXFxuICAgICAgICAgICAgICBcIi0gVGhlIGBmYWN0b3J5RGF0YWAgaXMgYSB2YWxpZCBlbmNvZGVkIGZ1bmN0aW9uIGNhbGwgZm9yIGNvbnRyYWN0IGRlcGxveW1lbnQgZnVuY3Rpb24gb24gdGhlIGZhY3RvcnkuXCJcXG4gICAgICAgICAgICBdLFxcbiAgICAgICAgICAgIG5hbWU6IFwiQ291bnRlcmZhY3R1YWxEZXBsb3ltZW50RmFpbGVkRXJyb3JcIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIFJhd0NvbnRyYWN0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjIge1xcbiAgICAgICAgY29uc3RydWN0b3IoeyBkYXRhLCBtZXNzYWdlIH0pIHtcXG4gICAgICAgICAgc3VwZXIobWVzc2FnZSB8fCBcIlwiLCB7IG5hbWU6IFwiUmF3Q29udHJhY3RFcnJvclwiIH0pO1xcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHtcXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB2YWx1ZTogM1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGF0YVwiLCB7XFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2Vycm9ycy9yZXF1ZXN0LmpzXFxuICB2YXIgSHR0cFJlcXVlc3RFcnJvciwgUnBjUmVxdWVzdEVycm9yLCBUaW1lb3V0RXJyb3I7XFxuICB2YXIgaW5pdF9yZXF1ZXN0ID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2Vycm9ycy9yZXF1ZXN0LmpzXCIoKSB7XFxuICAgICAgaW5pdF9zdHJpbmdpZnkoKTtcXG4gICAgICBpbml0X2Jhc2UoKTtcXG4gICAgICBpbml0X3V0aWxzMygpO1xcbiAgICAgIEh0dHBSZXF1ZXN0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjIge1xcbiAgICAgICAgY29uc3RydWN0b3IoeyBib2R5LCBjYXVzZSwgZGV0YWlscywgaGVhZGVycywgc3RhdHVzLCB1cmwgfSkge1xcbiAgICAgICAgICBzdXBlcihcIkhUVFAgcmVxdWVzdCBmYWlsZWQuXCIsIHtcXG4gICAgICAgICAgICBjYXVzZSxcXG4gICAgICAgICAgICBkZXRhaWxzLFxcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xcbiAgICAgICAgICAgICAgc3RhdHVzICYmIGBTdGF0dXM6ICR7c3RhdHVzfWAsXFxuICAgICAgICAgICAgICBgVVJMOiAke2dldFVybCh1cmwpfWAsXFxuICAgICAgICAgICAgICBib2R5ICYmIGBSZXF1ZXN0IGJvZHk6ICR7c3RyaW5naWZ5KGJvZHkpfWBcXG4gICAgICAgICAgICBdLmZpbHRlcihCb29sZWFuKSxcXG4gICAgICAgICAgICBuYW1lOiBcIkh0dHBSZXF1ZXN0RXJyb3JcIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYm9keVwiLCB7XFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaGVhZGVyc1wiLCB7XFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdHVzXCIsIHtcXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ1cmxcIiwge1xcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XFxuICAgICAgICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XFxuICAgICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xcbiAgICAgICAgICB0aGlzLnVybCA9IHVybDtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIFJwY1JlcXVlc3RFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgICAgICBjb25zdHJ1Y3Rvcih7IGJvZHksIGVycm9yLCB1cmwgfSkge1xcbiAgICAgICAgICBzdXBlcihcIlJQQyBSZXF1ZXN0IGZhaWxlZC5cIiwge1xcbiAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcXG4gICAgICAgICAgICBkZXRhaWxzOiBlcnJvci5tZXNzYWdlLFxcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW2BVUkw6ICR7Z2V0VXJsKHVybCl9YCwgYFJlcXVlc3QgYm9keTogJHtzdHJpbmdpZnkoYm9keSl9YF0sXFxuICAgICAgICAgICAgbmFtZTogXCJScGNSZXF1ZXN0RXJyb3JcIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB7XFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGF0YVwiLCB7XFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgdGhpcy5jb2RlID0gZXJyb3IuY29kZTtcXG4gICAgICAgICAgdGhpcy5kYXRhID0gZXJyb3IuZGF0YTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIFRpbWVvdXRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgICAgICBjb25zdHJ1Y3Rvcih7IGJvZHksIHVybCB9KSB7XFxuICAgICAgICAgIHN1cGVyKFwiVGhlIHJlcXVlc3QgdG9vayB0b28gbG9uZyB0byByZXNwb25kLlwiLCB7XFxuICAgICAgICAgICAgZGV0YWlsczogXCJUaGUgcmVxdWVzdCB0aW1lZCBvdXQuXCIsXFxuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbYFVSTDogJHtnZXRVcmwodXJsKX1gLCBgUmVxdWVzdCBib2R5OiAke3N0cmluZ2lmeShib2R5KX1gXSxcXG4gICAgICAgICAgICBuYW1lOiBcIlRpbWVvdXRFcnJvclwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vZXJyb3JzL3JwYy5qc1xcbiAgdmFyIHVua25vd25FcnJvckNvZGUsIFJwY0Vycm9yLCBQcm92aWRlclJwY0Vycm9yLCBQYXJzZVJwY0Vycm9yLCBJbnZhbGlkUmVxdWVzdFJwY0Vycm9yLCBNZXRob2ROb3RGb3VuZFJwY0Vycm9yLCBJbnZhbGlkUGFyYW1zUnBjRXJyb3IsIEludGVybmFsUnBjRXJyb3IsIEludmFsaWRJbnB1dFJwY0Vycm9yLCBSZXNvdXJjZU5vdEZvdW5kUnBjRXJyb3IsIFJlc291cmNlVW5hdmFpbGFibGVScGNFcnJvciwgVHJhbnNhY3Rpb25SZWplY3RlZFJwY0Vycm9yLCBNZXRob2ROb3RTdXBwb3J0ZWRScGNFcnJvciwgTGltaXRFeGNlZWRlZFJwY0Vycm9yLCBKc29uUnBjVmVyc2lvblVuc3VwcG9ydGVkRXJyb3IsIFVzZXJSZWplY3RlZFJlcXVlc3RFcnJvciwgVW5hdXRob3JpemVkUHJvdmlkZXJFcnJvciwgVW5zdXBwb3J0ZWRQcm92aWRlck1ldGhvZEVycm9yLCBQcm92aWRlckRpc2Nvbm5lY3RlZEVycm9yLCBDaGFpbkRpc2Nvbm5lY3RlZEVycm9yLCBTd2l0Y2hDaGFpbkVycm9yLCBVbnN1cHBvcnRlZE5vbk9wdGlvbmFsQ2FwYWJpbGl0eUVycm9yLCBVbnN1cHBvcnRlZENoYWluSWRFcnJvciwgRHVwbGljYXRlSWRFcnJvciwgVW5rbm93bkJ1bmRsZUlkRXJyb3IsIEJ1bmRsZVRvb0xhcmdlRXJyb3IsIEF0b21pY1JlYWR5V2FsbGV0UmVqZWN0ZWRVcGdyYWRlRXJyb3IsIEF0b21pY2l0eU5vdFN1cHBvcnRlZEVycm9yLCBVbmtub3duUnBjRXJyb3I7XFxuICB2YXIgaW5pdF9ycGMgPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vZXJyb3JzL3JwYy5qc1wiKCkge1xcbiAgICAgIGluaXRfYmFzZSgpO1xcbiAgICAgIGluaXRfcmVxdWVzdCgpO1xcbiAgICAgIHVua25vd25FcnJvckNvZGUgPSAtMTtcXG4gICAgICBScGNFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgICAgICBjb25zdHJ1Y3RvcihjYXVzZSwgeyBjb2RlLCBkb2NzUGF0aDogZG9jc1BhdGg4LCBtZXRhTWVzc2FnZXMsIG5hbWUsIHNob3J0TWVzc2FnZSB9KSB7XFxuICAgICAgICAgIHN1cGVyKHNob3J0TWVzc2FnZSwge1xcbiAgICAgICAgICAgIGNhdXNlLFxcbiAgICAgICAgICAgIGRvY3NQYXRoOiBkb2NzUGF0aDgsXFxuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBtZXRhTWVzc2FnZXMgfHwgY2F1c2U/Lm1ldGFNZXNzYWdlcyxcXG4gICAgICAgICAgICBuYW1lOiBuYW1lIHx8IFwiUnBjRXJyb3JcIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB7XFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZSB8fCBjYXVzZS5uYW1lO1xcbiAgICAgICAgICB0aGlzLmNvZGUgPSBjYXVzZSBpbnN0YW5jZW9mIFJwY1JlcXVlc3RFcnJvciA/IGNhdXNlLmNvZGUgOiBjb2RlID8/IHVua25vd25FcnJvckNvZGU7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICBQcm92aWRlclJwY0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBScGNFcnJvciB7XFxuICAgICAgICBjb25zdHJ1Y3RvcihjYXVzZSwgb3B0aW9ucykge1xcbiAgICAgICAgICBzdXBlcihjYXVzZSwgb3B0aW9ucyk7XFxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRhdGFcIiwge1xcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIHRoaXMuZGF0YSA9IG9wdGlvbnMuZGF0YTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIFBhcnNlUnBjRXJyb3IgPSBjbGFzcyBfUGFyc2VScGNFcnJvciBleHRlbmRzIFJwY0Vycm9yIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKGNhdXNlKSB7XFxuICAgICAgICAgIHN1cGVyKGNhdXNlLCB7XFxuICAgICAgICAgICAgY29kZTogX1BhcnNlUnBjRXJyb3IuY29kZSxcXG4gICAgICAgICAgICBuYW1lOiBcIlBhcnNlUnBjRXJyb3JcIixcXG4gICAgICAgICAgICBzaG9ydE1lc3NhZ2U6IFwiSW52YWxpZCBKU09OIHdhcyByZWNlaXZlZCBieSB0aGUgc2VydmVyLiBBbiBlcnJvciBvY2N1cnJlZCBvbiB0aGUgc2VydmVyIHdoaWxlIHBhcnNpbmcgdGhlIEpTT04gdGV4dC5cIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYXJzZVJwY0Vycm9yLCBcImNvZGVcIiwge1xcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgdmFsdWU6IC0zMjcwMFxcbiAgICAgIH0pO1xcbiAgICAgIEludmFsaWRSZXF1ZXN0UnBjRXJyb3IgPSBjbGFzcyBfSW52YWxpZFJlcXVlc3RScGNFcnJvciBleHRlbmRzIFJwY0Vycm9yIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKGNhdXNlKSB7XFxuICAgICAgICAgIHN1cGVyKGNhdXNlLCB7XFxuICAgICAgICAgICAgY29kZTogX0ludmFsaWRSZXF1ZXN0UnBjRXJyb3IuY29kZSxcXG4gICAgICAgICAgICBuYW1lOiBcIkludmFsaWRSZXF1ZXN0UnBjRXJyb3JcIixcXG4gICAgICAgICAgICBzaG9ydE1lc3NhZ2U6IFwiSlNPTiBpcyBub3QgYSB2YWxpZCByZXF1ZXN0IG9iamVjdC5cIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnZhbGlkUmVxdWVzdFJwY0Vycm9yLCBcImNvZGVcIiwge1xcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgdmFsdWU6IC0zMjYwMFxcbiAgICAgIH0pO1xcbiAgICAgIE1ldGhvZE5vdEZvdW5kUnBjRXJyb3IgPSBjbGFzcyBfTWV0aG9kTm90Rm91bmRScGNFcnJvciBleHRlbmRzIFJwY0Vycm9yIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKGNhdXNlLCB7IG1ldGhvZCB9ID0ge30pIHtcXG4gICAgICAgICAgc3VwZXIoY2F1c2UsIHtcXG4gICAgICAgICAgICBjb2RlOiBfTWV0aG9kTm90Rm91bmRScGNFcnJvci5jb2RlLFxcbiAgICAgICAgICAgIG5hbWU6IFwiTWV0aG9kTm90Rm91bmRScGNFcnJvclwiLFxcbiAgICAgICAgICAgIHNob3J0TWVzc2FnZTogYFRoZSBtZXRob2Qke21ldGhvZCA/IGAgXCIke21ldGhvZH1cImAgOiBcIlwifSBkb2VzIG5vdCBleGlzdCAvIGlzIG5vdCBhdmFpbGFibGUuYFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZXRob2ROb3RGb3VuZFJwY0Vycm9yLCBcImNvZGVcIiwge1xcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgdmFsdWU6IC0zMjYwMVxcbiAgICAgIH0pO1xcbiAgICAgIEludmFsaWRQYXJhbXNScGNFcnJvciA9IGNsYXNzIF9JbnZhbGlkUGFyYW1zUnBjRXJyb3IgZXh0ZW5kcyBScGNFcnJvciB7XFxuICAgICAgICBjb25zdHJ1Y3RvcihjYXVzZSkge1xcbiAgICAgICAgICBzdXBlcihjYXVzZSwge1xcbiAgICAgICAgICAgIGNvZGU6IF9JbnZhbGlkUGFyYW1zUnBjRXJyb3IuY29kZSxcXG4gICAgICAgICAgICBuYW1lOiBcIkludmFsaWRQYXJhbXNScGNFcnJvclwiLFxcbiAgICAgICAgICAgIHNob3J0TWVzc2FnZTogW1xcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIHBhcmFtZXRlcnMgd2VyZSBwcm92aWRlZCB0byB0aGUgUlBDIG1ldGhvZC5cIixcXG4gICAgICAgICAgICAgIFwiRG91YmxlIGNoZWNrIHlvdSBoYXZlIHByb3ZpZGVkIHRoZSBjb3JyZWN0IHBhcmFtZXRlcnMuXCJcXG4gICAgICAgICAgICBdLmpvaW4oXCJcXFxcblwiKVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnZhbGlkUGFyYW1zUnBjRXJyb3IsIFwiY29kZVwiLCB7XFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICB2YWx1ZTogLTMyNjAyXFxuICAgICAgfSk7XFxuICAgICAgSW50ZXJuYWxScGNFcnJvciA9IGNsYXNzIF9JbnRlcm5hbFJwY0Vycm9yIGV4dGVuZHMgUnBjRXJyb3Ige1xcbiAgICAgICAgY29uc3RydWN0b3IoY2F1c2UpIHtcXG4gICAgICAgICAgc3VwZXIoY2F1c2UsIHtcXG4gICAgICAgICAgICBjb2RlOiBfSW50ZXJuYWxScGNFcnJvci5jb2RlLFxcbiAgICAgICAgICAgIG5hbWU6IFwiSW50ZXJuYWxScGNFcnJvclwiLFxcbiAgICAgICAgICAgIHNob3J0TWVzc2FnZTogXCJBbiBpbnRlcm5hbCBlcnJvciB3YXMgcmVjZWl2ZWQuXCJcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW50ZXJuYWxScGNFcnJvciwgXCJjb2RlXCIsIHtcXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgIHZhbHVlOiAtMzI2MDNcXG4gICAgICB9KTtcXG4gICAgICBJbnZhbGlkSW5wdXRScGNFcnJvciA9IGNsYXNzIF9JbnZhbGlkSW5wdXRScGNFcnJvciBleHRlbmRzIFJwY0Vycm9yIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKGNhdXNlKSB7XFxuICAgICAgICAgIHN1cGVyKGNhdXNlLCB7XFxuICAgICAgICAgICAgY29kZTogX0ludmFsaWRJbnB1dFJwY0Vycm9yLmNvZGUsXFxuICAgICAgICAgICAgbmFtZTogXCJJbnZhbGlkSW5wdXRScGNFcnJvclwiLFxcbiAgICAgICAgICAgIHNob3J0TWVzc2FnZTogW1xcbiAgICAgICAgICAgICAgXCJNaXNzaW5nIG9yIGludmFsaWQgcGFyYW1ldGVycy5cIixcXG4gICAgICAgICAgICAgIFwiRG91YmxlIGNoZWNrIHlvdSBoYXZlIHByb3ZpZGVkIHRoZSBjb3JyZWN0IHBhcmFtZXRlcnMuXCJcXG4gICAgICAgICAgICBdLmpvaW4oXCJcXFxcblwiKVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnZhbGlkSW5wdXRScGNFcnJvciwgXCJjb2RlXCIsIHtcXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgIHZhbHVlOiAtMzJlM1xcbiAgICAgIH0pO1xcbiAgICAgIFJlc291cmNlTm90Rm91bmRScGNFcnJvciA9IGNsYXNzIF9SZXNvdXJjZU5vdEZvdW5kUnBjRXJyb3IgZXh0ZW5kcyBScGNFcnJvciB7XFxuICAgICAgICBjb25zdHJ1Y3RvcihjYXVzZSkge1xcbiAgICAgICAgICBzdXBlcihjYXVzZSwge1xcbiAgICAgICAgICAgIGNvZGU6IF9SZXNvdXJjZU5vdEZvdW5kUnBjRXJyb3IuY29kZSxcXG4gICAgICAgICAgICBuYW1lOiBcIlJlc291cmNlTm90Rm91bmRScGNFcnJvclwiLFxcbiAgICAgICAgICAgIHNob3J0TWVzc2FnZTogXCJSZXF1ZXN0ZWQgcmVzb3VyY2Ugbm90IGZvdW5kLlwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICB2YWx1ZTogXCJSZXNvdXJjZU5vdEZvdW5kUnBjRXJyb3JcIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXNvdXJjZU5vdEZvdW5kUnBjRXJyb3IsIFwiY29kZVwiLCB7XFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICB2YWx1ZTogLTMyMDAxXFxuICAgICAgfSk7XFxuICAgICAgUmVzb3VyY2VVbmF2YWlsYWJsZVJwY0Vycm9yID0gY2xhc3MgX1Jlc291cmNlVW5hdmFpbGFibGVScGNFcnJvciBleHRlbmRzIFJwY0Vycm9yIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKGNhdXNlKSB7XFxuICAgICAgICAgIHN1cGVyKGNhdXNlLCB7XFxuICAgICAgICAgICAgY29kZTogX1Jlc291cmNlVW5hdmFpbGFibGVScGNFcnJvci5jb2RlLFxcbiAgICAgICAgICAgIG5hbWU6IFwiUmVzb3VyY2VVbmF2YWlsYWJsZVJwY0Vycm9yXCIsXFxuICAgICAgICAgICAgc2hvcnRNZXNzYWdlOiBcIlJlcXVlc3RlZCByZXNvdXJjZSBub3QgYXZhaWxhYmxlLlwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlc291cmNlVW5hdmFpbGFibGVScGNFcnJvciwgXCJjb2RlXCIsIHtcXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgIHZhbHVlOiAtMzIwMDJcXG4gICAgICB9KTtcXG4gICAgICBUcmFuc2FjdGlvblJlamVjdGVkUnBjRXJyb3IgPSBjbGFzcyBfVHJhbnNhY3Rpb25SZWplY3RlZFJwY0Vycm9yIGV4dGVuZHMgUnBjRXJyb3Ige1xcbiAgICAgICAgY29uc3RydWN0b3IoY2F1c2UpIHtcXG4gICAgICAgICAgc3VwZXIoY2F1c2UsIHtcXG4gICAgICAgICAgICBjb2RlOiBfVHJhbnNhY3Rpb25SZWplY3RlZFJwY0Vycm9yLmNvZGUsXFxuICAgICAgICAgICAgbmFtZTogXCJUcmFuc2FjdGlvblJlamVjdGVkUnBjRXJyb3JcIixcXG4gICAgICAgICAgICBzaG9ydE1lc3NhZ2U6IFwiVHJhbnNhY3Rpb24gY3JlYXRpb24gZmFpbGVkLlwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zYWN0aW9uUmVqZWN0ZWRScGNFcnJvciwgXCJjb2RlXCIsIHtcXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgIHZhbHVlOiAtMzIwMDNcXG4gICAgICB9KTtcXG4gICAgICBNZXRob2ROb3RTdXBwb3J0ZWRScGNFcnJvciA9IGNsYXNzIF9NZXRob2ROb3RTdXBwb3J0ZWRScGNFcnJvciBleHRlbmRzIFJwY0Vycm9yIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKGNhdXNlLCB7IG1ldGhvZCB9ID0ge30pIHtcXG4gICAgICAgICAgc3VwZXIoY2F1c2UsIHtcXG4gICAgICAgICAgICBjb2RlOiBfTWV0aG9kTm90U3VwcG9ydGVkUnBjRXJyb3IuY29kZSxcXG4gICAgICAgICAgICBuYW1lOiBcIk1ldGhvZE5vdFN1cHBvcnRlZFJwY0Vycm9yXCIsXFxuICAgICAgICAgICAgc2hvcnRNZXNzYWdlOiBgTWV0aG9kJHttZXRob2QgPyBgIFwiJHttZXRob2R9XCJgIDogXCJcIn0gaXMgbm90IHN1cHBvcnRlZC5gXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ldGhvZE5vdFN1cHBvcnRlZFJwY0Vycm9yLCBcImNvZGVcIiwge1xcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgdmFsdWU6IC0zMjAwNFxcbiAgICAgIH0pO1xcbiAgICAgIExpbWl0RXhjZWVkZWRScGNFcnJvciA9IGNsYXNzIF9MaW1pdEV4Y2VlZGVkUnBjRXJyb3IgZXh0ZW5kcyBScGNFcnJvciB7XFxuICAgICAgICBjb25zdHJ1Y3RvcihjYXVzZSkge1xcbiAgICAgICAgICBzdXBlcihjYXVzZSwge1xcbiAgICAgICAgICAgIGNvZGU6IF9MaW1pdEV4Y2VlZGVkUnBjRXJyb3IuY29kZSxcXG4gICAgICAgICAgICBuYW1lOiBcIkxpbWl0RXhjZWVkZWRScGNFcnJvclwiLFxcbiAgICAgICAgICAgIHNob3J0TWVzc2FnZTogXCJSZXF1ZXN0IGV4Y2VlZHMgZGVmaW5lZCBsaW1pdC5cIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaW1pdEV4Y2VlZGVkUnBjRXJyb3IsIFwiY29kZVwiLCB7XFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICB2YWx1ZTogLTMyMDA1XFxuICAgICAgfSk7XFxuICAgICAgSnNvblJwY1ZlcnNpb25VbnN1cHBvcnRlZEVycm9yID0gY2xhc3MgX0pzb25ScGNWZXJzaW9uVW5zdXBwb3J0ZWRFcnJvciBleHRlbmRzIFJwY0Vycm9yIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKGNhdXNlKSB7XFxuICAgICAgICAgIHN1cGVyKGNhdXNlLCB7XFxuICAgICAgICAgICAgY29kZTogX0pzb25ScGNWZXJzaW9uVW5zdXBwb3J0ZWRFcnJvci5jb2RlLFxcbiAgICAgICAgICAgIG5hbWU6IFwiSnNvblJwY1ZlcnNpb25VbnN1cHBvcnRlZEVycm9yXCIsXFxuICAgICAgICAgICAgc2hvcnRNZXNzYWdlOiBcIlZlcnNpb24gb2YgSlNPTi1SUEMgcHJvdG9jb2wgaXMgbm90IHN1cHBvcnRlZC5cIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShKc29uUnBjVmVyc2lvblVuc3VwcG9ydGVkRXJyb3IsIFwiY29kZVwiLCB7XFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICB2YWx1ZTogLTMyMDA2XFxuICAgICAgfSk7XFxuICAgICAgVXNlclJlamVjdGVkUmVxdWVzdEVycm9yID0gY2xhc3MgX1VzZXJSZWplY3RlZFJlcXVlc3RFcnJvciBleHRlbmRzIFByb3ZpZGVyUnBjRXJyb3Ige1xcbiAgICAgICAgY29uc3RydWN0b3IoY2F1c2UpIHtcXG4gICAgICAgICAgc3VwZXIoY2F1c2UsIHtcXG4gICAgICAgICAgICBjb2RlOiBfVXNlclJlamVjdGVkUmVxdWVzdEVycm9yLmNvZGUsXFxuICAgICAgICAgICAgbmFtZTogXCJVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3JcIixcXG4gICAgICAgICAgICBzaG9ydE1lc3NhZ2U6IFwiVXNlciByZWplY3RlZCB0aGUgcmVxdWVzdC5cIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVc2VyUmVqZWN0ZWRSZXF1ZXN0RXJyb3IsIFwiY29kZVwiLCB7XFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICB2YWx1ZTogNDAwMVxcbiAgICAgIH0pO1xcbiAgICAgIFVuYXV0aG9yaXplZFByb3ZpZGVyRXJyb3IgPSBjbGFzcyBfVW5hdXRob3JpemVkUHJvdmlkZXJFcnJvciBleHRlbmRzIFByb3ZpZGVyUnBjRXJyb3Ige1xcbiAgICAgICAgY29uc3RydWN0b3IoY2F1c2UpIHtcXG4gICAgICAgICAgc3VwZXIoY2F1c2UsIHtcXG4gICAgICAgICAgICBjb2RlOiBfVW5hdXRob3JpemVkUHJvdmlkZXJFcnJvci5jb2RlLFxcbiAgICAgICAgICAgIG5hbWU6IFwiVW5hdXRob3JpemVkUHJvdmlkZXJFcnJvclwiLFxcbiAgICAgICAgICAgIHNob3J0TWVzc2FnZTogXCJUaGUgcmVxdWVzdGVkIG1ldGhvZCBhbmQvb3IgYWNjb3VudCBoYXMgbm90IGJlZW4gYXV0aG9yaXplZCBieSB0aGUgdXNlci5cIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVbmF1dGhvcml6ZWRQcm92aWRlckVycm9yLCBcImNvZGVcIiwge1xcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgdmFsdWU6IDQxMDBcXG4gICAgICB9KTtcXG4gICAgICBVbnN1cHBvcnRlZFByb3ZpZGVyTWV0aG9kRXJyb3IgPSBjbGFzcyBfVW5zdXBwb3J0ZWRQcm92aWRlck1ldGhvZEVycm9yIGV4dGVuZHMgUHJvdmlkZXJScGNFcnJvciB7XFxuICAgICAgICBjb25zdHJ1Y3RvcihjYXVzZSwgeyBtZXRob2QgfSA9IHt9KSB7XFxuICAgICAgICAgIHN1cGVyKGNhdXNlLCB7XFxuICAgICAgICAgICAgY29kZTogX1Vuc3VwcG9ydGVkUHJvdmlkZXJNZXRob2RFcnJvci5jb2RlLFxcbiAgICAgICAgICAgIG5hbWU6IFwiVW5zdXBwb3J0ZWRQcm92aWRlck1ldGhvZEVycm9yXCIsXFxuICAgICAgICAgICAgc2hvcnRNZXNzYWdlOiBgVGhlIFByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgdGhlIHJlcXVlc3RlZCBtZXRob2Qke21ldGhvZCA/IGAgXCIgJHttZXRob2R9XCJgIDogXCJcIn0uYFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVbnN1cHBvcnRlZFByb3ZpZGVyTWV0aG9kRXJyb3IsIFwiY29kZVwiLCB7XFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICB2YWx1ZTogNDIwMFxcbiAgICAgIH0pO1xcbiAgICAgIFByb3ZpZGVyRGlzY29ubmVjdGVkRXJyb3IgPSBjbGFzcyBfUHJvdmlkZXJEaXNjb25uZWN0ZWRFcnJvciBleHRlbmRzIFByb3ZpZGVyUnBjRXJyb3Ige1xcbiAgICAgICAgY29uc3RydWN0b3IoY2F1c2UpIHtcXG4gICAgICAgICAgc3VwZXIoY2F1c2UsIHtcXG4gICAgICAgICAgICBjb2RlOiBfUHJvdmlkZXJEaXNjb25uZWN0ZWRFcnJvci5jb2RlLFxcbiAgICAgICAgICAgIG5hbWU6IFwiUHJvdmlkZXJEaXNjb25uZWN0ZWRFcnJvclwiLFxcbiAgICAgICAgICAgIHNob3J0TWVzc2FnZTogXCJUaGUgUHJvdmlkZXIgaXMgZGlzY29ubmVjdGVkIGZyb20gYWxsIGNoYWlucy5cIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcm92aWRlckRpc2Nvbm5lY3RlZEVycm9yLCBcImNvZGVcIiwge1xcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgdmFsdWU6IDQ5MDBcXG4gICAgICB9KTtcXG4gICAgICBDaGFpbkRpc2Nvbm5lY3RlZEVycm9yID0gY2xhc3MgX0NoYWluRGlzY29ubmVjdGVkRXJyb3IgZXh0ZW5kcyBQcm92aWRlclJwY0Vycm9yIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKGNhdXNlKSB7XFxuICAgICAgICAgIHN1cGVyKGNhdXNlLCB7XFxuICAgICAgICAgICAgY29kZTogX0NoYWluRGlzY29ubmVjdGVkRXJyb3IuY29kZSxcXG4gICAgICAgICAgICBuYW1lOiBcIkNoYWluRGlzY29ubmVjdGVkRXJyb3JcIixcXG4gICAgICAgICAgICBzaG9ydE1lc3NhZ2U6IFwiVGhlIFByb3ZpZGVyIGlzIG5vdCBjb25uZWN0ZWQgdG8gdGhlIHJlcXVlc3RlZCBjaGFpbi5cIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGFpbkRpc2Nvbm5lY3RlZEVycm9yLCBcImNvZGVcIiwge1xcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgdmFsdWU6IDQ5MDFcXG4gICAgICB9KTtcXG4gICAgICBTd2l0Y2hDaGFpbkVycm9yID0gY2xhc3MgX1N3aXRjaENoYWluRXJyb3IgZXh0ZW5kcyBQcm92aWRlclJwY0Vycm9yIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKGNhdXNlKSB7XFxuICAgICAgICAgIHN1cGVyKGNhdXNlLCB7XFxuICAgICAgICAgICAgY29kZTogX1N3aXRjaENoYWluRXJyb3IuY29kZSxcXG4gICAgICAgICAgICBuYW1lOiBcIlN3aXRjaENoYWluRXJyb3JcIixcXG4gICAgICAgICAgICBzaG9ydE1lc3NhZ2U6IFwiQW4gZXJyb3Igb2NjdXJyZWQgd2hlbiBhdHRlbXB0aW5nIHRvIHN3aXRjaCBjaGFpbi5cIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTd2l0Y2hDaGFpbkVycm9yLCBcImNvZGVcIiwge1xcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgdmFsdWU6IDQ5MDJcXG4gICAgICB9KTtcXG4gICAgICBVbnN1cHBvcnRlZE5vbk9wdGlvbmFsQ2FwYWJpbGl0eUVycm9yID0gY2xhc3MgX1Vuc3VwcG9ydGVkTm9uT3B0aW9uYWxDYXBhYmlsaXR5RXJyb3IgZXh0ZW5kcyBQcm92aWRlclJwY0Vycm9yIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKGNhdXNlKSB7XFxuICAgICAgICAgIHN1cGVyKGNhdXNlLCB7XFxuICAgICAgICAgICAgY29kZTogX1Vuc3VwcG9ydGVkTm9uT3B0aW9uYWxDYXBhYmlsaXR5RXJyb3IuY29kZSxcXG4gICAgICAgICAgICBuYW1lOiBcIlVuc3VwcG9ydGVkTm9uT3B0aW9uYWxDYXBhYmlsaXR5RXJyb3JcIixcXG4gICAgICAgICAgICBzaG9ydE1lc3NhZ2U6IFwiVGhpcyBXYWxsZXQgZG9lcyBub3Qgc3VwcG9ydCBhIGNhcGFiaWxpdHkgdGhhdCB3YXMgbm90IG1hcmtlZCBhcyBvcHRpb25hbC5cIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVbnN1cHBvcnRlZE5vbk9wdGlvbmFsQ2FwYWJpbGl0eUVycm9yLCBcImNvZGVcIiwge1xcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgdmFsdWU6IDU3MDBcXG4gICAgICB9KTtcXG4gICAgICBVbnN1cHBvcnRlZENoYWluSWRFcnJvciA9IGNsYXNzIF9VbnN1cHBvcnRlZENoYWluSWRFcnJvciBleHRlbmRzIFByb3ZpZGVyUnBjRXJyb3Ige1xcbiAgICAgICAgY29uc3RydWN0b3IoY2F1c2UpIHtcXG4gICAgICAgICAgc3VwZXIoY2F1c2UsIHtcXG4gICAgICAgICAgICBjb2RlOiBfVW5zdXBwb3J0ZWRDaGFpbklkRXJyb3IuY29kZSxcXG4gICAgICAgICAgICBuYW1lOiBcIlVuc3VwcG9ydGVkQ2hhaW5JZEVycm9yXCIsXFxuICAgICAgICAgICAgc2hvcnRNZXNzYWdlOiBcIlRoaXMgV2FsbGV0IGRvZXMgbm90IHN1cHBvcnQgdGhlIHJlcXVlc3RlZCBjaGFpbiBJRC5cIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVbnN1cHBvcnRlZENoYWluSWRFcnJvciwgXCJjb2RlXCIsIHtcXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgIHZhbHVlOiA1NzEwXFxuICAgICAgfSk7XFxuICAgICAgRHVwbGljYXRlSWRFcnJvciA9IGNsYXNzIF9EdXBsaWNhdGVJZEVycm9yIGV4dGVuZHMgUHJvdmlkZXJScGNFcnJvciB7XFxuICAgICAgICBjb25zdHJ1Y3RvcihjYXVzZSkge1xcbiAgICAgICAgICBzdXBlcihjYXVzZSwge1xcbiAgICAgICAgICAgIGNvZGU6IF9EdXBsaWNhdGVJZEVycm9yLmNvZGUsXFxuICAgICAgICAgICAgbmFtZTogXCJEdXBsaWNhdGVJZEVycm9yXCIsXFxuICAgICAgICAgICAgc2hvcnRNZXNzYWdlOiBcIlRoZXJlIGlzIGFscmVhZHkgYSBidW5kbGUgc3VibWl0dGVkIHdpdGggdGhpcyBJRC5cIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsaWNhdGVJZEVycm9yLCBcImNvZGVcIiwge1xcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgdmFsdWU6IDU3MjBcXG4gICAgICB9KTtcXG4gICAgICBVbmtub3duQnVuZGxlSWRFcnJvciA9IGNsYXNzIF9Vbmtub3duQnVuZGxlSWRFcnJvciBleHRlbmRzIFByb3ZpZGVyUnBjRXJyb3Ige1xcbiAgICAgICAgY29uc3RydWN0b3IoY2F1c2UpIHtcXG4gICAgICAgICAgc3VwZXIoY2F1c2UsIHtcXG4gICAgICAgICAgICBjb2RlOiBfVW5rbm93bkJ1bmRsZUlkRXJyb3IuY29kZSxcXG4gICAgICAgICAgICBuYW1lOiBcIlVua25vd25CdW5kbGVJZEVycm9yXCIsXFxuICAgICAgICAgICAgc2hvcnRNZXNzYWdlOiBcIlRoaXMgYnVuZGxlIGlkIGlzIHVua25vd24gLyBoYXMgbm90IGJlZW4gc3VibWl0dGVkXCJcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVW5rbm93bkJ1bmRsZUlkRXJyb3IsIFwiY29kZVwiLCB7XFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICB2YWx1ZTogNTczMFxcbiAgICAgIH0pO1xcbiAgICAgIEJ1bmRsZVRvb0xhcmdlRXJyb3IgPSBjbGFzcyBfQnVuZGxlVG9vTGFyZ2VFcnJvciBleHRlbmRzIFByb3ZpZGVyUnBjRXJyb3Ige1xcbiAgICAgICAgY29uc3RydWN0b3IoY2F1c2UpIHtcXG4gICAgICAgICAgc3VwZXIoY2F1c2UsIHtcXG4gICAgICAgICAgICBjb2RlOiBfQnVuZGxlVG9vTGFyZ2VFcnJvci5jb2RlLFxcbiAgICAgICAgICAgIG5hbWU6IFwiQnVuZGxlVG9vTGFyZ2VFcnJvclwiLFxcbiAgICAgICAgICAgIHNob3J0TWVzc2FnZTogXCJUaGUgY2FsbCBidW5kbGUgaXMgdG9vIGxhcmdlIGZvciB0aGUgV2FsbGV0IHRvIHByb2Nlc3MuXCJcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVuZGxlVG9vTGFyZ2VFcnJvciwgXCJjb2RlXCIsIHtcXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgIHZhbHVlOiA1NzQwXFxuICAgICAgfSk7XFxuICAgICAgQXRvbWljUmVhZHlXYWxsZXRSZWplY3RlZFVwZ3JhZGVFcnJvciA9IGNsYXNzIF9BdG9taWNSZWFkeVdhbGxldFJlamVjdGVkVXBncmFkZUVycm9yIGV4dGVuZHMgUHJvdmlkZXJScGNFcnJvciB7XFxuICAgICAgICBjb25zdHJ1Y3RvcihjYXVzZSkge1xcbiAgICAgICAgICBzdXBlcihjYXVzZSwge1xcbiAgICAgICAgICAgIGNvZGU6IF9BdG9taWNSZWFkeVdhbGxldFJlamVjdGVkVXBncmFkZUVycm9yLmNvZGUsXFxuICAgICAgICAgICAgbmFtZTogXCJBdG9taWNSZWFkeVdhbGxldFJlamVjdGVkVXBncmFkZUVycm9yXCIsXFxuICAgICAgICAgICAgc2hvcnRNZXNzYWdlOiBcIlRoZSBXYWxsZXQgY2FuIHN1cHBvcnQgYXRvbWljaXR5IGFmdGVyIGFuIHVwZ3JhZGUsIGJ1dCB0aGUgdXNlciByZWplY3RlZCB0aGUgdXBncmFkZS5cIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBdG9taWNSZWFkeVdhbGxldFJlamVjdGVkVXBncmFkZUVycm9yLCBcImNvZGVcIiwge1xcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgdmFsdWU6IDU3NTBcXG4gICAgICB9KTtcXG4gICAgICBBdG9taWNpdHlOb3RTdXBwb3J0ZWRFcnJvciA9IGNsYXNzIF9BdG9taWNpdHlOb3RTdXBwb3J0ZWRFcnJvciBleHRlbmRzIFByb3ZpZGVyUnBjRXJyb3Ige1xcbiAgICAgICAgY29uc3RydWN0b3IoY2F1c2UpIHtcXG4gICAgICAgICAgc3VwZXIoY2F1c2UsIHtcXG4gICAgICAgICAgICBjb2RlOiBfQXRvbWljaXR5Tm90U3VwcG9ydGVkRXJyb3IuY29kZSxcXG4gICAgICAgICAgICBuYW1lOiBcIkF0b21pY2l0eU5vdFN1cHBvcnRlZEVycm9yXCIsXFxuICAgICAgICAgICAgc2hvcnRNZXNzYWdlOiBcIlRoZSB3YWxsZXQgZG9lcyBub3Qgc3VwcG9ydCBhdG9taWMgZXhlY3V0aW9uIGJ1dCB0aGUgcmVxdWVzdCByZXF1aXJlcyBpdC5cIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBdG9taWNpdHlOb3RTdXBwb3J0ZWRFcnJvciwgXCJjb2RlXCIsIHtcXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgIHZhbHVlOiA1NzYwXFxuICAgICAgfSk7XFxuICAgICAgVW5rbm93blJwY0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBScGNFcnJvciB7XFxuICAgICAgICBjb25zdHJ1Y3RvcihjYXVzZSkge1xcbiAgICAgICAgICBzdXBlcihjYXVzZSwge1xcbiAgICAgICAgICAgIG5hbWU6IFwiVW5rbm93blJwY0Vycm9yXCIsXFxuICAgICAgICAgICAgc2hvcnRNZXNzYWdlOiBcIkFuIHVua25vd24gUlBDIGVycm9yIG9jY3VycmVkLlwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2hhc2hlc0AxLjcuMS9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX21kLmpzXFxuICBmdW5jdGlvbiBzZXRCaWdVaW50NjQodmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUzKSB7XFxuICAgIGlmICh0eXBlb2Ygdmlldy5zZXRCaWdVaW50NjQgPT09IFwiZnVuY3Rpb25cIilcXG4gICAgICByZXR1cm4gdmlldy5zZXRCaWdVaW50NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUzKTtcXG4gICAgY29uc3QgXzMybjMgPSBCaWdJbnQoMzIpO1xcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCg0Mjk0OTY3Mjk1KTtcXG4gICAgY29uc3Qgd2ggPSBOdW1iZXIodmFsdWUgPj4gXzMybjMgJiBfdTMyX21heCk7XFxuICAgIGNvbnN0IHdsID0gTnVtYmVyKHZhbHVlICYgX3UzMl9tYXgpO1xcbiAgICBjb25zdCBoID0gaXNMRTMgPyA0IDogMDtcXG4gICAgY29uc3QgbCA9IGlzTEUzID8gMCA6IDQ7XFxuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRTMpO1xcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgbCwgd2wsIGlzTEUzKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIENoaShhLCBiLCBjKSB7XFxuICAgIHJldHVybiBhICYgYiBeIH5hICYgYztcXG4gIH1cXG4gIGZ1bmN0aW9uIE1haihhLCBiLCBjKSB7XFxuICAgIHJldHVybiBhICYgYiBeIGEgJiBjIF4gYiAmIGM7XFxuICB9XFxuICB2YXIgSGFzaE1EO1xcbiAgdmFyIGluaXRfbWQgPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2hhc2hlc0AxLjcuMS9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX21kLmpzXCIoKSB7XFxuICAgICAgaW5pdF9hc3NlcnQoKTtcXG4gICAgICBpbml0X3V0aWxzMigpO1xcbiAgICAgIEhhc2hNRCA9IGNsYXNzIGV4dGVuZHMgSGFzaCB7XFxuICAgICAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUzKSB7XFxuICAgICAgICAgIHN1cGVyKCk7XFxuICAgICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcXG4gICAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XFxuICAgICAgICAgIHRoaXMucGFkT2Zmc2V0ID0gcGFkT2Zmc2V0O1xcbiAgICAgICAgICB0aGlzLmlzTEUgPSBpc0xFMztcXG4gICAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xcbiAgICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XFxuICAgICAgICAgIHRoaXMucG9zID0gMDtcXG4gICAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcXG4gICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XFxuICAgICAgICAgIHRoaXMudmlldyA9IGNyZWF0ZVZpZXcodGhpcy5idWZmZXIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdXBkYXRlKGRhdGEpIHtcXG4gICAgICAgICAgYWV4aXN0cyh0aGlzKTtcXG4gICAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXI6IGJ1ZmZlcjIsIGJsb2NrTGVuIH0gPSB0aGlzO1xcbiAgICAgICAgICBkYXRhID0gdG9CeXRlczIoZGF0YSk7XFxuICAgICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xcbiAgICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47ICkge1xcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xcbiAgICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBjcmVhdGVWaWV3KGRhdGEpO1xcbiAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgYnVmZmVyMi5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XFxuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcXG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XFxuICAgICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XFxuICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIHRoaXMubGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xcbiAgICAgICAgICB0aGlzLnJvdW5kQ2xlYW4oKTtcXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgICB9XFxuICAgICAgICBkaWdlc3RJbnRvKG91dCkge1xcbiAgICAgICAgICBhZXhpc3RzKHRoaXMpO1xcbiAgICAgICAgICBhb3V0cHV0KG91dCwgdGhpcyk7XFxuICAgICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xcbiAgICAgICAgICBjb25zdCB7IGJ1ZmZlcjogYnVmZmVyMiwgdmlldywgYmxvY2tMZW4sIGlzTEU6IGlzTEUzIH0gPSB0aGlzO1xcbiAgICAgICAgICBsZXQgeyBwb3MgfSA9IHRoaXM7XFxuICAgICAgICAgIGJ1ZmZlcjJbcG9zKytdID0gMTI4O1xcbiAgICAgICAgICB0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XFxuICAgICAgICAgIGlmICh0aGlzLnBhZE9mZnNldCA+IGJsb2NrTGVuIC0gcG9zKSB7XFxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xcbiAgICAgICAgICAgIHBvcyA9IDA7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXFxuICAgICAgICAgICAgYnVmZmVyMltpXSA9IDA7XFxuICAgICAgICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFMyk7XFxuICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcXG4gICAgICAgICAgY29uc3Qgb3ZpZXcgPSBjcmVhdGVWaWV3KG91dCk7XFxuICAgICAgICAgIGNvbnN0IGxlbiA9IHRoaXMub3V0cHV0TGVuO1xcbiAgICAgICAgICBpZiAobGVuICUgNClcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0XCIpO1xcbiAgICAgICAgICBjb25zdCBvdXRMZW4gPSBsZW4gLyA0O1xcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0KCk7XFxuICAgICAgICAgIGlmIChvdXRMZW4gPiBzdGF0ZS5sZW5ndGgpXFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZVwiKTtcXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRMZW47IGkrKylcXG4gICAgICAgICAgICBvdmlldy5zZXRVaW50MzIoNCAqIGksIHN0YXRlW2ldLCBpc0xFMyk7XFxuICAgICAgICB9XFxuICAgICAgICBkaWdlc3QoKSB7XFxuICAgICAgICAgIGNvbnN0IHsgYnVmZmVyOiBidWZmZXIyLCBvdXRwdXRMZW4gfSA9IHRoaXM7XFxuICAgICAgICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIyKTtcXG4gICAgICAgICAgY29uc3QgcmVzID0gYnVmZmVyMi5zbGljZSgwLCBvdXRwdXRMZW4pO1xcbiAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcXG4gICAgICAgICAgcmV0dXJuIHJlcztcXG4gICAgICAgIH1cXG4gICAgICAgIF9jbG9uZUludG8odG8pIHtcXG4gICAgICAgICAgdG8gfHwgKHRvID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKSk7XFxuICAgICAgICAgIHRvLnNldCguLi50aGlzLmdldCgpKTtcXG4gICAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgYnVmZmVyOiBidWZmZXIyLCBsZW5ndGgsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIHBvcyB9ID0gdGhpcztcXG4gICAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xcbiAgICAgICAgICB0by5wb3MgPSBwb3M7XFxuICAgICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XFxuICAgICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcXG4gICAgICAgICAgaWYgKGxlbmd0aCAlIGJsb2NrTGVuKVxcbiAgICAgICAgICAgIHRvLmJ1ZmZlci5zZXQoYnVmZmVyMik7XFxuICAgICAgICAgIHJldHVybiB0bztcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStoYXNoZXNAMS43LjEvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTI1Ni5qc1xcbiAgdmFyIFNIQTI1Nl9LLCBTSEEyNTZfSVYsIFNIQTI1Nl9XLCBTSEEyNTYsIHNoYTI1NjtcXG4gIHZhciBpbml0X3NoYTI1NiA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS9Abm9ibGUraGFzaGVzQDEuNy4xL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanNcIigpIHtcXG4gICAgICBpbml0X21kKCk7XFxuICAgICAgaW5pdF91dGlsczIoKTtcXG4gICAgICBTSEEyNTZfSyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xcbiAgICAgICAgMTExNjM1MjQwOCxcXG4gICAgICAgIDE4OTk0NDc0NDEsXFxuICAgICAgICAzMDQ5MzIzNDcxLFxcbiAgICAgICAgMzkyMTAwOTU3MyxcXG4gICAgICAgIDk2MTk4NzE2MyxcXG4gICAgICAgIDE1MDg5NzA5OTMsXFxuICAgICAgICAyNDUzNjM1NzQ4LFxcbiAgICAgICAgMjg3MDc2MzIyMSxcXG4gICAgICAgIDM2MjQzODEwODAsXFxuICAgICAgICAzMTA1OTg0MDEsXFxuICAgICAgICA2MDcyMjUyNzgsXFxuICAgICAgICAxNDI2ODgxOTg3LFxcbiAgICAgICAgMTkyNTA3ODM4OCxcXG4gICAgICAgIDIxNjIwNzgyMDYsXFxuICAgICAgICAyNjE0ODg4MTAzLFxcbiAgICAgICAgMzI0ODIyMjU4MCxcXG4gICAgICAgIDM4MzUzOTA0MDEsXFxuICAgICAgICA0MDIyMjI0Nzc0LFxcbiAgICAgICAgMjY0MzQ3MDc4LFxcbiAgICAgICAgNjA0ODA3NjI4LFxcbiAgICAgICAgNzcwMjU1OTgzLFxcbiAgICAgICAgMTI0OTE1MDEyMixcXG4gICAgICAgIDE1NTUwODE2OTIsXFxuICAgICAgICAxOTk2MDY0OTg2LFxcbiAgICAgICAgMjU1NDIyMDg4MixcXG4gICAgICAgIDI4MjE4MzQzNDksXFxuICAgICAgICAyOTUyOTk2ODA4LFxcbiAgICAgICAgMzIxMDMxMzY3MSxcXG4gICAgICAgIDMzMzY1NzE4OTEsXFxuICAgICAgICAzNTg0NTI4NzExLFxcbiAgICAgICAgMTEzOTI2OTkzLFxcbiAgICAgICAgMzM4MjQxODk1LFxcbiAgICAgICAgNjY2MzA3MjA1LFxcbiAgICAgICAgNzczNTI5OTEyLFxcbiAgICAgICAgMTI5NDc1NzM3MixcXG4gICAgICAgIDEzOTYxODIyOTEsXFxuICAgICAgICAxNjk1MTgzNzAwLFxcbiAgICAgICAgMTk4NjY2MTA1MSxcXG4gICAgICAgIDIxNzcwMjYzNTAsXFxuICAgICAgICAyNDU2OTU2MDM3LFxcbiAgICAgICAgMjczMDQ4NTkyMSxcXG4gICAgICAgIDI4MjAzMDI0MTEsXFxuICAgICAgICAzMjU5NzMwODAwLFxcbiAgICAgICAgMzM0NTc2NDc3MSxcXG4gICAgICAgIDM1MTYwNjU4MTcsXFxuICAgICAgICAzNjAwMzUyODA0LFxcbiAgICAgICAgNDA5NDU3MTkwOSxcXG4gICAgICAgIDI3NTQyMzM0NCxcXG4gICAgICAgIDQzMDIyNzczNCxcXG4gICAgICAgIDUwNjk0ODYxNixcXG4gICAgICAgIDY1OTA2MDU1NixcXG4gICAgICAgIDg4Mzk5Nzg3NyxcXG4gICAgICAgIDk1ODEzOTU3MSxcXG4gICAgICAgIDEzMjI4MjIyMTgsXFxuICAgICAgICAxNTM3MDAyMDYzLFxcbiAgICAgICAgMTc0Nzg3Mzc3OSxcXG4gICAgICAgIDE5NTU1NjIyMjIsXFxuICAgICAgICAyMDI0MTA0ODE1LFxcbiAgICAgICAgMjIyNzczMDQ1MixcXG4gICAgICAgIDIzNjE4NTI0MjQsXFxuICAgICAgICAyNDI4NDM2NDc0LFxcbiAgICAgICAgMjc1NjczNDE4NyxcXG4gICAgICAgIDMyMDQwMzE0NzksXFxuICAgICAgICAzMzI5MzI1Mjk4XFxuICAgICAgXSk7XFxuICAgICAgU0hBMjU2X0lWID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXFxuICAgICAgICAxNzc5MDMzNzAzLFxcbiAgICAgICAgMzE0NDEzNDI3NyxcXG4gICAgICAgIDEwMTM5MDQyNDIsXFxuICAgICAgICAyNzczNDgwNzYyLFxcbiAgICAgICAgMTM1OTg5MzExOSxcXG4gICAgICAgIDI2MDA4MjI5MjQsXFxuICAgICAgICA1Mjg3MzQ2MzUsXFxuICAgICAgICAxNTQxNDU5MjI1XFxuICAgICAgXSk7XFxuICAgICAgU0hBMjU2X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDY0KTtcXG4gICAgICBTSEEyNTYgPSBjbGFzcyBleHRlbmRzIEhhc2hNRCB7XFxuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcXG4gICAgICAgICAgc3VwZXIoNjQsIDMyLCA4LCBmYWxzZSk7XFxuICAgICAgICAgIHRoaXMuQSA9IFNIQTI1Nl9JVlswXSB8IDA7XFxuICAgICAgICAgIHRoaXMuQiA9IFNIQTI1Nl9JVlsxXSB8IDA7XFxuICAgICAgICAgIHRoaXMuQyA9IFNIQTI1Nl9JVlsyXSB8IDA7XFxuICAgICAgICAgIHRoaXMuRCA9IFNIQTI1Nl9JVlszXSB8IDA7XFxuICAgICAgICAgIHRoaXMuRSA9IFNIQTI1Nl9JVls0XSB8IDA7XFxuICAgICAgICAgIHRoaXMuRiA9IFNIQTI1Nl9JVls1XSB8IDA7XFxuICAgICAgICAgIHRoaXMuRyA9IFNIQTI1Nl9JVls2XSB8IDA7XFxuICAgICAgICAgIHRoaXMuSCA9IFNIQTI1Nl9JVls3XSB8IDA7XFxuICAgICAgICB9XFxuICAgICAgICBnZXQoKSB7XFxuICAgICAgICAgIGNvbnN0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcXG4gICAgICAgICAgcmV0dXJuIFtBLCBCLCBDLCBELCBFLCBGLCBHLCBIXTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxcbiAgICAgICAgc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpIHtcXG4gICAgICAgICAgdGhpcy5BID0gQSB8IDA7XFxuICAgICAgICAgIHRoaXMuQiA9IEIgfCAwO1xcbiAgICAgICAgICB0aGlzLkMgPSBDIHwgMDtcXG4gICAgICAgICAgdGhpcy5EID0gRCB8IDA7XFxuICAgICAgICAgIHRoaXMuRSA9IEUgfCAwO1xcbiAgICAgICAgICB0aGlzLkYgPSBGIHwgMDtcXG4gICAgICAgICAgdGhpcy5HID0gRyB8IDA7XFxuICAgICAgICAgIHRoaXMuSCA9IEggfCAwO1xcbiAgICAgICAgfVxcbiAgICAgICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xcbiAgICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XFxuICAgICAgICAgICAgY29uc3QgVzE1ID0gU0hBMjU2X1dbaSAtIDE1XTtcXG4gICAgICAgICAgICBjb25zdCBXMiA9IFNIQTI1Nl9XW2kgLSAyXTtcXG4gICAgICAgICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiBXMTUgPj4+IDM7XFxuICAgICAgICAgICAgY29uc3QgczEgPSByb3RyKFcyLCAxNykgXiByb3RyKFcyLCAxOSkgXiBXMiA+Pj4gMTA7XFxuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSBzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSB8IDA7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgbGV0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XFxuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gcm90cihFLCA2KSBeIHJvdHIoRSwgMTEpIF4gcm90cihFLCAyNSk7XFxuICAgICAgICAgICAgY29uc3QgVDEgPSBIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSB8IDA7XFxuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XFxuICAgICAgICAgICAgY29uc3QgVDIgPSBzaWdtYTAgKyBNYWooQSwgQiwgQykgfCAwO1xcbiAgICAgICAgICAgIEggPSBHO1xcbiAgICAgICAgICAgIEcgPSBGO1xcbiAgICAgICAgICAgIEYgPSBFO1xcbiAgICAgICAgICAgIEUgPSBEICsgVDEgfCAwO1xcbiAgICAgICAgICAgIEQgPSBDO1xcbiAgICAgICAgICAgIEMgPSBCO1xcbiAgICAgICAgICAgIEIgPSBBO1xcbiAgICAgICAgICAgIEEgPSBUMSArIFQyIHwgMDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBBID0gQSArIHRoaXMuQSB8IDA7XFxuICAgICAgICAgIEIgPSBCICsgdGhpcy5CIHwgMDtcXG4gICAgICAgICAgQyA9IEMgKyB0aGlzLkMgfCAwO1xcbiAgICAgICAgICBEID0gRCArIHRoaXMuRCB8IDA7XFxuICAgICAgICAgIEUgPSBFICsgdGhpcy5FIHwgMDtcXG4gICAgICAgICAgRiA9IEYgKyB0aGlzLkYgfCAwO1xcbiAgICAgICAgICBHID0gRyArIHRoaXMuRyB8IDA7XFxuICAgICAgICAgIEggPSBIICsgdGhpcy5IIHwgMDtcXG4gICAgICAgICAgdGhpcy5zZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCk7XFxuICAgICAgICB9XFxuICAgICAgICByb3VuZENsZWFuKCkge1xcbiAgICAgICAgICBTSEEyNTZfVy5maWxsKDApO1xcbiAgICAgICAgfVxcbiAgICAgICAgZGVzdHJveSgpIHtcXG4gICAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XFxuICAgICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICBzaGEyNTYgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyNTYoKSk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2hhc2hlc0AxLjcuMS9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaG1hYy5qc1xcbiAgdmFyIEhNQUMsIGhtYWM7XFxuICB2YXIgaW5pdF9obWFjID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStoYXNoZXNAMS43LjEvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2htYWMuanNcIigpIHtcXG4gICAgICBpbml0X2Fzc2VydCgpO1xcbiAgICAgIGluaXRfdXRpbHMyKCk7XFxuICAgICAgSE1BQyA9IGNsYXNzIGV4dGVuZHMgSGFzaCB7XFxuICAgICAgICBjb25zdHJ1Y3RvcihoYXNoMiwgX2tleSkge1xcbiAgICAgICAgICBzdXBlcigpO1xcbiAgICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XFxuICAgICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XFxuICAgICAgICAgIGFoYXNoKGhhc2gyKTtcXG4gICAgICAgICAgY29uc3Qga2V5ID0gdG9CeXRlczIoX2tleSk7XFxuICAgICAgICAgIHRoaXMuaUhhc2ggPSBoYXNoMi5jcmVhdGUoKTtcXG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPT0gXCJmdW5jdGlvblwiKVxcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaFwiKTtcXG4gICAgICAgICAgdGhpcy5ibG9ja0xlbiA9IHRoaXMuaUhhc2guYmxvY2tMZW47XFxuICAgICAgICAgIHRoaXMub3V0cHV0TGVuID0gdGhpcy5pSGFzaC5vdXRwdXRMZW47XFxuICAgICAgICAgIGNvbnN0IGJsb2NrTGVuID0gdGhpcy5ibG9ja0xlbjtcXG4gICAgICAgICAgY29uc3QgcGFkNCA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcXG4gICAgICAgICAgcGFkNC5zZXQoa2V5Lmxlbmd0aCA+IGJsb2NrTGVuID8gaGFzaDIuY3JlYXRlKCkudXBkYXRlKGtleSkuZGlnZXN0KCkgOiBrZXkpO1xcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZDQubGVuZ3RoOyBpKyspXFxuICAgICAgICAgICAgcGFkNFtpXSBePSA1NDtcXG4gICAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUocGFkNCk7XFxuICAgICAgICAgIHRoaXMub0hhc2ggPSBoYXNoMi5jcmVhdGUoKTtcXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQ0Lmxlbmd0aDsgaSsrKVxcbiAgICAgICAgICAgIHBhZDRbaV0gXj0gNTQgXiA5MjtcXG4gICAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUocGFkNCk7XFxuICAgICAgICAgIHBhZDQuZmlsbCgwKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHVwZGF0ZShidWYpIHtcXG4gICAgICAgICAgYWV4aXN0cyh0aGlzKTtcXG4gICAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUoYnVmKTtcXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgICB9XFxuICAgICAgICBkaWdlc3RJbnRvKG91dCkge1xcbiAgICAgICAgICBhZXhpc3RzKHRoaXMpO1xcbiAgICAgICAgICBhYnl0ZXMob3V0LCB0aGlzLm91dHB1dExlbik7XFxuICAgICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xcbiAgICAgICAgICB0aGlzLmlIYXNoLmRpZ2VzdEludG8ob3V0KTtcXG4gICAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUob3V0KTtcXG4gICAgICAgICAgdGhpcy5vSGFzaC5kaWdlc3RJbnRvKG91dCk7XFxuICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZGlnZXN0KCkge1xcbiAgICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XFxuICAgICAgICAgIHRoaXMuZGlnZXN0SW50byhvdXQpO1xcbiAgICAgICAgICByZXR1cm4gb3V0O1xcbiAgICAgICAgfVxcbiAgICAgICAgX2Nsb25lSW50byh0bykge1xcbiAgICAgICAgICB0byB8fCAodG8gPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcXG4gICAgICAgICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XFxuICAgICAgICAgIHRvID0gdG87XFxuICAgICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XFxuICAgICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcXG4gICAgICAgICAgdG8uYmxvY2tMZW4gPSBibG9ja0xlbjtcXG4gICAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xcbiAgICAgICAgICB0by5vSGFzaCA9IG9IYXNoLl9jbG9uZUludG8odG8ub0hhc2gpO1xcbiAgICAgICAgICB0by5pSGFzaCA9IGlIYXNoLl9jbG9uZUludG8odG8uaUhhc2gpO1xcbiAgICAgICAgICByZXR1cm4gdG87XFxuICAgICAgICB9XFxuICAgICAgICBkZXN0cm95KCkge1xcbiAgICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XFxuICAgICAgICAgIHRoaXMub0hhc2guZGVzdHJveSgpO1xcbiAgICAgICAgICB0aGlzLmlIYXNoLmRlc3Ryb3koKTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIGhtYWMgPSAoaGFzaDIsIGtleSwgbWVzc2FnZSkgPT4gbmV3IEhNQUMoaGFzaDIsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpO1xcbiAgICAgIGhtYWMuY3JlYXRlID0gKGhhc2gyLCBrZXkpID0+IG5ldyBITUFDKGhhc2gyLCBrZXkpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStjdXJ2ZXNAMS44LjEvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3V0aWxzLmpzXFxuICB2YXIgdXRpbHNfZXhwb3J0cyA9IHt9O1xcbiAgX19leHBvcnQodXRpbHNfZXhwb3J0cywge1xcbiAgICBhSW5SYW5nZTogKCkgPT4gYUluUmFuZ2UsXFxuICAgIGFib29sOiAoKSA9PiBhYm9vbCxcXG4gICAgYWJ5dGVzOiAoKSA9PiBhYnl0ZXMyLFxcbiAgICBiaXRHZXQ6ICgpID0+IGJpdEdldCxcXG4gICAgYml0TGVuOiAoKSA9PiBiaXRMZW4sXFxuICAgIGJpdE1hc2s6ICgpID0+IGJpdE1hc2ssXFxuICAgIGJpdFNldDogKCkgPT4gYml0U2V0LFxcbiAgICBieXRlc1RvSGV4OiAoKSA9PiBieXRlc1RvSGV4MixcXG4gICAgYnl0ZXNUb051bWJlckJFOiAoKSA9PiBieXRlc1RvTnVtYmVyQkUsXFxuICAgIGJ5dGVzVG9OdW1iZXJMRTogKCkgPT4gYnl0ZXNUb051bWJlckxFLFxcbiAgICBjb25jYXRCeXRlczogKCkgPT4gY29uY2F0Qnl0ZXMzLFxcbiAgICBjcmVhdGVIbWFjRHJiZzogKCkgPT4gY3JlYXRlSG1hY0RyYmcsXFxuICAgIGVuc3VyZUJ5dGVzOiAoKSA9PiBlbnN1cmVCeXRlcyxcXG4gICAgZXF1YWxCeXRlczogKCkgPT4gZXF1YWxCeXRlcyxcXG4gICAgaGV4VG9CeXRlczogKCkgPT4gaGV4VG9CeXRlczIsXFxuICAgIGhleFRvTnVtYmVyOiAoKSA9PiBoZXhUb051bWJlcjIsXFxuICAgIGluUmFuZ2U6ICgpID0+IGluUmFuZ2UsXFxuICAgIGlzQnl0ZXM6ICgpID0+IGlzQnl0ZXMyLFxcbiAgICBtZW1vaXplZDogKCkgPT4gbWVtb2l6ZWQsXFxuICAgIG5vdEltcGxlbWVudGVkOiAoKSA9PiBub3RJbXBsZW1lbnRlZCxcXG4gICAgbnVtYmVyVG9CeXRlc0JFOiAoKSA9PiBudW1iZXJUb0J5dGVzQkUsXFxuICAgIG51bWJlclRvQnl0ZXNMRTogKCkgPT4gbnVtYmVyVG9CeXRlc0xFLFxcbiAgICBudW1iZXJUb0hleFVucGFkZGVkOiAoKSA9PiBudW1iZXJUb0hleFVucGFkZGVkLFxcbiAgICBudW1iZXJUb1ZhckJ5dGVzQkU6ICgpID0+IG51bWJlclRvVmFyQnl0ZXNCRSxcXG4gICAgdXRmOFRvQnl0ZXM6ICgpID0+IHV0ZjhUb0J5dGVzMixcXG4gICAgdmFsaWRhdGVPYmplY3Q6ICgpID0+IHZhbGlkYXRlT2JqZWN0XFxuICB9KTtcXG4gIGZ1bmN0aW9uIGlzQnl0ZXMyKGEpIHtcXG4gICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IEFycmF5QnVmZmVyLmlzVmlldyhhKSAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiVWludDhBcnJheVwiO1xcbiAgfVxcbiAgZnVuY3Rpb24gYWJ5dGVzMihpdGVtKSB7XFxuICAgIGlmICghaXNCeXRlczIoaXRlbSkpXFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVWludDhBcnJheSBleHBlY3RlZFwiKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGFib29sKHRpdGxlLCB2YWx1ZSkge1xcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImJvb2xlYW5cIilcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IodGl0bGUgKyBcIiBib29sZWFuIGV4cGVjdGVkLCBnb3QgXCIgKyB2YWx1ZSk7XFxuICB9XFxuICBmdW5jdGlvbiBieXRlc1RvSGV4MihieXRlcykge1xcbiAgICBhYnl0ZXMyKGJ5dGVzKTtcXG4gICAgbGV0IGhleCA9IFwiXCI7XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICBoZXggKz0gaGV4ZXMyW2J5dGVzW2ldXTtcXG4gICAgfVxcbiAgICByZXR1cm4gaGV4O1xcbiAgfVxcbiAgZnVuY3Rpb24gbnVtYmVyVG9IZXhVbnBhZGRlZChudW0yKSB7XFxuICAgIGNvbnN0IGhleCA9IG51bTIudG9TdHJpbmcoMTYpO1xcbiAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyBcIjBcIiArIGhleCA6IGhleDtcXG4gIH1cXG4gIGZ1bmN0aW9uIGhleFRvTnVtYmVyMihoZXgpIHtcXG4gICAgaWYgKHR5cGVvZiBoZXggIT09IFwic3RyaW5nXCIpXFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IFwiICsgdHlwZW9mIGhleCk7XFxuICAgIHJldHVybiBoZXggPT09IFwiXCIgPyBfMG4yIDogQmlnSW50KFwiMHhcIiArIGhleCk7XFxuICB9XFxuICBmdW5jdGlvbiBhc2NpaVRvQmFzZTE2KGNoKSB7XFxuICAgIGlmIChjaCA+PSBhc2NpaXMuXzAgJiYgY2ggPD0gYXNjaWlzLl85KVxcbiAgICAgIHJldHVybiBjaCAtIGFzY2lpcy5fMDtcXG4gICAgaWYgKGNoID49IGFzY2lpcy5BICYmIGNoIDw9IGFzY2lpcy5GKVxcbiAgICAgIHJldHVybiBjaCAtIChhc2NpaXMuQSAtIDEwKTtcXG4gICAgaWYgKGNoID49IGFzY2lpcy5hICYmIGNoIDw9IGFzY2lpcy5mKVxcbiAgICAgIHJldHVybiBjaCAtIChhc2NpaXMuYSAtIDEwKTtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgZnVuY3Rpb24gaGV4VG9CeXRlczIoaGV4KSB7XFxuICAgIGlmICh0eXBlb2YgaGV4ICE9PSBcInN0cmluZ1wiKVxcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCBcIiArIHR5cGVvZiBoZXgpO1xcbiAgICBjb25zdCBobCA9IGhleC5sZW5ndGg7XFxuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xcbiAgICBpZiAoaGwgJSAyKVxcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoIFwiICsgaGwpO1xcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFsKTtcXG4gICAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcXG4gICAgICBjb25zdCBuMSA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkpKTtcXG4gICAgICBjb25zdCBuMiA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkgKyAxKSk7XFxuICAgICAgaWYgKG4xID09PSB2b2lkIDAgfHwgbjIgPT09IHZvaWQgMCkge1xcbiAgICAgICAgY29uc3QgY2hhciA9IGhleFtoaV0gKyBoZXhbaGkgKyAxXTtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcXCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3Qgbm9uLWhleCBjaGFyYWN0ZXIgXCJcXCcgKyBjaGFyICsgXFwnXCIgYXQgaW5kZXggXFwnICsgaGkpO1xcbiAgICAgIH1cXG4gICAgICBhcnJheVthaV0gPSBuMSAqIDE2ICsgbjI7XFxuICAgIH1cXG4gICAgcmV0dXJuIGFycmF5O1xcbiAgfVxcbiAgZnVuY3Rpb24gYnl0ZXNUb051bWJlckJFKGJ5dGVzKSB7XFxuICAgIHJldHVybiBoZXhUb051bWJlcjIoYnl0ZXNUb0hleDIoYnl0ZXMpKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJMRShieXRlcykge1xcbiAgICBhYnl0ZXMyKGJ5dGVzKTtcXG4gICAgcmV0dXJuIGhleFRvTnVtYmVyMihieXRlc1RvSGV4MihVaW50OEFycmF5LmZyb20oYnl0ZXMpLnJldmVyc2UoKSkpO1xcbiAgfVxcbiAgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikge1xcbiAgICByZXR1cm4gaGV4VG9CeXRlczIobi50b1N0cmluZygxNikucGFkU3RhcnQobGVuICogMiwgXCIwXCIpKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIG51bWJlclRvQnl0ZXNMRShuLCBsZW4pIHtcXG4gICAgcmV0dXJuIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pLnJldmVyc2UoKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIG51bWJlclRvVmFyQnl0ZXNCRShuKSB7XFxuICAgIHJldHVybiBoZXhUb0J5dGVzMihudW1iZXJUb0hleFVucGFkZGVkKG4pKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGVuc3VyZUJ5dGVzKHRpdGxlLCBoZXgsIGV4cGVjdGVkTGVuZ3RoKSB7XFxuICAgIGxldCByZXM7XFxuICAgIGlmICh0eXBlb2YgaGV4ID09PSBcInN0cmluZ1wiKSB7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIHJlcyA9IGhleFRvQnl0ZXMyKGhleCk7XFxuICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRpdGxlICsgXCIgbXVzdCBiZSBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGNhdXNlOiBcIiArIGUpO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmIChpc0J5dGVzMihoZXgpKSB7XFxuICAgICAgcmVzID0gVWludDhBcnJheS5mcm9tKGhleCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKHRpdGxlICsgXCIgbXVzdCBiZSBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXlcIik7XFxuICAgIH1cXG4gICAgY29uc3QgbGVuID0gcmVzLmxlbmd0aDtcXG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZExlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW4gIT09IGV4cGVjdGVkTGVuZ3RoKVxcbiAgICAgIHRocm93IG5ldyBFcnJvcih0aXRsZSArIFwiIG9mIGxlbmd0aCBcIiArIGV4cGVjdGVkTGVuZ3RoICsgXCIgZXhwZWN0ZWQsIGdvdCBcIiArIGxlbik7XFxuICAgIHJldHVybiByZXM7XFxuICB9XFxuICBmdW5jdGlvbiBjb25jYXRCeXRlczMoLi4uYXJyYXlzKSB7XFxuICAgIGxldCBzdW0gPSAwO1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xcbiAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XFxuICAgICAgYWJ5dGVzMihhKTtcXG4gICAgICBzdW0gKz0gYS5sZW5ndGg7XFxuICAgIH1cXG4gICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoc3VtKTtcXG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZDQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcXG4gICAgICByZXMuc2V0KGEsIHBhZDQpO1xcbiAgICAgIHBhZDQgKz0gYS5sZW5ndGg7XFxuICAgIH1cXG4gICAgcmV0dXJuIHJlcztcXG4gIH1cXG4gIGZ1bmN0aW9uIGVxdWFsQnl0ZXMoYSwgYikge1xcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgbGV0IGRpZmYgPSAwO1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXFxuICAgICAgZGlmZiB8PSBhW2ldIF4gYltpXTtcXG4gICAgcmV0dXJuIGRpZmYgPT09IDA7XFxuICB9XFxuICBmdW5jdGlvbiB1dGY4VG9CeXRlczIoc3RyKSB7XFxuICAgIGlmICh0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiKVxcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInN0cmluZyBleHBlY3RlZFwiKTtcXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGluUmFuZ2UobiwgbWluLCBtYXgpIHtcXG4gICAgcmV0dXJuIGlzUG9zQmlnKG4pICYmIGlzUG9zQmlnKG1pbikgJiYgaXNQb3NCaWcobWF4KSAmJiBtaW4gPD0gbiAmJiBuIDwgbWF4O1xcbiAgfVxcbiAgZnVuY3Rpb24gYUluUmFuZ2UodGl0bGUsIG4sIG1pbiwgbWF4KSB7XFxuICAgIGlmICghaW5SYW5nZShuLCBtaW4sIG1heCkpXFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgdmFsaWQgXCIgKyB0aXRsZSArIFwiOiBcIiArIG1pbiArIFwiIDw9IG4gPCBcIiArIG1heCArIFwiLCBnb3QgXCIgKyBuKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGJpdExlbihuKSB7XFxuICAgIGxldCBsZW47XFxuICAgIGZvciAobGVuID0gMDsgbiA+IF8wbjI7IG4gPj49IF8xbjIsIGxlbiArPSAxKVxcbiAgICAgIDtcXG4gICAgcmV0dXJuIGxlbjtcXG4gIH1cXG4gIGZ1bmN0aW9uIGJpdEdldChuLCBwb3MpIHtcXG4gICAgcmV0dXJuIG4gPj4gQmlnSW50KHBvcykgJiBfMW4yO1xcbiAgfVxcbiAgZnVuY3Rpb24gYml0U2V0KG4sIHBvcywgdmFsdWUpIHtcXG4gICAgcmV0dXJuIG4gfCAodmFsdWUgPyBfMW4yIDogXzBuMikgPDwgQmlnSW50KHBvcyk7XFxuICB9XFxuICBmdW5jdGlvbiBjcmVhdGVIbWFjRHJiZyhoYXNoTGVuLCBxQnl0ZUxlbiwgaG1hY0ZuKSB7XFxuICAgIGlmICh0eXBlb2YgaGFzaExlbiAhPT0gXCJudW1iZXJcIiB8fCBoYXNoTGVuIDwgMilcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJoYXNoTGVuIG11c3QgYmUgYSBudW1iZXJcIik7XFxuICAgIGlmICh0eXBlb2YgcUJ5dGVMZW4gIT09IFwibnVtYmVyXCIgfHwgcUJ5dGVMZW4gPCAyKVxcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInFCeXRlTGVuIG11c3QgYmUgYSBudW1iZXJcIik7XFxuICAgIGlmICh0eXBlb2YgaG1hY0ZuICE9PSBcImZ1bmN0aW9uXCIpXFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaG1hY0ZuIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcXG4gICAgbGV0IHYgPSB1OG4oaGFzaExlbik7XFxuICAgIGxldCBrID0gdThuKGhhc2hMZW4pO1xcbiAgICBsZXQgaSA9IDA7XFxuICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xcbiAgICAgIHYuZmlsbCgxKTtcXG4gICAgICBrLmZpbGwoMCk7XFxuICAgICAgaSA9IDA7XFxuICAgIH07XFxuICAgIGNvbnN0IGggPSAoLi4uYikgPT4gaG1hY0ZuKGssIHYsIC4uLmIpO1xcbiAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IHU4bigpKSA9PiB7XFxuICAgICAgayA9IGgodThmcihbMF0pLCBzZWVkKTtcXG4gICAgICB2ID0gaCgpO1xcbiAgICAgIGlmIChzZWVkLmxlbmd0aCA9PT0gMClcXG4gICAgICAgIHJldHVybjtcXG4gICAgICBrID0gaCh1OGZyKFsxXSksIHNlZWQpO1xcbiAgICAgIHYgPSBoKCk7XFxuICAgIH07XFxuICAgIGNvbnN0IGdlbjMgPSAoKSA9PiB7XFxuICAgICAgaWYgKGkrKyA+PSAxZTMpXFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkcmJnOiB0cmllZCAxMDAwIHZhbHVlc1wiKTtcXG4gICAgICBsZXQgbGVuID0gMDtcXG4gICAgICBjb25zdCBvdXQgPSBbXTtcXG4gICAgICB3aGlsZSAobGVuIDwgcUJ5dGVMZW4pIHtcXG4gICAgICAgIHYgPSBoKCk7XFxuICAgICAgICBjb25zdCBzbCA9IHYuc2xpY2UoKTtcXG4gICAgICAgIG91dC5wdXNoKHNsKTtcXG4gICAgICAgIGxlbiArPSB2Lmxlbmd0aDtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzMyguLi5vdXQpO1xcbiAgICB9O1xcbiAgICBjb25zdCBnZW5VbnRpbCA9IChzZWVkLCBwcmVkKSA9PiB7XFxuICAgICAgcmVzZXQoKTtcXG4gICAgICByZXNlZWQoc2VlZCk7XFxuICAgICAgbGV0IHJlcyA9IHZvaWQgMDtcXG4gICAgICB3aGlsZSAoIShyZXMgPSBwcmVkKGdlbjMoKSkpKVxcbiAgICAgICAgcmVzZWVkKCk7XFxuICAgICAgcmVzZXQoKTtcXG4gICAgICByZXR1cm4gcmVzO1xcbiAgICB9O1xcbiAgICByZXR1cm4gZ2VuVW50aWw7XFxuICB9XFxuICBmdW5jdGlvbiB2YWxpZGF0ZU9iamVjdChvYmplY3QsIHZhbGlkYXRvcnMsIG9wdFZhbGlkYXRvcnMgPSB7fSkge1xcbiAgICBjb25zdCBjaGVja0ZpZWxkID0gKGZpZWxkTmFtZSwgdHlwZSwgaXNPcHRpb25hbCkgPT4ge1xcbiAgICAgIGNvbnN0IGNoZWNrVmFsID0gdmFsaWRhdG9yRm5zW3R5cGVdO1xcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tWYWwgIT09IFwiZnVuY3Rpb25cIilcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdmFsaWRhdG9yIGZ1bmN0aW9uXCIpO1xcbiAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtmaWVsZE5hbWVdO1xcbiAgICAgIGlmIChpc09wdGlvbmFsICYmIHZhbCA9PT0gdm9pZCAwKVxcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIGlmICghY2hlY2tWYWwodmFsLCBvYmplY3QpKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYXJhbSBcIiArIFN0cmluZyhmaWVsZE5hbWUpICsgXCIgaXMgaW52YWxpZC4gRXhwZWN0ZWQgXCIgKyB0eXBlICsgXCIsIGdvdCBcIiArIHZhbCk7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbGlkYXRvcnMpKVxcbiAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCBmYWxzZSk7XFxuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0VmFsaWRhdG9ycykpXFxuICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIHRydWUpO1xcbiAgICByZXR1cm4gb2JqZWN0O1xcbiAgfVxcbiAgZnVuY3Rpb24gbWVtb2l6ZWQoZm4pIHtcXG4gICAgY29uc3QgbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XFxuICAgIHJldHVybiAoYXJnLCAuLi5hcmdzKSA9PiB7XFxuICAgICAgY29uc3QgdmFsID0gbWFwLmdldChhcmcpO1xcbiAgICAgIGlmICh2YWwgIT09IHZvaWQgMClcXG4gICAgICAgIHJldHVybiB2YWw7XFxuICAgICAgY29uc3QgY29tcHV0ZWQgPSBmbihhcmcsIC4uLmFyZ3MpO1xcbiAgICAgIG1hcC5zZXQoYXJnLCBjb21wdXRlZCk7XFxuICAgICAgcmV0dXJuIGNvbXB1dGVkO1xcbiAgICB9O1xcbiAgfVxcbiAgdmFyIF8wbjIsIF8xbjIsIF8ybjIsIGhleGVzMiwgYXNjaWlzLCBpc1Bvc0JpZywgYml0TWFzaywgdThuLCB1OGZyLCB2YWxpZGF0b3JGbnMsIG5vdEltcGxlbWVudGVkO1xcbiAgdmFyIGluaXRfdXRpbHM0ID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStjdXJ2ZXNAMS44LjEvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3V0aWxzLmpzXCIoKSB7XFxuICAgICAgXzBuMiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCk7XFxuICAgICAgXzFuMiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMSk7XFxuICAgICAgXzJuMiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMik7XFxuICAgICAgaGV4ZXMyID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKTtcXG4gICAgICBhc2NpaXMgPSB7IF8wOiA0OCwgXzk6IDU3LCBBOiA2NSwgRjogNzAsIGE6IDk3LCBmOiAxMDIgfTtcXG4gICAgICBpc1Bvc0JpZyA9IChuKSA9PiB0eXBlb2YgbiA9PT0gXCJiaWdpbnRcIiAmJiBfMG4yIDw9IG47XFxuICAgICAgYml0TWFzayA9IChuKSA9PiAoXzJuMiA8PCBCaWdJbnQobiAtIDEpKSAtIF8xbjI7XFxuICAgICAgdThuID0gKGRhdGEpID0+IG5ldyBVaW50OEFycmF5KGRhdGEpO1xcbiAgICAgIHU4ZnIgPSAoYXJyKSA9PiBVaW50OEFycmF5LmZyb20oYXJyKTtcXG4gICAgICB2YWxpZGF0b3JGbnMgPSB7XFxuICAgICAgICBiaWdpbnQ6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwiYmlnaW50XCIsXFxuICAgICAgICBmdW5jdGlvbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiLFxcbiAgICAgICAgYm9vbGVhbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJib29sZWFuXCIsXFxuICAgICAgICBzdHJpbmc6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIsXFxuICAgICAgICBzdHJpbmdPclVpbnQ4QXJyYXk6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgfHwgaXNCeXRlczIodmFsKSxcXG4gICAgICAgIGlzU2FmZUludGVnZXI6ICh2YWwpID0+IE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbCksXFxuICAgICAgICBhcnJheTogKHZhbCkgPT4gQXJyYXkuaXNBcnJheSh2YWwpLFxcbiAgICAgICAgZmllbGQ6ICh2YWwsIG9iamVjdCkgPT4gb2JqZWN0LkZwLmlzVmFsaWQodmFsKSxcXG4gICAgICAgIGhhc2g6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIiAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwub3V0cHV0TGVuKVxcbiAgICAgIH07XFxuICAgICAgbm90SW1wbGVtZW50ZWQgPSAoKSA9PiB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XFxuICAgICAgfTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS9Abm9ibGUrY3VydmVzQDEuOC4xL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzXFxuICBmdW5jdGlvbiBtb2QoYSwgYikge1xcbiAgICBjb25zdCByZXN1bHQgPSBhICUgYjtcXG4gICAgcmV0dXJuIHJlc3VsdCA+PSBfMG4zID8gcmVzdWx0IDogYiArIHJlc3VsdDtcXG4gIH1cXG4gIGZ1bmN0aW9uIHBvdyhudW0yLCBwb3dlciwgbW9kdWxvKSB7XFxuICAgIGlmIChwb3dlciA8IF8wbjMpXFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBleHBvbmVudCwgbmVnYXRpdmVzIHVuc3VwcG9ydGVkXCIpO1xcbiAgICBpZiAobW9kdWxvIDw9IF8wbjMpXFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBtb2R1bHVzXCIpO1xcbiAgICBpZiAobW9kdWxvID09PSBfMW4zKVxcbiAgICAgIHJldHVybiBfMG4zO1xcbiAgICBsZXQgcmVzID0gXzFuMztcXG4gICAgd2hpbGUgKHBvd2VyID4gXzBuMykge1xcbiAgICAgIGlmIChwb3dlciAmIF8xbjMpXFxuICAgICAgICByZXMgPSByZXMgKiBudW0yICUgbW9kdWxvO1xcbiAgICAgIG51bTIgPSBudW0yICogbnVtMiAlIG1vZHVsbztcXG4gICAgICBwb3dlciA+Pj0gXzFuMztcXG4gICAgfVxcbiAgICByZXR1cm4gcmVzO1xcbiAgfVxcbiAgZnVuY3Rpb24gcG93Mih4LCBwb3dlciwgbW9kdWxvKSB7XFxuICAgIGxldCByZXMgPSB4O1xcbiAgICB3aGlsZSAocG93ZXItLSA+IF8wbjMpIHtcXG4gICAgICByZXMgKj0gcmVzO1xcbiAgICAgIHJlcyAlPSBtb2R1bG87XFxuICAgIH1cXG4gICAgcmV0dXJuIHJlcztcXG4gIH1cXG4gIGZ1bmN0aW9uIGludmVydChudW1iZXIsIG1vZHVsbykge1xcbiAgICBpZiAobnVtYmVyID09PSBfMG4zKVxcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmVydDogZXhwZWN0ZWQgbm9uLXplcm8gbnVtYmVyXCIpO1xcbiAgICBpZiAobW9kdWxvIDw9IF8wbjMpXFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52ZXJ0OiBleHBlY3RlZCBwb3NpdGl2ZSBtb2R1bHVzLCBnb3QgXCIgKyBtb2R1bG8pO1xcbiAgICBsZXQgYSA9IG1vZChudW1iZXIsIG1vZHVsbyk7XFxuICAgIGxldCBiID0gbW9kdWxvO1xcbiAgICBsZXQgeCA9IF8wbjMsIHkgPSBfMW4zLCB1ID0gXzFuMywgdiA9IF8wbjM7XFxuICAgIHdoaWxlIChhICE9PSBfMG4zKSB7XFxuICAgICAgY29uc3QgcSA9IGIgLyBhO1xcbiAgICAgIGNvbnN0IHIgPSBiICUgYTtcXG4gICAgICBjb25zdCBtID0geCAtIHUgKiBxO1xcbiAgICAgIGNvbnN0IG4gPSB5IC0gdiAqIHE7XFxuICAgICAgYiA9IGEsIGEgPSByLCB4ID0gdSwgeSA9IHYsIHUgPSBtLCB2ID0gbjtcXG4gICAgfVxcbiAgICBjb25zdCBnY2QgPSBiO1xcbiAgICBpZiAoZ2NkICE9PSBfMW4zKVxcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmVydDogZG9lcyBub3QgZXhpc3RcIik7XFxuICAgIHJldHVybiBtb2QoeCwgbW9kdWxvKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIHRvbmVsbGlTaGFua3MoUCkge1xcbiAgICBjb25zdCBsZWdlbmRyZUMgPSAoUCAtIF8xbjMpIC8gXzJuMztcXG4gICAgbGV0IFEsIFMsIFo7XFxuICAgIGZvciAoUSA9IFAgLSBfMW4zLCBTID0gMDsgUSAlIF8ybjMgPT09IF8wbjM7IFEgLz0gXzJuMywgUysrKVxcbiAgICAgIDtcXG4gICAgZm9yIChaID0gXzJuMzsgWiA8IFAgJiYgcG93KFosIGxlZ2VuZHJlQywgUCkgIT09IFAgLSBfMW4zOyBaKyspIHtcXG4gICAgICBpZiAoWiA+IDFlMylcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIHNxdWFyZSByb290OiBsaWtlbHkgbm9uLXByaW1lIFBcIik7XFxuICAgIH1cXG4gICAgaWYgKFMgPT09IDEpIHtcXG4gICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbjMpIC8gXzRuO1xcbiAgICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpRmFzdChGcCwgbikge1xcbiAgICAgICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xcbiAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3RcIik7XFxuICAgICAgICByZXR1cm4gcm9vdDtcXG4gICAgICB9O1xcbiAgICB9XFxuICAgIGNvbnN0IFExZGl2MiA9IChRICsgXzFuMykgLyBfMm4zO1xcbiAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaVNsb3coRnAsIG4pIHtcXG4gICAgICBpZiAoRnAucG93KG4sIGxlZ2VuZHJlQykgPT09IEZwLm5lZyhGcC5PTkUpKVxcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3RcIik7XFxuICAgICAgbGV0IHIgPSBTO1xcbiAgICAgIGxldCBnID0gRnAucG93KEZwLm11bChGcC5PTkUsIFopLCBRKTtcXG4gICAgICBsZXQgeCA9IEZwLnBvdyhuLCBRMWRpdjIpO1xcbiAgICAgIGxldCBiID0gRnAucG93KG4sIFEpO1xcbiAgICAgIHdoaWxlICghRnAuZXFsKGIsIEZwLk9ORSkpIHtcXG4gICAgICAgIGlmIChGcC5lcWwoYiwgRnAuWkVSTykpXFxuICAgICAgICAgIHJldHVybiBGcC5aRVJPO1xcbiAgICAgICAgbGV0IG0gPSAxO1xcbiAgICAgICAgZm9yIChsZXQgdDIgPSBGcC5zcXIoYik7IG0gPCByOyBtKyspIHtcXG4gICAgICAgICAgaWYgKEZwLmVxbCh0MiwgRnAuT05FKSlcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgdDIgPSBGcC5zcXIodDIpO1xcbiAgICAgICAgfVxcbiAgICAgICAgY29uc3QgZ2UgPSBGcC5wb3coZywgXzFuMyA8PCBCaWdJbnQociAtIG0gLSAxKSk7XFxuICAgICAgICBnID0gRnAuc3FyKGdlKTtcXG4gICAgICAgIHggPSBGcC5tdWwoeCwgZ2UpO1xcbiAgICAgICAgYiA9IEZwLm11bChiLCBnKTtcXG4gICAgICAgIHIgPSBtO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4geDtcXG4gICAgfTtcXG4gIH1cXG4gIGZ1bmN0aW9uIEZwU3FydChQKSB7XFxuICAgIGlmIChQICUgXzRuID09PSBfM24pIHtcXG4gICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbjMpIC8gXzRuO1xcbiAgICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0M21vZDQoRnAsIG4pIHtcXG4gICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcXG4gICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIHNxdWFyZSByb290XCIpO1xcbiAgICAgICAgcmV0dXJuIHJvb3Q7XFxuICAgICAgfTtcXG4gICAgfVxcbiAgICBpZiAoUCAlIF84biA9PT0gXzVuKSB7XFxuICAgICAgY29uc3QgYzEgPSAoUCAtIF81bikgLyBfOG47XFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQ1bW9kOChGcCwgbikge1xcbiAgICAgICAgY29uc3QgbjIgPSBGcC5tdWwobiwgXzJuMyk7XFxuICAgICAgICBjb25zdCB2ID0gRnAucG93KG4yLCBjMSk7XFxuICAgICAgICBjb25zdCBudiA9IEZwLm11bChuLCB2KTtcXG4gICAgICAgIGNvbnN0IGkgPSBGcC5tdWwoRnAubXVsKG52LCBfMm4zKSwgdik7XFxuICAgICAgICBjb25zdCByb290ID0gRnAubXVsKG52LCBGcC5zdWIoaSwgRnAuT05FKSk7XFxuICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBzcXVhcmUgcm9vdFwiKTtcXG4gICAgICAgIHJldHVybiByb290O1xcbiAgICAgIH07XFxuICAgIH1cXG4gICAgaWYgKFAgJSBfMTZuID09PSBfOW4pIHtcXG4gICAgfVxcbiAgICByZXR1cm4gdG9uZWxsaVNoYW5rcyhQKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIHZhbGlkYXRlRmllbGQoZmllbGQpIHtcXG4gICAgY29uc3QgaW5pdGlhbCA9IHtcXG4gICAgICBPUkRFUjogXCJiaWdpbnRcIixcXG4gICAgICBNQVNLOiBcImJpZ2ludFwiLFxcbiAgICAgIEJZVEVTOiBcImlzU2FmZUludGVnZXJcIixcXG4gICAgICBCSVRTOiBcImlzU2FmZUludGVnZXJcIlxcbiAgICB9O1xcbiAgICBjb25zdCBvcHRzID0gRklFTERfRklFTERTLnJlZHVjZSgobWFwLCB2YWwpID0+IHtcXG4gICAgICBtYXBbdmFsXSA9IFwiZnVuY3Rpb25cIjtcXG4gICAgICByZXR1cm4gbWFwO1xcbiAgICB9LCBpbml0aWFsKTtcXG4gICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KGZpZWxkLCBvcHRzKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIEZwUG93KGYsIG51bTIsIHBvd2VyKSB7XFxuICAgIGlmIChwb3dlciA8IF8wbjMpXFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBleHBvbmVudCwgbmVnYXRpdmVzIHVuc3VwcG9ydGVkXCIpO1xcbiAgICBpZiAocG93ZXIgPT09IF8wbjMpXFxuICAgICAgcmV0dXJuIGYuT05FO1xcbiAgICBpZiAocG93ZXIgPT09IF8xbjMpXFxuICAgICAgcmV0dXJuIG51bTI7XFxuICAgIGxldCBwID0gZi5PTkU7XFxuICAgIGxldCBkID0gbnVtMjtcXG4gICAgd2hpbGUgKHBvd2VyID4gXzBuMykge1xcbiAgICAgIGlmIChwb3dlciAmIF8xbjMpXFxuICAgICAgICBwID0gZi5tdWwocCwgZCk7XFxuICAgICAgZCA9IGYuc3FyKGQpO1xcbiAgICAgIHBvd2VyID4+PSBfMW4zO1xcbiAgICB9XFxuICAgIHJldHVybiBwO1xcbiAgfVxcbiAgZnVuY3Rpb24gRnBJbnZlcnRCYXRjaChmLCBudW1zKSB7XFxuICAgIGNvbnN0IHRtcCA9IG5ldyBBcnJheShudW1zLmxlbmd0aCk7XFxuICAgIGNvbnN0IGxhc3RNdWx0aXBsaWVkID0gbnVtcy5yZWR1Y2UoKGFjYywgbnVtMiwgaSkgPT4ge1xcbiAgICAgIGlmIChmLmlzMChudW0yKSlcXG4gICAgICAgIHJldHVybiBhY2M7XFxuICAgICAgdG1wW2ldID0gYWNjO1xcbiAgICAgIHJldHVybiBmLm11bChhY2MsIG51bTIpO1xcbiAgICB9LCBmLk9ORSk7XFxuICAgIGNvbnN0IGludmVydGVkID0gZi5pbnYobGFzdE11bHRpcGxpZWQpO1xcbiAgICBudW1zLnJlZHVjZVJpZ2h0KChhY2MsIG51bTIsIGkpID0+IHtcXG4gICAgICBpZiAoZi5pczAobnVtMikpXFxuICAgICAgICByZXR1cm4gYWNjO1xcbiAgICAgIHRtcFtpXSA9IGYubXVsKGFjYywgdG1wW2ldKTtcXG4gICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0yKTtcXG4gICAgfSwgaW52ZXJ0ZWQpO1xcbiAgICByZXR1cm4gdG1wO1xcbiAgfVxcbiAgZnVuY3Rpb24gbkxlbmd0aChuLCBuQml0TGVuZ3RoKSB7XFxuICAgIGNvbnN0IF9uQml0TGVuZ3RoID0gbkJpdExlbmd0aCAhPT0gdm9pZCAwID8gbkJpdExlbmd0aCA6IG4udG9TdHJpbmcoMikubGVuZ3RoO1xcbiAgICBjb25zdCBuQnl0ZUxlbmd0aCA9IE1hdGguY2VpbChfbkJpdExlbmd0aCAvIDgpO1xcbiAgICByZXR1cm4geyBuQml0TGVuZ3RoOiBfbkJpdExlbmd0aCwgbkJ5dGVMZW5ndGggfTtcXG4gIH1cXG4gIGZ1bmN0aW9uIEZpZWxkKE9SREVSLCBiaXRMZW4yLCBpc0xFMyA9IGZhbHNlLCByZWRlZiA9IHt9KSB7XFxuICAgIGlmIChPUkRFUiA8PSBfMG4zKVxcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZmllbGQ6IGV4cGVjdGVkIE9SREVSID4gMCwgZ290IFwiICsgT1JERVIpO1xcbiAgICBjb25zdCB7IG5CaXRMZW5ndGg6IEJJVFMsIG5CeXRlTGVuZ3RoOiBCWVRFUyB9ID0gbkxlbmd0aChPUkRFUiwgYml0TGVuMik7XFxuICAgIGlmIChCWVRFUyA+IDIwNDgpXFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmaWVsZDogZXhwZWN0ZWQgT1JERVIgb2YgPD0gMjA0OCBieXRlc1wiKTtcXG4gICAgbGV0IHNxcnRQO1xcbiAgICBjb25zdCBmID0gT2JqZWN0LmZyZWV6ZSh7XFxuICAgICAgT1JERVIsXFxuICAgICAgaXNMRTogaXNMRTMsXFxuICAgICAgQklUUyxcXG4gICAgICBCWVRFUyxcXG4gICAgICBNQVNLOiBiaXRNYXNrKEJJVFMpLFxcbiAgICAgIFpFUk86IF8wbjMsXFxuICAgICAgT05FOiBfMW4zLFxcbiAgICAgIGNyZWF0ZTogKG51bTIpID0+IG1vZChudW0yLCBPUkRFUiksXFxuICAgICAgaXNWYWxpZDogKG51bTIpID0+IHtcXG4gICAgICAgIGlmICh0eXBlb2YgbnVtMiAhPT0gXCJiaWdpbnRcIilcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmaWVsZCBlbGVtZW50OiBleHBlY3RlZCBiaWdpbnQsIGdvdCBcIiArIHR5cGVvZiBudW0yKTtcXG4gICAgICAgIHJldHVybiBfMG4zIDw9IG51bTIgJiYgbnVtMiA8IE9SREVSO1xcbiAgICAgIH0sXFxuICAgICAgaXMwOiAobnVtMikgPT4gbnVtMiA9PT0gXzBuMyxcXG4gICAgICBpc09kZDogKG51bTIpID0+IChudW0yICYgXzFuMykgPT09IF8xbjMsXFxuICAgICAgbmVnOiAobnVtMikgPT4gbW9kKC1udW0yLCBPUkRFUiksXFxuICAgICAgZXFsOiAobGhzLCByaHMpID0+IGxocyA9PT0gcmhzLFxcbiAgICAgIHNxcjogKG51bTIpID0+IG1vZChudW0yICogbnVtMiwgT1JERVIpLFxcbiAgICAgIGFkZDogKGxocywgcmhzKSA9PiBtb2QobGhzICsgcmhzLCBPUkRFUiksXFxuICAgICAgc3ViOiAobGhzLCByaHMpID0+IG1vZChsaHMgLSByaHMsIE9SREVSKSxcXG4gICAgICBtdWw6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIHJocywgT1JERVIpLFxcbiAgICAgIHBvdzogKG51bTIsIHBvd2VyKSA9PiBGcFBvdyhmLCBudW0yLCBwb3dlciksXFxuICAgICAgZGl2OiAobGhzLCByaHMpID0+IG1vZChsaHMgKiBpbnZlcnQocmhzLCBPUkRFUiksIE9SREVSKSxcXG4gICAgICAvLyBTYW1lIGFzIGFib3ZlLCBidXQgZG9lc25cXCd0IG5vcm1hbGl6ZVxcbiAgICAgIHNxck46IChudW0yKSA9PiBudW0yICogbnVtMixcXG4gICAgICBhZGROOiAobGhzLCByaHMpID0+IGxocyArIHJocyxcXG4gICAgICBzdWJOOiAobGhzLCByaHMpID0+IGxocyAtIHJocyxcXG4gICAgICBtdWxOOiAobGhzLCByaHMpID0+IGxocyAqIHJocyxcXG4gICAgICBpbnY6IChudW0yKSA9PiBpbnZlcnQobnVtMiwgT1JERVIpLFxcbiAgICAgIHNxcnQ6IHJlZGVmLnNxcnQgfHwgKChuKSA9PiB7XFxuICAgICAgICBpZiAoIXNxcnRQKVxcbiAgICAgICAgICBzcXJ0UCA9IEZwU3FydChPUkRFUik7XFxuICAgICAgICByZXR1cm4gc3FydFAoZiwgbik7XFxuICAgICAgfSksXFxuICAgICAgaW52ZXJ0QmF0Y2g6IChsc3QpID0+IEZwSW52ZXJ0QmF0Y2goZiwgbHN0KSxcXG4gICAgICAvLyBUT0RPOiBkbyB3ZSByZWFsbHkgbmVlZCBjb25zdGFudCBjbW92P1xcbiAgICAgIC8vIFdlIGRvblxcJ3QgaGF2ZSBjb25zdC10aW1lIGJpZ2ludHMgYW55d2F5LCBzbyBwcm9iYWJseSB3aWxsIGJlIG5vdCB2ZXJ5IHVzZWZ1bFxcbiAgICAgIGNtb3Y6IChhLCBiLCBjKSA9PiBjID8gYiA6IGEsXFxuICAgICAgdG9CeXRlczogKG51bTIpID0+IGlzTEUzID8gbnVtYmVyVG9CeXRlc0xFKG51bTIsIEJZVEVTKSA6IG51bWJlclRvQnl0ZXNCRShudW0yLCBCWVRFUyksXFxuICAgICAgZnJvbUJ5dGVzOiAoYnl0ZXMpID0+IHtcXG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IEJZVEVTKVxcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZC5mcm9tQnl0ZXM6IGV4cGVjdGVkIFwiICsgQllURVMgKyBcIiBieXRlcywgZ290IFwiICsgYnl0ZXMubGVuZ3RoKTtcXG4gICAgICAgIHJldHVybiBpc0xFMyA/IGJ5dGVzVG9OdW1iZXJMRShieXRlcykgOiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGYpO1xcbiAgfVxcbiAgZnVuY3Rpb24gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKSB7XFxuICAgIGlmICh0eXBlb2YgZmllbGRPcmRlciAhPT0gXCJiaWdpbnRcIilcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaWVsZCBvcmRlciBtdXN0IGJlIGJpZ2ludFwiKTtcXG4gICAgY29uc3QgYml0TGVuZ3RoID0gZmllbGRPcmRlci50b1N0cmluZygyKS5sZW5ndGg7XFxuICAgIHJldHVybiBNYXRoLmNlaWwoYml0TGVuZ3RoIC8gOCk7XFxuICB9XFxuICBmdW5jdGlvbiBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpIHtcXG4gICAgY29uc3QgbGVuZ3RoID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcXG4gICAgcmV0dXJuIGxlbmd0aCArIE1hdGguY2VpbChsZW5ndGggLyAyKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIG1hcEhhc2hUb0ZpZWxkKGtleSwgZmllbGRPcmRlciwgaXNMRTMgPSBmYWxzZSkge1xcbiAgICBjb25zdCBsZW4gPSBrZXkubGVuZ3RoO1xcbiAgICBjb25zdCBmaWVsZExlbiA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XFxuICAgIGNvbnN0IG1pbkxlbiA9IGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcik7XFxuICAgIGlmIChsZW4gPCAxNiB8fCBsZW4gPCBtaW5MZW4gfHwgbGVuID4gMTAyNClcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RlZCBcIiArIG1pbkxlbiArIFwiLTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCBcIiArIGxlbik7XFxuICAgIGNvbnN0IG51bTIgPSBpc0xFMyA/IGJ5dGVzVG9OdW1iZXJMRShrZXkpIDogYnl0ZXNUb051bWJlckJFKGtleSk7XFxuICAgIGNvbnN0IHJlZHVjZWQgPSBtb2QobnVtMiwgZmllbGRPcmRlciAtIF8xbjMpICsgXzFuMztcXG4gICAgcmV0dXJuIGlzTEUzID8gbnVtYmVyVG9CeXRlc0xFKHJlZHVjZWQsIGZpZWxkTGVuKSA6IG51bWJlclRvQnl0ZXNCRShyZWR1Y2VkLCBmaWVsZExlbik7XFxuICB9XFxuICB2YXIgXzBuMywgXzFuMywgXzJuMywgXzNuLCBfNG4sIF81biwgXzhuLCBfOW4sIF8xNm4sIEZJRUxEX0ZJRUxEUztcXG4gIHZhciBpbml0X21vZHVsYXIgPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjguMS9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9kdWxhci5qc1wiKCkge1xcbiAgICAgIGluaXRfdXRpbHM0KCk7XFxuICAgICAgXzBuMyA9IEJpZ0ludCgwKTtcXG4gICAgICBfMW4zID0gQmlnSW50KDEpO1xcbiAgICAgIF8ybjMgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIpO1xcbiAgICAgIF8zbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMyk7XFxuICAgICAgXzRuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg0KTtcXG4gICAgICBfNW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDUpO1xcbiAgICAgIF84biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoOCk7XFxuICAgICAgXzluID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg5KTtcXG4gICAgICBfMTZuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgxNik7XFxuICAgICAgRklFTERfRklFTERTID0gW1xcbiAgICAgICAgXCJjcmVhdGVcIixcXG4gICAgICAgIFwiaXNWYWxpZFwiLFxcbiAgICAgICAgXCJpczBcIixcXG4gICAgICAgIFwibmVnXCIsXFxuICAgICAgICBcImludlwiLFxcbiAgICAgICAgXCJzcXJ0XCIsXFxuICAgICAgICBcInNxclwiLFxcbiAgICAgICAgXCJlcWxcIixcXG4gICAgICAgIFwiYWRkXCIsXFxuICAgICAgICBcInN1YlwiLFxcbiAgICAgICAgXCJtdWxcIixcXG4gICAgICAgIFwicG93XCIsXFxuICAgICAgICBcImRpdlwiLFxcbiAgICAgICAgXCJhZGROXCIsXFxuICAgICAgICBcInN1Yk5cIixcXG4gICAgICAgIFwibXVsTlwiLFxcbiAgICAgICAgXCJzcXJOXCJcXG4gICAgICBdO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStjdXJ2ZXNAMS44LjEvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2N1cnZlLmpzXFxuICBmdW5jdGlvbiBjb25zdFRpbWVOZWdhdGUoY29uZGl0aW9uLCBpdGVtKSB7XFxuICAgIGNvbnN0IG5lZyA9IGl0ZW0ubmVnYXRlKCk7XFxuICAgIHJldHVybiBjb25kaXRpb24gPyBuZWcgOiBpdGVtO1xcbiAgfVxcbiAgZnVuY3Rpb24gdmFsaWRhdGVXKFcsIGJpdHMpIHtcXG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihXKSB8fCBXIDw9IDAgfHwgVyA+IGJpdHMpXFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB3aW5kb3cgc2l6ZSwgZXhwZWN0ZWQgWzEuLlwiICsgYml0cyArIFwiXSwgZ290IFc9XCIgKyBXKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGNhbGNXT3B0cyhXLCBiaXRzKSB7XFxuICAgIHZhbGlkYXRlVyhXLCBiaXRzKTtcXG4gICAgY29uc3Qgd2luZG93cyA9IE1hdGguY2VpbChiaXRzIC8gVykgKyAxO1xcbiAgICBjb25zdCB3aW5kb3dTaXplID0gMiAqKiAoVyAtIDEpO1xcbiAgICByZXR1cm4geyB3aW5kb3dzLCB3aW5kb3dTaXplIH07XFxuICB9XFxuICBmdW5jdGlvbiB2YWxpZGF0ZU1TTVBvaW50cyhwb2ludHMsIGMpIHtcXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBvaW50cykpXFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgZXhwZWN0ZWRcIik7XFxuICAgIHBvaW50cy5mb3JFYWNoKChwLCBpKSA9PiB7XFxuICAgICAgaWYgKCEocCBpbnN0YW5jZW9mIGMpKVxcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwb2ludCBhdCBpbmRleCBcIiArIGkpO1xcbiAgICB9KTtcXG4gIH1cXG4gIGZ1bmN0aW9uIHZhbGlkYXRlTVNNU2NhbGFycyhzY2FsYXJzLCBmaWVsZCkge1xcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NhbGFycykpXFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgb2Ygc2NhbGFycyBleHBlY3RlZFwiKTtcXG4gICAgc2NhbGFycy5mb3JFYWNoKChzLCBpKSA9PiB7XFxuICAgICAgaWYgKCFmaWVsZC5pc1ZhbGlkKHMpKVxcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzY2FsYXIgYXQgaW5kZXggXCIgKyBpKTtcXG4gICAgfSk7XFxuICB9XFxuICBmdW5jdGlvbiBnZXRXKFApIHtcXG4gICAgcmV0dXJuIHBvaW50V2luZG93U2l6ZXMuZ2V0KFApIHx8IDE7XFxuICB9XFxuICBmdW5jdGlvbiB3TkFGKGMsIGJpdHMpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBjb25zdFRpbWVOZWdhdGUsXFxuICAgICAgaGFzUHJlY29tcHV0ZXMoZWxtKSB7XFxuICAgICAgICByZXR1cm4gZ2V0VyhlbG0pICE9PSAxO1xcbiAgICAgIH0sXFxuICAgICAgLy8gbm9uLWNvbnN0IHRpbWUgbXVsdGlwbGljYXRpb24gbGFkZGVyXFxuICAgICAgdW5zYWZlTGFkZGVyKGVsbSwgbiwgcCA9IGMuWkVSTykge1xcbiAgICAgICAgbGV0IGQgPSBlbG07XFxuICAgICAgICB3aGlsZSAobiA+IF8wbjQpIHtcXG4gICAgICAgICAgaWYgKG4gJiBfMW40KVxcbiAgICAgICAgICAgIHAgPSBwLmFkZChkKTtcXG4gICAgICAgICAgZCA9IGQuZG91YmxlKCk7XFxuICAgICAgICAgIG4gPj49IF8xbjQ7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gcDtcXG4gICAgICB9LFxcbiAgICAgIC8qKlxcbiAgICAgICAqIENyZWF0ZXMgYSB3TkFGIHByZWNvbXB1dGF0aW9uIHdpbmRvdy4gVXNlZCBmb3IgY2FjaGluZy5cXG4gICAgICAgKiBEZWZhdWx0IHdpbmRvdyBzaXplIGlzIHNldCBieSBgdXRpbHMucHJlY29tcHV0ZSgpYCBhbmQgaXMgZXF1YWwgdG8gOC5cXG4gICAgICAgKiBOdW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGRlcGVuZHMgb24gdGhlIGN1cnZlIHNpemU6XFxuICAgICAgICogMl4oXFx1ezFENDRBfVxcdTIyMTIxKSAqIChNYXRoLmNlaWwoXFx1ezFENDVCfSAvIFxcdXsxRDQ0QX0pICsgMSksIHdoZXJlOlxcbiAgICAgICAqIC0gXFx1ezFENDRBfSBpcyB0aGUgd2luZG93IHNpemVcXG4gICAgICAgKiAtIFxcdXsxRDQ1Qn0gaXMgdGhlIGJpdGxlbmd0aCBvZiB0aGUgY3VydmUgb3JkZXIuXFxuICAgICAgICogRm9yIGEgMjU2LWJpdCBjdXJ2ZSBhbmQgd2luZG93IHNpemUgOCwgdGhlIG51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgaXMgMTI4ICogMzMgPSA0MjI0LlxcbiAgICAgICAqIEBwYXJhbSBlbG0gUG9pbnQgaW5zdGFuY2VcXG4gICAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxcbiAgICAgICAqIEByZXR1cm5zIHByZWNvbXB1dGVkIHBvaW50IHRhYmxlcyBmbGF0dGVuZWQgdG8gYSBzaW5nbGUgYXJyYXlcXG4gICAgICAgKi9cXG4gICAgICBwcmVjb21wdXRlV2luZG93KGVsbSwgVykge1xcbiAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBjYWxjV09wdHMoVywgYml0cyk7XFxuICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcXG4gICAgICAgIGxldCBwID0gZWxtO1xcbiAgICAgICAgbGV0IGJhc2UyID0gcDtcXG4gICAgICAgIGZvciAobGV0IHdpbmRvdzIgPSAwOyB3aW5kb3cyIDwgd2luZG93czsgd2luZG93MisrKSB7XFxuICAgICAgICAgIGJhc2UyID0gcDtcXG4gICAgICAgICAgcG9pbnRzLnB1c2goYmFzZTIpO1xcbiAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHdpbmRvd1NpemU7IGkrKykge1xcbiAgICAgICAgICAgIGJhc2UyID0gYmFzZTIuYWRkKHApO1xcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UyKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBwID0gYmFzZTIuZG91YmxlKCk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gcG9pbnRzO1xcbiAgICAgIH0sXFxuICAgICAgLyoqXFxuICAgICAgICogSW1wbGVtZW50cyBlYyBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxcbiAgICAgICAqIEBwYXJhbSBXIHdpbmRvdyBzaXplXFxuICAgICAgICogQHBhcmFtIHByZWNvbXB1dGVzIHByZWNvbXB1dGVkIHRhYmxlc1xcbiAgICAgICAqIEBwYXJhbSBuIHNjYWxhciAod2UgZG9uXFwndCBjaGVjayBoZXJlLCBidXQgc2hvdWxkIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcilcXG4gICAgICAgKiBAcmV0dXJucyByZWFsIGFuZCBmYWtlIChmb3IgY29uc3QtdGltZSkgcG9pbnRzXFxuICAgICAgICovXFxuICAgICAgd05BRihXLCBwcmVjb21wdXRlcywgbikge1xcbiAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBjYWxjV09wdHMoVywgYml0cyk7XFxuICAgICAgICBsZXQgcCA9IGMuWkVSTztcXG4gICAgICAgIGxldCBmID0gYy5CQVNFO1xcbiAgICAgICAgY29uc3QgbWFzayA9IEJpZ0ludCgyICoqIFcgLSAxKTtcXG4gICAgICAgIGNvbnN0IG1heE51bWJlciA9IDIgKiogVztcXG4gICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoVyk7XFxuICAgICAgICBmb3IgKGxldCB3aW5kb3cyID0gMDsgd2luZG93MiA8IHdpbmRvd3M7IHdpbmRvdzIrKykge1xcbiAgICAgICAgICBjb25zdCBvZmZzZXQgPSB3aW5kb3cyICogd2luZG93U2l6ZTtcXG4gICAgICAgICAgbGV0IHdiaXRzID0gTnVtYmVyKG4gJiBtYXNrKTtcXG4gICAgICAgICAgbiA+Pj0gc2hpZnRCeTtcXG4gICAgICAgICAgaWYgKHdiaXRzID4gd2luZG93U2l6ZSkge1xcbiAgICAgICAgICAgIHdiaXRzIC09IG1heE51bWJlcjtcXG4gICAgICAgICAgICBuICs9IF8xbjQ7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgY29uc3Qgb2Zmc2V0MSA9IG9mZnNldDtcXG4gICAgICAgICAgY29uc3Qgb2Zmc2V0MiA9IG9mZnNldCArIE1hdGguYWJzKHdiaXRzKSAtIDE7XFxuICAgICAgICAgIGNvbnN0IGNvbmQxID0gd2luZG93MiAlIDIgIT09IDA7XFxuICAgICAgICAgIGNvbnN0IGNvbmQyID0gd2JpdHMgPCAwO1xcbiAgICAgICAgICBpZiAod2JpdHMgPT09IDApIHtcXG4gICAgICAgICAgICBmID0gZi5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQxLCBwcmVjb21wdXRlc1tvZmZzZXQxXSkpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHAgPSBwLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDIsIHByZWNvbXB1dGVzW29mZnNldDJdKSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB7IHAsIGYgfTtcXG4gICAgICB9LFxcbiAgICAgIC8qKlxcbiAgICAgICAqIEltcGxlbWVudHMgZWMgdW5zYWZlIChub24gY29uc3QtdGltZSkgbXVsdGlwbGljYXRpb24gdXNpbmcgcHJlY29tcHV0ZWQgdGFibGVzIGFuZCB3LWFyeSBub24tYWRqYWNlbnQgZm9ybS5cXG4gICAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxcbiAgICAgICAqIEBwYXJhbSBwcmVjb21wdXRlcyBwcmVjb21wdXRlZCB0YWJsZXNcXG4gICAgICAgKiBAcGFyYW0gbiBzY2FsYXIgKHdlIGRvblxcJ3QgY2hlY2sgaGVyZSwgYnV0IHNob3VsZCBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXIpXFxuICAgICAgICogQHBhcmFtIGFjYyBhY2N1bXVsYXRvciBwb2ludCB0byBhZGQgcmVzdWx0IG9mIG11bHRpcGxpY2F0aW9uXFxuICAgICAgICogQHJldHVybnMgcG9pbnRcXG4gICAgICAgKi9cXG4gICAgICB3TkFGVW5zYWZlKFcsIHByZWNvbXB1dGVzLCBuLCBhY2MgPSBjLlpFUk8pIHtcXG4gICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gY2FsY1dPcHRzKFcsIGJpdHMpO1xcbiAgICAgICAgY29uc3QgbWFzayA9IEJpZ0ludCgyICoqIFcgLSAxKTtcXG4gICAgICAgIGNvbnN0IG1heE51bWJlciA9IDIgKiogVztcXG4gICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoVyk7XFxuICAgICAgICBmb3IgKGxldCB3aW5kb3cyID0gMDsgd2luZG93MiA8IHdpbmRvd3M7IHdpbmRvdzIrKykge1xcbiAgICAgICAgICBjb25zdCBvZmZzZXQgPSB3aW5kb3cyICogd2luZG93U2l6ZTtcXG4gICAgICAgICAgaWYgKG4gPT09IF8wbjQpXFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIGxldCB3Yml0cyA9IE51bWJlcihuICYgbWFzayk7XFxuICAgICAgICAgIG4gPj49IHNoaWZ0Qnk7XFxuICAgICAgICAgIGlmICh3Yml0cyA+IHdpbmRvd1NpemUpIHtcXG4gICAgICAgICAgICB3Yml0cyAtPSBtYXhOdW1iZXI7XFxuICAgICAgICAgICAgbiArPSBfMW40O1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmICh3Yml0cyA9PT0gMClcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgbGV0IGN1cnIgPSBwcmVjb21wdXRlc1tvZmZzZXQgKyBNYXRoLmFicyh3Yml0cykgLSAxXTtcXG4gICAgICAgICAgaWYgKHdiaXRzIDwgMClcXG4gICAgICAgICAgICBjdXJyID0gY3Vyci5uZWdhdGUoKTtcXG4gICAgICAgICAgYWNjID0gYWNjLmFkZChjdXJyKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBhY2M7XFxuICAgICAgfSxcXG4gICAgICBnZXRQcmVjb21wdXRlcyhXLCBQLCB0cmFuc2Zvcm0pIHtcXG4gICAgICAgIGxldCBjb21wID0gcG9pbnRQcmVjb21wdXRlcy5nZXQoUCk7XFxuICAgICAgICBpZiAoIWNvbXApIHtcXG4gICAgICAgICAgY29tcCA9IHRoaXMucHJlY29tcHV0ZVdpbmRvdyhQLCBXKTtcXG4gICAgICAgICAgaWYgKFcgIT09IDEpXFxuICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5zZXQoUCwgdHJhbnNmb3JtKGNvbXApKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBjb21wO1xcbiAgICAgIH0sXFxuICAgICAgd05BRkNhY2hlZChQLCBuLCB0cmFuc2Zvcm0pIHtcXG4gICAgICAgIGNvbnN0IFcgPSBnZXRXKFApO1xcbiAgICAgICAgcmV0dXJuIHRoaXMud05BRihXLCB0aGlzLmdldFByZWNvbXB1dGVzKFcsIFAsIHRyYW5zZm9ybSksIG4pO1xcbiAgICAgIH0sXFxuICAgICAgd05BRkNhY2hlZFVuc2FmZShQLCBuLCB0cmFuc2Zvcm0sIHByZXYpIHtcXG4gICAgICAgIGNvbnN0IFcgPSBnZXRXKFApO1xcbiAgICAgICAgaWYgKFcgPT09IDEpXFxuICAgICAgICAgIHJldHVybiB0aGlzLnVuc2FmZUxhZGRlcihQLCBuLCBwcmV2KTtcXG4gICAgICAgIHJldHVybiB0aGlzLndOQUZVbnNhZmUoVywgdGhpcy5nZXRQcmVjb21wdXRlcyhXLCBQLCB0cmFuc2Zvcm0pLCBuLCBwcmV2KTtcXG4gICAgICB9LFxcbiAgICAgIC8vIFdlIGNhbGN1bGF0ZSBwcmVjb21wdXRlcyBmb3IgZWxsaXB0aWMgY3VydmUgcG9pbnQgbXVsdGlwbGljYXRpb25cXG4gICAgICAvLyB1c2luZyB3aW5kb3dlZCBtZXRob2QuIFRoaXMgc3BlY2lmaWVzIHdpbmRvdyBzaXplIGFuZFxcbiAgICAgIC8vIHN0b3JlcyBwcmVjb21wdXRlZCB2YWx1ZXMuIFVzdWFsbHkgb25seSBiYXNlIHBvaW50IHdvdWxkIGJlIHByZWNvbXB1dGVkLlxcbiAgICAgIHNldFdpbmRvd1NpemUoUCwgVykge1xcbiAgICAgICAgdmFsaWRhdGVXKFcsIGJpdHMpO1xcbiAgICAgICAgcG9pbnRXaW5kb3dTaXplcy5zZXQoUCwgVyk7XFxuICAgICAgICBwb2ludFByZWNvbXB1dGVzLmRlbGV0ZShQKTtcXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuICBmdW5jdGlvbiBwaXBwZW5nZXIoYywgZmllbGROLCBwb2ludHMsIHNjYWxhcnMpIHtcXG4gICAgdmFsaWRhdGVNU01Qb2ludHMocG9pbnRzLCBjKTtcXG4gICAgdmFsaWRhdGVNU01TY2FsYXJzKHNjYWxhcnMsIGZpZWxkTik7XFxuICAgIGlmIChwb2ludHMubGVuZ3RoICE9PSBzY2FsYXJzLmxlbmd0aClcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcnJheXMgb2YgcG9pbnRzIGFuZCBzY2FsYXJzIG11c3QgaGF2ZSBlcXVhbCBsZW5ndGhcIik7XFxuICAgIGNvbnN0IHplcm8gPSBjLlpFUk87XFxuICAgIGNvbnN0IHdiaXRzID0gYml0TGVuKEJpZ0ludChwb2ludHMubGVuZ3RoKSk7XFxuICAgIGNvbnN0IHdpbmRvd1NpemUgPSB3Yml0cyA+IDEyID8gd2JpdHMgLSAzIDogd2JpdHMgPiA0ID8gd2JpdHMgLSAyIDogd2JpdHMgPyAyIDogMTtcXG4gICAgY29uc3QgTUFTSyA9ICgxIDw8IHdpbmRvd1NpemUpIC0gMTtcXG4gICAgY29uc3QgYnVja2V0cyA9IG5ldyBBcnJheShNQVNLICsgMSkuZmlsbCh6ZXJvKTtcXG4gICAgY29uc3QgbGFzdEJpdHMgPSBNYXRoLmZsb29yKChmaWVsZE4uQklUUyAtIDEpIC8gd2luZG93U2l6ZSkgKiB3aW5kb3dTaXplO1xcbiAgICBsZXQgc3VtID0gemVybztcXG4gICAgZm9yIChsZXQgaSA9IGxhc3RCaXRzOyBpID49IDA7IGkgLT0gd2luZG93U2l6ZSkge1xcbiAgICAgIGJ1Y2tldHMuZmlsbCh6ZXJvKTtcXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNjYWxhcnMubGVuZ3RoOyBqKyspIHtcXG4gICAgICAgIGNvbnN0IHNjYWxhciA9IHNjYWxhcnNbal07XFxuICAgICAgICBjb25zdCB3Yml0czIgPSBOdW1iZXIoc2NhbGFyID4+IEJpZ0ludChpKSAmIEJpZ0ludChNQVNLKSk7XFxuICAgICAgICBidWNrZXRzW3diaXRzMl0gPSBidWNrZXRzW3diaXRzMl0uYWRkKHBvaW50c1tqXSk7XFxuICAgICAgfVxcbiAgICAgIGxldCByZXNJID0gemVybztcXG4gICAgICBmb3IgKGxldCBqID0gYnVja2V0cy5sZW5ndGggLSAxLCBzdW1JID0gemVybzsgaiA+IDA7IGotLSkge1xcbiAgICAgICAgc3VtSSA9IHN1bUkuYWRkKGJ1Y2tldHNbal0pO1xcbiAgICAgICAgcmVzSSA9IHJlc0kuYWRkKHN1bUkpO1xcbiAgICAgIH1cXG4gICAgICBzdW0gPSBzdW0uYWRkKHJlc0kpO1xcbiAgICAgIGlmIChpICE9PSAwKVxcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aW5kb3dTaXplOyBqKyspXFxuICAgICAgICAgIHN1bSA9IHN1bS5kb3VibGUoKTtcXG4gICAgfVxcbiAgICByZXR1cm4gc3VtO1xcbiAgfVxcbiAgZnVuY3Rpb24gdmFsaWRhdGVCYXNpYyhjdXJ2ZSkge1xcbiAgICB2YWxpZGF0ZUZpZWxkKGN1cnZlLkZwKTtcXG4gICAgdmFsaWRhdGVPYmplY3QoY3VydmUsIHtcXG4gICAgICBuOiBcImJpZ2ludFwiLFxcbiAgICAgIGg6IFwiYmlnaW50XCIsXFxuICAgICAgR3g6IFwiZmllbGRcIixcXG4gICAgICBHeTogXCJmaWVsZFwiXFxuICAgIH0sIHtcXG4gICAgICBuQml0TGVuZ3RoOiBcImlzU2FmZUludGVnZXJcIixcXG4gICAgICBuQnl0ZUxlbmd0aDogXCJpc1NhZmVJbnRlZ2VyXCJcXG4gICAgfSk7XFxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcXG4gICAgICAuLi5uTGVuZ3RoKGN1cnZlLm4sIGN1cnZlLm5CaXRMZW5ndGgpLFxcbiAgICAgIC4uLmN1cnZlLFxcbiAgICAgIC4uLnsgcDogY3VydmUuRnAuT1JERVIgfVxcbiAgICB9KTtcXG4gIH1cXG4gIHZhciBfMG40LCBfMW40LCBwb2ludFByZWNvbXB1dGVzLCBwb2ludFdpbmRvd1NpemVzO1xcbiAgdmFyIGluaXRfY3VydmUgPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjguMS9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvY3VydmUuanNcIigpIHtcXG4gICAgICBpbml0X21vZHVsYXIoKTtcXG4gICAgICBpbml0X3V0aWxzNCgpO1xcbiAgICAgIF8wbjQgPSBCaWdJbnQoMCk7XFxuICAgICAgXzFuNCA9IEJpZ0ludCgxKTtcXG4gICAgICBwb2ludFByZWNvbXB1dGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XFxuICAgICAgcG9pbnRXaW5kb3dTaXplcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStjdXJ2ZXNAMS44LjEvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzXFxuICBmdW5jdGlvbiB2YWxpZGF0ZVNpZ1Zlck9wdHMob3B0cykge1xcbiAgICBpZiAob3B0cy5sb3dTICE9PSB2b2lkIDApXFxuICAgICAgYWJvb2woXCJsb3dTXCIsIG9wdHMubG93Uyk7XFxuICAgIGlmIChvcHRzLnByZWhhc2ggIT09IHZvaWQgMClcXG4gICAgICBhYm9vbChcInByZWhhc2hcIiwgb3B0cy5wcmVoYXNoKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIHZhbGlkYXRlUG9pbnRPcHRzKGN1cnZlKSB7XFxuICAgIGNvbnN0IG9wdHMgPSB2YWxpZGF0ZUJhc2ljKGN1cnZlKTtcXG4gICAgdmFsaWRhdGVPYmplY3Qob3B0cywge1xcbiAgICAgIGE6IFwiZmllbGRcIixcXG4gICAgICBiOiBcImZpZWxkXCJcXG4gICAgfSwge1xcbiAgICAgIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogXCJhcnJheVwiLFxcbiAgICAgIHdyYXBQcml2YXRlS2V5OiBcImJvb2xlYW5cIixcXG4gICAgICBpc1RvcnNpb25GcmVlOiBcImZ1bmN0aW9uXCIsXFxuICAgICAgY2xlYXJDb2ZhY3RvcjogXCJmdW5jdGlvblwiLFxcbiAgICAgIGFsbG93SW5maW5pdHlQb2ludDogXCJib29sZWFuXCIsXFxuICAgICAgZnJvbUJ5dGVzOiBcImZ1bmN0aW9uXCIsXFxuICAgICAgdG9CeXRlczogXCJmdW5jdGlvblwiXFxuICAgIH0pO1xcbiAgICBjb25zdCB7IGVuZG8sIEZwLCBhIH0gPSBvcHRzO1xcbiAgICBpZiAoZW5kbykge1xcbiAgICAgIGlmICghRnAuZXFsKGEsIEZwLlpFUk8pKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGVuZG9tb3JwaGlzbSwgY2FuIG9ubHkgYmUgZGVmaW5lZCBmb3IgS29ibGl0eiBjdXJ2ZXMgdGhhdCBoYXZlIGE9MFwiKTtcXG4gICAgICB9XFxuICAgICAgaWYgKHR5cGVvZiBlbmRvICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBlbmRvLmJldGEgIT09IFwiYmlnaW50XCIgfHwgdHlwZW9mIGVuZG8uc3BsaXRTY2FsYXIgIT09IFwiZnVuY3Rpb25cIikge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBlbmRvbW9ycGhpc20sIGV4cGVjdGVkIGJldGE6IGJpZ2ludCBhbmQgc3BsaXRTY2FsYXI6IGZ1bmN0aW9uXCIpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLm9wdHMgfSk7XFxuICB9XFxuICBmdW5jdGlvbiB3ZWllcnN0cmFzc1BvaW50cyhvcHRzKSB7XFxuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVQb2ludE9wdHMob3B0cyk7XFxuICAgIGNvbnN0IHsgRnAgfSA9IENVUlZFO1xcbiAgICBjb25zdCBGbiA9IEZpZWxkKENVUlZFLm4sIENVUlZFLm5CaXRMZW5ndGgpO1xcbiAgICBjb25zdCB0b0J5dGVzNCA9IENVUlZFLnRvQnl0ZXMgfHwgKChfYywgcG9pbnQsIF9pc0NvbXByZXNzZWQpID0+IHtcXG4gICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcXG4gICAgICByZXR1cm4gY29uY2F0Qnl0ZXMzKFVpbnQ4QXJyYXkuZnJvbShbNF0pLCBGcC50b0J5dGVzKGEueCksIEZwLnRvQnl0ZXMoYS55KSk7XFxuICAgIH0pO1xcbiAgICBjb25zdCBmcm9tQnl0ZXMyID0gQ1VSVkUuZnJvbUJ5dGVzIHx8ICgoYnl0ZXMpID0+IHtcXG4gICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XFxuICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XFxuICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcXG4gICAgICByZXR1cm4geyB4LCB5IH07XFxuICAgIH0pO1xcbiAgICBmdW5jdGlvbiB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpIHtcXG4gICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xcbiAgICAgIGNvbnN0IHgyID0gRnAuc3FyKHgpO1xcbiAgICAgIGNvbnN0IHgzID0gRnAubXVsKHgyLCB4KTtcXG4gICAgICByZXR1cm4gRnAuYWRkKEZwLmFkZCh4MywgRnAubXVsKHgsIGEpKSwgYik7XFxuICAgIH1cXG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKENVUlZFLkd5KSwgd2VpZXJzdHJhc3NFcXVhdGlvbihDVVJWRS5HeCkpKVxcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBnZW5lcmF0b3IgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHRcIik7XFxuICAgIGZ1bmN0aW9uIGlzV2l0aGluQ3VydmVPcmRlcihudW0yKSB7XFxuICAgICAgcmV0dXJuIGluUmFuZ2UobnVtMiwgXzFuNSwgQ1VSVkUubik7XFxuICAgIH1cXG4gICAgZnVuY3Rpb24gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihrZXkpIHtcXG4gICAgICBjb25zdCB7IGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogbGVuZ3RocywgbkJ5dGVMZW5ndGgsIHdyYXBQcml2YXRlS2V5LCBuOiBOIH0gPSBDVVJWRTtcXG4gICAgICBpZiAobGVuZ3RocyAmJiB0eXBlb2Yga2V5ICE9PSBcImJpZ2ludFwiKSB7XFxuICAgICAgICBpZiAoaXNCeXRlczIoa2V5KSlcXG4gICAgICAgICAga2V5ID0gYnl0ZXNUb0hleDIoa2V5KTtcXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSBcInN0cmluZ1wiIHx8ICFsZW5ndGhzLmluY2x1ZGVzKGtleS5sZW5ndGgpKVxcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHByaXZhdGUga2V5XCIpO1xcbiAgICAgICAga2V5ID0ga2V5LnBhZFN0YXJ0KG5CeXRlTGVuZ3RoICogMiwgXCIwXCIpO1xcbiAgICAgIH1cXG4gICAgICBsZXQgbnVtMjtcXG4gICAgICB0cnkge1xcbiAgICAgICAgbnVtMiA9IHR5cGVvZiBrZXkgPT09IFwiYmlnaW50XCIgPyBrZXkgOiBieXRlc1RvTnVtYmVyQkUoZW5zdXJlQnl0ZXMoXCJwcml2YXRlIGtleVwiLCBrZXksIG5CeXRlTGVuZ3RoKSk7XFxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcHJpdmF0ZSBrZXksIGV4cGVjdGVkIGhleCBvciBcIiArIG5CeXRlTGVuZ3RoICsgXCIgYnl0ZXMsIGdvdCBcIiArIHR5cGVvZiBrZXkpO1xcbiAgICAgIH1cXG4gICAgICBpZiAod3JhcFByaXZhdGVLZXkpXFxuICAgICAgICBudW0yID0gbW9kKG51bTIsIE4pO1xcbiAgICAgIGFJblJhbmdlKFwicHJpdmF0ZSBrZXlcIiwgbnVtMiwgXzFuNSwgTik7XFxuICAgICAgcmV0dXJuIG51bTI7XFxuICAgIH1cXG4gICAgZnVuY3Rpb24gYXNzZXJ0UHJqUG9pbnQob3RoZXIpIHtcXG4gICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFBvaW50MikpXFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm9qZWN0aXZlUG9pbnQgZXhwZWN0ZWRcIik7XFxuICAgIH1cXG4gICAgY29uc3QgdG9BZmZpbmVNZW1vID0gbWVtb2l6ZWQoKHAsIGl6KSA9PiB7XFxuICAgICAgY29uc3QgeyBweDogeCwgcHk6IHksIHB6OiB6MiB9ID0gcDtcXG4gICAgICBpZiAoRnAuZXFsKHoyLCBGcC5PTkUpKVxcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xcbiAgICAgIGNvbnN0IGlzMCA9IHAuaXMwKCk7XFxuICAgICAgaWYgKGl6ID09IG51bGwpXFxuICAgICAgICBpeiA9IGlzMCA/IEZwLk9ORSA6IEZwLmludih6Mik7XFxuICAgICAgY29uc3QgYXggPSBGcC5tdWwoeCwgaXopO1xcbiAgICAgIGNvbnN0IGF5ID0gRnAubXVsKHksIGl6KTtcXG4gICAgICBjb25zdCB6eiA9IEZwLm11bCh6MiwgaXopO1xcbiAgICAgIGlmIChpczApXFxuICAgICAgICByZXR1cm4geyB4OiBGcC5aRVJPLCB5OiBGcC5aRVJPIH07XFxuICAgICAgaWYgKCFGcC5lcWwoenosIEZwLk9ORSkpXFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZaIHdhcyBpbnZhbGlkXCIpO1xcbiAgICAgIHJldHVybiB7IHg6IGF4LCB5OiBheSB9O1xcbiAgICB9KTtcXG4gICAgY29uc3QgYXNzZXJ0VmFsaWRNZW1vID0gbWVtb2l6ZWQoKHApID0+IHtcXG4gICAgICBpZiAocC5pczAoKSkge1xcbiAgICAgICAgaWYgKENVUlZFLmFsbG93SW5maW5pdHlQb2ludCAmJiAhRnAuaXMwKHAucHkpKVxcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgcG9pbnQ6IFpFUk9cIik7XFxuICAgICAgfVxcbiAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcC50b0FmZmluZSgpO1xcbiAgICAgIGlmICghRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBwb2ludDogeCBvciB5IG5vdCBGRVwiKTtcXG4gICAgICBjb25zdCBsZWZ0ID0gRnAuc3FyKHkpO1xcbiAgICAgIGNvbnN0IHJpZ2h0ID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTtcXG4gICAgICBpZiAoIUZwLmVxbChsZWZ0LCByaWdodCkpXFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHRcIik7XFxuICAgICAgaWYgKCFwLmlzVG9yc2lvbkZyZWUoKSlcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBwb2ludDogbm90IGluIHByaW1lLW9yZGVyIHN1Ymdyb3VwXCIpO1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9KTtcXG4gICAgY2xhc3MgUG9pbnQyIHtcXG4gICAgICBjb25zdHJ1Y3RvcihweCwgcHksIHB6KSB7XFxuICAgICAgICB0aGlzLnB4ID0gcHg7XFxuICAgICAgICB0aGlzLnB5ID0gcHk7XFxuICAgICAgICB0aGlzLnB6ID0gcHo7XFxuICAgICAgICBpZiAocHggPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweCkpXFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInggcmVxdWlyZWRcIik7XFxuICAgICAgICBpZiAocHkgPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweSkpXFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInkgcmVxdWlyZWRcIik7XFxuICAgICAgICBpZiAocHogPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweikpXFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInogcmVxdWlyZWRcIik7XFxuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xcbiAgICAgIH1cXG4gICAgICAvLyBEb2VzIG5vdCB2YWxpZGF0ZSBpZiB0aGUgcG9pbnQgaXMgb24tY3VydmUuXFxuICAgICAgLy8gVXNlIGZyb21IZXggaW5zdGVhZCwgb3IgY2FsbCBhc3NlcnRWYWxpZGl0eSgpIGxhdGVyLlxcbiAgICAgIHN0YXRpYyBmcm9tQWZmaW5lKHApIHtcXG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcCB8fCB7fTtcXG4gICAgICAgIGlmICghcCB8fCAhRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBhZmZpbmUgcG9pbnRcIik7XFxuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIFBvaW50MilcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJvamVjdGl2ZSBwb2ludCBub3QgYWxsb3dlZFwiKTtcXG4gICAgICAgIGNvbnN0IGlzMCA9IChpKSA9PiBGcC5lcWwoaSwgRnAuWkVSTyk7XFxuICAgICAgICBpZiAoaXMwKHgpICYmIGlzMCh5KSlcXG4gICAgICAgICAgcmV0dXJuIFBvaW50Mi5aRVJPO1xcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludDIoeCwgeSwgRnAuT05FKTtcXG4gICAgICB9XFxuICAgICAgZ2V0IHgoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLng7XFxuICAgICAgfVxcbiAgICAgIGdldCB5KCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS55O1xcbiAgICAgIH1cXG4gICAgICAvKipcXG4gICAgICAgKiBUYWtlcyBhIGJ1bmNoIG9mIFByb2plY3RpdmUgUG9pbnRzIGJ1dCBleGVjdXRlcyBvbmx5IG9uZVxcbiAgICAgICAqIGludmVyc2lvbiBvbiBhbGwgb2YgdGhlbS4gSW52ZXJzaW9uIGlzIHZlcnkgc2xvdyBvcGVyYXRpb24sXFxuICAgICAgICogc28gdGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSBtYXNzaXZlbHkuXFxuICAgICAgICogT3B0aW1pemF0aW9uOiBjb252ZXJ0cyBhIGxpc3Qgb2YgcHJvamVjdGl2ZSBwb2ludHMgdG8gYSBsaXN0IG9mIGlkZW50aWNhbCBwb2ludHMgd2l0aCBaPTEuXFxuICAgICAgICovXFxuICAgICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzKSB7XFxuICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKHBvaW50cy5tYXAoKHApID0+IHAucHopKTtcXG4gICAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50Mi5mcm9tQWZmaW5lKTtcXG4gICAgICB9XFxuICAgICAgLyoqXFxuICAgICAgICogQ29udmVydHMgaGFzaCBzdHJpbmcgb3IgVWludDhBcnJheSB0byBQb2ludC5cXG4gICAgICAgKiBAcGFyYW0gaGV4IHNob3J0L2xvbmcgRUNEU0EgaGV4XFxuICAgICAgICovXFxuICAgICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XFxuICAgICAgICBjb25zdCBQID0gUG9pbnQyLmZyb21BZmZpbmUoZnJvbUJ5dGVzMihlbnN1cmVCeXRlcyhcInBvaW50SGV4XCIsIGhleCkpKTtcXG4gICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcXG4gICAgICAgIHJldHVybiBQO1xcbiAgICAgIH1cXG4gICAgICAvLyBNdWx0aXBsaWVzIGdlbmVyYXRvciBwb2ludCBieSBwcml2YXRlS2V5LlxcbiAgICAgIHN0YXRpYyBmcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XFxuICAgICAgICByZXR1cm4gUG9pbnQyLkJBU0UubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KSk7XFxuICAgICAgfVxcbiAgICAgIC8vIE11bHRpc2NhbGFyIE11bHRpcGxpY2F0aW9uXFxuICAgICAgc3RhdGljIG1zbShwb2ludHMsIHNjYWxhcnMpIHtcXG4gICAgICAgIHJldHVybiBwaXBwZW5nZXIoUG9pbnQyLCBGbiwgcG9pbnRzLCBzY2FsYXJzKTtcXG4gICAgICB9XFxuICAgICAgLy8gXCJQcml2YXRlIG1ldGhvZFwiLCBkb25cXCd0IHVzZSBpdCBkaXJlY3RseVxcbiAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcXG4gICAgICAgIHduYWYuc2V0V2luZG93U2l6ZSh0aGlzLCB3aW5kb3dTaXplKTtcXG4gICAgICB9XFxuICAgICAgLy8gQSBwb2ludCBvbiBjdXJ2ZSBpcyB2YWxpZCBpZiBpdCBjb25mb3JtcyB0byBlcXVhdGlvbi5cXG4gICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcXG4gICAgICAgIGFzc2VydFZhbGlkTWVtbyh0aGlzKTtcXG4gICAgICB9XFxuICAgICAgaGFzRXZlblkoKSB7XFxuICAgICAgICBjb25zdCB7IHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcXG4gICAgICAgIGlmIChGcC5pc09kZClcXG4gICAgICAgICAgcmV0dXJuICFGcC5pc09kZCh5KTtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIGRvZXNuXFwndCBzdXBwb3J0IGlzT2RkXCIpO1xcbiAgICAgIH1cXG4gICAgICAvKipcXG4gICAgICAgKiBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLlxcbiAgICAgICAqL1xcbiAgICAgIGVxdWFscyhvdGhlcikge1xcbiAgICAgICAgYXNzZXJ0UHJqUG9pbnQob3RoZXIpO1xcbiAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xcbiAgICAgICAgY29uc3QgeyBweDogWDIsIHB5OiBZMiwgcHo6IFoyIH0gPSBvdGhlcjtcXG4gICAgICAgIGNvbnN0IFUxID0gRnAuZXFsKEZwLm11bChYMSwgWjIpLCBGcC5tdWwoWDIsIFoxKSk7XFxuICAgICAgICBjb25zdCBVMiA9IEZwLmVxbChGcC5tdWwoWTEsIFoyKSwgRnAubXVsKFkyLCBaMSkpO1xcbiAgICAgICAgcmV0dXJuIFUxICYmIFUyO1xcbiAgICAgIH1cXG4gICAgICAvKipcXG4gICAgICAgKiBGbGlwcyBwb2ludCB0byBvbmUgY29ycmVzcG9uZGluZyB0byAoeCwgLXkpIGluIEFmZmluZSBjb29yZGluYXRlcy5cXG4gICAgICAgKi9cXG4gICAgICBuZWdhdGUoKSB7XFxuICAgICAgICByZXR1cm4gbmV3IFBvaW50Mih0aGlzLnB4LCBGcC5uZWcodGhpcy5weSksIHRoaXMucHopO1xcbiAgICAgIH1cXG4gICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgZG91YmxpbmcgZm9ybXVsYS5cXG4gICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXFxuICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gM1xcbiAgICAgIC8vIENvc3Q6IDhNICsgM1MgKyAzKmEgKyAyKmIzICsgMTVhZGQuXFxuICAgICAgZG91YmxlKCkge1xcbiAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcXG4gICAgICAgIGNvbnN0IGIzID0gRnAubXVsKGIsIF8zbjIpO1xcbiAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xcbiAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87XFxuICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgxKTtcXG4gICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTEpO1xcbiAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMSk7XFxuICAgICAgICBsZXQgdDMgPSBGcC5tdWwoWDEsIFkxKTtcXG4gICAgICAgIHQzID0gRnAuYWRkKHQzLCB0Myk7XFxuICAgICAgICBaMyA9IEZwLm11bChYMSwgWjEpO1xcbiAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcXG4gICAgICAgIFgzID0gRnAubXVsKGEsIFozKTtcXG4gICAgICAgIFkzID0gRnAubXVsKGIzLCB0Mik7XFxuICAgICAgICBZMyA9IEZwLmFkZChYMywgWTMpO1xcbiAgICAgICAgWDMgPSBGcC5zdWIodDEsIFkzKTtcXG4gICAgICAgIFkzID0gRnAuYWRkKHQxLCBZMyk7XFxuICAgICAgICBZMyA9IEZwLm11bChYMywgWTMpO1xcbiAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcXG4gICAgICAgIFozID0gRnAubXVsKGIzLCBaMyk7XFxuICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XFxuICAgICAgICB0MyA9IEZwLnN1Yih0MCwgdDIpO1xcbiAgICAgICAgdDMgPSBGcC5tdWwoYSwgdDMpO1xcbiAgICAgICAgdDMgPSBGcC5hZGQodDMsIFozKTtcXG4gICAgICAgIFozID0gRnAuYWRkKHQwLCB0MCk7XFxuICAgICAgICB0MCA9IEZwLmFkZChaMywgdDApO1xcbiAgICAgICAgdDAgPSBGcC5hZGQodDAsIHQyKTtcXG4gICAgICAgIHQwID0gRnAubXVsKHQwLCB0Myk7XFxuICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xcbiAgICAgICAgdDIgPSBGcC5tdWwoWTEsIFoxKTtcXG4gICAgICAgIHQyID0gRnAuYWRkKHQyLCB0Mik7XFxuICAgICAgICB0MCA9IEZwLm11bCh0MiwgdDMpO1xcbiAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcXG4gICAgICAgIFozID0gRnAubXVsKHQyLCB0MSk7XFxuICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xcbiAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQyKFgzLCBZMywgWjMpO1xcbiAgICAgIH1cXG4gICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgYWRkaXRpb24gZm9ybXVsYS5cXG4gICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXFxuICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gMVxcbiAgICAgIC8vIENvc3Q6IDEyTSArIDBTICsgMyphICsgMypiMyArIDIzYWRkLlxcbiAgICAgIGFkZChvdGhlcikge1xcbiAgICAgICAgYXNzZXJ0UHJqUG9pbnQob3RoZXIpO1xcbiAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xcbiAgICAgICAgY29uc3QgeyBweDogWDIsIHB5OiBZMiwgcHo6IFoyIH0gPSBvdGhlcjtcXG4gICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPO1xcbiAgICAgICAgY29uc3QgYSA9IENVUlZFLmE7XFxuICAgICAgICBjb25zdCBiMyA9IEZwLm11bChDVVJWRS5iLCBfM24yKTtcXG4gICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDIpO1xcbiAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMik7XFxuICAgICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoyKTtcXG4gICAgICAgIGxldCB0MyA9IEZwLmFkZChYMSwgWTEpO1xcbiAgICAgICAgbGV0IHQ0ID0gRnAuYWRkKFgyLCBZMik7XFxuICAgICAgICB0MyA9IEZwLm11bCh0MywgdDQpO1xcbiAgICAgICAgdDQgPSBGcC5hZGQodDAsIHQxKTtcXG4gICAgICAgIHQzID0gRnAuc3ViKHQzLCB0NCk7XFxuICAgICAgICB0NCA9IEZwLmFkZChYMSwgWjEpO1xcbiAgICAgICAgbGV0IHQ1ID0gRnAuYWRkKFgyLCBaMik7XFxuICAgICAgICB0NCA9IEZwLm11bCh0NCwgdDUpO1xcbiAgICAgICAgdDUgPSBGcC5hZGQodDAsIHQyKTtcXG4gICAgICAgIHQ0ID0gRnAuc3ViKHQ0LCB0NSk7XFxuICAgICAgICB0NSA9IEZwLmFkZChZMSwgWjEpO1xcbiAgICAgICAgWDMgPSBGcC5hZGQoWTIsIFoyKTtcXG4gICAgICAgIHQ1ID0gRnAubXVsKHQ1LCBYMyk7XFxuICAgICAgICBYMyA9IEZwLmFkZCh0MSwgdDIpO1xcbiAgICAgICAgdDUgPSBGcC5zdWIodDUsIFgzKTtcXG4gICAgICAgIFozID0gRnAubXVsKGEsIHQ0KTtcXG4gICAgICAgIFgzID0gRnAubXVsKGIzLCB0Mik7XFxuICAgICAgICBaMyA9IEZwLmFkZChYMywgWjMpO1xcbiAgICAgICAgWDMgPSBGcC5zdWIodDEsIFozKTtcXG4gICAgICAgIFozID0gRnAuYWRkKHQxLCBaMyk7XFxuICAgICAgICBZMyA9IEZwLm11bChYMywgWjMpO1xcbiAgICAgICAgdDEgPSBGcC5hZGQodDAsIHQwKTtcXG4gICAgICAgIHQxID0gRnAuYWRkKHQxLCB0MCk7XFxuICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XFxuICAgICAgICB0NCA9IEZwLm11bChiMywgdDQpO1xcbiAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQyKTtcXG4gICAgICAgIHQyID0gRnAuc3ViKHQwLCB0Mik7XFxuICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XFxuICAgICAgICB0NCA9IEZwLmFkZCh0NCwgdDIpO1xcbiAgICAgICAgdDAgPSBGcC5tdWwodDEsIHQ0KTtcXG4gICAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XFxuICAgICAgICB0MCA9IEZwLm11bCh0NSwgdDQpO1xcbiAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcXG4gICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XFxuICAgICAgICB0MCA9IEZwLm11bCh0MywgdDEpO1xcbiAgICAgICAgWjMgPSBGcC5tdWwodDUsIFozKTtcXG4gICAgICAgIFozID0gRnAuYWRkKFozLCB0MCk7XFxuICAgICAgICByZXR1cm4gbmV3IFBvaW50MihYMywgWTMsIFozKTtcXG4gICAgICB9XFxuICAgICAgc3VidHJhY3Qob3RoZXIpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XFxuICAgICAgfVxcbiAgICAgIGlzMCgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhQb2ludDIuWkVSTyk7XFxuICAgICAgfVxcbiAgICAgIHdOQUYobikge1xcbiAgICAgICAgcmV0dXJuIHduYWYud05BRkNhY2hlZCh0aGlzLCBuLCBQb2ludDIubm9ybWFsaXplWik7XFxuICAgICAgfVxcbiAgICAgIC8qKlxcbiAgICAgICAqIE5vbi1jb25zdGFudC10aW1lIG11bHRpcGxpY2F0aW9uLiBVc2VzIGRvdWJsZS1hbmQtYWRkIGFsZ29yaXRobS5cXG4gICAgICAgKiBJdFxcJ3MgZmFzdGVyLCBidXQgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIHlvdSBkb25cXCd0IGNhcmUgYWJvdXRcXG4gICAgICAgKiBhbiBleHBvc2VkIHByaXZhdGUga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbiwgd2hpY2ggd29ya3Mgb3ZlciAqcHVibGljKiBrZXlzLlxcbiAgICAgICAqL1xcbiAgICAgIG11bHRpcGx5VW5zYWZlKHNjKSB7XFxuICAgICAgICBjb25zdCB7IGVuZG8sIG46IE4gfSA9IENVUlZFO1xcbiAgICAgICAgYUluUmFuZ2UoXCJzY2FsYXJcIiwgc2MsIF8wbjUsIE4pO1xcbiAgICAgICAgY29uc3QgSSA9IFBvaW50Mi5aRVJPO1xcbiAgICAgICAgaWYgKHNjID09PSBfMG41KVxcbiAgICAgICAgICByZXR1cm4gSTtcXG4gICAgICAgIGlmICh0aGlzLmlzMCgpIHx8IHNjID09PSBfMW41KVxcbiAgICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgICAgIGlmICghZW5kbyB8fCB3bmFmLmhhc1ByZWNvbXB1dGVzKHRoaXMpKVxcbiAgICAgICAgICByZXR1cm4gd25hZi53TkFGQ2FjaGVkVW5zYWZlKHRoaXMsIHNjLCBQb2ludDIubm9ybWFsaXplWik7XFxuICAgICAgICBsZXQgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihzYyk7XFxuICAgICAgICBsZXQgazFwID0gSTtcXG4gICAgICAgIGxldCBrMnAgPSBJO1xcbiAgICAgICAgbGV0IGQgPSB0aGlzO1xcbiAgICAgICAgd2hpbGUgKGsxID4gXzBuNSB8fCBrMiA+IF8wbjUpIHtcXG4gICAgICAgICAgaWYgKGsxICYgXzFuNSlcXG4gICAgICAgICAgICBrMXAgPSBrMXAuYWRkKGQpO1xcbiAgICAgICAgICBpZiAoazIgJiBfMW41KVxcbiAgICAgICAgICAgIGsycCA9IGsycC5hZGQoZCk7XFxuICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xcbiAgICAgICAgICBrMSA+Pj0gXzFuNTtcXG4gICAgICAgICAgazIgPj49IF8xbjU7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoazFuZWcpXFxuICAgICAgICAgIGsxcCA9IGsxcC5uZWdhdGUoKTtcXG4gICAgICAgIGlmIChrMm5lZylcXG4gICAgICAgICAgazJwID0gazJwLm5lZ2F0ZSgpO1xcbiAgICAgICAgazJwID0gbmV3IFBvaW50MihGcC5tdWwoazJwLnB4LCBlbmRvLmJldGEpLCBrMnAucHksIGsycC5weik7XFxuICAgICAgICByZXR1cm4gazFwLmFkZChrMnApO1xcbiAgICAgIH1cXG4gICAgICAvKipcXG4gICAgICAgKiBDb25zdGFudCB0aW1lIG11bHRpcGxpY2F0aW9uLlxcbiAgICAgICAqIFVzZXMgd05BRiBtZXRob2QuIFdpbmRvd2VkIG1ldGhvZCBtYXkgYmUgMTAlIGZhc3RlcixcXG4gICAgICAgKiBidXQgdGFrZXMgMnggbG9uZ2VyIHRvIGdlbmVyYXRlIGFuZCBjb25zdW1lcyAyeCBtZW1vcnkuXFxuICAgICAgICogVXNlcyBwcmVjb21wdXRlcyB3aGVuIGF2YWlsYWJsZS5cXG4gICAgICAgKiBVc2VzIGVuZG9tb3JwaGlzbSBmb3IgS29ibGl0eiBjdXJ2ZXMuXFxuICAgICAgICogQHBhcmFtIHNjYWxhciBieSB3aGljaCB0aGUgcG9pbnQgd291bGQgYmUgbXVsdGlwbGllZFxcbiAgICAgICAqIEByZXR1cm5zIE5ldyBwb2ludFxcbiAgICAgICAqL1xcbiAgICAgIG11bHRpcGx5KHNjYWxhcikge1xcbiAgICAgICAgY29uc3QgeyBlbmRvLCBuOiBOIH0gPSBDVVJWRTtcXG4gICAgICAgIGFJblJhbmdlKFwic2NhbGFyXCIsIHNjYWxhciwgXzFuNSwgTik7XFxuICAgICAgICBsZXQgcG9pbnQsIGZha2U7XFxuICAgICAgICBpZiAoZW5kbykge1xcbiAgICAgICAgICBjb25zdCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBlbmRvLnNwbGl0U2NhbGFyKHNjYWxhcik7XFxuICAgICAgICAgIGxldCB7IHA6IGsxcCwgZjogZjFwIH0gPSB0aGlzLndOQUYoazEpO1xcbiAgICAgICAgICBsZXQgeyBwOiBrMnAsIGY6IGYycCB9ID0gdGhpcy53TkFGKGsyKTtcXG4gICAgICAgICAgazFwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazFuZWcsIGsxcCk7XFxuICAgICAgICAgIGsycCA9IHduYWYuY29uc3RUaW1lTmVnYXRlKGsybmVnLCBrMnApO1xcbiAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQyKEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcXG4gICAgICAgICAgcG9pbnQgPSBrMXAuYWRkKGsycCk7XFxuICAgICAgICAgIGZha2UgPSBmMXAuYWRkKGYycCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHRoaXMud05BRihzY2FsYXIpO1xcbiAgICAgICAgICBwb2ludCA9IHA7XFxuICAgICAgICAgIGZha2UgPSBmO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIFBvaW50Mi5ub3JtYWxpemVaKFtwb2ludCwgZmFrZV0pWzBdO1xcbiAgICAgIH1cXG4gICAgICAvKipcXG4gICAgICAgKiBFZmZpY2llbnRseSBjYWxjdWxhdGUgYGFQICsgYlFgLiBVbnNhZmUsIGNhbiBleHBvc2UgcHJpdmF0ZSBrZXksIGlmIHVzZWQgaW5jb3JyZWN0bHkuXFxuICAgICAgICogTm90IHVzaW5nIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiBwcmVjb21wdXRhdGlvbiB0YWJsZXMgYXJlIGZhc3Rlci5cXG4gICAgICAgKiBUaGUgdHJpY2sgY291bGQgYmUgdXNlZnVsIGlmIGJvdGggUCBhbmQgUSBhcmUgbm90IEcgKG5vdCBpbiBvdXIgY2FzZSkuXFxuICAgICAgICogQHJldHVybnMgbm9uLXplcm8gYWZmaW5lIHBvaW50XFxuICAgICAgICovXFxuICAgICAgbXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYikge1xcbiAgICAgICAgY29uc3QgRyA9IFBvaW50Mi5CQVNFO1xcbiAgICAgICAgY29uc3QgbXVsID0gKFAsIGEyKSA9PiBhMiA9PT0gXzBuNSB8fCBhMiA9PT0gXzFuNSB8fCAhUC5lcXVhbHMoRykgPyBQLm11bHRpcGx5VW5zYWZlKGEyKSA6IFAubXVsdGlwbHkoYTIpO1xcbiAgICAgICAgY29uc3Qgc3VtID0gbXVsKHRoaXMsIGEpLmFkZChtdWwoUSwgYikpO1xcbiAgICAgICAgcmV0dXJuIHN1bS5pczAoKSA/IHZvaWQgMCA6IHN1bTtcXG4gICAgICB9XFxuICAgICAgLy8gQ29udmVydHMgUHJvamVjdGl2ZSBwb2ludCB0byBhZmZpbmUgKHgsIHkpIGNvb3JkaW5hdGVzLlxcbiAgICAgIC8vIENhbiBhY2NlcHQgcHJlY29tcHV0ZWQgWl4tMSAtIGZvciBleGFtcGxlLCBmcm9tIGludmVydEJhdGNoLlxcbiAgICAgIC8vICh4LCB5LCB6KSBcXHUyMjBCICh4PXgveiwgeT15L3opXFxuICAgICAgdG9BZmZpbmUoaXopIHtcXG4gICAgICAgIHJldHVybiB0b0FmZmluZU1lbW8odGhpcywgaXopO1xcbiAgICAgIH1cXG4gICAgICBpc1RvcnNpb25GcmVlKCkge1xcbiAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgaXNUb3JzaW9uRnJlZSB9ID0gQ1VSVkU7XFxuICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbjUpXFxuICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgaWYgKGlzVG9yc2lvbkZyZWUpXFxuICAgICAgICAgIHJldHVybiBpc1RvcnNpb25GcmVlKFBvaW50MiwgdGhpcyk7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpc1RvcnNpb25GcmVlKCkgaGFzIG5vdCBiZWVuIGRlY2xhcmVkIGZvciB0aGUgZWxsaXB0aWMgY3VydmVcIik7XFxuICAgICAgfVxcbiAgICAgIGNsZWFyQ29mYWN0b3IoKSB7XFxuICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBjbGVhckNvZmFjdG9yIH0gPSBDVVJWRTtcXG4gICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuNSlcXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgICBpZiAoY2xlYXJDb2ZhY3RvcilcXG4gICAgICAgICAgcmV0dXJuIGNsZWFyQ29mYWN0b3IoUG9pbnQyLCB0aGlzKTtcXG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKENVUlZFLmgpO1xcbiAgICAgIH1cXG4gICAgICB0b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcXG4gICAgICAgIGFib29sKFwiaXNDb21wcmVzc2VkXCIsIGlzQ29tcHJlc3NlZCk7XFxuICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XFxuICAgICAgICByZXR1cm4gdG9CeXRlczQoUG9pbnQyLCB0aGlzLCBpc0NvbXByZXNzZWQpO1xcbiAgICAgIH1cXG4gICAgICB0b0hleChpc0NvbXByZXNzZWQgPSB0cnVlKSB7XFxuICAgICAgICBhYm9vbChcImlzQ29tcHJlc3NlZFwiLCBpc0NvbXByZXNzZWQpO1xcbiAgICAgICAgcmV0dXJuIGJ5dGVzVG9IZXgyKHRoaXMudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgUG9pbnQyLkJBU0UgPSBuZXcgUG9pbnQyKENVUlZFLkd4LCBDVVJWRS5HeSwgRnAuT05FKTtcXG4gICAgUG9pbnQyLlpFUk8gPSBuZXcgUG9pbnQyKEZwLlpFUk8sIEZwLk9ORSwgRnAuWkVSTyk7XFxuICAgIGNvbnN0IF9iaXRzID0gQ1VSVkUubkJpdExlbmd0aDtcXG4gICAgY29uc3Qgd25hZiA9IHdOQUYoUG9pbnQyLCBDVVJWRS5lbmRvID8gTWF0aC5jZWlsKF9iaXRzIC8gMikgOiBfYml0cyk7XFxuICAgIHJldHVybiB7XFxuICAgICAgQ1VSVkUsXFxuICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludDIsXFxuICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcXG4gICAgICB3ZWllcnN0cmFzc0VxdWF0aW9uLFxcbiAgICAgIGlzV2l0aGluQ3VydmVPcmRlclxcbiAgICB9O1xcbiAgfVxcbiAgZnVuY3Rpb24gdmFsaWRhdGVPcHRzKGN1cnZlKSB7XFxuICAgIGNvbnN0IG9wdHMgPSB2YWxpZGF0ZUJhc2ljKGN1cnZlKTtcXG4gICAgdmFsaWRhdGVPYmplY3Qob3B0cywge1xcbiAgICAgIGhhc2g6IFwiaGFzaFwiLFxcbiAgICAgIGhtYWM6IFwiZnVuY3Rpb25cIixcXG4gICAgICByYW5kb21CeXRlczogXCJmdW5jdGlvblwiXFxuICAgIH0sIHtcXG4gICAgICBiaXRzMmludDogXCJmdW5jdGlvblwiLFxcbiAgICAgIGJpdHMyaW50X21vZE46IFwiZnVuY3Rpb25cIixcXG4gICAgICBsb3dTOiBcImJvb2xlYW5cIlxcbiAgICB9KTtcXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBsb3dTOiB0cnVlLCAuLi5vcHRzIH0pO1xcbiAgfVxcbiAgZnVuY3Rpb24gd2VpZXJzdHJhc3MoY3VydmVEZWYpIHtcXG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZU9wdHMoY3VydmVEZWYpO1xcbiAgICBjb25zdCB7IEZwLCBuOiBDVVJWRV9PUkRFUiB9ID0gQ1VSVkU7XFxuICAgIGNvbnN0IGNvbXByZXNzZWRMZW4gPSBGcC5CWVRFUyArIDE7XFxuICAgIGNvbnN0IHVuY29tcHJlc3NlZExlbiA9IDIgKiBGcC5CWVRFUyArIDE7XFxuICAgIGZ1bmN0aW9uIG1vZE4yKGEpIHtcXG4gICAgICByZXR1cm4gbW9kKGEsIENVUlZFX09SREVSKTtcXG4gICAgfVxcbiAgICBmdW5jdGlvbiBpbnZOKGEpIHtcXG4gICAgICByZXR1cm4gaW52ZXJ0KGEsIENVUlZFX09SREVSKTtcXG4gICAgfVxcbiAgICBjb25zdCB7IFByb2plY3RpdmVQb2ludDogUG9pbnQyLCBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLCB3ZWllcnN0cmFzc0VxdWF0aW9uLCBpc1dpdGhpbkN1cnZlT3JkZXIgfSA9IHdlaWVyc3RyYXNzUG9pbnRzKHtcXG4gICAgICAuLi5DVVJWRSxcXG4gICAgICB0b0J5dGVzKF9jLCBwb2ludCwgaXNDb21wcmVzc2VkKSB7XFxuICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcXG4gICAgICAgIGNvbnN0IHggPSBGcC50b0J5dGVzKGEueCk7XFxuICAgICAgICBjb25zdCBjYXQgPSBjb25jYXRCeXRlczM7XFxuICAgICAgICBhYm9vbChcImlzQ29tcHJlc3NlZFwiLCBpc0NvbXByZXNzZWQpO1xcbiAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCkge1xcbiAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbcG9pbnQuaGFzRXZlblkoKSA/IDIgOiAzXSksIHgpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oWzRdKSwgeCwgRnAudG9CeXRlcyhhLnkpKTtcXG4gICAgICAgIH1cXG4gICAgICB9LFxcbiAgICAgIGZyb21CeXRlcyhieXRlcykge1xcbiAgICAgICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoO1xcbiAgICAgICAgY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xcbiAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xcbiAgICAgICAgaWYgKGxlbiA9PT0gY29tcHJlc3NlZExlbiAmJiAoaGVhZCA9PT0gMiB8fCBoZWFkID09PSAzKSkge1xcbiAgICAgICAgICBjb25zdCB4ID0gYnl0ZXNUb051bWJlckJFKHRhaWwpO1xcbiAgICAgICAgICBpZiAoIWluUmFuZ2UoeCwgXzFuNSwgRnAuT1JERVIpKVxcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvaW50IGlzIG5vdCBvbiBjdXJ2ZVwiKTtcXG4gICAgICAgICAgY29uc3QgeTIgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpO1xcbiAgICAgICAgICBsZXQgeTtcXG4gICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICB5ID0gRnAuc3FydCh5Mik7XFxuICAgICAgICAgIH0gY2F0Y2ggKHNxcnRFcnJvcikge1xcbiAgICAgICAgICAgIGNvbnN0IHN1ZmZpeCA9IHNxcnRFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gXCI6IFwiICsgc3FydEVycm9yLm1lc3NhZ2UgOiBcIlwiO1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvaW50IGlzIG5vdCBvbiBjdXJ2ZVwiICsgc3VmZml4KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBjb25zdCBpc1lPZGQgPSAoeSAmIF8xbjUpID09PSBfMW41O1xcbiAgICAgICAgICBjb25zdCBpc0hlYWRPZGQgPSAoaGVhZCAmIDEpID09PSAxO1xcbiAgICAgICAgICBpZiAoaXNIZWFkT2RkICE9PSBpc1lPZGQpXFxuICAgICAgICAgICAgeSA9IEZwLm5lZyh5KTtcXG4gICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xcbiAgICAgICAgfSBlbHNlIGlmIChsZW4gPT09IHVuY29tcHJlc3NlZExlbiAmJiBoZWFkID09PSA0KSB7XFxuICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xcbiAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xcbiAgICAgICAgICByZXR1cm4geyB4LCB5IH07XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBjb25zdCBjbCA9IGNvbXByZXNzZWRMZW47XFxuICAgICAgICAgIGNvbnN0IHVsID0gdW5jb21wcmVzc2VkTGVuO1xcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFBvaW50LCBleHBlY3RlZCBsZW5ndGggb2YgXCIgKyBjbCArIFwiLCBvciB1bmNvbXByZXNzZWQgXCIgKyB1bCArIFwiLCBnb3QgXCIgKyBsZW4pO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSk7XFxuICAgIGNvbnN0IG51bVRvTkJ5dGVTdHIgPSAobnVtMikgPT4gYnl0ZXNUb0hleDIobnVtYmVyVG9CeXRlc0JFKG51bTIsIENVUlZFLm5CeXRlTGVuZ3RoKSk7XFxuICAgIGZ1bmN0aW9uIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihudW1iZXIpIHtcXG4gICAgICBjb25zdCBIQUxGID0gQ1VSVkVfT1JERVIgPj4gXzFuNTtcXG4gICAgICByZXR1cm4gbnVtYmVyID4gSEFMRjtcXG4gICAgfVxcbiAgICBmdW5jdGlvbiBub3JtYWxpemVTKHMpIHtcXG4gICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpID8gbW9kTjIoLXMpIDogcztcXG4gICAgfVxcbiAgICBjb25zdCBzbGNOdW0gPSAoYiwgZnJvbTUsIHRvKSA9PiBieXRlc1RvTnVtYmVyQkUoYi5zbGljZShmcm9tNSwgdG8pKTtcXG4gICAgY2xhc3MgU2lnbmF0dXJlIHtcXG4gICAgICBjb25zdHJ1Y3RvcihyLCBzLCByZWNvdmVyeSkge1xcbiAgICAgICAgdGhpcy5yID0gcjtcXG4gICAgICAgIHRoaXMucyA9IHM7XFxuICAgICAgICB0aGlzLnJlY292ZXJ5ID0gcmVjb3Zlcnk7XFxuICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XFxuICAgICAgfVxcbiAgICAgIC8vIHBhaXIgKGJ5dGVzIG9mIHIsIGJ5dGVzIG9mIHMpXFxuICAgICAgc3RhdGljIGZyb21Db21wYWN0KGhleCkge1xcbiAgICAgICAgY29uc3QgbCA9IENVUlZFLm5CeXRlTGVuZ3RoO1xcbiAgICAgICAgaGV4ID0gZW5zdXJlQnl0ZXMoXCJjb21wYWN0U2lnbmF0dXJlXCIsIGhleCwgbCAqIDIpO1xcbiAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoc2xjTnVtKGhleCwgMCwgbCksIHNsY051bShoZXgsIGwsIDIgKiBsKSk7XFxuICAgICAgfVxcbiAgICAgIC8vIERFUiBlbmNvZGVkIEVDRFNBIHNpZ25hdHVyZVxcbiAgICAgIC8vIGh0dHBzOi8vYml0Y29pbi5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNTc2NDQvd2hhdC1hcmUtdGhlLXBhcnRzLW9mLWEtYml0Y29pbi10cmFuc2FjdGlvbi1pbnB1dC1zY3JpcHRcXG4gICAgICBzdGF0aWMgZnJvbURFUihoZXgpIHtcXG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gREVSLnRvU2lnKGVuc3VyZUJ5dGVzKFwiREVSXCIsIGhleCkpO1xcbiAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgcyk7XFxuICAgICAgfVxcbiAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xcbiAgICAgICAgYUluUmFuZ2UoXCJyXCIsIHRoaXMuciwgXzFuNSwgQ1VSVkVfT1JERVIpO1xcbiAgICAgICAgYUluUmFuZ2UoXCJzXCIsIHRoaXMucywgXzFuNSwgQ1VSVkVfT1JERVIpO1xcbiAgICAgIH1cXG4gICAgICBhZGRSZWNvdmVyeUJpdChyZWNvdmVyeSkge1xcbiAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUodGhpcy5yLCB0aGlzLnMsIHJlY292ZXJ5KTtcXG4gICAgICB9XFxuICAgICAgcmVjb3ZlclB1YmxpY0tleShtc2dIYXNoKSB7XFxuICAgICAgICBjb25zdCB7IHIsIHMsIHJlY292ZXJ5OiByZWMgfSA9IHRoaXM7XFxuICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihlbnN1cmVCeXRlcyhcIm1zZ0hhc2hcIiwgbXNnSGFzaCkpO1xcbiAgICAgICAgaWYgKHJlYyA9PSBudWxsIHx8ICFbMCwgMSwgMiwgM10uaW5jbHVkZXMocmVjKSlcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVjb3ZlcnkgaWQgaW52YWxpZFwiKTtcXG4gICAgICAgIGNvbnN0IHJhZGogPSByZWMgPT09IDIgfHwgcmVjID09PSAzID8gciArIENVUlZFLm4gOiByO1xcbiAgICAgICAgaWYgKHJhZGogPj0gRnAuT1JERVIpXFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInJlY292ZXJ5IGlkIDIgb3IgMyBpbnZhbGlkXCIpO1xcbiAgICAgICAgY29uc3QgcHJlZml4ID0gKHJlYyAmIDEpID09PSAwID8gXCIwMlwiIDogXCIwM1wiO1xcbiAgICAgICAgY29uc3QgUiA9IFBvaW50Mi5mcm9tSGV4KHByZWZpeCArIG51bVRvTkJ5dGVTdHIocmFkaikpO1xcbiAgICAgICAgY29uc3QgaXIgPSBpbnZOKHJhZGopO1xcbiAgICAgICAgY29uc3QgdTEgPSBtb2ROMigtaCAqIGlyKTtcXG4gICAgICAgIGNvbnN0IHUyID0gbW9kTjIocyAqIGlyKTtcXG4gICAgICAgIGNvbnN0IFEgPSBQb2ludDIuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShSLCB1MSwgdTIpO1xcbiAgICAgICAgaWYgKCFRKVxcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwb2ludCBhdCBpbmZpbmlmeVwiKTtcXG4gICAgICAgIFEuYXNzZXJ0VmFsaWRpdHkoKTtcXG4gICAgICAgIHJldHVybiBRO1xcbiAgICAgIH1cXG4gICAgICAvLyBTaWduYXR1cmVzIHNob3VsZCBiZSBsb3ctcywgdG8gcHJldmVudCBtYWxsZWFiaWxpdHkuXFxuICAgICAgaGFzSGlnaFMoKSB7XFxuICAgICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHRoaXMucyk7XFxuICAgICAgfVxcbiAgICAgIG5vcm1hbGl6ZVMoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5oYXNIaWdoUygpID8gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIG1vZE4yKC10aGlzLnMpLCB0aGlzLnJlY292ZXJ5KSA6IHRoaXM7XFxuICAgICAgfVxcbiAgICAgIC8vIERFUi1lbmNvZGVkXFxuICAgICAgdG9ERVJSYXdCeXRlcygpIHtcXG4gICAgICAgIHJldHVybiBoZXhUb0J5dGVzMih0aGlzLnRvREVSSGV4KCkpO1xcbiAgICAgIH1cXG4gICAgICB0b0RFUkhleCgpIHtcXG4gICAgICAgIHJldHVybiBERVIuaGV4RnJvbVNpZyh7IHI6IHRoaXMuciwgczogdGhpcy5zIH0pO1xcbiAgICAgIH1cXG4gICAgICAvLyBwYWRkZWQgYnl0ZXMgb2YgciwgdGhlbiBwYWRkZWQgYnl0ZXMgb2Ygc1xcbiAgICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xcbiAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXMyKHRoaXMudG9Db21wYWN0SGV4KCkpO1xcbiAgICAgIH1cXG4gICAgICB0b0NvbXBhY3RIZXgoKSB7XFxuICAgICAgICByZXR1cm4gbnVtVG9OQnl0ZVN0cih0aGlzLnIpICsgbnVtVG9OQnl0ZVN0cih0aGlzLnMpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBjb25zdCB1dGlscyA9IHtcXG4gICAgICBpc1ZhbGlkUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpO1xcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICB9LFxcbiAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXFxuICAgICAgLyoqXFxuICAgICAgICogUHJvZHVjZXMgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHByaXZhdGUga2V5IGZyb20gcmFuZG9tIG9mIHNpemVcXG4gICAgICAgKiAoZ3JvdXBMZW4gKyBjZWlsKGdyb3VwTGVuIC8gMikpIHdpdGggbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlnaWJsZS5cXG4gICAgICAgKi9cXG4gICAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB7XFxuICAgICAgICBjb25zdCBsZW5ndGggPSBnZXRNaW5IYXNoTGVuZ3RoKENVUlZFLm4pO1xcbiAgICAgICAgcmV0dXJuIG1hcEhhc2hUb0ZpZWxkKENVUlZFLnJhbmRvbUJ5dGVzKGxlbmd0aCksIENVUlZFLm4pO1xcbiAgICAgIH0sXFxuICAgICAgLyoqXFxuICAgICAgICogQ3JlYXRlcyBwcmVjb21wdXRlIHRhYmxlIGZvciBhbiBhcmJpdHJhcnkgRUMgcG9pbnQuIE1ha2VzIHBvaW50IFwiY2FjaGVkXCIuXFxuICAgICAgICogQWxsb3dzIHRvIG1hc3NpdmVseSBzcGVlZC11cCBgcG9pbnQubXVsdGlwbHkoc2NhbGFyKWAuXFxuICAgICAgICogQHJldHVybnMgY2FjaGVkIHBvaW50XFxuICAgICAgICogQGV4YW1wbGVcXG4gICAgICAgKiBjb25zdCBmYXN0ID0gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuZnJvbUhleChzb21lb25lc1B1YktleSkpO1xcbiAgICAgICAqIGZhc3QubXVsdGlwbHkocHJpdktleSk7IC8vIG11Y2ggZmFzdGVyIEVDREggbm93XFxuICAgICAgICovXFxuICAgICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQgPSBQb2ludDIuQkFTRSkge1xcbiAgICAgICAgcG9pbnQuX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSk7XFxuICAgICAgICBwb2ludC5tdWx0aXBseShCaWdJbnQoMykpO1xcbiAgICAgICAgcmV0dXJuIHBvaW50O1xcbiAgICAgIH1cXG4gICAgfTtcXG4gICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZhdGVLZXksIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcXG4gICAgICByZXR1cm4gUG9pbnQyLmZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcXG4gICAgfVxcbiAgICBmdW5jdGlvbiBpc1Byb2JQdWIoaXRlbSkge1xcbiAgICAgIGNvbnN0IGFyciA9IGlzQnl0ZXMyKGl0ZW0pO1xcbiAgICAgIGNvbnN0IHN0ciA9IHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiO1xcbiAgICAgIGNvbnN0IGxlbiA9IChhcnIgfHwgc3RyKSAmJiBpdGVtLmxlbmd0aDtcXG4gICAgICBpZiAoYXJyKVxcbiAgICAgICAgcmV0dXJuIGxlbiA9PT0gY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IHVuY29tcHJlc3NlZExlbjtcXG4gICAgICBpZiAoc3RyKVxcbiAgICAgICAgcmV0dXJuIGxlbiA9PT0gMiAqIGNvbXByZXNzZWRMZW4gfHwgbGVuID09PSAyICogdW5jb21wcmVzc2VkTGVuO1xcbiAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUG9pbnQyKVxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICAgIGZ1bmN0aW9uIGdldFNoYXJlZFNlY3JldChwcml2YXRlQSwgcHVibGljQiwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xcbiAgICAgIGlmIChpc1Byb2JQdWIocHJpdmF0ZUEpKVxcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmlyc3QgYXJnIG11c3QgYmUgcHJpdmF0ZSBrZXlcIik7XFxuICAgICAgaWYgKCFpc1Byb2JQdWIocHVibGljQikpXFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZWNvbmQgYXJnIG11c3QgYmUgcHVibGljIGtleVwiKTtcXG4gICAgICBjb25zdCBiID0gUG9pbnQyLmZyb21IZXgocHVibGljQik7XFxuICAgICAgcmV0dXJuIGIubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlQSkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcXG4gICAgfVxcbiAgICBjb25zdCBiaXRzMmludCA9IENVUlZFLmJpdHMyaW50IHx8IGZ1bmN0aW9uKGJ5dGVzKSB7XFxuICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA+IDgxOTIpXFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBpcyB0b28gbGFyZ2VcIik7XFxuICAgICAgY29uc3QgbnVtMiA9IGJ5dGVzVG9OdW1iZXJCRShieXRlcyk7XFxuICAgICAgY29uc3QgZGVsdGEgPSBieXRlcy5sZW5ndGggKiA4IC0gQ1VSVkUubkJpdExlbmd0aDtcXG4gICAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtMiA+PiBCaWdJbnQoZGVsdGEpIDogbnVtMjtcXG4gICAgfTtcXG4gICAgY29uc3QgYml0czJpbnRfbW9kTiA9IENVUlZFLmJpdHMyaW50X21vZE4gfHwgZnVuY3Rpb24oYnl0ZXMpIHtcXG4gICAgICByZXR1cm4gbW9kTjIoYml0czJpbnQoYnl0ZXMpKTtcXG4gICAgfTtcXG4gICAgY29uc3QgT1JERVJfTUFTSyA9IGJpdE1hc2soQ1VSVkUubkJpdExlbmd0aCk7XFxuICAgIGZ1bmN0aW9uIGludDJvY3RldHMobnVtMikge1xcbiAgICAgIGFJblJhbmdlKFwibnVtIDwgMl5cIiArIENVUlZFLm5CaXRMZW5ndGgsIG51bTIsIF8wbjUsIE9SREVSX01BU0spO1xcbiAgICAgIHJldHVybiBudW1iZXJUb0J5dGVzQkUobnVtMiwgQ1VSVkUubkJ5dGVMZW5ndGgpO1xcbiAgICB9XFxuICAgIGZ1bmN0aW9uIHByZXBTaWcobXNnSGFzaCwgcHJpdmF0ZUtleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XFxuICAgICAgaWYgKFtcInJlY292ZXJlZFwiLCBcImNhbm9uaWNhbFwiXS5zb21lKChrKSA9PiBrIGluIG9wdHMpKVxcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2lnbigpIGxlZ2FjeSBvcHRpb25zIG5vdCBzdXBwb3J0ZWRcIik7XFxuICAgICAgY29uc3QgeyBoYXNoOiBoYXNoMiwgcmFuZG9tQnl0ZXM6IHJhbmRvbUJ5dGVzMiB9ID0gQ1VSVkU7XFxuICAgICAgbGV0IHsgbG93UywgcHJlaGFzaCwgZXh0cmFFbnRyb3B5OiBlbnQgfSA9IG9wdHM7XFxuICAgICAgaWYgKGxvd1MgPT0gbnVsbClcXG4gICAgICAgIGxvd1MgPSB0cnVlO1xcbiAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcyhcIm1zZ0hhc2hcIiwgbXNnSGFzaCk7XFxuICAgICAgdmFsaWRhdGVTaWdWZXJPcHRzKG9wdHMpO1xcbiAgICAgIGlmIChwcmVoYXNoKVxcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKFwicHJlaGFzaGVkIG1zZ0hhc2hcIiwgaGFzaDIobXNnSGFzaCkpO1xcbiAgICAgIGNvbnN0IGgxaW50ID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTtcXG4gICAgICBjb25zdCBkID0gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTtcXG4gICAgICBjb25zdCBzZWVkQXJncyA9IFtpbnQyb2N0ZXRzKGQpLCBpbnQyb2N0ZXRzKGgxaW50KV07XFxuICAgICAgaWYgKGVudCAhPSBudWxsICYmIGVudCAhPT0gZmFsc2UpIHtcXG4gICAgICAgIGNvbnN0IGUgPSBlbnQgPT09IHRydWUgPyByYW5kb21CeXRlczIoRnAuQllURVMpIDogZW50O1xcbiAgICAgICAgc2VlZEFyZ3MucHVzaChlbnN1cmVCeXRlcyhcImV4dHJhRW50cm9weVwiLCBlKSk7XFxuICAgICAgfVxcbiAgICAgIGNvbnN0IHNlZWQgPSBjb25jYXRCeXRlczMoLi4uc2VlZEFyZ3MpO1xcbiAgICAgIGNvbnN0IG0gPSBoMWludDtcXG4gICAgICBmdW5jdGlvbiBrMnNpZyhrQnl0ZXMpIHtcXG4gICAgICAgIGNvbnN0IGsgPSBiaXRzMmludChrQnl0ZXMpO1xcbiAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIoaykpXFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIGNvbnN0IGlrID0gaW52TihrKTtcXG4gICAgICAgIGNvbnN0IHEgPSBQb2ludDIuQkFTRS5tdWx0aXBseShrKS50b0FmZmluZSgpO1xcbiAgICAgICAgY29uc3QgciA9IG1vZE4yKHEueCk7XFxuICAgICAgICBpZiAociA9PT0gXzBuNSlcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgY29uc3QgcyA9IG1vZE4yKGlrICogbW9kTjIobSArIHIgKiBkKSk7XFxuICAgICAgICBpZiAocyA9PT0gXzBuNSlcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgbGV0IHJlY292ZXJ5ID0gKHEueCA9PT0gciA/IDAgOiAyKSB8IE51bWJlcihxLnkgJiBfMW41KTtcXG4gICAgICAgIGxldCBub3JtUyA9IHM7XFxuICAgICAgICBpZiAobG93UyAmJiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIocykpIHtcXG4gICAgICAgICAgbm9ybVMgPSBub3JtYWxpemVTKHMpO1xcbiAgICAgICAgICByZWNvdmVyeSBePSAxO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgbm9ybVMsIHJlY292ZXJ5KTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHsgc2VlZCwgazJzaWcgfTtcXG4gICAgfVxcbiAgICBjb25zdCBkZWZhdWx0U2lnT3B0cyA9IHsgbG93UzogQ1VSVkUubG93UywgcHJlaGFzaDogZmFsc2UgfTtcXG4gICAgY29uc3QgZGVmYXVsdFZlck9wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XFxuICAgIGZ1bmN0aW9uIHNpZ24obXNnSGFzaCwgcHJpdktleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XFxuICAgICAgY29uc3QgeyBzZWVkLCBrMnNpZyB9ID0gcHJlcFNpZyhtc2dIYXNoLCBwcml2S2V5LCBvcHRzKTtcXG4gICAgICBjb25zdCBDID0gQ1VSVkU7XFxuICAgICAgY29uc3QgZHJiZyA9IGNyZWF0ZUhtYWNEcmJnKEMuaGFzaC5vdXRwdXRMZW4sIEMubkJ5dGVMZW5ndGgsIEMuaG1hYyk7XFxuICAgICAgcmV0dXJuIGRyYmcoc2VlZCwgazJzaWcpO1xcbiAgICB9XFxuICAgIFBvaW50Mi5CQVNFLl9zZXRXaW5kb3dTaXplKDgpO1xcbiAgICBmdW5jdGlvbiB2ZXJpZnkoc2lnbmF0dXJlLCBtc2dIYXNoLCBwdWJsaWNLZXksIG9wdHMgPSBkZWZhdWx0VmVyT3B0cykge1xcbiAgICAgIGNvbnN0IHNnID0gc2lnbmF0dXJlO1xcbiAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcyhcIm1zZ0hhc2hcIiwgbXNnSGFzaCk7XFxuICAgICAgcHVibGljS2V5ID0gZW5zdXJlQnl0ZXMoXCJwdWJsaWNLZXlcIiwgcHVibGljS2V5KTtcXG4gICAgICBjb25zdCB7IGxvd1MsIHByZWhhc2gsIGZvcm1hdCB9ID0gb3B0cztcXG4gICAgICB2YWxpZGF0ZVNpZ1Zlck9wdHMob3B0cyk7XFxuICAgICAgaWYgKFwic3RyaWN0XCIgaW4gb3B0cylcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9wdGlvbnMuc3RyaWN0IHdhcyByZW5hbWVkIHRvIGxvd1NcIik7XFxuICAgICAgaWYgKGZvcm1hdCAhPT0gdm9pZCAwICYmIGZvcm1hdCAhPT0gXCJjb21wYWN0XCIgJiYgZm9ybWF0ICE9PSBcImRlclwiKVxcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZm9ybWF0IG11c3QgYmUgY29tcGFjdCBvciBkZXJcIik7XFxuICAgICAgY29uc3QgaXNIZXgyID0gdHlwZW9mIHNnID09PSBcInN0cmluZ1wiIHx8IGlzQnl0ZXMyKHNnKTtcXG4gICAgICBjb25zdCBpc09iaiA9ICFpc0hleDIgJiYgIWZvcm1hdCAmJiB0eXBlb2Ygc2cgPT09IFwib2JqZWN0XCIgJiYgc2cgIT09IG51bGwgJiYgdHlwZW9mIHNnLnIgPT09IFwiYmlnaW50XCIgJiYgdHlwZW9mIHNnLnMgPT09IFwiYmlnaW50XCI7XFxuICAgICAgaWYgKCFpc0hleDIgJiYgIWlzT2JqKVxcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzaWduYXR1cmUsIGV4cGVjdGVkIFVpbnQ4QXJyYXksIGhleCBzdHJpbmcgb3IgU2lnbmF0dXJlIGluc3RhbmNlXCIpO1xcbiAgICAgIGxldCBfc2lnID0gdm9pZCAwO1xcbiAgICAgIGxldCBQO1xcbiAgICAgIHRyeSB7XFxuICAgICAgICBpZiAoaXNPYmopXFxuICAgICAgICAgIF9zaWcgPSBuZXcgU2lnbmF0dXJlKHNnLnIsIHNnLnMpO1xcbiAgICAgICAgaWYgKGlzSGV4Mikge1xcbiAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGlmIChmb3JtYXQgIT09IFwiY29tcGFjdFwiKVxcbiAgICAgICAgICAgICAgX3NpZyA9IFNpZ25hdHVyZS5mcm9tREVSKHNnKTtcXG4gICAgICAgICAgfSBjYXRjaCAoZGVyRXJyb3IpIHtcXG4gICAgICAgICAgICBpZiAoIShkZXJFcnJvciBpbnN0YW5jZW9mIERFUi5FcnIpKVxcbiAgICAgICAgICAgICAgdGhyb3cgZGVyRXJyb3I7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKCFfc2lnICYmIGZvcm1hdCAhPT0gXCJkZXJcIilcXG4gICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KHNnKTtcXG4gICAgICAgIH1cXG4gICAgICAgIFAgPSBQb2ludDIuZnJvbUhleChwdWJsaWNLZXkpO1xcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcbiAgICAgIGlmICghX3NpZylcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICBpZiAobG93UyAmJiBfc2lnLmhhc0hpZ2hTKCkpXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgaWYgKHByZWhhc2gpXFxuICAgICAgICBtc2dIYXNoID0gQ1VSVkUuaGFzaChtc2dIYXNoKTtcXG4gICAgICBjb25zdCB7IHIsIHMgfSA9IF9zaWc7XFxuICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7XFxuICAgICAgY29uc3QgaXMgPSBpbnZOKHMpO1xcbiAgICAgIGNvbnN0IHUxID0gbW9kTjIoaCAqIGlzKTtcXG4gICAgICBjb25zdCB1MiA9IG1vZE4yKHIgKiBpcyk7XFxuICAgICAgY29uc3QgUiA9IFBvaW50Mi5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFAsIHUxLCB1Mik/LnRvQWZmaW5lKCk7XFxuICAgICAgaWYgKCFSKVxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIGNvbnN0IHYgPSBtb2ROMihSLngpO1xcbiAgICAgIHJldHVybiB2ID09PSByO1xcbiAgICB9XFxuICAgIHJldHVybiB7XFxuICAgICAgQ1VSVkUsXFxuICAgICAgZ2V0UHVibGljS2V5LFxcbiAgICAgIGdldFNoYXJlZFNlY3JldCxcXG4gICAgICBzaWduLFxcbiAgICAgIHZlcmlmeSxcXG4gICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50MixcXG4gICAgICBTaWduYXR1cmUsXFxuICAgICAgdXRpbHNcXG4gICAgfTtcXG4gIH1cXG4gIGZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XFxuICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcXG4gICAgbGV0IGwgPSBfMG41O1xcbiAgICBmb3IgKGxldCBvID0gcSAtIF8xbjU7IG8gJSBfMm40ID09PSBfMG41OyBvIC89IF8ybjQpXFxuICAgICAgbCArPSBfMW41O1xcbiAgICBjb25zdCBjMSA9IGw7XFxuICAgIGNvbnN0IF8ybl9wb3dfYzFfMSA9IF8ybjQgPDwgYzEgLSBfMW41IC0gXzFuNTtcXG4gICAgY29uc3QgXzJuX3Bvd19jMSA9IF8ybl9wb3dfYzFfMSAqIF8ybjQ7XFxuICAgIGNvbnN0IGMyID0gKHEgLSBfMW41KSAvIF8ybl9wb3dfYzE7XFxuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuNSkgLyBfMm40O1xcbiAgICBjb25zdCBjNCA9IF8ybl9wb3dfYzEgLSBfMW41O1xcbiAgICBjb25zdCBjNSA9IF8ybl9wb3dfYzFfMTtcXG4gICAgY29uc3QgYzYgPSBGcC5wb3coWiwgYzIpO1xcbiAgICBjb25zdCBjNyA9IEZwLnBvdyhaLCAoYzIgKyBfMW41KSAvIF8ybjQpO1xcbiAgICBsZXQgc3FydFJhdGlvID0gKHUsIHYpID0+IHtcXG4gICAgICBsZXQgdHYxID0gYzY7XFxuICAgICAgbGV0IHR2MiA9IEZwLnBvdyh2LCBjNCk7XFxuICAgICAgbGV0IHR2MyA9IEZwLnNxcih0djIpO1xcbiAgICAgIHR2MyA9IEZwLm11bCh0djMsIHYpO1xcbiAgICAgIGxldCB0djUgPSBGcC5tdWwodSwgdHYzKTtcXG4gICAgICB0djUgPSBGcC5wb3codHY1LCBjMyk7XFxuICAgICAgdHY1ID0gRnAubXVsKHR2NSwgdHYyKTtcXG4gICAgICB0djIgPSBGcC5tdWwodHY1LCB2KTtcXG4gICAgICB0djMgPSBGcC5tdWwodHY1LCB1KTtcXG4gICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTtcXG4gICAgICB0djUgPSBGcC5wb3codHY0LCBjNSk7XFxuICAgICAgbGV0IGlzUVIgPSBGcC5lcWwodHY1LCBGcC5PTkUpO1xcbiAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTtcXG4gICAgICB0djUgPSBGcC5tdWwodHY0LCB0djEpO1xcbiAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGlzUVIpO1xcbiAgICAgIHR2NCA9IEZwLmNtb3YodHY1LCB0djQsIGlzUVIpO1xcbiAgICAgIGZvciAobGV0IGkgPSBjMTsgaSA+IF8xbjU7IGktLSkge1xcbiAgICAgICAgbGV0IHR2NTIgPSBpIC0gXzJuNDtcXG4gICAgICAgIHR2NTIgPSBfMm40IDw8IHR2NTIgLSBfMW41O1xcbiAgICAgICAgbGV0IHR2djUgPSBGcC5wb3codHY0LCB0djUyKTtcXG4gICAgICAgIGNvbnN0IGUxID0gRnAuZXFsKHR2djUsIEZwLk9ORSk7XFxuICAgICAgICB0djIgPSBGcC5tdWwodHYzLCB0djEpO1xcbiAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYxKTtcXG4gICAgICAgIHR2djUgPSBGcC5tdWwodHY0LCB0djEpO1xcbiAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgZTEpO1xcbiAgICAgICAgdHY0ID0gRnAuY21vdih0dnY1LCB0djQsIGUxKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHR2MyB9O1xcbiAgICB9O1xcbiAgICBpZiAoRnAuT1JERVIgJSBfNG4yID09PSBfM24yKSB7XFxuICAgICAgY29uc3QgYzEyID0gKEZwLk9SREVSIC0gXzNuMikgLyBfNG4yO1xcbiAgICAgIGNvbnN0IGMyMiA9IEZwLnNxcnQoRnAubmVnKFopKTtcXG4gICAgICBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xcbiAgICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTtcXG4gICAgICAgIGNvbnN0IHR2MiA9IEZwLm11bCh1LCB2KTtcXG4gICAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2Mik7XFxuICAgICAgICBsZXQgeTEgPSBGcC5wb3codHYxLCBjMTIpO1xcbiAgICAgICAgeTEgPSBGcC5tdWwoeTEsIHR2Mik7XFxuICAgICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIyKTtcXG4gICAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTtcXG4gICAgICAgIGNvbnN0IGlzUVIgPSBGcC5lcWwodHYzLCB1KTtcXG4gICAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpO1xcbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTtcXG4gICAgICB9O1xcbiAgICB9XFxuICAgIHJldHVybiBzcXJ0UmF0aW87XFxuICB9XFxuICBmdW5jdGlvbiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCBvcHRzKSB7XFxuICAgIHZhbGlkYXRlRmllbGQoRnApO1xcbiAgICBpZiAoIUZwLmlzVmFsaWQob3B0cy5BKSB8fCAhRnAuaXNWYWxpZChvcHRzLkIpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuWikpXFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWFwVG9DdXJ2ZVNpbXBsZVNXVTogaW52YWxpZCBvcHRzXCIpO1xcbiAgICBjb25zdCBzcXJ0UmF0aW8gPSBTV1VGcFNxcnRSYXRpbyhGcCwgb3B0cy5aKTtcXG4gICAgaWYgKCFGcC5pc09kZClcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGcC5pc09kZCBpcyBub3QgaW1wbGVtZW50ZWQhXCIpO1xcbiAgICByZXR1cm4gKHUpID0+IHtcXG4gICAgICBsZXQgdHYxLCB0djIsIHR2MywgdHY0LCB0djUsIHR2NiwgeCwgeTtcXG4gICAgICB0djEgPSBGcC5zcXIodSk7XFxuICAgICAgdHYxID0gRnAubXVsKHR2MSwgb3B0cy5aKTtcXG4gICAgICB0djIgPSBGcC5zcXIodHYxKTtcXG4gICAgICB0djIgPSBGcC5hZGQodHYyLCB0djEpO1xcbiAgICAgIHR2MyA9IEZwLmFkZCh0djIsIEZwLk9ORSk7XFxuICAgICAgdHYzID0gRnAubXVsKHR2Mywgb3B0cy5CKTtcXG4gICAgICB0djQgPSBGcC5jbW92KG9wdHMuWiwgRnAubmVnKHR2MiksICFGcC5lcWwodHYyLCBGcC5aRVJPKSk7XFxuICAgICAgdHY0ID0gRnAubXVsKHR2NCwgb3B0cy5BKTtcXG4gICAgICB0djIgPSBGcC5zcXIodHYzKTtcXG4gICAgICB0djYgPSBGcC5zcXIodHY0KTtcXG4gICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkEpO1xcbiAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2NSk7XFxuICAgICAgdHYyID0gRnAubXVsKHR2MiwgdHYzKTtcXG4gICAgICB0djYgPSBGcC5tdWwodHY2LCB0djQpO1xcbiAgICAgIHR2NSA9IEZwLm11bCh0djYsIG9wdHMuQik7XFxuICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTtcXG4gICAgICB4ID0gRnAubXVsKHR2MSwgdHYzKTtcXG4gICAgICBjb25zdCB7IGlzVmFsaWQ6IGlzVmFsaWQyLCB2YWx1ZSB9ID0gc3FydFJhdGlvKHR2MiwgdHY2KTtcXG4gICAgICB5ID0gRnAubXVsKHR2MSwgdSk7XFxuICAgICAgeSA9IEZwLm11bCh5LCB2YWx1ZSk7XFxuICAgICAgeCA9IEZwLmNtb3YoeCwgdHYzLCBpc1ZhbGlkMik7XFxuICAgICAgeSA9IEZwLmNtb3YoeSwgdmFsdWUsIGlzVmFsaWQyKTtcXG4gICAgICBjb25zdCBlMSA9IEZwLmlzT2RkKHUpID09PSBGcC5pc09kZCh5KTtcXG4gICAgICB5ID0gRnAuY21vdihGcC5uZWcoeSksIHksIGUxKTtcXG4gICAgICB4ID0gRnAuZGl2KHgsIHR2NCk7XFxuICAgICAgcmV0dXJuIHsgeCwgeSB9O1xcbiAgICB9O1xcbiAgfVxcbiAgdmFyIGIybiwgaDJiLCBERVJFcnIsIERFUiwgXzBuNSwgXzFuNSwgXzJuNCwgXzNuMiwgXzRuMjtcXG4gIHZhciBpbml0X3dlaWVyc3RyYXNzID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStjdXJ2ZXNAMS44LjEvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzXCIoKSB7XFxuICAgICAgaW5pdF9jdXJ2ZSgpO1xcbiAgICAgIGluaXRfbW9kdWxhcigpO1xcbiAgICAgIGluaXRfdXRpbHM0KCk7XFxuICAgICAgaW5pdF91dGlsczQoKTtcXG4gICAgICAoeyBieXRlc1RvTnVtYmVyQkU6IGIybiwgaGV4VG9CeXRlczogaDJiIH0gPSB1dGlsc19leHBvcnRzKTtcXG4gICAgICBERVJFcnIgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKG0gPSBcIlwiKSB7XFxuICAgICAgICAgIHN1cGVyKG0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgREVSID0ge1xcbiAgICAgICAgLy8gYXNuLjEgREVSIGVuY29kaW5nIHV0aWxzXFxuICAgICAgICBFcnI6IERFUkVycixcXG4gICAgICAgIC8vIEJhc2ljIGJ1aWxkaW5nIGJsb2NrIGlzIFRMViAoVGFnLUxlbmd0aC1WYWx1ZSlcXG4gICAgICAgIF90bHY6IHtcXG4gICAgICAgICAgZW5jb2RlOiAodGFnLCBkYXRhKSA9PiB7XFxuICAgICAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcXG4gICAgICAgICAgICBpZiAodGFnIDwgMCB8fCB0YWcgPiAyNTYpXFxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRShcInRsdi5lbmNvZGU6IHdyb25nIHRhZ1wiKTtcXG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggJiAxKVxcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoXCJ0bHYuZW5jb2RlOiB1bnBhZGRlZCBkYXRhXCIpO1xcbiAgICAgICAgICAgIGNvbnN0IGRhdGFMZW4gPSBkYXRhLmxlbmd0aCAvIDI7XFxuICAgICAgICAgICAgY29uc3QgbGVuID0gbnVtYmVyVG9IZXhVbnBhZGRlZChkYXRhTGVuKTtcXG4gICAgICAgICAgICBpZiAobGVuLmxlbmd0aCAvIDIgJiAxMjgpXFxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRShcInRsdi5lbmNvZGU6IGxvbmcgZm9ybSBsZW5ndGggdG9vIGJpZ1wiKTtcXG4gICAgICAgICAgICBjb25zdCBsZW5MZW4gPSBkYXRhTGVuID4gMTI3ID8gbnVtYmVyVG9IZXhVbnBhZGRlZChsZW4ubGVuZ3RoIC8gMiB8IDEyOCkgOiBcIlwiO1xcbiAgICAgICAgICAgIGNvbnN0IHQgPSBudW1iZXJUb0hleFVucGFkZGVkKHRhZyk7XFxuICAgICAgICAgICAgcmV0dXJuIHQgKyBsZW5MZW4gKyBsZW4gKyBkYXRhO1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICAvLyB2IC0gdmFsdWUsIGwgLSBsZWZ0IGJ5dGVzICh1bnBhcnNlZClcXG4gICAgICAgICAgZGVjb2RlKHRhZywgZGF0YSkge1xcbiAgICAgICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XFxuICAgICAgICAgICAgbGV0IHBvcyA9IDA7XFxuICAgICAgICAgICAgaWYgKHRhZyA8IDAgfHwgdGFnID4gMjU2KVxcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoXCJ0bHYuZW5jb2RlOiB3cm9uZyB0YWdcIik7XFxuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMiB8fCBkYXRhW3BvcysrXSAhPT0gdGFnKVxcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoXCJ0bHYuZGVjb2RlOiB3cm9uZyB0bHZcIik7XFxuICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBkYXRhW3BvcysrXTtcXG4gICAgICAgICAgICBjb25zdCBpc0xvbmcgPSAhIShmaXJzdCAmIDEyOCk7XFxuICAgICAgICAgICAgbGV0IGxlbmd0aCA9IDA7XFxuICAgICAgICAgICAgaWYgKCFpc0xvbmcpXFxuICAgICAgICAgICAgICBsZW5ndGggPSBmaXJzdDtcXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgIGNvbnN0IGxlbkxlbiA9IGZpcnN0ICYgMTI3O1xcbiAgICAgICAgICAgICAgaWYgKCFsZW5MZW4pXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKFwidGx2LmRlY29kZShsb25nKTogaW5kZWZpbml0ZSBsZW5ndGggbm90IHN1cHBvcnRlZFwiKTtcXG4gICAgICAgICAgICAgIGlmIChsZW5MZW4gPiA0KVxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRShcInRsdi5kZWNvZGUobG9uZyk6IGJ5dGUgbGVuZ3RoIGlzIHRvbyBiaWdcIik7XFxuICAgICAgICAgICAgICBjb25zdCBsZW5ndGhCeXRlcyA9IGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyBsZW5MZW4pO1xcbiAgICAgICAgICAgICAgaWYgKGxlbmd0aEJ5dGVzLmxlbmd0aCAhPT0gbGVuTGVuKVxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRShcInRsdi5kZWNvZGU6IGxlbmd0aCBieXRlcyBub3QgY29tcGxldGVcIik7XFxuICAgICAgICAgICAgICBpZiAobGVuZ3RoQnl0ZXNbMF0gPT09IDApXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKFwidGx2LmRlY29kZShsb25nKTogemVybyBsZWZ0bW9zdCBieXRlXCIpO1xcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBiIG9mIGxlbmd0aEJ5dGVzKVxcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBsZW5ndGggPDwgOCB8IGI7XFxuICAgICAgICAgICAgICBwb3MgKz0gbGVuTGVuO1xcbiAgICAgICAgICAgICAgaWYgKGxlbmd0aCA8IDEyOClcXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoXCJ0bHYuZGVjb2RlKGxvbmcpOiBub3QgbWluaW1hbCBlbmNvZGluZ1wiKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgY29uc3QgdiA9IGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyBsZW5ndGgpO1xcbiAgICAgICAgICAgIGlmICh2Lmxlbmd0aCAhPT0gbGVuZ3RoKVxcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoXCJ0bHYuZGVjb2RlOiB3cm9uZyB2YWx1ZSBsZW5ndGhcIik7XFxuICAgICAgICAgICAgcmV0dXJuIHsgdiwgbDogZGF0YS5zdWJhcnJheShwb3MgKyBsZW5ndGgpIH07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICAvLyBodHRwczovL2NyeXB0by5zdGFja2V4Y2hhbmdlLmNvbS9hLzU3NzM0IExlZnRtb3N0IGJpdCBvZiBmaXJzdCBieXRlIGlzIFxcJ25lZ2F0aXZlXFwnIGZsYWcsXFxuICAgICAgICAvLyBzaW5jZSB3ZSBhbHdheXMgdXNlIHBvc2l0aXZlIGludGVnZXJzIGhlcmUuIEl0IG11c3QgYWx3YXlzIGJlIGVtcHR5OlxcbiAgICAgICAgLy8gLSBhZGQgemVybyBieXRlIGlmIGV4aXN0c1xcbiAgICAgICAgLy8gLSBpZiBuZXh0IGJ5dGUgZG9lc25cXCd0IGhhdmUgYSBmbGFnLCBsZWFkaW5nIHplcm8gaXMgbm90IGFsbG93ZWQgKG1pbmltYWwgZW5jb2RpbmcpXFxuICAgICAgICBfaW50OiB7XFxuICAgICAgICAgIGVuY29kZShudW0yKSB7XFxuICAgICAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcXG4gICAgICAgICAgICBpZiAobnVtMiA8IF8wbjUpXFxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRShcImludGVnZXI6IG5lZ2F0aXZlIGludGVnZXJzIGFyZSBub3QgYWxsb3dlZFwiKTtcXG4gICAgICAgICAgICBsZXQgaGV4ID0gbnVtYmVyVG9IZXhVbnBhZGRlZChudW0yKTtcXG4gICAgICAgICAgICBpZiAoTnVtYmVyLnBhcnNlSW50KGhleFswXSwgMTYpICYgOClcXG4gICAgICAgICAgICAgIGhleCA9IFwiMDBcIiArIGhleDtcXG4gICAgICAgICAgICBpZiAoaGV4Lmxlbmd0aCAmIDEpXFxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRShcInVuZXhwZWN0ZWQgREVSIHBhcnNpbmcgYXNzZXJ0aW9uOiB1bnBhZGRlZCBoZXhcIik7XFxuICAgICAgICAgICAgcmV0dXJuIGhleDtcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgZGVjb2RlKGRhdGEpIHtcXG4gICAgICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xcbiAgICAgICAgICAgIGlmIChkYXRhWzBdICYgMTI4KVxcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoXCJpbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiBuZWdhdGl2ZVwiKTtcXG4gICAgICAgICAgICBpZiAoZGF0YVswXSA9PT0gMCAmJiAhKGRhdGFbMV0gJiAxMjgpKVxcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoXCJpbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB1bm5lY2Vzc2FyeSBsZWFkaW5nIHplcm9cIik7XFxuICAgICAgICAgICAgcmV0dXJuIGIybihkYXRhKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIHRvU2lnKGhleCkge1xcbiAgICAgICAgICBjb25zdCB7IEVycjogRSwgX2ludDogaW50LCBfdGx2OiB0bHYgfSA9IERFUjtcXG4gICAgICAgICAgY29uc3QgZGF0YSA9IHR5cGVvZiBoZXggPT09IFwic3RyaW5nXCIgPyBoMmIoaGV4KSA6IGhleDtcXG4gICAgICAgICAgYWJ5dGVzMihkYXRhKTtcXG4gICAgICAgICAgY29uc3QgeyB2OiBzZXFCeXRlcywgbDogc2VxTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDQ4LCBkYXRhKTtcXG4gICAgICAgICAgaWYgKHNlcUxlZnRCeXRlcy5sZW5ndGgpXFxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoXCJpbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nXCIpO1xcbiAgICAgICAgICBjb25zdCB7IHY6IHJCeXRlcywgbDogckxlZnRCeXRlcyB9ID0gdGx2LmRlY29kZSgyLCBzZXFCeXRlcyk7XFxuICAgICAgICAgIGNvbnN0IHsgdjogc0J5dGVzLCBsOiBzTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDIsIHJMZWZ0Qnl0ZXMpO1xcbiAgICAgICAgICBpZiAoc0xlZnRCeXRlcy5sZW5ndGgpXFxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoXCJpbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nXCIpO1xcbiAgICAgICAgICByZXR1cm4geyByOiBpbnQuZGVjb2RlKHJCeXRlcyksIHM6IGludC5kZWNvZGUoc0J5dGVzKSB9O1xcbiAgICAgICAgfSxcXG4gICAgICAgIGhleEZyb21TaWcoc2lnKSB7XFxuICAgICAgICAgIGNvbnN0IHsgX3RsdjogdGx2LCBfaW50OiBpbnQgfSA9IERFUjtcXG4gICAgICAgICAgY29uc3QgcnMgPSB0bHYuZW5jb2RlKDIsIGludC5lbmNvZGUoc2lnLnIpKTtcXG4gICAgICAgICAgY29uc3Qgc3MgPSB0bHYuZW5jb2RlKDIsIGludC5lbmNvZGUoc2lnLnMpKTtcXG4gICAgICAgICAgY29uc3Qgc2VxID0gcnMgKyBzcztcXG4gICAgICAgICAgcmV0dXJuIHRsdi5lbmNvZGUoNDgsIHNlcSk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICBfMG41ID0gQmlnSW50KDApO1xcbiAgICAgIF8xbjUgPSBCaWdJbnQoMSk7XFxuICAgICAgXzJuNCA9IEJpZ0ludCgyKTtcXG4gICAgICBfM24yID0gQmlnSW50KDMpO1xcbiAgICAgIF80bjIgPSBCaWdJbnQoNCk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjguMS9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vX3Nob3J0d191dGlscy5qc1xcbiAgZnVuY3Rpb24gZ2V0SGFzaChoYXNoMikge1xcbiAgICByZXR1cm4ge1xcbiAgICAgIGhhc2g6IGhhc2gyLFxcbiAgICAgIGhtYWM6IChrZXksIC4uLm1zZ3MpID0+IGhtYWMoaGFzaDIsIGtleSwgY29uY2F0Qnl0ZXMoLi4ubXNncykpLFxcbiAgICAgIHJhbmRvbUJ5dGVzXFxuICAgIH07XFxuICB9XFxuICBmdW5jdGlvbiBjcmVhdGVDdXJ2ZShjdXJ2ZURlZiwgZGVmSGFzaCkge1xcbiAgICBjb25zdCBjcmVhdGUgPSAoaGFzaDIpID0+IHdlaWVyc3RyYXNzKHsgLi4uY3VydmVEZWYsIC4uLmdldEhhc2goaGFzaDIpIH0pO1xcbiAgICByZXR1cm4geyAuLi5jcmVhdGUoZGVmSGFzaCksIGNyZWF0ZSB9O1xcbiAgfVxcbiAgdmFyIGluaXRfc2hvcnR3X3V0aWxzID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStjdXJ2ZXNAMS44LjEvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL19zaG9ydHdfdXRpbHMuanNcIigpIHtcXG4gICAgICBpbml0X2htYWMoKTtcXG4gICAgICBpbml0X3V0aWxzMigpO1xcbiAgICAgIGluaXRfd2VpZXJzdHJhc3MoKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS9Abm9ibGUrY3VydmVzQDEuOC4xL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzXFxuICBmdW5jdGlvbiBpMm9zcCh2YWx1ZSwgbGVuZ3RoKSB7XFxuICAgIGFudW0odmFsdWUpO1xcbiAgICBhbnVtKGxlbmd0aCk7XFxuICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPj0gMSA8PCA4ICogbGVuZ3RoKVxcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgSTJPU1AgaW5wdXQ6IFwiICsgdmFsdWUpO1xcbiAgICBjb25zdCByZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoIH0pLmZpbGwoMCk7XFxuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xcbiAgICAgIHJlc1tpXSA9IHZhbHVlICYgMjU1O1xcbiAgICAgIHZhbHVlID4+Pj0gODtcXG4gICAgfVxcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIHN0cnhvcihhLCBiKSB7XFxuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGEubGVuZ3RoKTtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgYXJyW2ldID0gYVtpXSBeIGJbaV07XFxuICAgIH1cXG4gICAgcmV0dXJuIGFycjtcXG4gIH1cXG4gIGZ1bmN0aW9uIGFudW0oaXRlbSkge1xcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGl0ZW0pKVxcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm51bWJlciBleHBlY3RlZFwiKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuSW5CeXRlcywgSCkge1xcbiAgICBhYnl0ZXMyKG1zZyk7XFxuICAgIGFieXRlczIoRFNUKTtcXG4gICAgYW51bShsZW5JbkJ5dGVzKTtcXG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpXFxuICAgICAgRFNUID0gSChjb25jYXRCeXRlczModXRmOFRvQnl0ZXMyKFwiSDJDLU9WRVJTSVpFLURTVC1cIiksIERTVCkpO1xcbiAgICBjb25zdCB7IG91dHB1dExlbjogYl9pbl9ieXRlcywgYmxvY2tMZW46IHJfaW5fYnl0ZXMgfSA9IEg7XFxuICAgIGNvbnN0IGVsbCA9IE1hdGguY2VpbChsZW5JbkJ5dGVzIC8gYl9pbl9ieXRlcyk7XFxuICAgIGlmIChsZW5JbkJ5dGVzID4gNjU1MzUgfHwgZWxsID4gMjU1KVxcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImV4cGFuZF9tZXNzYWdlX3htZDogaW52YWxpZCBsZW5JbkJ5dGVzXCIpO1xcbiAgICBjb25zdCBEU1RfcHJpbWUgPSBjb25jYXRCeXRlczMoRFNULCBpMm9zcChEU1QubGVuZ3RoLCAxKSk7XFxuICAgIGNvbnN0IFpfcGFkID0gaTJvc3AoMCwgcl9pbl9ieXRlcyk7XFxuICAgIGNvbnN0IGxfaV9iX3N0ciA9IGkyb3NwKGxlbkluQnl0ZXMsIDIpO1xcbiAgICBjb25zdCBiID0gbmV3IEFycmF5KGVsbCk7XFxuICAgIGNvbnN0IGJfMCA9IEgoY29uY2F0Qnl0ZXMzKFpfcGFkLCBtc2csIGxfaV9iX3N0ciwgaTJvc3AoMCwgMSksIERTVF9wcmltZSkpO1xcbiAgICBiWzBdID0gSChjb25jYXRCeXRlczMoYl8wLCBpMm9zcCgxLCAxKSwgRFNUX3ByaW1lKSk7XFxuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGVsbDsgaSsrKSB7XFxuICAgICAgY29uc3QgYXJncyA9IFtzdHJ4b3IoYl8wLCBiW2kgLSAxXSksIGkyb3NwKGkgKyAxLCAxKSwgRFNUX3ByaW1lXTtcXG4gICAgICBiW2ldID0gSChjb25jYXRCeXRlczMoLi4uYXJncykpO1xcbiAgICB9XFxuICAgIGNvbnN0IHBzZXVkb19yYW5kb21fYnl0ZXMgPSBjb25jYXRCeXRlczMoLi4uYik7XFxuICAgIHJldHVybiBwc2V1ZG9fcmFuZG9tX2J5dGVzLnNsaWNlKDAsIGxlbkluQnl0ZXMpO1xcbiAgfVxcbiAgZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBrLCBIKSB7XFxuICAgIGFieXRlczIobXNnKTtcXG4gICAgYWJ5dGVzMihEU1QpO1xcbiAgICBhbnVtKGxlbkluQnl0ZXMpO1xcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSkge1xcbiAgICAgIGNvbnN0IGRrTGVuID0gTWF0aC5jZWlsKDIgKiBrIC8gOCk7XFxuICAgICAgRFNUID0gSC5jcmVhdGUoeyBka0xlbiB9KS51cGRhdGUodXRmOFRvQnl0ZXMyKFwiSDJDLU9WRVJTSVpFLURTVC1cIikpLnVwZGF0ZShEU1QpLmRpZ2VzdCgpO1xcbiAgICB9XFxuICAgIGlmIChsZW5JbkJ5dGVzID4gNjU1MzUgfHwgRFNULmxlbmd0aCA+IDI1NSlcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHBhbmRfbWVzc2FnZV94b2Y6IGludmFsaWQgbGVuSW5CeXRlc1wiKTtcXG4gICAgcmV0dXJuIEguY3JlYXRlKHsgZGtMZW46IGxlbkluQnl0ZXMgfSkudXBkYXRlKG1zZykudXBkYXRlKGkyb3NwKGxlbkluQnl0ZXMsIDIpKS51cGRhdGUoRFNUKS51cGRhdGUoaTJvc3AoRFNULmxlbmd0aCwgMSkpLmRpZ2VzdCgpO1xcbiAgfVxcbiAgZnVuY3Rpb24gaGFzaF90b19maWVsZChtc2csIGNvdW50LCBvcHRpb25zKSB7XFxuICAgIHZhbGlkYXRlT2JqZWN0KG9wdGlvbnMsIHtcXG4gICAgICBEU1Q6IFwic3RyaW5nT3JVaW50OEFycmF5XCIsXFxuICAgICAgcDogXCJiaWdpbnRcIixcXG4gICAgICBtOiBcImlzU2FmZUludGVnZXJcIixcXG4gICAgICBrOiBcImlzU2FmZUludGVnZXJcIixcXG4gICAgICBoYXNoOiBcImhhc2hcIlxcbiAgICB9KTtcXG4gICAgY29uc3QgeyBwLCBrLCBtLCBoYXNoOiBoYXNoMiwgZXhwYW5kLCBEU1Q6IF9EU1QgfSA9IG9wdGlvbnM7XFxuICAgIGFieXRlczIobXNnKTtcXG4gICAgYW51bShjb3VudCk7XFxuICAgIGNvbnN0IERTVCA9IHR5cGVvZiBfRFNUID09PSBcInN0cmluZ1wiID8gdXRmOFRvQnl0ZXMyKF9EU1QpIDogX0RTVDtcXG4gICAgY29uc3QgbG9nMnAgPSBwLnRvU3RyaW5nKDIpLmxlbmd0aDtcXG4gICAgY29uc3QgTCA9IE1hdGguY2VpbCgobG9nMnAgKyBrKSAvIDgpO1xcbiAgICBjb25zdCBsZW5faW5fYnl0ZXMgPSBjb3VudCAqIG0gKiBMO1xcbiAgICBsZXQgcHJiO1xcbiAgICBpZiAoZXhwYW5kID09PSBcInhtZFwiKSB7XFxuICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGhhc2gyKTtcXG4gICAgfSBlbHNlIGlmIChleHBhbmQgPT09IFwieG9mXCIpIHtcXG4gICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaywgaGFzaDIpO1xcbiAgICB9IGVsc2UgaWYgKGV4cGFuZCA9PT0gXCJfaW50ZXJuYWxfcGFzc1wiKSB7XFxuICAgICAgcHJiID0gbXNnO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcihcXCdleHBhbmQgbXVzdCBiZSBcInhtZFwiIG9yIFwieG9mXCJcXCcpO1xcbiAgICB9XFxuICAgIGNvbnN0IHUgPSBuZXcgQXJyYXkoY291bnQpO1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcXG4gICAgICBjb25zdCBlID0gbmV3IEFycmF5KG0pO1xcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbTsgaisrKSB7XFxuICAgICAgICBjb25zdCBlbG1fb2Zmc2V0ID0gTCAqIChqICsgaSAqIG0pO1xcbiAgICAgICAgY29uc3QgdHYgPSBwcmIuc3ViYXJyYXkoZWxtX29mZnNldCwgZWxtX29mZnNldCArIEwpO1xcbiAgICAgICAgZVtqXSA9IG1vZChvczJpcCh0diksIHApO1xcbiAgICAgIH1cXG4gICAgICB1W2ldID0gZTtcXG4gICAgfVxcbiAgICByZXR1cm4gdTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGlzb2dlbnlNYXAoZmllbGQsIG1hcCkge1xcbiAgICBjb25zdCBDT0VGRiA9IG1hcC5tYXAoKGkpID0+IEFycmF5LmZyb20oaSkucmV2ZXJzZSgpKTtcXG4gICAgcmV0dXJuICh4LCB5KSA9PiB7XFxuICAgICAgY29uc3QgW3hOdW0sIHhEZW4sIHlOdW0sIHlEZW5dID0gQ09FRkYubWFwKCh2YWwpID0+IHZhbC5yZWR1Y2UoKGFjYywgaSkgPT4gZmllbGQuYWRkKGZpZWxkLm11bChhY2MsIHgpLCBpKSkpO1xcbiAgICAgIHggPSBmaWVsZC5kaXYoeE51bSwgeERlbik7XFxuICAgICAgeSA9IGZpZWxkLm11bCh5LCBmaWVsZC5kaXYoeU51bSwgeURlbikpO1xcbiAgICAgIHJldHVybiB7IHgsIHkgfTtcXG4gICAgfTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGNyZWF0ZUhhc2hlcihQb2ludDIsIG1hcFRvQ3VydmUsIGRlZikge1xcbiAgICBpZiAodHlwZW9mIG1hcFRvQ3VydmUgIT09IFwiZnVuY3Rpb25cIilcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXBUb0N1cnZlKCkgbXVzdCBiZSBkZWZpbmVkXCIpO1xcbiAgICByZXR1cm4ge1xcbiAgICAgIC8vIEVuY29kZXMgYnl0ZSBzdHJpbmcgdG8gZWxsaXB0aWMgY3VydmUuXFxuICAgICAgLy8gaGFzaF90b19jdXJ2ZSBmcm9tIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tM1xcbiAgICAgIGhhc2hUb0N1cnZlKG1zZywgb3B0aW9ucykge1xcbiAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAyLCB7IC4uLmRlZiwgRFNUOiBkZWYuRFNULCAuLi5vcHRpb25zIH0pO1xcbiAgICAgICAgY29uc3QgdTAgPSBQb2ludDIuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMF0pKTtcXG4gICAgICAgIGNvbnN0IHUxID0gUG9pbnQyLmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzFdKSk7XFxuICAgICAgICBjb25zdCBQID0gdTAuYWRkKHUxKS5jbGVhckNvZmFjdG9yKCk7XFxuICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XFxuICAgICAgICByZXR1cm4gUDtcXG4gICAgICB9LFxcbiAgICAgIC8vIEVuY29kZXMgYnl0ZSBzdHJpbmcgdG8gZWxsaXB0aWMgY3VydmUuXFxuICAgICAgLy8gZW5jb2RlX3RvX2N1cnZlIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi0zXFxuICAgICAgZW5jb2RlVG9DdXJ2ZShtc2csIG9wdGlvbnMpIHtcXG4gICAgICAgIGNvbnN0IHUgPSBoYXNoX3RvX2ZpZWxkKG1zZywgMSwgeyAuLi5kZWYsIERTVDogZGVmLmVuY29kZURTVCwgLi4ub3B0aW9ucyB9KTtcXG4gICAgICAgIGNvbnN0IFAgPSBQb2ludDIuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMF0pKS5jbGVhckNvZmFjdG9yKCk7XFxuICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XFxuICAgICAgICByZXR1cm4gUDtcXG4gICAgICB9LFxcbiAgICAgIC8vIFNhbWUgYXMgZW5jb2RlVG9DdXJ2ZSwgYnV0IHdpdGhvdXQgaGFzaFxcbiAgICAgIG1hcFRvQ3VydmUoc2NhbGFycykge1xcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNjYWxhcnMpKVxcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXBUb0N1cnZlOiBleHBlY3RlZCBhcnJheSBvZiBiaWdpbnRzXCIpO1xcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHNjYWxhcnMpXFxuICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gXCJiaWdpbnRcIilcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXBUb0N1cnZlOiBleHBlY3RlZCBhcnJheSBvZiBiaWdpbnRzXCIpO1xcbiAgICAgICAgY29uc3QgUCA9IFBvaW50Mi5mcm9tQWZmaW5lKG1hcFRvQ3VydmUoc2NhbGFycykpLmNsZWFyQ29mYWN0b3IoKTtcXG4gICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcXG4gICAgICAgIHJldHVybiBQO1xcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG4gIHZhciBvczJpcDtcXG4gIHZhciBpbml0X2hhc2hfdG9fY3VydmUgPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjguMS9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qc1wiKCkge1xcbiAgICAgIGluaXRfbW9kdWxhcigpO1xcbiAgICAgIGluaXRfdXRpbHM0KCk7XFxuICAgICAgb3MyaXAgPSBieXRlc1RvTnVtYmVyQkU7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjguMS9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vc2VjcDI1NmsxLmpzXFxuICB2YXIgc2VjcDI1NmsxX2V4cG9ydHMgPSB7fTtcXG4gIF9fZXhwb3J0KHNlY3AyNTZrMV9leHBvcnRzLCB7XFxuICAgIGVuY29kZVRvQ3VydmU6ICgpID0+IGVuY29kZVRvQ3VydmUsXFxuICAgIGhhc2hUb0N1cnZlOiAoKSA9PiBoYXNoVG9DdXJ2ZSxcXG4gICAgc2Nobm9ycjogKCkgPT4gc2Nobm9ycixcXG4gICAgc2VjcDI1NmsxOiAoKSA9PiBzZWNwMjU2azFcXG4gIH0pO1xcbiAgZnVuY3Rpb24gc3FydE1vZCh5KSB7XFxuICAgIGNvbnN0IFAgPSBzZWNwMjU2azFQO1xcbiAgICBjb25zdCBfM24zID0gQmlnSW50KDMpLCBfNm4gPSBCaWdJbnQoNiksIF8xMW4gPSBCaWdJbnQoMTEpLCBfMjJuID0gQmlnSW50KDIyKTtcXG4gICAgY29uc3QgXzIzbiA9IEJpZ0ludCgyMyksIF80NG4gPSBCaWdJbnQoNDQpLCBfODhuID0gQmlnSW50KDg4KTtcXG4gICAgY29uc3QgYjIgPSB5ICogeSAqIHkgJSBQO1xcbiAgICBjb25zdCBiMyA9IGIyICogYjIgKiB5ICUgUDtcXG4gICAgY29uc3QgYjYgPSBwb3cyKGIzLCBfM24zLCBQKSAqIGIzICUgUDtcXG4gICAgY29uc3QgYjkgPSBwb3cyKGI2LCBfM24zLCBQKSAqIGIzICUgUDtcXG4gICAgY29uc3QgYjExID0gcG93MihiOSwgXzJuNSwgUCkgKiBiMiAlIFA7XFxuICAgIGNvbnN0IGIyMiA9IHBvdzIoYjExLCBfMTFuLCBQKSAqIGIxMSAlIFA7XFxuICAgIGNvbnN0IGI0NCA9IHBvdzIoYjIyLCBfMjJuLCBQKSAqIGIyMiAlIFA7XFxuICAgIGNvbnN0IGI4OCA9IHBvdzIoYjQ0LCBfNDRuLCBQKSAqIGI0NCAlIFA7XFxuICAgIGNvbnN0IGIxNzYgPSBwb3cyKGI4OCwgXzg4biwgUCkgKiBiODggJSBQO1xcbiAgICBjb25zdCBiMjIwID0gcG93MihiMTc2LCBfNDRuLCBQKSAqIGI0NCAlIFA7XFxuICAgIGNvbnN0IGIyMjMgPSBwb3cyKGIyMjAsIF8zbjMsIFApICogYjMgJSBQO1xcbiAgICBjb25zdCB0MSA9IHBvdzIoYjIyMywgXzIzbiwgUCkgKiBiMjIgJSBQO1xcbiAgICBjb25zdCB0MiA9IHBvdzIodDEsIF82biwgUCkgKiBiMiAlIFA7XFxuICAgIGNvbnN0IHJvb3QgPSBwb3cyKHQyLCBfMm41LCBQKTtcXG4gICAgaWYgKCFGcGsxLmVxbChGcGsxLnNxcihyb290KSwgeSkpXFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3RcIik7XFxuICAgIHJldHVybiByb290O1xcbiAgfVxcbiAgZnVuY3Rpb24gdGFnZ2VkSGFzaCh0YWcsIC4uLm1lc3NhZ2VzKSB7XFxuICAgIGxldCB0YWdQID0gVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXTtcXG4gICAgaWYgKHRhZ1AgPT09IHZvaWQgMCkge1xcbiAgICAgIGNvbnN0IHRhZ0ggPSBzaGEyNTYoVWludDhBcnJheS5mcm9tKHRhZywgKGMpID0+IGMuY2hhckNvZGVBdCgwKSkpO1xcbiAgICAgIHRhZ1AgPSBjb25jYXRCeXRlczModGFnSCwgdGFnSCk7XFxuICAgICAgVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXSA9IHRhZ1A7XFxuICAgIH1cXG4gICAgcmV0dXJuIHNoYTI1Nihjb25jYXRCeXRlczModGFnUCwgLi4ubWVzc2FnZXMpKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdikge1xcbiAgICBsZXQgZF8gPSBzZWNwMjU2azEudXRpbHMubm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2KTtcXG4gICAgbGV0IHAgPSBQb2ludC5mcm9tUHJpdmF0ZUtleShkXyk7XFxuICAgIGNvbnN0IHNjYWxhciA9IHAuaGFzRXZlblkoKSA/IGRfIDogbW9kTigtZF8pO1xcbiAgICByZXR1cm4geyBzY2FsYXIsIGJ5dGVzOiBwb2ludFRvQnl0ZXMocCkgfTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGxpZnRfeCh4KSB7XFxuICAgIGFJblJhbmdlKFwieFwiLCB4LCBfMW42LCBzZWNwMjU2azFQKTtcXG4gICAgY29uc3QgeHggPSBtb2RQKHggKiB4KTtcXG4gICAgY29uc3QgYyA9IG1vZFAoeHggKiB4ICsgQmlnSW50KDcpKTtcXG4gICAgbGV0IHkgPSBzcXJ0TW9kKGMpO1xcbiAgICBpZiAoeSAlIF8ybjUgIT09IF8wbjYpXFxuICAgICAgeSA9IG1vZFAoLXkpO1xcbiAgICBjb25zdCBwID0gbmV3IFBvaW50KHgsIHksIF8xbjYpO1xcbiAgICBwLmFzc2VydFZhbGlkaXR5KCk7XFxuICAgIHJldHVybiBwO1xcbiAgfVxcbiAgZnVuY3Rpb24gY2hhbGxlbmdlKC4uLmFyZ3MpIHtcXG4gICAgcmV0dXJuIG1vZE4obnVtKHRhZ2dlZEhhc2goXCJCSVAwMzQwL2NoYWxsZW5nZVwiLCAuLi5hcmdzKSkpO1xcbiAgfVxcbiAgZnVuY3Rpb24gc2Nobm9yckdldFB1YmxpY0tleShwcml2YXRlS2V5KSB7XFxuICAgIHJldHVybiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpLmJ5dGVzO1xcbiAgfVxcbiAgZnVuY3Rpb24gc2Nobm9yclNpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSwgYXV4UmFuZCA9IHJhbmRvbUJ5dGVzKDMyKSkge1xcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoXCJtZXNzYWdlXCIsIG1lc3NhZ2UpO1xcbiAgICBjb25zdCB7IGJ5dGVzOiBweCwgc2NhbGFyOiBkIH0gPSBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpO1xcbiAgICBjb25zdCBhID0gZW5zdXJlQnl0ZXMoXCJhdXhSYW5kXCIsIGF1eFJhbmQsIDMyKTtcXG4gICAgY29uc3QgdCA9IG51bVRvMzJiKGQgXiBudW0odGFnZ2VkSGFzaChcIkJJUDAzNDAvYXV4XCIsIGEpKSk7XFxuICAgIGNvbnN0IHJhbmQgPSB0YWdnZWRIYXNoKFwiQklQMDM0MC9ub25jZVwiLCB0LCBweCwgbSk7XFxuICAgIGNvbnN0IGtfID0gbW9kTihudW0ocmFuZCkpO1xcbiAgICBpZiAoa18gPT09IF8wbjYpXFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2lnbiBmYWlsZWQ6IGsgaXMgemVyb1wiKTtcXG4gICAgY29uc3QgeyBieXRlczogcngsIHNjYWxhcjogayB9ID0gc2Nobm9yckdldEV4dFB1YktleShrXyk7XFxuICAgIGNvbnN0IGUgPSBjaGFsbGVuZ2UocngsIHB4LCBtKTtcXG4gICAgY29uc3Qgc2lnID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xcbiAgICBzaWcuc2V0KHJ4LCAwKTtcXG4gICAgc2lnLnNldChudW1UbzMyYihtb2ROKGsgKyBlICogZCkpLCAzMik7XFxuICAgIGlmICghc2Nobm9yclZlcmlmeShzaWcsIG0sIHB4KSlcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzaWduOiBJbnZhbGlkIHNpZ25hdHVyZSBwcm9kdWNlZFwiKTtcXG4gICAgcmV0dXJuIHNpZztcXG4gIH1cXG4gIGZ1bmN0aW9uIHNjaG5vcnJWZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcXG4gICAgY29uc3Qgc2lnID0gZW5zdXJlQnl0ZXMoXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlLCA2NCk7XFxuICAgIGNvbnN0IG0gPSBlbnN1cmVCeXRlcyhcIm1lc3NhZ2VcIiwgbWVzc2FnZSk7XFxuICAgIGNvbnN0IHB1YiA9IGVuc3VyZUJ5dGVzKFwicHVibGljS2V5XCIsIHB1YmxpY0tleSwgMzIpO1xcbiAgICB0cnkge1xcbiAgICAgIGNvbnN0IFAgPSBsaWZ0X3gobnVtKHB1YikpO1xcbiAgICAgIGNvbnN0IHIgPSBudW0oc2lnLnN1YmFycmF5KDAsIDMyKSk7XFxuICAgICAgaWYgKCFpblJhbmdlKHIsIF8xbjYsIHNlY3AyNTZrMVApKVxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIGNvbnN0IHMgPSBudW0oc2lnLnN1YmFycmF5KDMyLCA2NCkpO1xcbiAgICAgIGlmICghaW5SYW5nZShzLCBfMW42LCBzZWNwMjU2azFOKSlcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICBjb25zdCBlID0gY2hhbGxlbmdlKG51bVRvMzJiKHIpLCBwb2ludFRvQnl0ZXMoUCksIG0pO1xcbiAgICAgIGNvbnN0IFIgPSBHbXVsQWRkKFAsIHMsIG1vZE4oLWUpKTtcXG4gICAgICBpZiAoIVIgfHwgIVIuaGFzRXZlblkoKSB8fCBSLnRvQWZmaW5lKCkueCAhPT0gcilcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gIH1cXG4gIHZhciBzZWNwMjU2azFQLCBzZWNwMjU2azFOLCBfMW42LCBfMm41LCBkaXZOZWFyZXN0LCBGcGsxLCBzZWNwMjU2azEsIF8wbjYsIFRBR0dFRF9IQVNIX1BSRUZJWEVTLCBwb2ludFRvQnl0ZXMsIG51bVRvMzJiLCBtb2RQLCBtb2ROLCBQb2ludCwgR211bEFkZCwgbnVtLCBzY2hub3JyLCBpc29NYXAsIG1hcFNXVSwgaHRmLCBoYXNoVG9DdXJ2ZSwgZW5jb2RlVG9DdXJ2ZTtcXG4gIHZhciBpbml0X3NlY3AyNTZrMSA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS9Abm9ibGUrY3VydmVzQDEuOC4xL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanNcIigpIHtcXG4gICAgICBpbml0X3NoYTI1NigpO1xcbiAgICAgIGluaXRfdXRpbHMyKCk7XFxuICAgICAgaW5pdF9zaG9ydHdfdXRpbHMoKTtcXG4gICAgICBpbml0X2hhc2hfdG9fY3VydmUoKTtcXG4gICAgICBpbml0X21vZHVsYXIoKTtcXG4gICAgICBpbml0X3V0aWxzNCgpO1xcbiAgICAgIGluaXRfd2VpZXJzdHJhc3MoKTtcXG4gICAgICBzZWNwMjU2azFQID0gQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmYzJmXCIpO1xcbiAgICAgIHNlY3AyNTZrMU4gPSBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDFcIik7XFxuICAgICAgXzFuNiA9IEJpZ0ludCgxKTtcXG4gICAgICBfMm41ID0gQmlnSW50KDIpO1xcbiAgICAgIGRpdk5lYXJlc3QgPSAoYSwgYikgPT4gKGEgKyBiIC8gXzJuNSkgLyBiO1xcbiAgICAgIEZwazEgPSBGaWVsZChzZWNwMjU2azFQLCB2b2lkIDAsIHZvaWQgMCwgeyBzcXJ0OiBzcXJ0TW9kIH0pO1xcbiAgICAgIHNlY3AyNTZrMSA9IGNyZWF0ZUN1cnZlKHtcXG4gICAgICAgIGE6IEJpZ0ludCgwKSxcXG4gICAgICAgIC8vIGVxdWF0aW9uIHBhcmFtczogYSwgYlxcbiAgICAgICAgYjogQmlnSW50KDcpLFxcbiAgICAgICAgRnA6IEZwazEsXFxuICAgICAgICAvLyBGaWVsZFxcJ3MgcHJpbWU6IDJuKioyNTZuIC0gMm4qKjMybiAtIDJuKio5biAtIDJuKio4biAtIDJuKio3biAtIDJuKio2biAtIDJuKio0biAtIDFuXFxuICAgICAgICBuOiBzZWNwMjU2azFOLFxcbiAgICAgICAgLy8gQ3VydmUgb3JkZXIsIHRvdGFsIGNvdW50IG9mIHZhbGlkIHBvaW50cyBpbiB0aGUgZmllbGRcXG4gICAgICAgIC8vIEJhc2UgcG9pbnQgKHgsIHkpIGFrYSBnZW5lcmF0b3IgcG9pbnRcXG4gICAgICAgIEd4OiBCaWdJbnQoXCI1NTA2NjI2MzAyMjI3NzM0MzY2OTU3ODcxODg5NTE2ODUzNDMyNjI1MDYwMzQ1Mzc3NzU5NDE3NTUwMDE4NzM2MDM4OTExNjcyOTI0MFwiKSxcXG4gICAgICAgIEd5OiBCaWdJbnQoXCIzMjY3MDUxMDAyMDc1ODgxNjk3ODA4MzA4NTEzMDUwNzA0MzE4NDQ3MTI3MzM4MDY1OTI0MzI3NTkzODkwNDMzNTc1NzMzNzQ4MjQyNFwiKSxcXG4gICAgICAgIGg6IEJpZ0ludCgxKSxcXG4gICAgICAgIC8vIENvZmFjdG9yXFxuICAgICAgICBsb3dTOiB0cnVlLFxcbiAgICAgICAgLy8gQWxsb3cgb25seSBsb3ctUyBzaWduYXR1cmVzIGJ5IGRlZmF1bHQgaW4gc2lnbigpIGFuZCB2ZXJpZnkoKVxcbiAgICAgICAgZW5kbzoge1xcbiAgICAgICAgICAvLyBFbmRvbW9ycGhpc20sIHNlZSBhYm92ZVxcbiAgICAgICAgICBiZXRhOiBCaWdJbnQoXCIweDdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWVcIiksXFxuICAgICAgICAgIHNwbGl0U2NhbGFyOiAoaykgPT4ge1xcbiAgICAgICAgICAgIGNvbnN0IG4gPSBzZWNwMjU2azFOO1xcbiAgICAgICAgICAgIGNvbnN0IGExID0gQmlnSW50KFwiMHgzMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNVwiKTtcXG4gICAgICAgICAgICBjb25zdCBiMSA9IC1fMW42ICogQmlnSW50KFwiMHhlNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjM1wiKTtcXG4gICAgICAgICAgICBjb25zdCBhMiA9IEJpZ0ludChcIjB4MTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4XCIpO1xcbiAgICAgICAgICAgIGNvbnN0IGIyID0gYTE7XFxuICAgICAgICAgICAgY29uc3QgUE9XXzJfMTI4ID0gQmlnSW50KFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIik7XFxuICAgICAgICAgICAgY29uc3QgYzEgPSBkaXZOZWFyZXN0KGIyICogaywgbik7XFxuICAgICAgICAgICAgY29uc3QgYzIgPSBkaXZOZWFyZXN0KC1iMSAqIGssIG4pO1xcbiAgICAgICAgICAgIGxldCBrMSA9IG1vZChrIC0gYzEgKiBhMSAtIGMyICogYTIsIG4pO1xcbiAgICAgICAgICAgIGxldCBrMiA9IG1vZCgtYzEgKiBiMSAtIGMyICogYjIsIG4pO1xcbiAgICAgICAgICAgIGNvbnN0IGsxbmVnID0gazEgPiBQT1dfMl8xMjg7XFxuICAgICAgICAgICAgY29uc3QgazJuZWcgPSBrMiA+IFBPV18yXzEyODtcXG4gICAgICAgICAgICBpZiAoazFuZWcpXFxuICAgICAgICAgICAgICBrMSA9IG4gLSBrMTtcXG4gICAgICAgICAgICBpZiAoazJuZWcpXFxuICAgICAgICAgICAgICBrMiA9IG4gLSBrMjtcXG4gICAgICAgICAgICBpZiAoazEgPiBQT1dfMl8xMjggfHwgazIgPiBQT1dfMl8xMjgpIHtcXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNwbGl0U2NhbGFyOiBFbmRvbW9ycGhpc20gZmFpbGVkLCBrPVwiICsgayk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9LCBzaGEyNTYpO1xcbiAgICAgIF8wbjYgPSBCaWdJbnQoMCk7XFxuICAgICAgVEFHR0VEX0hBU0hfUFJFRklYRVMgPSB7fTtcXG4gICAgICBwb2ludFRvQnl0ZXMgPSAocG9pbnQpID0+IHBvaW50LnRvUmF3Qnl0ZXModHJ1ZSkuc2xpY2UoMSk7XFxuICAgICAgbnVtVG8zMmIgPSAobikgPT4gbnVtYmVyVG9CeXRlc0JFKG4sIDMyKTtcXG4gICAgICBtb2RQID0gKHgpID0+IG1vZCh4LCBzZWNwMjU2azFQKTtcXG4gICAgICBtb2ROID0gKHgpID0+IG1vZCh4LCBzZWNwMjU2azFOKTtcXG4gICAgICBQb2ludCA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQ7XFxuICAgICAgR211bEFkZCA9IChRLCBhLCBiKSA9PiBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpO1xcbiAgICAgIG51bSA9IGJ5dGVzVG9OdW1iZXJCRTtcXG4gICAgICBzY2hub3JyID0gLyogQF9fUFVSRV9fICovICgoKSA9PiAoe1xcbiAgICAgICAgZ2V0UHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5LFxcbiAgICAgICAgc2lnbjogc2Nobm9yclNpZ24sXFxuICAgICAgICB2ZXJpZnk6IHNjaG5vcnJWZXJpZnksXFxuICAgICAgICB1dGlsczoge1xcbiAgICAgICAgICByYW5kb21Qcml2YXRlS2V5OiBzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSxcXG4gICAgICAgICAgbGlmdF94LFxcbiAgICAgICAgICBwb2ludFRvQnl0ZXMsXFxuICAgICAgICAgIG51bWJlclRvQnl0ZXNCRSxcXG4gICAgICAgICAgYnl0ZXNUb051bWJlckJFLFxcbiAgICAgICAgICB0YWdnZWRIYXNoLFxcbiAgICAgICAgICBtb2RcXG4gICAgICAgIH1cXG4gICAgICB9KSkoKTtcXG4gICAgICBpc29NYXAgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGlzb2dlbnlNYXAoRnBrMSwgW1xcbiAgICAgICAgLy8geE51bVxcbiAgICAgICAgW1xcbiAgICAgICAgICBcIjB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYThjN1wiLFxcbiAgICAgICAgICBcIjB4N2QzZDRjODBiYzMyMWQ1YjlmMzE1Y2VhN2ZkNDRjNWQ1OTVkMmZjMGJmNjNiOTJkZmZmMTA0NGYxN2M2NTgxXCIsXFxuICAgICAgICAgIFwiMHg1MzRjMzI4ZDIzZjIzNGU2ZTJhNDEzZGVjYTI1Y2FlY2U0NTA2MTQ0MDM3YzQwMzE0ZWNiZDBiNTNkOWRkMjYyXCIsXFxuICAgICAgICAgIFwiMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhODhjXCJcXG4gICAgICAgIF0sXFxuICAgICAgICAvLyB4RGVuXFxuICAgICAgICBbXFxuICAgICAgICAgIFwiMHhkMzU3NzExOTNkOTQ5MThhOWNhMzRjY2JiN2I2NDBkZDg2Y2Q0MDk1NDJmODQ4N2Q5ZmU2Yjc0NTc4MWViNDliXCIsXFxuICAgICAgICAgIFwiMHhlZGFkYzZmNjQzODNkYzFkZjdjNGIyZDUxYjU0MjI1NDA2ZDM2YjY0MWY1ZTQxYmJjNTJhNTY2MTJhOGM2ZDE0XCIsXFxuICAgICAgICAgIFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxXCJcXG4gICAgICAgICAgLy8gTEFTVCAxXFxuICAgICAgICBdLFxcbiAgICAgICAgLy8geU51bVxcbiAgICAgICAgW1xcbiAgICAgICAgICBcIjB4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGI4ZTM4ZTIzY1wiLFxcbiAgICAgICAgICBcIjB4Yzc1ZTBjMzJkNWNiN2MwZmE5ZDBhNTRiMTJhMGE2ZDU2NDdhYjA0NmQ2ODZkYTZmZGZmYzkwZmMyMDFkNzFhM1wiLFxcbiAgICAgICAgICBcIjB4MjlhNjE5NDY5MWY5MWE3MzcxNTIwOWVmNjUxMmU1NzY3MjI4MzBhMjAxYmUyMDE4YTc2NWU4NWE5ZWNlZTkzMVwiLFxcbiAgICAgICAgICBcIjB4MmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmYzOGUzOGQ4NFwiXFxuICAgICAgICBdLFxcbiAgICAgICAgLy8geURlblxcbiAgICAgICAgW1xcbiAgICAgICAgICBcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZjkzYlwiLFxcbiAgICAgICAgICBcIjB4N2EwNjUzNGJiOGJkYjQ5ZmQ1ZTllNjYzMjcyMmMyOTg5NDY3YzFiZmM4ZThkOTc4ZGZiNDI1ZDI2ODVjMjU3M1wiLFxcbiAgICAgICAgICBcIjB4NjQ4NGFhNzE2NTQ1Y2EyY2YzYTcwYzNmYThmZTMzN2UwYTNkMjExNjJmMGQ2Mjk5YTdiZjgxOTJiZmQyYTc2ZlwiLFxcbiAgICAgICAgICBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMVwiXFxuICAgICAgICAgIC8vIExBU1QgMVxcbiAgICAgICAgXVxcbiAgICAgIF0ubWFwKChpKSA9PiBpLm1hcCgoaikgPT4gQmlnSW50KGopKSkpKSgpO1xcbiAgICAgIG1hcFNXVSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gbWFwVG9DdXJ2ZVNpbXBsZVNXVShGcGsxLCB7XFxuICAgICAgICBBOiBCaWdJbnQoXCIweDNmODczMWFiZGQ2NjFhZGNhMDhhNTU1OGYwZjVkMjcyZTk1M2QzNjNjYjZmMGU1ZDQwNTQ0N2MwMWE0NDQ1MzNcIiksXFxuICAgICAgICBCOiBCaWdJbnQoXCIxNzcxXCIpLFxcbiAgICAgICAgWjogRnBrMS5jcmVhdGUoQmlnSW50KFwiLTExXCIpKVxcbiAgICAgIH0pKSgpO1xcbiAgICAgIGh0ZiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gY3JlYXRlSGFzaGVyKHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQsIChzY2FsYXJzKSA9PiB7XFxuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IG1hcFNXVShGcGsxLmNyZWF0ZShzY2FsYXJzWzBdKSk7XFxuICAgICAgICByZXR1cm4gaXNvTWFwKHgsIHkpO1xcbiAgICAgIH0sIHtcXG4gICAgICAgIERTVDogXCJzZWNwMjU2azFfWE1EOlNIQS0yNTZfU1NXVV9ST19cIixcXG4gICAgICAgIGVuY29kZURTVDogXCJzZWNwMjU2azFfWE1EOlNIQS0yNTZfU1NXVV9OVV9cIixcXG4gICAgICAgIHA6IEZwazEuT1JERVIsXFxuICAgICAgICBtOiAxLFxcbiAgICAgICAgazogMTI4LFxcbiAgICAgICAgZXhwYW5kOiBcInhtZFwiLFxcbiAgICAgICAgaGFzaDogc2hhMjU2XFxuICAgICAgfSkpKCk7XFxuICAgICAgaGFzaFRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGh0Zi5oYXNoVG9DdXJ2ZSkoKTtcXG4gICAgICBlbmNvZGVUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBodGYuZW5jb2RlVG9DdXJ2ZSkoKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9lcnJvcnMvbm9kZS5qc1xcbiAgdmFyIEV4ZWN1dGlvblJldmVydGVkRXJyb3IsIEZlZUNhcFRvb0hpZ2hFcnJvciwgRmVlQ2FwVG9vTG93RXJyb3IsIE5vbmNlVG9vSGlnaEVycm9yLCBOb25jZVRvb0xvd0Vycm9yLCBOb25jZU1heFZhbHVlRXJyb3IsIEluc3VmZmljaWVudEZ1bmRzRXJyb3IsIEludHJpbnNpY0dhc1Rvb0hpZ2hFcnJvciwgSW50cmluc2ljR2FzVG9vTG93RXJyb3IsIFRyYW5zYWN0aW9uVHlwZU5vdFN1cHBvcnRlZEVycm9yLCBUaXBBYm92ZUZlZUNhcEVycm9yLCBVbmtub3duTm9kZUVycm9yO1xcbiAgdmFyIGluaXRfbm9kZSA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9lcnJvcnMvbm9kZS5qc1wiKCkge1xcbiAgICAgIGluaXRfZm9ybWF0R3dlaSgpO1xcbiAgICAgIGluaXRfYmFzZSgpO1xcbiAgICAgIEV4ZWN1dGlvblJldmVydGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjIge1xcbiAgICAgICAgY29uc3RydWN0b3IoeyBjYXVzZSwgbWVzc2FnZSB9ID0ge30pIHtcXG4gICAgICAgICAgY29uc3QgcmVhc29uID0gbWVzc2FnZT8ucmVwbGFjZShcImV4ZWN1dGlvbiByZXZlcnRlZDogXCIsIFwiXCIpPy5yZXBsYWNlKFwiZXhlY3V0aW9uIHJldmVydGVkXCIsIFwiXCIpO1xcbiAgICAgICAgICBzdXBlcihgRXhlY3V0aW9uIHJldmVydGVkICR7cmVhc29uID8gYHdpdGggcmVhc29uOiAke3JlYXNvbn1gIDogXCJmb3IgYW4gdW5rbm93biByZWFzb25cIn0uYCwge1xcbiAgICAgICAgICAgIGNhdXNlLFxcbiAgICAgICAgICAgIG5hbWU6IFwiRXhlY3V0aW9uUmV2ZXJ0ZWRFcnJvclwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV4ZWN1dGlvblJldmVydGVkRXJyb3IsIFwiY29kZVwiLCB7XFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICB2YWx1ZTogM1xcbiAgICAgIH0pO1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFeGVjdXRpb25SZXZlcnRlZEVycm9yLCBcIm5vZGVNZXNzYWdlXCIsIHtcXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgIHZhbHVlOiAvZXhlY3V0aW9uIHJldmVydGVkL1xcbiAgICAgIH0pO1xcbiAgICAgIEZlZUNhcFRvb0hpZ2hFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgICAgICBjb25zdHJ1Y3Rvcih7IGNhdXNlLCBtYXhGZWVQZXJHYXMgfSA9IHt9KSB7XFxuICAgICAgICAgIHN1cGVyKGBUaGUgZmVlIGNhcCAoXFxcXGBtYXhGZWVQZXJHYXNcXFxcYCR7bWF4RmVlUGVyR2FzID8gYCA9ICR7Zm9ybWF0R3dlaShtYXhGZWVQZXJHYXMpfSBnd2VpYCA6IFwiXCJ9KSBjYW5ub3QgYmUgaGlnaGVyIHRoYW4gdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZSAoMl4yNTYtMSkuYCwge1xcbiAgICAgICAgICAgIGNhdXNlLFxcbiAgICAgICAgICAgIG5hbWU6IFwiRmVlQ2FwVG9vSGlnaEVycm9yXCJcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmVlQ2FwVG9vSGlnaEVycm9yLCBcIm5vZGVNZXNzYWdlXCIsIHtcXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgIHZhbHVlOiAvbWF4IGZlZSBwZXIgZ2FzIGhpZ2hlciB0aGFuIDJcXFxcXjI1Ni0xfGZlZSBjYXAgaGlnaGVyIHRoYW4gMlxcXFxeMjU2LTEvXFxuICAgICAgfSk7XFxuICAgICAgRmVlQ2FwVG9vTG93RXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjIge1xcbiAgICAgICAgY29uc3RydWN0b3IoeyBjYXVzZSwgbWF4RmVlUGVyR2FzIH0gPSB7fSkge1xcbiAgICAgICAgICBzdXBlcihgVGhlIGZlZSBjYXAgKFxcXFxgbWF4RmVlUGVyR2FzXFxcXGAke21heEZlZVBlckdhcyA/IGAgPSAke2Zvcm1hdEd3ZWkobWF4RmVlUGVyR2FzKX1gIDogXCJcIn0gZ3dlaSkgY2Fubm90IGJlIGxvd2VyIHRoYW4gdGhlIGJsb2NrIGJhc2UgZmVlLmAsIHtcXG4gICAgICAgICAgICBjYXVzZSxcXG4gICAgICAgICAgICBuYW1lOiBcIkZlZUNhcFRvb0xvd0Vycm9yXCJcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmVlQ2FwVG9vTG93RXJyb3IsIFwibm9kZU1lc3NhZ2VcIiwge1xcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgdmFsdWU6IC9tYXggZmVlIHBlciBnYXMgbGVzcyB0aGFuIGJsb2NrIGJhc2UgZmVlfGZlZSBjYXAgbGVzcyB0aGFuIGJsb2NrIGJhc2UgZmVlfHRyYW5zYWN0aW9uIGlzIG91dGRhdGVkL1xcbiAgICAgIH0pO1xcbiAgICAgIE5vbmNlVG9vSGlnaEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IyIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKHsgY2F1c2UsIG5vbmNlIH0gPSB7fSkge1xcbiAgICAgICAgICBzdXBlcihgTm9uY2UgcHJvdmlkZWQgZm9yIHRoZSB0cmFuc2FjdGlvbiAke25vbmNlID8gYCgke25vbmNlfSkgYCA6IFwiXCJ9aXMgaGlnaGVyIHRoYW4gdGhlIG5leHQgb25lIGV4cGVjdGVkLmAsIHsgY2F1c2UsIG5hbWU6IFwiTm9uY2VUb29IaWdoRXJyb3JcIiB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOb25jZVRvb0hpZ2hFcnJvciwgXCJub2RlTWVzc2FnZVwiLCB7XFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICB2YWx1ZTogL25vbmNlIHRvbyBoaWdoL1xcbiAgICAgIH0pO1xcbiAgICAgIE5vbmNlVG9vTG93RXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjIge1xcbiAgICAgICAgY29uc3RydWN0b3IoeyBjYXVzZSwgbm9uY2UgfSA9IHt9KSB7XFxuICAgICAgICAgIHN1cGVyKFtcXG4gICAgICAgICAgICBgTm9uY2UgcHJvdmlkZWQgZm9yIHRoZSB0cmFuc2FjdGlvbiAke25vbmNlID8gYCgke25vbmNlfSkgYCA6IFwiXCJ9aXMgbG93ZXIgdGhhbiB0aGUgY3VycmVudCBub25jZSBvZiB0aGUgYWNjb3VudC5gLFxcbiAgICAgICAgICAgIFwiVHJ5IGluY3JlYXNpbmcgdGhlIG5vbmNlIG9yIGZpbmQgdGhlIGxhdGVzdCBub25jZSB3aXRoIGBnZXRUcmFuc2FjdGlvbkNvdW50YC5cIlxcbiAgICAgICAgICBdLmpvaW4oXCJcXFxcblwiKSwgeyBjYXVzZSwgbmFtZTogXCJOb25jZVRvb0xvd0Vycm9yXCIgfSk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTm9uY2VUb29Mb3dFcnJvciwgXCJub2RlTWVzc2FnZVwiLCB7XFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICB2YWx1ZTogL25vbmNlIHRvbyBsb3d8dHJhbnNhY3Rpb24gYWxyZWFkeSBpbXBvcnRlZHxhbHJlYWR5IGtub3duL1xcbiAgICAgIH0pO1xcbiAgICAgIE5vbmNlTWF4VmFsdWVFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgICAgICBjb25zdHJ1Y3Rvcih7IGNhdXNlLCBub25jZSB9ID0ge30pIHtcXG4gICAgICAgICAgc3VwZXIoYE5vbmNlIHByb3ZpZGVkIGZvciB0aGUgdHJhbnNhY3Rpb24gJHtub25jZSA/IGAoJHtub25jZX0pIGAgOiBcIlwifWV4Y2VlZHMgdGhlIG1heGltdW0gYWxsb3dlZCBub25jZS5gLCB7IGNhdXNlLCBuYW1lOiBcIk5vbmNlTWF4VmFsdWVFcnJvclwiIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5vbmNlTWF4VmFsdWVFcnJvciwgXCJub2RlTWVzc2FnZVwiLCB7XFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICB2YWx1ZTogL25vbmNlIGhhcyBtYXggdmFsdWUvXFxuICAgICAgfSk7XFxuICAgICAgSW5zdWZmaWNpZW50RnVuZHNFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgICAgICBjb25zdHJ1Y3Rvcih7IGNhdXNlIH0gPSB7fSkge1xcbiAgICAgICAgICBzdXBlcihbXFxuICAgICAgICAgICAgXCJUaGUgdG90YWwgY29zdCAoZ2FzICogZ2FzIGZlZSArIHZhbHVlKSBvZiBleGVjdXRpbmcgdGhpcyB0cmFuc2FjdGlvbiBleGNlZWRzIHRoZSBiYWxhbmNlIG9mIHRoZSBhY2NvdW50LlwiXFxuICAgICAgICAgIF0uam9pbihcIlxcXFxuXCIpLCB7XFxuICAgICAgICAgICAgY2F1c2UsXFxuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXFxuICAgICAgICAgICAgICBcIlRoaXMgZXJyb3IgY291bGQgYXJpc2Ugd2hlbiB0aGUgYWNjb3VudCBkb2VzIG5vdCBoYXZlIGVub3VnaCBmdW5kcyB0bzpcIixcXG4gICAgICAgICAgICAgIFwiIC0gcGF5IGZvciB0aGUgdG90YWwgZ2FzIGZlZSxcIixcXG4gICAgICAgICAgICAgIFwiIC0gcGF5IGZvciB0aGUgdmFsdWUgdG8gc2VuZC5cIixcXG4gICAgICAgICAgICAgIFwiIFwiLFxcbiAgICAgICAgICAgICAgXCJUaGUgY29zdCBvZiB0aGUgdHJhbnNhY3Rpb24gaXMgY2FsY3VsYXRlZCBhcyBgZ2FzICogZ2FzIGZlZSArIHZhbHVlYCwgd2hlcmU6XCIsXFxuICAgICAgICAgICAgICBcIiAtIGBnYXNgIGlzIHRoZSBhbW91bnQgb2YgZ2FzIG5lZWRlZCBmb3IgdHJhbnNhY3Rpb24gdG8gZXhlY3V0ZSxcIixcXG4gICAgICAgICAgICAgIFwiIC0gYGdhcyBmZWVgIGlzIHRoZSBnYXMgZmVlLFwiLFxcbiAgICAgICAgICAgICAgXCIgLSBgdmFsdWVgIGlzIHRoZSBhbW91bnQgb2YgZXRoZXIgdG8gc2VuZCB0byB0aGUgcmVjaXBpZW50LlwiXFxuICAgICAgICAgICAgXSxcXG4gICAgICAgICAgICBuYW1lOiBcIkluc3VmZmljaWVudEZ1bmRzRXJyb3JcIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnN1ZmZpY2llbnRGdW5kc0Vycm9yLCBcIm5vZGVNZXNzYWdlXCIsIHtcXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgIHZhbHVlOiAvaW5zdWZmaWNpZW50IGZ1bmRzfGV4Y2VlZHMgdHJhbnNhY3Rpb24gc2VuZGVyIGFjY291bnQgYmFsYW5jZS9cXG4gICAgICB9KTtcXG4gICAgICBJbnRyaW5zaWNHYXNUb29IaWdoRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjIge1xcbiAgICAgICAgY29uc3RydWN0b3IoeyBjYXVzZSwgZ2FzIH0gPSB7fSkge1xcbiAgICAgICAgICBzdXBlcihgVGhlIGFtb3VudCBvZiBnYXMgJHtnYXMgPyBgKCR7Z2FzfSkgYCA6IFwiXCJ9cHJvdmlkZWQgZm9yIHRoZSB0cmFuc2FjdGlvbiBleGNlZWRzIHRoZSBsaW1pdCBhbGxvd2VkIGZvciB0aGUgYmxvY2suYCwge1xcbiAgICAgICAgICAgIGNhdXNlLFxcbiAgICAgICAgICAgIG5hbWU6IFwiSW50cmluc2ljR2FzVG9vSGlnaEVycm9yXCJcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW50cmluc2ljR2FzVG9vSGlnaEVycm9yLCBcIm5vZGVNZXNzYWdlXCIsIHtcXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgIHZhbHVlOiAvaW50cmluc2ljIGdhcyB0b28gaGlnaHxnYXMgbGltaXQgcmVhY2hlZC9cXG4gICAgICB9KTtcXG4gICAgICBJbnRyaW5zaWNHYXNUb29Mb3dFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgICAgICBjb25zdHJ1Y3Rvcih7IGNhdXNlLCBnYXMgfSA9IHt9KSB7XFxuICAgICAgICAgIHN1cGVyKGBUaGUgYW1vdW50IG9mIGdhcyAke2dhcyA/IGAoJHtnYXN9KSBgIDogXCJcIn1wcm92aWRlZCBmb3IgdGhlIHRyYW5zYWN0aW9uIGlzIHRvbyBsb3cuYCwge1xcbiAgICAgICAgICAgIGNhdXNlLFxcbiAgICAgICAgICAgIG5hbWU6IFwiSW50cmluc2ljR2FzVG9vTG93RXJyb3JcIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnRyaW5zaWNHYXNUb29Mb3dFcnJvciwgXCJub2RlTWVzc2FnZVwiLCB7XFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICB2YWx1ZTogL2ludHJpbnNpYyBnYXMgdG9vIGxvdy9cXG4gICAgICB9KTtcXG4gICAgICBUcmFuc2FjdGlvblR5cGVOb3RTdXBwb3J0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgICAgICBjb25zdHJ1Y3Rvcih7IGNhdXNlIH0pIHtcXG4gICAgICAgICAgc3VwZXIoXCJUaGUgdHJhbnNhY3Rpb24gdHlwZSBpcyBub3Qgc3VwcG9ydGVkIGZvciB0aGlzIGNoYWluLlwiLCB7XFxuICAgICAgICAgICAgY2F1c2UsXFxuICAgICAgICAgICAgbmFtZTogXCJUcmFuc2FjdGlvblR5cGVOb3RTdXBwb3J0ZWRFcnJvclwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zYWN0aW9uVHlwZU5vdFN1cHBvcnRlZEVycm9yLCBcIm5vZGVNZXNzYWdlXCIsIHtcXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgIHZhbHVlOiAvdHJhbnNhY3Rpb24gdHlwZSBub3QgdmFsaWQvXFxuICAgICAgfSk7XFxuICAgICAgVGlwQWJvdmVGZWVDYXBFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgICAgICBjb25zdHJ1Y3Rvcih7IGNhdXNlLCBtYXhQcmlvcml0eUZlZVBlckdhcywgbWF4RmVlUGVyR2FzIH0gPSB7fSkge1xcbiAgICAgICAgICBzdXBlcihbXFxuICAgICAgICAgICAgYFRoZSBwcm92aWRlZCB0aXAgKFxcXFxgbWF4UHJpb3JpdHlGZWVQZXJHYXNcXFxcYCR7bWF4UHJpb3JpdHlGZWVQZXJHYXMgPyBgID0gJHtmb3JtYXRHd2VpKG1heFByaW9yaXR5RmVlUGVyR2FzKX0gZ3dlaWAgOiBcIlwifSkgY2Fubm90IGJlIGhpZ2hlciB0aGFuIHRoZSBmZWUgY2FwIChcXFxcYG1heEZlZVBlckdhc1xcXFxgJHttYXhGZWVQZXJHYXMgPyBgID0gJHtmb3JtYXRHd2VpKG1heEZlZVBlckdhcyl9IGd3ZWlgIDogXCJcIn0pLmBcXG4gICAgICAgICAgXS5qb2luKFwiXFxcXG5cIiksIHtcXG4gICAgICAgICAgICBjYXVzZSxcXG4gICAgICAgICAgICBuYW1lOiBcIlRpcEFib3ZlRmVlQ2FwRXJyb3JcIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaXBBYm92ZUZlZUNhcEVycm9yLCBcIm5vZGVNZXNzYWdlXCIsIHtcXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgIHZhbHVlOiAvbWF4IHByaW9yaXR5IGZlZSBwZXIgZ2FzIGhpZ2hlciB0aGFuIG1heCBmZWUgcGVyIGdhc3x0aXAgaGlnaGVyIHRoYW4gZmVlIGNhcC9cXG4gICAgICB9KTtcXG4gICAgICBVbmtub3duTm9kZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IyIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKHsgY2F1c2UgfSkge1xcbiAgICAgICAgICBzdXBlcihgQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgZXhlY3V0aW5nOiAke2NhdXNlPy5zaG9ydE1lc3NhZ2V9YCwge1xcbiAgICAgICAgICAgIGNhdXNlLFxcbiAgICAgICAgICAgIG5hbWU6IFwiVW5rbm93bk5vZGVFcnJvclwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvZXJyb3JzL2dldE5vZGVFcnJvci5qc1xcbiAgZnVuY3Rpb24gZ2V0Tm9kZUVycm9yKGVyciwgYXJncykge1xcbiAgICBjb25zdCBtZXNzYWdlID0gKGVyci5kZXRhaWxzIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XFxuICAgIGNvbnN0IGV4ZWN1dGlvblJldmVydGVkRXJyb3IgPSBlcnIgaW5zdGFuY2VvZiBCYXNlRXJyb3IyID8gZXJyLndhbGsoKGUpID0+IGU/LmNvZGUgPT09IEV4ZWN1dGlvblJldmVydGVkRXJyb3IuY29kZSkgOiBlcnI7XFxuICAgIGlmIChleGVjdXRpb25SZXZlcnRlZEVycm9yIGluc3RhbmNlb2YgQmFzZUVycm9yMilcXG4gICAgICByZXR1cm4gbmV3IEV4ZWN1dGlvblJldmVydGVkRXJyb3Ioe1xcbiAgICAgICAgY2F1c2U6IGVycixcXG4gICAgICAgIG1lc3NhZ2U6IGV4ZWN1dGlvblJldmVydGVkRXJyb3IuZGV0YWlsc1xcbiAgICAgIH0pO1xcbiAgICBpZiAoRXhlY3V0aW9uUmV2ZXJ0ZWRFcnJvci5ub2RlTWVzc2FnZS50ZXN0KG1lc3NhZ2UpKVxcbiAgICAgIHJldHVybiBuZXcgRXhlY3V0aW9uUmV2ZXJ0ZWRFcnJvcih7XFxuICAgICAgICBjYXVzZTogZXJyLFxcbiAgICAgICAgbWVzc2FnZTogZXJyLmRldGFpbHNcXG4gICAgICB9KTtcXG4gICAgaWYgKEZlZUNhcFRvb0hpZ2hFcnJvci5ub2RlTWVzc2FnZS50ZXN0KG1lc3NhZ2UpKVxcbiAgICAgIHJldHVybiBuZXcgRmVlQ2FwVG9vSGlnaEVycm9yKHtcXG4gICAgICAgIGNhdXNlOiBlcnIsXFxuICAgICAgICBtYXhGZWVQZXJHYXM6IGFyZ3M/Lm1heEZlZVBlckdhc1xcbiAgICAgIH0pO1xcbiAgICBpZiAoRmVlQ2FwVG9vTG93RXJyb3Iubm9kZU1lc3NhZ2UudGVzdChtZXNzYWdlKSlcXG4gICAgICByZXR1cm4gbmV3IEZlZUNhcFRvb0xvd0Vycm9yKHtcXG4gICAgICAgIGNhdXNlOiBlcnIsXFxuICAgICAgICBtYXhGZWVQZXJHYXM6IGFyZ3M/Lm1heEZlZVBlckdhc1xcbiAgICAgIH0pO1xcbiAgICBpZiAoTm9uY2VUb29IaWdoRXJyb3Iubm9kZU1lc3NhZ2UudGVzdChtZXNzYWdlKSlcXG4gICAgICByZXR1cm4gbmV3IE5vbmNlVG9vSGlnaEVycm9yKHsgY2F1c2U6IGVyciwgbm9uY2U6IGFyZ3M/Lm5vbmNlIH0pO1xcbiAgICBpZiAoTm9uY2VUb29Mb3dFcnJvci5ub2RlTWVzc2FnZS50ZXN0KG1lc3NhZ2UpKVxcbiAgICAgIHJldHVybiBuZXcgTm9uY2VUb29Mb3dFcnJvcih7IGNhdXNlOiBlcnIsIG5vbmNlOiBhcmdzPy5ub25jZSB9KTtcXG4gICAgaWYgKE5vbmNlTWF4VmFsdWVFcnJvci5ub2RlTWVzc2FnZS50ZXN0KG1lc3NhZ2UpKVxcbiAgICAgIHJldHVybiBuZXcgTm9uY2VNYXhWYWx1ZUVycm9yKHsgY2F1c2U6IGVyciwgbm9uY2U6IGFyZ3M/Lm5vbmNlIH0pO1xcbiAgICBpZiAoSW5zdWZmaWNpZW50RnVuZHNFcnJvci5ub2RlTWVzc2FnZS50ZXN0KG1lc3NhZ2UpKVxcbiAgICAgIHJldHVybiBuZXcgSW5zdWZmaWNpZW50RnVuZHNFcnJvcih7IGNhdXNlOiBlcnIgfSk7XFxuICAgIGlmIChJbnRyaW5zaWNHYXNUb29IaWdoRXJyb3Iubm9kZU1lc3NhZ2UudGVzdChtZXNzYWdlKSlcXG4gICAgICByZXR1cm4gbmV3IEludHJpbnNpY0dhc1Rvb0hpZ2hFcnJvcih7IGNhdXNlOiBlcnIsIGdhczogYXJncz8uZ2FzIH0pO1xcbiAgICBpZiAoSW50cmluc2ljR2FzVG9vTG93RXJyb3Iubm9kZU1lc3NhZ2UudGVzdChtZXNzYWdlKSlcXG4gICAgICByZXR1cm4gbmV3IEludHJpbnNpY0dhc1Rvb0xvd0Vycm9yKHsgY2F1c2U6IGVyciwgZ2FzOiBhcmdzPy5nYXMgfSk7XFxuICAgIGlmIChUcmFuc2FjdGlvblR5cGVOb3RTdXBwb3J0ZWRFcnJvci5ub2RlTWVzc2FnZS50ZXN0KG1lc3NhZ2UpKVxcbiAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25UeXBlTm90U3VwcG9ydGVkRXJyb3IoeyBjYXVzZTogZXJyIH0pO1xcbiAgICBpZiAoVGlwQWJvdmVGZWVDYXBFcnJvci5ub2RlTWVzc2FnZS50ZXN0KG1lc3NhZ2UpKVxcbiAgICAgIHJldHVybiBuZXcgVGlwQWJvdmVGZWVDYXBFcnJvcih7XFxuICAgICAgICBjYXVzZTogZXJyLFxcbiAgICAgICAgbWF4RmVlUGVyR2FzOiBhcmdzPy5tYXhGZWVQZXJHYXMsXFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogYXJncz8ubWF4UHJpb3JpdHlGZWVQZXJHYXNcXG4gICAgICB9KTtcXG4gICAgcmV0dXJuIG5ldyBVbmtub3duTm9kZUVycm9yKHtcXG4gICAgICBjYXVzZTogZXJyXFxuICAgIH0pO1xcbiAgfVxcbiAgdmFyIGluaXRfZ2V0Tm9kZUVycm9yID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2Vycm9ycy9nZXROb2RlRXJyb3IuanNcIigpIHtcXG4gICAgICBpbml0X2Jhc2UoKTtcXG4gICAgICBpbml0X25vZGUoKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9mb3JtYXR0ZXJzL2V4dHJhY3QuanNcXG4gIGZ1bmN0aW9uIGV4dHJhY3QodmFsdWVfLCB7IGZvcm1hdCB9KSB7XFxuICAgIGlmICghZm9ybWF0KVxcbiAgICAgIHJldHVybiB7fTtcXG4gICAgY29uc3QgdmFsdWUgPSB7fTtcXG4gICAgZnVuY3Rpb24gZXh0cmFjdF8oZm9ybWF0dGVkMikge1xcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmb3JtYXR0ZWQyKTtcXG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XFxuICAgICAgICBpZiAoa2V5IGluIHZhbHVlXylcXG4gICAgICAgICAgdmFsdWVba2V5XSA9IHZhbHVlX1trZXldO1xcbiAgICAgICAgaWYgKGZvcm1hdHRlZDJba2V5XSAmJiB0eXBlb2YgZm9ybWF0dGVkMltrZXldID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGZvcm1hdHRlZDJba2V5XSkpXFxuICAgICAgICAgIGV4dHJhY3RfKGZvcm1hdHRlZDJba2V5XSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGNvbnN0IGZvcm1hdHRlZCA9IGZvcm1hdCh2YWx1ZV8gfHwge30pO1xcbiAgICBleHRyYWN0Xyhmb3JtYXR0ZWQpO1xcbiAgICByZXR1cm4gdmFsdWU7XFxuICB9XFxuICB2YXIgaW5pdF9leHRyYWN0ID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2Zvcm1hdHRlcnMvZXh0cmFjdC5qc1wiKCkge1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2Zvcm1hdHRlcnMvZm9ybWF0dGVyLmpzXFxuICBmdW5jdGlvbiBkZWZpbmVGb3JtYXR0ZXIodHlwZSwgZm9ybWF0KSB7XFxuICAgIHJldHVybiAoeyBleGNsdWRlLCBmb3JtYXQ6IG92ZXJyaWRlcyB9KSA9PiB7XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIGV4Y2x1ZGUsXFxuICAgICAgICBmb3JtYXQ6IChhcmdzKSA9PiB7XFxuICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZCA9IGZvcm1hdChhcmdzKTtcXG4gICAgICAgICAgaWYgKGV4Y2x1ZGUpIHtcXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBleGNsdWRlKSB7XFxuICAgICAgICAgICAgICBkZWxldGUgZm9ybWF0dGVkW2tleV07XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgLi4uZm9ybWF0dGVkLFxcbiAgICAgICAgICAgIC4uLm92ZXJyaWRlcyhhcmdzKVxcbiAgICAgICAgICB9O1xcbiAgICAgICAgfSxcXG4gICAgICAgIHR5cGVcXG4gICAgICB9O1xcbiAgICB9O1xcbiAgfVxcbiAgdmFyIGluaXRfZm9ybWF0dGVyID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2Zvcm1hdHRlcnMvZm9ybWF0dGVyLmpzXCIoKSB7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvZm9ybWF0dGVycy90cmFuc2FjdGlvblJlcXVlc3QuanNcXG4gIGZ1bmN0aW9uIGZvcm1hdFRyYW5zYWN0aW9uUmVxdWVzdChyZXF1ZXN0KSB7XFxuICAgIGNvbnN0IHJwY1JlcXVlc3QgPSB7fTtcXG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0LmF1dGhvcml6YXRpb25MaXN0ICE9PSBcInVuZGVmaW5lZFwiKVxcbiAgICAgIHJwY1JlcXVlc3QuYXV0aG9yaXphdGlvbkxpc3QgPSBmb3JtYXRBdXRob3JpemF0aW9uTGlzdChyZXF1ZXN0LmF1dGhvcml6YXRpb25MaXN0KTtcXG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0LmFjY2Vzc0xpc3QgIT09IFwidW5kZWZpbmVkXCIpXFxuICAgICAgcnBjUmVxdWVzdC5hY2Nlc3NMaXN0ID0gcmVxdWVzdC5hY2Nlc3NMaXN0O1xcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QuYmxvYlZlcnNpb25lZEhhc2hlcyAhPT0gXCJ1bmRlZmluZWRcIilcXG4gICAgICBycGNSZXF1ZXN0LmJsb2JWZXJzaW9uZWRIYXNoZXMgPSByZXF1ZXN0LmJsb2JWZXJzaW9uZWRIYXNoZXM7XFxuICAgIGlmICh0eXBlb2YgcmVxdWVzdC5ibG9icyAhPT0gXCJ1bmRlZmluZWRcIikge1xcbiAgICAgIGlmICh0eXBlb2YgcmVxdWVzdC5ibG9ic1swXSAhPT0gXCJzdHJpbmdcIilcXG4gICAgICAgIHJwY1JlcXVlc3QuYmxvYnMgPSByZXF1ZXN0LmJsb2JzLm1hcCgoeCkgPT4gYnl0ZXNUb0hleCh4KSk7XFxuICAgICAgZWxzZVxcbiAgICAgICAgcnBjUmVxdWVzdC5ibG9icyA9IHJlcXVlc3QuYmxvYnM7XFxuICAgIH1cXG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0LmRhdGEgIT09IFwidW5kZWZpbmVkXCIpXFxuICAgICAgcnBjUmVxdWVzdC5kYXRhID0gcmVxdWVzdC5kYXRhO1xcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QuZnJvbSAhPT0gXCJ1bmRlZmluZWRcIilcXG4gICAgICBycGNSZXF1ZXN0LmZyb20gPSByZXF1ZXN0LmZyb207XFxuICAgIGlmICh0eXBlb2YgcmVxdWVzdC5nYXMgIT09IFwidW5kZWZpbmVkXCIpXFxuICAgICAgcnBjUmVxdWVzdC5nYXMgPSBudW1iZXJUb0hleChyZXF1ZXN0Lmdhcyk7XFxuICAgIGlmICh0eXBlb2YgcmVxdWVzdC5nYXNQcmljZSAhPT0gXCJ1bmRlZmluZWRcIilcXG4gICAgICBycGNSZXF1ZXN0Lmdhc1ByaWNlID0gbnVtYmVyVG9IZXgocmVxdWVzdC5nYXNQcmljZSk7XFxuICAgIGlmICh0eXBlb2YgcmVxdWVzdC5tYXhGZWVQZXJCbG9iR2FzICE9PSBcInVuZGVmaW5lZFwiKVxcbiAgICAgIHJwY1JlcXVlc3QubWF4RmVlUGVyQmxvYkdhcyA9IG51bWJlclRvSGV4KHJlcXVlc3QubWF4RmVlUGVyQmxvYkdhcyk7XFxuICAgIGlmICh0eXBlb2YgcmVxdWVzdC5tYXhGZWVQZXJHYXMgIT09IFwidW5kZWZpbmVkXCIpXFxuICAgICAgcnBjUmVxdWVzdC5tYXhGZWVQZXJHYXMgPSBudW1iZXJUb0hleChyZXF1ZXN0Lm1heEZlZVBlckdhcyk7XFxuICAgIGlmICh0eXBlb2YgcmVxdWVzdC5tYXhQcmlvcml0eUZlZVBlckdhcyAhPT0gXCJ1bmRlZmluZWRcIilcXG4gICAgICBycGNSZXF1ZXN0Lm1heFByaW9yaXR5RmVlUGVyR2FzID0gbnVtYmVyVG9IZXgocmVxdWVzdC5tYXhQcmlvcml0eUZlZVBlckdhcyk7XFxuICAgIGlmICh0eXBlb2YgcmVxdWVzdC5ub25jZSAhPT0gXCJ1bmRlZmluZWRcIilcXG4gICAgICBycGNSZXF1ZXN0Lm5vbmNlID0gbnVtYmVyVG9IZXgocmVxdWVzdC5ub25jZSk7XFxuICAgIGlmICh0eXBlb2YgcmVxdWVzdC50byAhPT0gXCJ1bmRlZmluZWRcIilcXG4gICAgICBycGNSZXF1ZXN0LnRvID0gcmVxdWVzdC50bztcXG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0LnR5cGUgIT09IFwidW5kZWZpbmVkXCIpXFxuICAgICAgcnBjUmVxdWVzdC50eXBlID0gcnBjVHJhbnNhY3Rpb25UeXBlW3JlcXVlc3QudHlwZV07XFxuICAgIGlmICh0eXBlb2YgcmVxdWVzdC52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIilcXG4gICAgICBycGNSZXF1ZXN0LnZhbHVlID0gbnVtYmVyVG9IZXgocmVxdWVzdC52YWx1ZSk7XFxuICAgIHJldHVybiBycGNSZXF1ZXN0O1xcbiAgfVxcbiAgZnVuY3Rpb24gZm9ybWF0QXV0aG9yaXphdGlvbkxpc3QoYXV0aG9yaXphdGlvbkxpc3QpIHtcXG4gICAgcmV0dXJuIGF1dGhvcml6YXRpb25MaXN0Lm1hcCgoYXV0aG9yaXphdGlvbikgPT4gKHtcXG4gICAgICBhZGRyZXNzOiBhdXRob3JpemF0aW9uLmFkZHJlc3MsXFxuICAgICAgcjogYXV0aG9yaXphdGlvbi5yID8gbnVtYmVyVG9IZXgoQmlnSW50KGF1dGhvcml6YXRpb24ucikpIDogYXV0aG9yaXphdGlvbi5yLFxcbiAgICAgIHM6IGF1dGhvcml6YXRpb24ucyA/IG51bWJlclRvSGV4KEJpZ0ludChhdXRob3JpemF0aW9uLnMpKSA6IGF1dGhvcml6YXRpb24ucyxcXG4gICAgICBjaGFpbklkOiBudW1iZXJUb0hleChhdXRob3JpemF0aW9uLmNoYWluSWQpLFxcbiAgICAgIG5vbmNlOiBudW1iZXJUb0hleChhdXRob3JpemF0aW9uLm5vbmNlKSxcXG4gICAgICAuLi50eXBlb2YgYXV0aG9yaXphdGlvbi55UGFyaXR5ICE9PSBcInVuZGVmaW5lZFwiID8geyB5UGFyaXR5OiBudW1iZXJUb0hleChhdXRob3JpemF0aW9uLnlQYXJpdHkpIH0gOiB7fSxcXG4gICAgICAuLi50eXBlb2YgYXV0aG9yaXphdGlvbi52ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBhdXRob3JpemF0aW9uLnlQYXJpdHkgPT09IFwidW5kZWZpbmVkXCIgPyB7IHY6IG51bWJlclRvSGV4KGF1dGhvcml6YXRpb24udikgfSA6IHt9XFxuICAgIH0pKTtcXG4gIH1cXG4gIHZhciBycGNUcmFuc2FjdGlvblR5cGU7XFxuICB2YXIgaW5pdF90cmFuc2FjdGlvblJlcXVlc3QgPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvZm9ybWF0dGVycy90cmFuc2FjdGlvblJlcXVlc3QuanNcIigpIHtcXG4gICAgICBpbml0X3RvSGV4KCk7XFxuICAgICAgcnBjVHJhbnNhY3Rpb25UeXBlID0ge1xcbiAgICAgICAgbGVnYWN5OiBcIjB4MFwiLFxcbiAgICAgICAgZWlwMjkzMDogXCIweDFcIixcXG4gICAgICAgIGVpcDE1NTk6IFwiMHgyXCIsXFxuICAgICAgICBlaXA0ODQ0OiBcIjB4M1wiLFxcbiAgICAgICAgZWlwNzcwMjogXCIweDRcIlxcbiAgICAgIH07XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvc3RhdGVPdmVycmlkZS5qc1xcbiAgZnVuY3Rpb24gc2VyaWFsaXplU3RhdGVNYXBwaW5nKHN0YXRlTWFwcGluZykge1xcbiAgICBpZiAoIXN0YXRlTWFwcGluZyB8fCBzdGF0ZU1hcHBpbmcubGVuZ3RoID09PSAwKVxcbiAgICAgIHJldHVybiB2b2lkIDA7XFxuICAgIHJldHVybiBzdGF0ZU1hcHBpbmcucmVkdWNlKChhY2MsIHsgc2xvdCwgdmFsdWUgfSkgPT4ge1xcbiAgICAgIGlmIChzbG90Lmxlbmd0aCAhPT0gNjYpXFxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEJ5dGVzTGVuZ3RoRXJyb3Ioe1xcbiAgICAgICAgICBzaXplOiBzbG90Lmxlbmd0aCxcXG4gICAgICAgICAgdGFyZ2V0U2l6ZTogNjYsXFxuICAgICAgICAgIHR5cGU6IFwiaGV4XCJcXG4gICAgICAgIH0pO1xcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IDY2KVxcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRCeXRlc0xlbmd0aEVycm9yKHtcXG4gICAgICAgICAgc2l6ZTogdmFsdWUubGVuZ3RoLFxcbiAgICAgICAgICB0YXJnZXRTaXplOiA2NixcXG4gICAgICAgICAgdHlwZTogXCJoZXhcIlxcbiAgICAgICAgfSk7XFxuICAgICAgYWNjW3Nsb3RdID0gdmFsdWU7XFxuICAgICAgcmV0dXJuIGFjYztcXG4gICAgfSwge30pO1xcbiAgfVxcbiAgZnVuY3Rpb24gc2VyaWFsaXplQWNjb3VudFN0YXRlT3ZlcnJpZGUocGFyYW1ldGVycykge1xcbiAgICBjb25zdCB7IGJhbGFuY2UsIG5vbmNlLCBzdGF0ZSwgc3RhdGVEaWZmLCBjb2RlIH0gPSBwYXJhbWV0ZXJzO1xcbiAgICBjb25zdCBycGNBY2NvdW50U3RhdGVPdmVycmlkZSA9IHt9O1xcbiAgICBpZiAoY29kZSAhPT0gdm9pZCAwKVxcbiAgICAgIHJwY0FjY291bnRTdGF0ZU92ZXJyaWRlLmNvZGUgPSBjb2RlO1xcbiAgICBpZiAoYmFsYW5jZSAhPT0gdm9pZCAwKVxcbiAgICAgIHJwY0FjY291bnRTdGF0ZU92ZXJyaWRlLmJhbGFuY2UgPSBudW1iZXJUb0hleChiYWxhbmNlKTtcXG4gICAgaWYgKG5vbmNlICE9PSB2b2lkIDApXFxuICAgICAgcnBjQWNjb3VudFN0YXRlT3ZlcnJpZGUubm9uY2UgPSBudW1iZXJUb0hleChub25jZSk7XFxuICAgIGlmIChzdGF0ZSAhPT0gdm9pZCAwKVxcbiAgICAgIHJwY0FjY291bnRTdGF0ZU92ZXJyaWRlLnN0YXRlID0gc2VyaWFsaXplU3RhdGVNYXBwaW5nKHN0YXRlKTtcXG4gICAgaWYgKHN0YXRlRGlmZiAhPT0gdm9pZCAwKSB7XFxuICAgICAgaWYgKHJwY0FjY291bnRTdGF0ZU92ZXJyaWRlLnN0YXRlKVxcbiAgICAgICAgdGhyb3cgbmV3IFN0YXRlQXNzaWdubWVudENvbmZsaWN0RXJyb3IoKTtcXG4gICAgICBycGNBY2NvdW50U3RhdGVPdmVycmlkZS5zdGF0ZURpZmYgPSBzZXJpYWxpemVTdGF0ZU1hcHBpbmcoc3RhdGVEaWZmKTtcXG4gICAgfVxcbiAgICByZXR1cm4gcnBjQWNjb3VudFN0YXRlT3ZlcnJpZGU7XFxuICB9XFxuICBmdW5jdGlvbiBzZXJpYWxpemVTdGF0ZU92ZXJyaWRlKHBhcmFtZXRlcnMpIHtcXG4gICAgaWYgKCFwYXJhbWV0ZXJzKVxcbiAgICAgIHJldHVybiB2b2lkIDA7XFxuICAgIGNvbnN0IHJwY1N0YXRlT3ZlcnJpZGUgPSB7fTtcXG4gICAgZm9yIChjb25zdCB7IGFkZHJlc3MsIC4uLmFjY291bnRTdGF0ZSB9IG9mIHBhcmFtZXRlcnMpIHtcXG4gICAgICBpZiAoIWlzQWRkcmVzcyhhZGRyZXNzLCB7IHN0cmljdDogZmFsc2UgfSkpXFxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcih7IGFkZHJlc3MgfSk7XFxuICAgICAgaWYgKHJwY1N0YXRlT3ZlcnJpZGVbYWRkcmVzc10pXFxuICAgICAgICB0aHJvdyBuZXcgQWNjb3VudFN0YXRlQ29uZmxpY3RFcnJvcih7IGFkZHJlc3MgfSk7XFxuICAgICAgcnBjU3RhdGVPdmVycmlkZVthZGRyZXNzXSA9IHNlcmlhbGl6ZUFjY291bnRTdGF0ZU92ZXJyaWRlKGFjY291bnRTdGF0ZSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHJwY1N0YXRlT3ZlcnJpZGU7XFxuICB9XFxuICB2YXIgaW5pdF9zdGF0ZU92ZXJyaWRlMiA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9zdGF0ZU92ZXJyaWRlLmpzXCIoKSB7XFxuICAgICAgaW5pdF9hZGRyZXNzKCk7XFxuICAgICAgaW5pdF9kYXRhKCk7XFxuICAgICAgaW5pdF9zdGF0ZU92ZXJyaWRlKCk7XFxuICAgICAgaW5pdF9pc0FkZHJlc3MoKTtcXG4gICAgICBpbml0X3RvSGV4KCk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vY29uc3RhbnRzL251bWJlci5qc1xcbiAgdmFyIG1heEludDgsIG1heEludDE2LCBtYXhJbnQyNCwgbWF4SW50MzIsIG1heEludDQwLCBtYXhJbnQ0OCwgbWF4SW50NTYsIG1heEludDY0LCBtYXhJbnQ3MiwgbWF4SW50ODAsIG1heEludDg4LCBtYXhJbnQ5NiwgbWF4SW50MTA0LCBtYXhJbnQxMTIsIG1heEludDEyMCwgbWF4SW50MTI4LCBtYXhJbnQxMzYsIG1heEludDE0NCwgbWF4SW50MTUyLCBtYXhJbnQxNjAsIG1heEludDE2OCwgbWF4SW50MTc2LCBtYXhJbnQxODQsIG1heEludDE5MiwgbWF4SW50MjAwLCBtYXhJbnQyMDgsIG1heEludDIxNiwgbWF4SW50MjI0LCBtYXhJbnQyMzIsIG1heEludDI0MCwgbWF4SW50MjQ4LCBtYXhJbnQyNTYsIG1pbkludDgsIG1pbkludDE2LCBtaW5JbnQyNCwgbWluSW50MzIsIG1pbkludDQwLCBtaW5JbnQ0OCwgbWluSW50NTYsIG1pbkludDY0LCBtaW5JbnQ3MiwgbWluSW50ODAsIG1pbkludDg4LCBtaW5JbnQ5NiwgbWluSW50MTA0LCBtaW5JbnQxMTIsIG1pbkludDEyMCwgbWluSW50MTI4LCBtaW5JbnQxMzYsIG1pbkludDE0NCwgbWluSW50MTUyLCBtaW5JbnQxNjAsIG1pbkludDE2OCwgbWluSW50MTc2LCBtaW5JbnQxODQsIG1pbkludDE5MiwgbWluSW50MjAwLCBtaW5JbnQyMDgsIG1pbkludDIxNiwgbWluSW50MjI0LCBtaW5JbnQyMzIsIG1pbkludDI0MCwgbWluSW50MjQ4LCBtaW5JbnQyNTYsIG1heFVpbnQ4LCBtYXhVaW50MTYsIG1heFVpbnQyNCwgbWF4VWludDMyLCBtYXhVaW50NDAsIG1heFVpbnQ0OCwgbWF4VWludDU2LCBtYXhVaW50NjQsIG1heFVpbnQ3MiwgbWF4VWludDgwLCBtYXhVaW50ODgsIG1heFVpbnQ5NiwgbWF4VWludDEwNCwgbWF4VWludDExMiwgbWF4VWludDEyMCwgbWF4VWludDEyOCwgbWF4VWludDEzNiwgbWF4VWludDE0NCwgbWF4VWludDE1MiwgbWF4VWludDE2MCwgbWF4VWludDE2OCwgbWF4VWludDE3NiwgbWF4VWludDE4NCwgbWF4VWludDE5MiwgbWF4VWludDIwMCwgbWF4VWludDIwOCwgbWF4VWludDIxNiwgbWF4VWludDIyNCwgbWF4VWludDIzMiwgbWF4VWludDI0MCwgbWF4VWludDI0OCwgbWF4VWludDI1NjtcXG4gIHZhciBpbml0X251bWJlciA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9jb25zdGFudHMvbnVtYmVyLmpzXCIoKSB7XFxuICAgICAgbWF4SW50OCA9IDJuICoqICg4biAtIDFuKSAtIDFuO1xcbiAgICAgIG1heEludDE2ID0gMm4gKiogKDE2biAtIDFuKSAtIDFuO1xcbiAgICAgIG1heEludDI0ID0gMm4gKiogKDI0biAtIDFuKSAtIDFuO1xcbiAgICAgIG1heEludDMyID0gMm4gKiogKDMybiAtIDFuKSAtIDFuO1xcbiAgICAgIG1heEludDQwID0gMm4gKiogKDQwbiAtIDFuKSAtIDFuO1xcbiAgICAgIG1heEludDQ4ID0gMm4gKiogKDQ4biAtIDFuKSAtIDFuO1xcbiAgICAgIG1heEludDU2ID0gMm4gKiogKDU2biAtIDFuKSAtIDFuO1xcbiAgICAgIG1heEludDY0ID0gMm4gKiogKDY0biAtIDFuKSAtIDFuO1xcbiAgICAgIG1heEludDcyID0gMm4gKiogKDcybiAtIDFuKSAtIDFuO1xcbiAgICAgIG1heEludDgwID0gMm4gKiogKDgwbiAtIDFuKSAtIDFuO1xcbiAgICAgIG1heEludDg4ID0gMm4gKiogKDg4biAtIDFuKSAtIDFuO1xcbiAgICAgIG1heEludDk2ID0gMm4gKiogKDk2biAtIDFuKSAtIDFuO1xcbiAgICAgIG1heEludDEwNCA9IDJuICoqICgxMDRuIC0gMW4pIC0gMW47XFxuICAgICAgbWF4SW50MTEyID0gMm4gKiogKDExMm4gLSAxbikgLSAxbjtcXG4gICAgICBtYXhJbnQxMjAgPSAybiAqKiAoMTIwbiAtIDFuKSAtIDFuO1xcbiAgICAgIG1heEludDEyOCA9IDJuICoqICgxMjhuIC0gMW4pIC0gMW47XFxuICAgICAgbWF4SW50MTM2ID0gMm4gKiogKDEzNm4gLSAxbikgLSAxbjtcXG4gICAgICBtYXhJbnQxNDQgPSAybiAqKiAoMTQ0biAtIDFuKSAtIDFuO1xcbiAgICAgIG1heEludDE1MiA9IDJuICoqICgxNTJuIC0gMW4pIC0gMW47XFxuICAgICAgbWF4SW50MTYwID0gMm4gKiogKDE2MG4gLSAxbikgLSAxbjtcXG4gICAgICBtYXhJbnQxNjggPSAybiAqKiAoMTY4biAtIDFuKSAtIDFuO1xcbiAgICAgIG1heEludDE3NiA9IDJuICoqICgxNzZuIC0gMW4pIC0gMW47XFxuICAgICAgbWF4SW50MTg0ID0gMm4gKiogKDE4NG4gLSAxbikgLSAxbjtcXG4gICAgICBtYXhJbnQxOTIgPSAybiAqKiAoMTkybiAtIDFuKSAtIDFuO1xcbiAgICAgIG1heEludDIwMCA9IDJuICoqICgyMDBuIC0gMW4pIC0gMW47XFxuICAgICAgbWF4SW50MjA4ID0gMm4gKiogKDIwOG4gLSAxbikgLSAxbjtcXG4gICAgICBtYXhJbnQyMTYgPSAybiAqKiAoMjE2biAtIDFuKSAtIDFuO1xcbiAgICAgIG1heEludDIyNCA9IDJuICoqICgyMjRuIC0gMW4pIC0gMW47XFxuICAgICAgbWF4SW50MjMyID0gMm4gKiogKDIzMm4gLSAxbikgLSAxbjtcXG4gICAgICBtYXhJbnQyNDAgPSAybiAqKiAoMjQwbiAtIDFuKSAtIDFuO1xcbiAgICAgIG1heEludDI0OCA9IDJuICoqICgyNDhuIC0gMW4pIC0gMW47XFxuICAgICAgbWF4SW50MjU2ID0gMm4gKiogKDI1Nm4gLSAxbikgLSAxbjtcXG4gICAgICBtaW5JbnQ4ID0gLSgybiAqKiAoOG4gLSAxbikpO1xcbiAgICAgIG1pbkludDE2ID0gLSgybiAqKiAoMTZuIC0gMW4pKTtcXG4gICAgICBtaW5JbnQyNCA9IC0oMm4gKiogKDI0biAtIDFuKSk7XFxuICAgICAgbWluSW50MzIgPSAtKDJuICoqICgzMm4gLSAxbikpO1xcbiAgICAgIG1pbkludDQwID0gLSgybiAqKiAoNDBuIC0gMW4pKTtcXG4gICAgICBtaW5JbnQ0OCA9IC0oMm4gKiogKDQ4biAtIDFuKSk7XFxuICAgICAgbWluSW50NTYgPSAtKDJuICoqICg1Nm4gLSAxbikpO1xcbiAgICAgIG1pbkludDY0ID0gLSgybiAqKiAoNjRuIC0gMW4pKTtcXG4gICAgICBtaW5JbnQ3MiA9IC0oMm4gKiogKDcybiAtIDFuKSk7XFxuICAgICAgbWluSW50ODAgPSAtKDJuICoqICg4MG4gLSAxbikpO1xcbiAgICAgIG1pbkludDg4ID0gLSgybiAqKiAoODhuIC0gMW4pKTtcXG4gICAgICBtaW5JbnQ5NiA9IC0oMm4gKiogKDk2biAtIDFuKSk7XFxuICAgICAgbWluSW50MTA0ID0gLSgybiAqKiAoMTA0biAtIDFuKSk7XFxuICAgICAgbWluSW50MTEyID0gLSgybiAqKiAoMTEybiAtIDFuKSk7XFxuICAgICAgbWluSW50MTIwID0gLSgybiAqKiAoMTIwbiAtIDFuKSk7XFxuICAgICAgbWluSW50MTI4ID0gLSgybiAqKiAoMTI4biAtIDFuKSk7XFxuICAgICAgbWluSW50MTM2ID0gLSgybiAqKiAoMTM2biAtIDFuKSk7XFxuICAgICAgbWluSW50MTQ0ID0gLSgybiAqKiAoMTQ0biAtIDFuKSk7XFxuICAgICAgbWluSW50MTUyID0gLSgybiAqKiAoMTUybiAtIDFuKSk7XFxuICAgICAgbWluSW50MTYwID0gLSgybiAqKiAoMTYwbiAtIDFuKSk7XFxuICAgICAgbWluSW50MTY4ID0gLSgybiAqKiAoMTY4biAtIDFuKSk7XFxuICAgICAgbWluSW50MTc2ID0gLSgybiAqKiAoMTc2biAtIDFuKSk7XFxuICAgICAgbWluSW50MTg0ID0gLSgybiAqKiAoMTg0biAtIDFuKSk7XFxuICAgICAgbWluSW50MTkyID0gLSgybiAqKiAoMTkybiAtIDFuKSk7XFxuICAgICAgbWluSW50MjAwID0gLSgybiAqKiAoMjAwbiAtIDFuKSk7XFxuICAgICAgbWluSW50MjA4ID0gLSgybiAqKiAoMjA4biAtIDFuKSk7XFxuICAgICAgbWluSW50MjE2ID0gLSgybiAqKiAoMjE2biAtIDFuKSk7XFxuICAgICAgbWluSW50MjI0ID0gLSgybiAqKiAoMjI0biAtIDFuKSk7XFxuICAgICAgbWluSW50MjMyID0gLSgybiAqKiAoMjMybiAtIDFuKSk7XFxuICAgICAgbWluSW50MjQwID0gLSgybiAqKiAoMjQwbiAtIDFuKSk7XFxuICAgICAgbWluSW50MjQ4ID0gLSgybiAqKiAoMjQ4biAtIDFuKSk7XFxuICAgICAgbWluSW50MjU2ID0gLSgybiAqKiAoMjU2biAtIDFuKSk7XFxuICAgICAgbWF4VWludDggPSAybiAqKiA4biAtIDFuO1xcbiAgICAgIG1heFVpbnQxNiA9IDJuICoqIDE2biAtIDFuO1xcbiAgICAgIG1heFVpbnQyNCA9IDJuICoqIDI0biAtIDFuO1xcbiAgICAgIG1heFVpbnQzMiA9IDJuICoqIDMybiAtIDFuO1xcbiAgICAgIG1heFVpbnQ0MCA9IDJuICoqIDQwbiAtIDFuO1xcbiAgICAgIG1heFVpbnQ0OCA9IDJuICoqIDQ4biAtIDFuO1xcbiAgICAgIG1heFVpbnQ1NiA9IDJuICoqIDU2biAtIDFuO1xcbiAgICAgIG1heFVpbnQ2NCA9IDJuICoqIDY0biAtIDFuO1xcbiAgICAgIG1heFVpbnQ3MiA9IDJuICoqIDcybiAtIDFuO1xcbiAgICAgIG1heFVpbnQ4MCA9IDJuICoqIDgwbiAtIDFuO1xcbiAgICAgIG1heFVpbnQ4OCA9IDJuICoqIDg4biAtIDFuO1xcbiAgICAgIG1heFVpbnQ5NiA9IDJuICoqIDk2biAtIDFuO1xcbiAgICAgIG1heFVpbnQxMDQgPSAybiAqKiAxMDRuIC0gMW47XFxuICAgICAgbWF4VWludDExMiA9IDJuICoqIDExMm4gLSAxbjtcXG4gICAgICBtYXhVaW50MTIwID0gMm4gKiogMTIwbiAtIDFuO1xcbiAgICAgIG1heFVpbnQxMjggPSAybiAqKiAxMjhuIC0gMW47XFxuICAgICAgbWF4VWludDEzNiA9IDJuICoqIDEzNm4gLSAxbjtcXG4gICAgICBtYXhVaW50MTQ0ID0gMm4gKiogMTQ0biAtIDFuO1xcbiAgICAgIG1heFVpbnQxNTIgPSAybiAqKiAxNTJuIC0gMW47XFxuICAgICAgbWF4VWludDE2MCA9IDJuICoqIDE2MG4gLSAxbjtcXG4gICAgICBtYXhVaW50MTY4ID0gMm4gKiogMTY4biAtIDFuO1xcbiAgICAgIG1heFVpbnQxNzYgPSAybiAqKiAxNzZuIC0gMW47XFxuICAgICAgbWF4VWludDE4NCA9IDJuICoqIDE4NG4gLSAxbjtcXG4gICAgICBtYXhVaW50MTkyID0gMm4gKiogMTkybiAtIDFuO1xcbiAgICAgIG1heFVpbnQyMDAgPSAybiAqKiAyMDBuIC0gMW47XFxuICAgICAgbWF4VWludDIwOCA9IDJuICoqIDIwOG4gLSAxbjtcXG4gICAgICBtYXhVaW50MjE2ID0gMm4gKiogMjE2biAtIDFuO1xcbiAgICAgIG1heFVpbnQyMjQgPSAybiAqKiAyMjRuIC0gMW47XFxuICAgICAgbWF4VWludDIzMiA9IDJuICoqIDIzMm4gLSAxbjtcXG4gICAgICBtYXhVaW50MjQwID0gMm4gKiogMjQwbiAtIDFuO1xcbiAgICAgIG1heFVpbnQyNDggPSAybiAqKiAyNDhuIC0gMW47XFxuICAgICAgbWF4VWludDI1NiA9IDJuICoqIDI1Nm4gLSAxbjtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy90cmFuc2FjdGlvbi9hc3NlcnRSZXF1ZXN0LmpzXFxuICBmdW5jdGlvbiBhc3NlcnRSZXF1ZXN0KGFyZ3MpIHtcXG4gICAgY29uc3QgeyBhY2NvdW50OiBhY2NvdW50XywgZ2FzUHJpY2UsIG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIHRvIH0gPSBhcmdzO1xcbiAgICBjb25zdCBhY2NvdW50ID0gYWNjb3VudF8gPyBwYXJzZUFjY291bnQoYWNjb3VudF8pIDogdm9pZCAwO1xcbiAgICBpZiAoYWNjb3VudCAmJiAhaXNBZGRyZXNzKGFjY291bnQuYWRkcmVzcykpXFxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoeyBhZGRyZXNzOiBhY2NvdW50LmFkZHJlc3MgfSk7XFxuICAgIGlmICh0byAmJiAhaXNBZGRyZXNzKHRvKSlcXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcih7IGFkZHJlc3M6IHRvIH0pO1xcbiAgICBpZiAodHlwZW9mIGdhc1ByaWNlICE9PSBcInVuZGVmaW5lZFwiICYmICh0eXBlb2YgbWF4RmVlUGVyR2FzICE9PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBtYXhQcmlvcml0eUZlZVBlckdhcyAhPT0gXCJ1bmRlZmluZWRcIikpXFxuICAgICAgdGhyb3cgbmV3IEZlZUNvbmZsaWN0RXJyb3IoKTtcXG4gICAgaWYgKG1heEZlZVBlckdhcyAmJiBtYXhGZWVQZXJHYXMgPiBtYXhVaW50MjU2KVxcbiAgICAgIHRocm93IG5ldyBGZWVDYXBUb29IaWdoRXJyb3IoeyBtYXhGZWVQZXJHYXMgfSk7XFxuICAgIGlmIChtYXhQcmlvcml0eUZlZVBlckdhcyAmJiBtYXhGZWVQZXJHYXMgJiYgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPiBtYXhGZWVQZXJHYXMpXFxuICAgICAgdGhyb3cgbmV3IFRpcEFib3ZlRmVlQ2FwRXJyb3IoeyBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzIH0pO1xcbiAgfVxcbiAgdmFyIGluaXRfYXNzZXJ0UmVxdWVzdCA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy90cmFuc2FjdGlvbi9hc3NlcnRSZXF1ZXN0LmpzXCIoKSB7XFxuICAgICAgaW5pdF9wYXJzZUFjY291bnQoKTtcXG4gICAgICBpbml0X251bWJlcigpO1xcbiAgICAgIGluaXRfYWRkcmVzcygpO1xcbiAgICAgIGluaXRfbm9kZSgpO1xcbiAgICAgIGluaXRfdHJhbnNhY3Rpb24oKTtcXG4gICAgICBpbml0X2lzQWRkcmVzcygpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2FkZHJlc3MvaXNBZGRyZXNzRXF1YWwuanNcXG4gIGZ1bmN0aW9uIGlzQWRkcmVzc0VxdWFsKGEsIGIpIHtcXG4gICAgaWYgKCFpc0FkZHJlc3MoYSwgeyBzdHJpY3Q6IGZhbHNlIH0pKVxcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKHsgYWRkcmVzczogYSB9KTtcXG4gICAgaWYgKCFpc0FkZHJlc3MoYiwgeyBzdHJpY3Q6IGZhbHNlIH0pKVxcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKHsgYWRkcmVzczogYiB9KTtcXG4gICAgcmV0dXJuIGEudG9Mb3dlckNhc2UoKSA9PT0gYi50b0xvd2VyQ2FzZSgpO1xcbiAgfVxcbiAgdmFyIGluaXRfaXNBZGRyZXNzRXF1YWwgPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvYWRkcmVzcy9pc0FkZHJlc3NFcXVhbC5qc1wiKCkge1xcbiAgICAgIGluaXRfYWRkcmVzcygpO1xcbiAgICAgIGluaXRfaXNBZGRyZXNzKCk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvYWJpL2RlY29kZUZ1bmN0aW9uUmVzdWx0LmpzXFxuICBmdW5jdGlvbiBkZWNvZGVGdW5jdGlvblJlc3VsdChwYXJhbWV0ZXJzKSB7XFxuICAgIGNvbnN0IHsgYWJpOiBhYmkyLCBhcmdzLCBmdW5jdGlvbk5hbWUsIGRhdGEgfSA9IHBhcmFtZXRlcnM7XFxuICAgIGxldCBhYmlJdGVtID0gYWJpMlswXTtcXG4gICAgaWYgKGZ1bmN0aW9uTmFtZSkge1xcbiAgICAgIGNvbnN0IGl0ZW0gPSBnZXRBYmlJdGVtKHsgYWJpOiBhYmkyLCBhcmdzLCBuYW1lOiBmdW5jdGlvbk5hbWUgfSk7XFxuICAgICAgaWYgKCFpdGVtKVxcbiAgICAgICAgdGhyb3cgbmV3IEFiaUZ1bmN0aW9uTm90Rm91bmRFcnJvcihmdW5jdGlvbk5hbWUsIHsgZG9jc1BhdGg6IGRvY3NQYXRoNCB9KTtcXG4gICAgICBhYmlJdGVtID0gaXRlbTtcXG4gICAgfVxcbiAgICBpZiAoYWJpSXRlbS50eXBlICE9PSBcImZ1bmN0aW9uXCIpXFxuICAgICAgdGhyb3cgbmV3IEFiaUZ1bmN0aW9uTm90Rm91bmRFcnJvcih2b2lkIDAsIHsgZG9jc1BhdGg6IGRvY3NQYXRoNCB9KTtcXG4gICAgaWYgKCFhYmlJdGVtLm91dHB1dHMpXFxuICAgICAgdGhyb3cgbmV3IEFiaUZ1bmN0aW9uT3V0cHV0c05vdEZvdW5kRXJyb3IoYWJpSXRlbS5uYW1lLCB7IGRvY3NQYXRoOiBkb2NzUGF0aDQgfSk7XFxuICAgIGNvbnN0IHZhbHVlcyA9IGRlY29kZUFiaVBhcmFtZXRlcnMoYWJpSXRlbS5vdXRwdXRzLCBkYXRhKTtcXG4gICAgaWYgKHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoID4gMSlcXG4gICAgICByZXR1cm4gdmFsdWVzO1xcbiAgICBpZiAodmFsdWVzICYmIHZhbHVlcy5sZW5ndGggPT09IDEpXFxuICAgICAgcmV0dXJuIHZhbHVlc1swXTtcXG4gICAgcmV0dXJuIHZvaWQgMDtcXG4gIH1cXG4gIHZhciBkb2NzUGF0aDQ7XFxuICB2YXIgaW5pdF9kZWNvZGVGdW5jdGlvblJlc3VsdCA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9hYmkvZGVjb2RlRnVuY3Rpb25SZXN1bHQuanNcIigpIHtcXG4gICAgICBpbml0X2FiaSgpO1xcbiAgICAgIGluaXRfZGVjb2RlQWJpUGFyYW1ldGVycygpO1xcbiAgICAgIGluaXRfZ2V0QWJpSXRlbSgpO1xcbiAgICAgIGRvY3NQYXRoNCA9IFwiL2RvY3MvY29udHJhY3QvZGVjb2RlRnVuY3Rpb25SZXN1bHRcIjtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9jb25zdGFudHMvYWJpcy5qc1xcbiAgdmFyIG11bHRpY2FsbDNBYmksIGJhdGNoR2F0ZXdheUFiaSwgdW5pdmVyc2FsUmVzb2x2ZXJFcnJvcnMsIHVuaXZlcnNhbFJlc29sdmVyUmVzb2x2ZUFiaSwgdW5pdmVyc2FsUmVzb2x2ZXJSZXZlcnNlQWJpLCB0ZXh0UmVzb2x2ZXJBYmksIGFkZHJlc3NSZXNvbHZlckFiaSwgdW5pdmVyc2FsU2lnbmF0dXJlVmFsaWRhdG9yQWJpO1xcbiAgdmFyIGluaXRfYWJpcyA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9jb25zdGFudHMvYWJpcy5qc1wiKCkge1xcbiAgICAgIG11bHRpY2FsbDNBYmkgPSBbXFxuICAgICAgICB7XFxuICAgICAgICAgIGlucHV0czogW1xcbiAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgIGNvbXBvbmVudHM6IFtcXG4gICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwidGFyZ2V0XCIsXFxuICAgICAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcXG4gICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwiYWxsb3dGYWlsdXJlXCIsXFxuICAgICAgICAgICAgICAgICAgdHlwZTogXCJib29sXCJcXG4gICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwiY2FsbERhdGFcIixcXG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImJ5dGVzXCJcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgXSxcXG4gICAgICAgICAgICAgIG5hbWU6IFwiY2FsbHNcIixcXG4gICAgICAgICAgICAgIHR5cGU6IFwidHVwbGVbXVwiXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICBdLFxcbiAgICAgICAgICBuYW1lOiBcImFnZ3JlZ2F0ZTNcIixcXG4gICAgICAgICAgb3V0cHV0czogW1xcbiAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgIGNvbXBvbmVudHM6IFtcXG4gICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwic3VjY2Vzc1wiLFxcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYm9vbFwiXFxuICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICBuYW1lOiBcInJldHVybkRhdGFcIixcXG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImJ5dGVzXCJcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgXSxcXG4gICAgICAgICAgICAgIG5hbWU6IFwicmV0dXJuRGF0YVwiLFxcbiAgICAgICAgICAgICAgdHlwZTogXCJ0dXBsZVtdXCJcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIF0sXFxuICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXFxuICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxcbiAgICAgICAgfVxcbiAgICAgIF07XFxuICAgICAgYmF0Y2hHYXRld2F5QWJpID0gW1xcbiAgICAgICAge1xcbiAgICAgICAgICBuYW1lOiBcInF1ZXJ5XCIsXFxuICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcXG4gICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcXG4gICAgICAgICAgaW5wdXRzOiBbXFxuICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgdHlwZTogXCJ0dXBsZVtdXCIsXFxuICAgICAgICAgICAgICBuYW1lOiBcInF1ZXJpZXNcIixcXG4gICAgICAgICAgICAgIGNvbXBvbmVudHM6IFtcXG4gICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiLFxcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwic2VuZGVyXCJcXG4gICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nW11cIixcXG4gICAgICAgICAgICAgICAgICBuYW1lOiBcInVybHNcIlxcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgdHlwZTogXCJieXRlc1wiLFxcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwiZGF0YVwiXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIF1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIF0sXFxuICAgICAgICAgIG91dHB1dHM6IFtcXG4gICAgICAgICAgICB7XFxuICAgICAgICAgICAgICB0eXBlOiBcImJvb2xbXVwiLFxcbiAgICAgICAgICAgICAgbmFtZTogXCJmYWlsdXJlc1wiXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICB7XFxuICAgICAgICAgICAgICB0eXBlOiBcImJ5dGVzW11cIixcXG4gICAgICAgICAgICAgIG5hbWU6IFwicmVzcG9uc2VzXCJcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIF1cXG4gICAgICAgIH0sXFxuICAgICAgICB7XFxuICAgICAgICAgIG5hbWU6IFwiSHR0cEVycm9yXCIsXFxuICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcXG4gICAgICAgICAgaW5wdXRzOiBbXFxuICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgdHlwZTogXCJ1aW50MTZcIixcXG4gICAgICAgICAgICAgIG5hbWU6IFwic3RhdHVzXCJcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXFxuICAgICAgICAgICAgICBuYW1lOiBcIm1lc3NhZ2VcIlxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgXVxcbiAgICAgICAgfVxcbiAgICAgIF07XFxuICAgICAgdW5pdmVyc2FsUmVzb2x2ZXJFcnJvcnMgPSBbXFxuICAgICAgICB7XFxuICAgICAgICAgIGlucHV0czogW10sXFxuICAgICAgICAgIG5hbWU6IFwiUmVzb2x2ZXJOb3RGb3VuZFwiLFxcbiAgICAgICAgICB0eXBlOiBcImVycm9yXCJcXG4gICAgICAgIH0sXFxuICAgICAgICB7XFxuICAgICAgICAgIGlucHV0czogW10sXFxuICAgICAgICAgIG5hbWU6IFwiUmVzb2x2ZXJXaWxkY2FyZE5vdFN1cHBvcnRlZFwiLFxcbiAgICAgICAgICB0eXBlOiBcImVycm9yXCJcXG4gICAgICAgIH0sXFxuICAgICAgICB7XFxuICAgICAgICAgIGlucHV0czogW10sXFxuICAgICAgICAgIG5hbWU6IFwiUmVzb2x2ZXJOb3RDb250cmFjdFwiLFxcbiAgICAgICAgICB0eXBlOiBcImVycm9yXCJcXG4gICAgICAgIH0sXFxuICAgICAgICB7XFxuICAgICAgICAgIGlucHV0czogW1xcbiAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgIG5hbWU6IFwicmV0dXJuRGF0YVwiLFxcbiAgICAgICAgICAgICAgdHlwZTogXCJieXRlc1wiXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICBdLFxcbiAgICAgICAgICBuYW1lOiBcIlJlc29sdmVyRXJyb3JcIixcXG4gICAgICAgICAgdHlwZTogXCJlcnJvclwiXFxuICAgICAgICB9LFxcbiAgICAgICAge1xcbiAgICAgICAgICBpbnB1dHM6IFtcXG4gICAgICAgICAgICB7XFxuICAgICAgICAgICAgICBjb21wb25lbnRzOiBbXFxuICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICBuYW1lOiBcInN0YXR1c1wiLFxcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDE2XCJcXG4gICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwibWVzc2FnZVwiLFxcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCJcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgXSxcXG4gICAgICAgICAgICAgIG5hbWU6IFwiZXJyb3JzXCIsXFxuICAgICAgICAgICAgICB0eXBlOiBcInR1cGxlW11cIlxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgXSxcXG4gICAgICAgICAgbmFtZTogXCJIdHRwRXJyb3JcIixcXG4gICAgICAgICAgdHlwZTogXCJlcnJvclwiXFxuICAgICAgICB9XFxuICAgICAgXTtcXG4gICAgICB1bml2ZXJzYWxSZXNvbHZlclJlc29sdmVBYmkgPSBbXFxuICAgICAgICAuLi51bml2ZXJzYWxSZXNvbHZlckVycm9ycyxcXG4gICAgICAgIHtcXG4gICAgICAgICAgbmFtZTogXCJyZXNvbHZlXCIsXFxuICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcXG4gICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcXG4gICAgICAgICAgaW5wdXRzOiBbXFxuICAgICAgICAgICAgeyBuYW1lOiBcIm5hbWVcIiwgdHlwZTogXCJieXRlc1wiIH0sXFxuICAgICAgICAgICAgeyBuYW1lOiBcImRhdGFcIiwgdHlwZTogXCJieXRlc1wiIH1cXG4gICAgICAgICAgXSxcXG4gICAgICAgICAgb3V0cHV0czogW1xcbiAgICAgICAgICAgIHsgbmFtZTogXCJcIiwgdHlwZTogXCJieXRlc1wiIH0sXFxuICAgICAgICAgICAgeyBuYW1lOiBcImFkZHJlc3NcIiwgdHlwZTogXCJhZGRyZXNzXCIgfVxcbiAgICAgICAgICBdXFxuICAgICAgICB9LFxcbiAgICAgICAge1xcbiAgICAgICAgICBuYW1lOiBcInJlc29sdmVcIixcXG4gICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxcbiAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxcbiAgICAgICAgICBpbnB1dHM6IFtcXG4gICAgICAgICAgICB7IG5hbWU6IFwibmFtZVwiLCB0eXBlOiBcImJ5dGVzXCIgfSxcXG4gICAgICAgICAgICB7IG5hbWU6IFwiZGF0YVwiLCB0eXBlOiBcImJ5dGVzXCIgfSxcXG4gICAgICAgICAgICB7IG5hbWU6IFwiZ2F0ZXdheXNcIiwgdHlwZTogXCJzdHJpbmdbXVwiIH1cXG4gICAgICAgICAgXSxcXG4gICAgICAgICAgb3V0cHV0czogW1xcbiAgICAgICAgICAgIHsgbmFtZTogXCJcIiwgdHlwZTogXCJieXRlc1wiIH0sXFxuICAgICAgICAgICAgeyBuYW1lOiBcImFkZHJlc3NcIiwgdHlwZTogXCJhZGRyZXNzXCIgfVxcbiAgICAgICAgICBdXFxuICAgICAgICB9XFxuICAgICAgXTtcXG4gICAgICB1bml2ZXJzYWxSZXNvbHZlclJldmVyc2VBYmkgPSBbXFxuICAgICAgICAuLi51bml2ZXJzYWxSZXNvbHZlckVycm9ycyxcXG4gICAgICAgIHtcXG4gICAgICAgICAgbmFtZTogXCJyZXZlcnNlXCIsXFxuICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcXG4gICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcXG4gICAgICAgICAgaW5wdXRzOiBbeyB0eXBlOiBcImJ5dGVzXCIsIG5hbWU6IFwicmV2ZXJzZU5hbWVcIiB9XSxcXG4gICAgICAgICAgb3V0cHV0czogW1xcbiAgICAgICAgICAgIHsgdHlwZTogXCJzdHJpbmdcIiwgbmFtZTogXCJyZXNvbHZlZE5hbWVcIiB9LFxcbiAgICAgICAgICAgIHsgdHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwicmVzb2x2ZWRBZGRyZXNzXCIgfSxcXG4gICAgICAgICAgICB7IHR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcInJldmVyc2VSZXNvbHZlclwiIH0sXFxuICAgICAgICAgICAgeyB0eXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJyZXNvbHZlclwiIH1cXG4gICAgICAgICAgXVxcbiAgICAgICAgfSxcXG4gICAgICAgIHtcXG4gICAgICAgICAgbmFtZTogXCJyZXZlcnNlXCIsXFxuICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcXG4gICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcXG4gICAgICAgICAgaW5wdXRzOiBbXFxuICAgICAgICAgICAgeyB0eXBlOiBcImJ5dGVzXCIsIG5hbWU6IFwicmV2ZXJzZU5hbWVcIiB9LFxcbiAgICAgICAgICAgIHsgdHlwZTogXCJzdHJpbmdbXVwiLCBuYW1lOiBcImdhdGV3YXlzXCIgfVxcbiAgICAgICAgICBdLFxcbiAgICAgICAgICBvdXRwdXRzOiBbXFxuICAgICAgICAgICAgeyB0eXBlOiBcInN0cmluZ1wiLCBuYW1lOiBcInJlc29sdmVkTmFtZVwiIH0sXFxuICAgICAgICAgICAgeyB0eXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJyZXNvbHZlZEFkZHJlc3NcIiB9LFxcbiAgICAgICAgICAgIHsgdHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwicmV2ZXJzZVJlc29sdmVyXCIgfSxcXG4gICAgICAgICAgICB7IHR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcInJlc29sdmVyXCIgfVxcbiAgICAgICAgICBdXFxuICAgICAgICB9XFxuICAgICAgXTtcXG4gICAgICB0ZXh0UmVzb2x2ZXJBYmkgPSBbXFxuICAgICAgICB7XFxuICAgICAgICAgIG5hbWU6IFwidGV4dFwiLFxcbiAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXFxuICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXFxuICAgICAgICAgIGlucHV0czogW1xcbiAgICAgICAgICAgIHsgbmFtZTogXCJuYW1lXCIsIHR5cGU6IFwiYnl0ZXMzMlwiIH0sXFxuICAgICAgICAgICAgeyBuYW1lOiBcImtleVwiLCB0eXBlOiBcInN0cmluZ1wiIH1cXG4gICAgICAgICAgXSxcXG4gICAgICAgICAgb3V0cHV0czogW3sgbmFtZTogXCJcIiwgdHlwZTogXCJzdHJpbmdcIiB9XVxcbiAgICAgICAgfVxcbiAgICAgIF07XFxuICAgICAgYWRkcmVzc1Jlc29sdmVyQWJpID0gW1xcbiAgICAgICAge1xcbiAgICAgICAgICBuYW1lOiBcImFkZHJcIixcXG4gICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxcbiAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxcbiAgICAgICAgICBpbnB1dHM6IFt7IG5hbWU6IFwibmFtZVwiLCB0eXBlOiBcImJ5dGVzMzJcIiB9XSxcXG4gICAgICAgICAgb3V0cHV0czogW3sgbmFtZTogXCJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfV1cXG4gICAgICAgIH0sXFxuICAgICAgICB7XFxuICAgICAgICAgIG5hbWU6IFwiYWRkclwiLFxcbiAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXFxuICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXFxuICAgICAgICAgIGlucHV0czogW1xcbiAgICAgICAgICAgIHsgbmFtZTogXCJuYW1lXCIsIHR5cGU6IFwiYnl0ZXMzMlwiIH0sXFxuICAgICAgICAgICAgeyBuYW1lOiBcImNvaW5UeXBlXCIsIHR5cGU6IFwidWludDI1NlwiIH1cXG4gICAgICAgICAgXSxcXG4gICAgICAgICAgb3V0cHV0czogW3sgbmFtZTogXCJcIiwgdHlwZTogXCJieXRlc1wiIH1dXFxuICAgICAgICB9XFxuICAgICAgXTtcXG4gICAgICB1bml2ZXJzYWxTaWduYXR1cmVWYWxpZGF0b3JBYmkgPSBbXFxuICAgICAgICB7XFxuICAgICAgICAgIGlucHV0czogW1xcbiAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgIG5hbWU6IFwiX3NpZ25lclwiLFxcbiAgICAgICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgIG5hbWU6IFwiX2hhc2hcIixcXG4gICAgICAgICAgICAgIHR5cGU6IFwiYnl0ZXMzMlwiXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICB7XFxuICAgICAgICAgICAgICBuYW1lOiBcIl9zaWduYXR1cmVcIixcXG4gICAgICAgICAgICAgIHR5cGU6IFwiYnl0ZXNcIlxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgXSxcXG4gICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcXG4gICAgICAgICAgdHlwZTogXCJjb25zdHJ1Y3RvclwiXFxuICAgICAgICB9LFxcbiAgICAgICAge1xcbiAgICAgICAgICBpbnB1dHM6IFtcXG4gICAgICAgICAgICB7XFxuICAgICAgICAgICAgICBuYW1lOiBcIl9zaWduZXJcIixcXG4gICAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICB7XFxuICAgICAgICAgICAgICBuYW1lOiBcIl9oYXNoXCIsXFxuICAgICAgICAgICAgICB0eXBlOiBcImJ5dGVzMzJcIlxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgbmFtZTogXCJfc2lnbmF0dXJlXCIsXFxuICAgICAgICAgICAgICB0eXBlOiBcImJ5dGVzXCJcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIF0sXFxuICAgICAgICAgIG91dHB1dHM6IFtcXG4gICAgICAgICAgICB7XFxuICAgICAgICAgICAgICB0eXBlOiBcImJvb2xcIlxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgXSxcXG4gICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcXG4gICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxcbiAgICAgICAgICBuYW1lOiBcImlzVmFsaWRTaWdcIlxcbiAgICAgICAgfVxcbiAgICAgIF07XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vY29uc3RhbnRzL2NvbnRyYWN0LmpzXFxuICB2YXIgYWdncmVnYXRlM1NpZ25hdHVyZTtcXG4gIHZhciBpbml0X2NvbnRyYWN0MiA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9jb25zdGFudHMvY29udHJhY3QuanNcIigpIHtcXG4gICAgICBhZ2dyZWdhdGUzU2lnbmF0dXJlID0gXCIweDgyYWQ1NmNiXCI7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vY29uc3RhbnRzL2NvbnRyYWN0cy5qc1xcbiAgdmFyIGRlcGxveWxlc3NDYWxsVmlhQnl0ZWNvZGVCeXRlY29kZSwgZGVwbG95bGVzc0NhbGxWaWFGYWN0b3J5Qnl0ZWNvZGUsIHVuaXZlcnNhbFNpZ25hdHVyZVZhbGlkYXRvckJ5dGVDb2RlO1xcbiAgdmFyIGluaXRfY29udHJhY3RzID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2NvbnN0YW50cy9jb250cmFjdHMuanNcIigpIHtcXG4gICAgICBkZXBsb3lsZXNzQ2FsbFZpYUJ5dGVjb2RlQnl0ZWNvZGUgPSBcIjB4NjA4MDYwNDA1MjM0ODAxNTYxMDAxMDU3NjAwMDgwZmQ1YjUwNjA0MDUxNjEwMThlMzgwMzgwNjEwMThlODMzOTgxMDE2MDQwODE5MDUyNjEwMDJmOTE2MTAxMjQ1NjViNjAwMDgwODM1MTYwMjA4NTAxNjAwMGY1OTA1MDgwM2I2MTAwNDg1NzYwMDA4MGZkNWI2MDAwODA4MzUxNjAyMDg1MDE2MDAwODU1YWYxNjA0MDUxM2Q2MDAwODIzZTgxNjEwMDY3NTczZDgxZmQ1YjNkODFmMzViNjM0ZTQ4N2I3MTYwZTAxYjYwMDA1MjYwNDE2MDA0NTI2MDI0NjAwMGZkNWI2MDAwODI2MDFmODMwMTEyNjEwMDkyNTc2MDAwODBmZDViODE1MTYwMDE2MDAxNjA0MDFiMDM4MTExMTU2MTAwYWI1NzYxMDBhYjYxMDA2YjU2NWI2MDQwNTE2MDFmODIwMTYwMWYxOTkwODExNjYwM2YwMTE2ODEwMTYwMDE2MDAxNjA0MDFiMDM4MTExODI4MjEwMTcxNTYxMDBkOTU3NjEwMGQ5NjEwMDZiNTY1YjYwNDA1MjgxODE1MjgzODIwMTYwMjAwMTg1MTAxNTYxMDBmMTU3NjAwMDgwZmQ1YjYwMDA1YjgyODExMDE1NjEwMTEwNTc2MDIwODE4NjAxODEwMTUxODM4MzAxODIwMTUyMDE2MTAwZjQ1NjViNTA2MDAwOTE4MTAxNjAyMDAxOTE5MDkxNTI5MzkyNTA1MDUwNTY1YjYwMDA4MDYwNDA4Mzg1MDMxMjE1NjEwMTM3NTc2MDAwODBmZDViODI1MTYwMDE2MDAxNjA0MDFiMDM4MTExMTU2MTAxNGQ1NzYwMDA4MGZkNWI2MTAxNTk4NTgyODYwMTYxMDA4MTU2NWI2MDIwODUwMTUxOTA5MzUwOTA1MDYwMDE2MDAxNjA0MDFiMDM4MTExMTU2MTAxNzc1NzYwMDA4MGZkNWI2MTAxODM4NTgyODYwMTYxMDA4MTU2NWI5MTUwNTA5MjUwOTI5MDUwNTZmZVwiO1xcbiAgICAgIGRlcGxveWxlc3NDYWxsVmlhRmFjdG9yeUJ5dGVjb2RlID0gXCIweDYwODA2MDQwNTIzNDgwMTU2MTAwMTA1NzYwMDA4MGZkNWI1MDYwNDA1MTYxMDJjMDM4MDM4MDYxMDJjMDgzMzk4MTAxNjA0MDgxOTA1MjYxMDAyZjkxNjEwMWU2NTY1YjgzNjAwMTYwMDE2MGEwMWIwMzE2M2I2MDAwMDM2MTAwZTQ1NzYwMDA4MDgzNjAwMTYwMDE2MGEwMWIwMzE2ODM2MDQwNTE2MTAwNWM5MTkwNjEwMjcwNTY1YjYwMDA2MDQwNTE4MDgzMDM4MTYwMDA4NjVhZjE5MTUwNTAzZDgwNjAwMDgxMTQ2MTAwOTk1NzYwNDA1MTkxNTA2MDFmMTk2MDNmM2QwMTE2ODIwMTYwNDA1MjNkODI1MjNkNjAwMDYwMjA4NDAxM2U2MTAwOWU1NjViNjA2MDkxNTA1YjUwOTE1MDkxNTA4MTE1ODA2MTAwYjg1NzUwNjAwMTYwMDE2MGEwMWIwMzg2MTYzYjE1NWIxNTYxMDBlMTU3ODA2MDQwNTE2MzEwMWJiOThkNjBlMDFiODE1MjYwMDQwMTYxMDBkODkxOTA2MTAyOGM1NjViNjA0MDUxODA5MTAzOTBmZDViNTA1MDViNjAwMDgwODQ1MTYwMjA4NjAxNjAwMDg4NWFmMTYwNDA1MTNkNjAwMDgyM2U4MTYxMDEwMzU3M2Q4MWZkNWIzZDgxZjM1YjgwNTE2MDAxNjAwMTYwYTAxYjAzODExNjgxMTQ2MTAxMWU1NzYwMDA4MGZkNWI5MTkwNTA1NjViNjM0ZTQ4N2I3MTYwZTAxYjYwMDA1MjYwNDE2MDA0NTI2MDI0NjAwMGZkNWI2MDAwNWI4MzgxMTAxNTYxMDE1NDU3ODE4MTAxNTE4MzgyMDE1MjYwMjAwMTYxMDEzYzU2NWI1MDUwNjAwMDkxMDE1MjU2NWI2MDAwODI2MDFmODMwMTEyNjEwMTZlNTc2MDAwODBmZDViODE1MTYwMDE2MDAxNjA0MDFiMDM4MTExMTU2MTAxODc1NzYxMDE4NzYxMDEyMzU2NWI2MDQwNTE2MDFmODIwMTYwMWYxOTkwODExNjYwM2YwMTE2ODEwMTYwMDE2MDAxNjA0MDFiMDM4MTExODI4MjEwMTcxNTYxMDFiNTU3NjEwMWI1NjEwMTIzNTY1YjYwNDA1MjgxODE1MjgzODIwMTYwMjAwMTg1MTAxNTYxMDFjZDU3NjAwMDgwZmQ1YjYxMDFkZTgyNjAyMDgzMDE2MDIwODcwMTYxMDEzOTU2NWI5NDkzNTA1MDUwNTA1NjViNjAwMDgwNjAwMDgwNjA4MDg1ODcwMzEyMTU2MTAxZmM1NzYwMDA4MGZkNWI2MTAyMDU4NTYxMDEwNzU2NWI2MDIwODYwMTUxOTA5NDUwNjAwMTYwMDE2MDQwMWIwMzgxMTExNTYxMDIyMTU3NjAwMDgwZmQ1YjYxMDIyZDg3ODI4ODAxNjEwMTVkNTY1YjkzNTA1MDYxMDIzYzYwNDA4NjAxNjEwMTA3NTY1YjYwNjA4NjAxNTE5MDkyNTA2MDAxNjAwMTYwNDAxYjAzODExMTE1NjEwMjU4NTc2MDAwODBmZDViNjEwMjY0ODc4Mjg4MDE2MTAxNWQ1NjViOTE1MDUwOTI5NTkxOTQ1MDkyNTA1NjViNjAwMDgyNTE2MTAyODI4MTg0NjAyMDg3MDE2MTAxMzk1NjViOTE5MDkxMDE5MjkxNTA1MDU2NWI2MDIwODE1MjYwMDA4MjUxODA2MDIwODQwMTUyNjEwMmFiODE2MDQwODUwMTYwMjA4NzAxNjEwMTM5NTY1YjYwMWYwMTYwMWYxOTE2OTE5MDkxMDE2MDQwMDE5MjkxNTA1MDU2ZmVcIjtcXG4gICAgICB1bml2ZXJzYWxTaWduYXR1cmVWYWxpZGF0b3JCeXRlQ29kZSA9IFwiMHg2MDgwNjA0MDUyMzQ4MDE1NjEwMDEwNTc2MDAwODBmZDViNTA2MDQwNTE2MTA2OTQzODAzODA2MTA2OTQ4MzM5ODEwMTYwNDA4MTkwNTI2MTAwMmY5MTYxMDUxZTU2NWI2MDAwNjEwMDNjODQ4NDg0NjEwMDQ4NTY1YjkwNTA4MDYwMDA1MjYwMDE2MDFmZjM1YjYwMDA3ZjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2MTAwNzQ4MzYxMDQwYzU2NWIwMzYxMDFlNzU3NjAwMDYwNjA4MDg0ODA2MDIwMDE5MDUxODEwMTkwNjEwMDkyOTE5MDYxMDU3NzU2NWI2MDQwNTE5Mjk1NTA5MDkzNTA5MTUwNjAwMDkwNjAwMTYwMDE2MGEwMWIwMzg1MTY5MDYxMDBiNjkwODU5MDYxMDVkZDU2NWI2MDAwNjA0MDUxODA4MzAzODE2MDAwODY1YWYxOTE1MDUwM2Q4MDYwMDA4MTE0NjEwMGYzNTc2MDQwNTE5MTUwNjAxZjE5NjAzZjNkMDExNjgyMDE2MDQwNTIzZDgyNTIzZDYwMDA2MDIwODQwMTNlNjEwMGY4NTY1YjYwNjA5MTUwNWI1MDUwOTA1MDg3NjAwMTYwMDE2MGEwMWIwMzE2M2I2MDAwMDM2MTAxNjA1NzgwNjEwMTYwNTc2MDQwNTE2MjQ2MWJjZDYwZTUxYjgxNTI2MDIwNjAwNDgyMDE1MjYwMWU2MDI0ODIwMTUyN2Y1MzY5Njc2ZTYxNzQ3NTcyNjU1NjYxNmM2OTY0NjE3NDZmNzIzYTIwNjQ2NTcwNmM2Zjc5NmQ2NTZlNzQwMDAwNjA0NDgyMDE1MjYwNjQwMTViNjA0MDUxODA5MTAzOTBmZDViNjA0MDUxNjMwYjEzNWQzZjYwZTExYjgwODI1MjkwNjAwMTYwMDE2MGEwMWIwMzhhMTY5MDYzMTYyNmJhN2U5MDYxMDE5MDkwOGI5MDg3OTA2MDA0MDE2MTA1Zjk1NjViNjAyMDYwNDA1MTgwODMwMzgxODY1YWZhMTU4MDE1NjEwMWFkNTczZDYwMDA4MDNlM2Q2MDAwZmQ1YjUwNTA1MDUwNjA0MDUxM2Q2MDFmMTk2MDFmODIwMTE2ODIwMTgwNjA0MDUyNTA4MTAxOTA2MTAxZDE5MTkwNjEwNjMzNTY1YjYwMDE2MDAxNjBlMDFiMDMxOTE2MTQ5NDUwNTA1MDUwNTA2MTA0MDU1NjViNjAwMTYwMDE2MGEwMWIwMzg0MTYzYjE1NjEwMjdhNTc2MDQwNTE2MzBiMTM1ZDNmNjBlMTFiODA4MjUyOTA2MDAxNjAwMTYwYTAxYjAzODYxNjkwNjMxNjI2YmE3ZTkwNjEwMjI3OTA4NzkwODc5MDYwMDQwMTYxMDVmOTU2NWI2MDIwNjA0MDUxODA4MzAzODE4NjVhZmExNTgwMTU2MTAyNDQ1NzNkNjAwMDgwM2UzZDYwMDBmZDViNTA1MDUwNTA2MDQwNTEzZDYwMWYxOTYwMWY4MjAxMTY4MjAxODA2MDQwNTI1MDgxMDE5MDYxMDI2ODkxOTA2MTA2MzM1NjViNjAwMTYwMDE2MGUwMWIwMzE5MTYxNDkwNTA2MTA0MDU1NjViODE1MTYwNDExNDYxMDJkZjU3NjA0MDUxNjI0NjFiY2Q2MGU1MWI4MTUyNjAyMDYwMDQ4MjAxNTI2MDNhNjAyNDgyMDE1MjYwMDA4MDUxNjAyMDYxMDY3NDgzMzk4MTUxOTE1MjYwNDQ4MjAxNTI3ZjNhMjA2OTZlNzY2MTZjNjk2NDIwNzM2OTY3NmU2MTc0NzU3MjY1MjA2YzY1NmU2Nzc0NjgwMDAwMDAwMDAwMDA2MDY0ODIwMTUyNjA4NDAxNjEwMTU3NTY1YjYxMDJlNzYxMDQyNTU2NWI1MDYwMjA4MjAxNTE2MDQwODA4NDAxNTE4NDUxODU5MzkyNjAwMDkxODU5MTkwODExMDYxMDMwYzU3NjEwMzBjNjEwNjVkNTY1YjAxNjAyMDAxNTE2MGY4MWM5MDUwNjAxYjgxMTQ4MDE1OTA2MTAzMmI1NzUwODA2MGZmMTY2MDFjMTQxNTViMTU2MTAzOGM1NzYwNDA1MTYyNDYxYmNkNjBlNTFiODE1MjYwMjA2MDA0ODIwMTUyNjAzYjYwMjQ4MjAxNTI2MDAwODA1MTYwMjA2MTA2NzQ4MzM5ODE1MTkxNTI2MDQ0ODIwMTUyN2YzYTIwNjk2ZTc2NjE2YzY5NjQyMDczNjk2NzZlNjE3NDc1NzI2NTIwNzYyMDc2NjE2Yzc1NjUwMDAwMDAwMDAwNjA2NDgyMDE1MjYwODQwMTYxMDE1NzU2NWI2MDQwODA1MTYwMDA4MTUyNjAyMDgxMDE4MDgzNTI4OTkwNTI2MGZmODMxNjkxODEwMTkxOTA5MTUyNjA2MDgxMDE4NDkwNTI2MDgwODEwMTgzOTA1MjYwMDE2MDAxNjBhMDFiMDM4OTE2OTA2MDAxOTA2MGEwMDE2MDIwNjA0MDUxNjAyMDgxMDM5MDgwODQwMzkwODU1YWZhMTU4MDE1NjEwM2VhNTczZDYwMDA4MDNlM2Q2MDAwZmQ1YjUwNTA1MDYwMjA2MDQwNTEwMzUxNjAwMTYwMDE2MGEwMWIwMzE2MTQ5NDUwNTA1MDUwNTA1YjkzOTI1MDUwNTA1NjViNjAwMDYwMjA4MjUxMTAxNTYxMDQxZDU3NjAwMDgwZmQ1YjUwODA1MTAxNTE5MDU2NWI2MDQwNTE4MDYwNjAwMTYwNDA1MjgwNjAwMzkwNjAyMDgyMDI4MDM2ODMzNzUwOTE5MjkxNTA1MDU2NWI2MDAxNjAwMTYwYTAxYjAzODExNjgxMTQ2MTA0NTg1NzYwMDA4MGZkNWI1MDU2NWI2MzRlNDg3YjcxNjBlMDFiNjAwMDUyNjA0MTYwMDQ1MjYwMjQ2MDAwZmQ1YjYwMDA1YjgzODExMDE1NjEwNDhjNTc4MTgxMDE1MTgzODIwMTUyNjAyMDAxNjEwNDc0NTY1YjUwNTA2MDAwOTEwMTUyNTY1YjYwMDA4MjYwMWY4MzAxMTI2MTA0YTY1NzYwMDA4MGZkNWI4MTUxNjAwMTYwMDE2MDQwMWIwMzgxMTExNTYxMDRiZjU3NjEwNGJmNjEwNDViNTY1YjYwNDA1MTYwMWY4MjAxNjAxZjE5OTA4MTE2NjAzZjAxMTY4MTAxNjAwMTYwMDE2MDQwMWIwMzgxMTE4MjgyMTAxNzE1NjEwNGVkNTc2MTA0ZWQ2MTA0NWI1NjViNjA0MDUyODE4MTUyODM4MjAxNjAyMDAxODUxMDE1NjEwNTA1NTc2MDAwODBmZDViNjEwNTE2ODI2MDIwODMwMTYwMjA4NzAxNjEwNDcxNTY1Yjk0OTM1MDUwNTA1MDU2NWI2MDAwODA2MDAwNjA2MDg0ODYwMzEyMTU2MTA1MzM1NzYwMDA4MGZkNWI4MzUxNjEwNTNlODE2MTA0NDM1NjViNjAyMDg1MDE1MTYwNDA4NjAxNTE5MTk0NTA5MjUwNjAwMTYwMDE2MDQwMWIwMzgxMTExNTYxMDU2MTU3NjAwMDgwZmQ1YjYxMDU2ZDg2ODI4NzAxNjEwNDk1NTY1YjkxNTA1MDkyNTA5MjUwOTI1NjViNjAwMDgwNjAwMDYwNjA4NDg2MDMxMjE1NjEwNThjNTc2MDAwODBmZDViODM1MTYxMDU5NzgxNjEwNDQzNTY1YjYwMjA4NTAxNTE5MDkzNTA2MDAxNjAwMTYwNDAxYjAzODExMTE1NjEwNWIzNTc2MDAwODBmZDViNjEwNWJmODY4Mjg3MDE2MTA0OTU1NjViNjA0MDg2MDE1MTkwOTM1MDkwNTA2MDAxNjAwMTYwNDAxYjAzODExMTE1NjEwNTYxNTc2MDAwODBmZDViNjAwMDgyNTE2MTA1ZWY4MTg0NjAyMDg3MDE2MTA0NzE1NjViOTE5MDkxMDE5MjkxNTA1MDU2NWI4MjgxNTI2MDQwNjAyMDgyMDE1MjYwMDA4MjUxODA2MDQwODQwMTUyNjEwNjFlODE2MDYwODUwMTYwMjA4NzAxNjEwNDcxNTY1YjYwMWYwMTYwMWYxOTE2OTE5MDkxMDE2MDYwMDE5MzkyNTA1MDUwNTY1YjYwMDA2MDIwODI4NDAzMTIxNTYxMDY0NTU3NjAwMDgwZmQ1YjgxNTE2MDAxNjAwMTYwZTAxYjAzMTk4MTE2ODExNDYxMDQwNTU3NjAwMDgwZmQ1YjYzNGU0ODdiNzE2MGUwMWI2MDAwNTI2MDMyNjAwNDUyNjAyNDYwMDBmZGZlNTM2OTY3NmU2MTc0NzU3MjY1NTY2MTZjNjk2NDYxNzQ2ZjcyMjM3MjY1NjM2Zjc2NjU3MjUzNjk2NzZlNjU3MlwiO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2Vycm9ycy9jaGFpbi5qc1xcbiAgdmFyIENoYWluRG9lc05vdFN1cHBvcnRDb250cmFjdCwgQ2hhaW5NaXNtYXRjaEVycm9yLCBDaGFpbk5vdEZvdW5kRXJyb3IsIENsaWVudENoYWluTm90Q29uZmlndXJlZEVycm9yLCBJbnZhbGlkQ2hhaW5JZEVycm9yO1xcbiAgdmFyIGluaXRfY2hhaW4gPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vZXJyb3JzL2NoYWluLmpzXCIoKSB7XFxuICAgICAgaW5pdF9iYXNlKCk7XFxuICAgICAgQ2hhaW5Eb2VzTm90U3VwcG9ydENvbnRyYWN0ID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IyIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKHsgYmxvY2tOdW1iZXIsIGNoYWluLCBjb250cmFjdCB9KSB7XFxuICAgICAgICAgIHN1cGVyKGBDaGFpbiBcIiR7Y2hhaW4ubmFtZX1cIiBkb2VzIG5vdCBzdXBwb3J0IGNvbnRyYWN0IFwiJHtjb250cmFjdC5uYW1lfVwiLmAsIHtcXG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcXG4gICAgICAgICAgICAgIFwiVGhpcyBjb3VsZCBiZSBkdWUgdG8gYW55IG9mIHRoZSBmb2xsb3dpbmc6XCIsXFxuICAgICAgICAgICAgICAuLi5ibG9ja051bWJlciAmJiBjb250cmFjdC5ibG9ja0NyZWF0ZWQgJiYgY29udHJhY3QuYmxvY2tDcmVhdGVkID4gYmxvY2tOdW1iZXIgPyBbXFxuICAgICAgICAgICAgICAgIGAtIFRoZSBjb250cmFjdCBcIiR7Y29udHJhY3QubmFtZX1cIiB3YXMgbm90IGRlcGxveWVkIHVudGlsIGJsb2NrICR7Y29udHJhY3QuYmxvY2tDcmVhdGVkfSAoY3VycmVudCBibG9jayAke2Jsb2NrTnVtYmVyfSkuYFxcbiAgICAgICAgICAgICAgXSA6IFtcXG4gICAgICAgICAgICAgICAgYC0gVGhlIGNoYWluIGRvZXMgbm90IGhhdmUgdGhlIGNvbnRyYWN0IFwiJHtjb250cmFjdC5uYW1lfVwiIGNvbmZpZ3VyZWQuYFxcbiAgICAgICAgICAgICAgXVxcbiAgICAgICAgICAgIF0sXFxuICAgICAgICAgICAgbmFtZTogXCJDaGFpbkRvZXNOb3RTdXBwb3J0Q29udHJhY3RcIlxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIENoYWluTWlzbWF0Y2hFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgICAgICBjb25zdHJ1Y3Rvcih7IGNoYWluLCBjdXJyZW50Q2hhaW5JZCB9KSB7XFxuICAgICAgICAgIHN1cGVyKGBUaGUgY3VycmVudCBjaGFpbiBvZiB0aGUgd2FsbGV0IChpZDogJHtjdXJyZW50Q2hhaW5JZH0pIGRvZXMgbm90IG1hdGNoIHRoZSB0YXJnZXQgY2hhaW4gZm9yIHRoZSB0cmFuc2FjdGlvbiAoaWQ6ICR7Y2hhaW4uaWR9IFxcXFx1MjAxMyAke2NoYWluLm5hbWV9KS5gLCB7XFxuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXFxuICAgICAgICAgICAgICBgQ3VycmVudCBDaGFpbiBJRDogICR7Y3VycmVudENoYWluSWR9YCxcXG4gICAgICAgICAgICAgIGBFeHBlY3RlZCBDaGFpbiBJRDogJHtjaGFpbi5pZH0gXFxcXHUyMDEzICR7Y2hhaW4ubmFtZX1gXFxuICAgICAgICAgICAgXSxcXG4gICAgICAgICAgICBuYW1lOiBcIkNoYWluTWlzbWF0Y2hFcnJvclwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgQ2hhaW5Ob3RGb3VuZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IyIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xcbiAgICAgICAgICBzdXBlcihbXFxuICAgICAgICAgICAgXCJObyBjaGFpbiB3YXMgcHJvdmlkZWQgdG8gdGhlIHJlcXVlc3QuXCIsXFxuICAgICAgICAgICAgXCJQbGVhc2UgcHJvdmlkZSBhIGNoYWluIHdpdGggdGhlIGBjaGFpbmAgYXJndW1lbnQgb24gdGhlIEFjdGlvbiwgb3IgYnkgc3VwcGx5aW5nIGEgYGNoYWluYCB0byBXYWxsZXRDbGllbnQuXCJcXG4gICAgICAgICAgXS5qb2luKFwiXFxcXG5cIiksIHtcXG4gICAgICAgICAgICBuYW1lOiBcIkNoYWluTm90Rm91bmRFcnJvclwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgQ2xpZW50Q2hhaW5Ob3RDb25maWd1cmVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjIge1xcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XFxuICAgICAgICAgIHN1cGVyKFwiTm8gY2hhaW4gd2FzIHByb3ZpZGVkIHRvIHRoZSBDbGllbnQuXCIsIHtcXG4gICAgICAgICAgICBuYW1lOiBcIkNsaWVudENoYWluTm90Q29uZmlndXJlZEVycm9yXCJcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICBJbnZhbGlkQ2hhaW5JZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IyIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKHsgY2hhaW5JZCB9KSB7XFxuICAgICAgICAgIHN1cGVyKHR5cGVvZiBjaGFpbklkID09PSBcIm51bWJlclwiID8gYENoYWluIElEIFwiJHtjaGFpbklkfVwiIGlzIGludmFsaWQuYCA6IFwiQ2hhaW4gSUQgaXMgaW52YWxpZC5cIiwgeyBuYW1lOiBcIkludmFsaWRDaGFpbklkRXJyb3JcIiB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2FiaS9lbmNvZGVEZXBsb3lEYXRhLmpzXFxuICBmdW5jdGlvbiBlbmNvZGVEZXBsb3lEYXRhKHBhcmFtZXRlcnMpIHtcXG4gICAgY29uc3QgeyBhYmk6IGFiaTIsIGFyZ3MsIGJ5dGVjb2RlIH0gPSBwYXJhbWV0ZXJzO1xcbiAgICBpZiAoIWFyZ3MgfHwgYXJncy5sZW5ndGggPT09IDApXFxuICAgICAgcmV0dXJuIGJ5dGVjb2RlO1xcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGFiaTIuZmluZCgoeCkgPT4gXCJ0eXBlXCIgaW4geCAmJiB4LnR5cGUgPT09IFwiY29uc3RydWN0b3JcIik7XFxuICAgIGlmICghZGVzY3JpcHRpb24pXFxuICAgICAgdGhyb3cgbmV3IEFiaUNvbnN0cnVjdG9yTm90Rm91bmRFcnJvcih7IGRvY3NQYXRoOiBkb2NzUGF0aDUgfSk7XFxuICAgIGlmICghKFwiaW5wdXRzXCIgaW4gZGVzY3JpcHRpb24pKVxcbiAgICAgIHRocm93IG5ldyBBYmlDb25zdHJ1Y3RvclBhcmFtc05vdEZvdW5kRXJyb3IoeyBkb2NzUGF0aDogZG9jc1BhdGg1IH0pO1xcbiAgICBpZiAoIWRlc2NyaXB0aW9uLmlucHV0cyB8fCBkZXNjcmlwdGlvbi5pbnB1dHMubGVuZ3RoID09PSAwKVxcbiAgICAgIHRocm93IG5ldyBBYmlDb25zdHJ1Y3RvclBhcmFtc05vdEZvdW5kRXJyb3IoeyBkb2NzUGF0aDogZG9jc1BhdGg1IH0pO1xcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlQWJpUGFyYW1ldGVycyhkZXNjcmlwdGlvbi5pbnB1dHMsIGFyZ3MpO1xcbiAgICByZXR1cm4gY29uY2F0SGV4KFtieXRlY29kZSwgZGF0YV0pO1xcbiAgfVxcbiAgdmFyIGRvY3NQYXRoNTtcXG4gIHZhciBpbml0X2VuY29kZURlcGxveURhdGEgPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvYWJpL2VuY29kZURlcGxveURhdGEuanNcIigpIHtcXG4gICAgICBpbml0X2FiaSgpO1xcbiAgICAgIGluaXRfY29uY2F0KCk7XFxuICAgICAgaW5pdF9lbmNvZGVBYmlQYXJhbWV0ZXJzKCk7XFxuICAgICAgZG9jc1BhdGg1ID0gXCIvZG9jcy9jb250cmFjdC9lbmNvZGVEZXBsb3lEYXRhXCI7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvY2hhaW4vZ2V0Q2hhaW5Db250cmFjdEFkZHJlc3MuanNcXG4gIGZ1bmN0aW9uIGdldENoYWluQ29udHJhY3RBZGRyZXNzKHsgYmxvY2tOdW1iZXIsIGNoYWluLCBjb250cmFjdDogbmFtZSB9KSB7XFxuICAgIGNvbnN0IGNvbnRyYWN0ID0gY2hhaW4/LmNvbnRyYWN0cz8uW25hbWVdO1xcbiAgICBpZiAoIWNvbnRyYWN0KVxcbiAgICAgIHRocm93IG5ldyBDaGFpbkRvZXNOb3RTdXBwb3J0Q29udHJhY3Qoe1xcbiAgICAgICAgY2hhaW4sXFxuICAgICAgICBjb250cmFjdDogeyBuYW1lIH1cXG4gICAgICB9KTtcXG4gICAgaWYgKGJsb2NrTnVtYmVyICYmIGNvbnRyYWN0LmJsb2NrQ3JlYXRlZCAmJiBjb250cmFjdC5ibG9ja0NyZWF0ZWQgPiBibG9ja051bWJlcilcXG4gICAgICB0aHJvdyBuZXcgQ2hhaW5Eb2VzTm90U3VwcG9ydENvbnRyYWN0KHtcXG4gICAgICAgIGJsb2NrTnVtYmVyLFxcbiAgICAgICAgY2hhaW4sXFxuICAgICAgICBjb250cmFjdDoge1xcbiAgICAgICAgICBuYW1lLFxcbiAgICAgICAgICBibG9ja0NyZWF0ZWQ6IGNvbnRyYWN0LmJsb2NrQ3JlYXRlZFxcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICByZXR1cm4gY29udHJhY3QuYWRkcmVzcztcXG4gIH1cXG4gIHZhciBpbml0X2dldENoYWluQ29udHJhY3RBZGRyZXNzID0gX19lc20oe1xcbiAgICBcIi4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2NoYWluL2dldENoYWluQ29udHJhY3RBZGRyZXNzLmpzXCIoKSB7XFxuICAgICAgaW5pdF9jaGFpbigpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2Vycm9ycy9nZXRDYWxsRXJyb3IuanNcXG4gIGZ1bmN0aW9uIGdldENhbGxFcnJvcihlcnIsIHsgZG9jc1BhdGg6IGRvY3NQYXRoOCwgLi4uYXJncyB9KSB7XFxuICAgIGNvbnN0IGNhdXNlID0gKCgpID0+IHtcXG4gICAgICBjb25zdCBjYXVzZTIgPSBnZXROb2RlRXJyb3IoZXJyLCBhcmdzKTtcXG4gICAgICBpZiAoY2F1c2UyIGluc3RhbmNlb2YgVW5rbm93bk5vZGVFcnJvcilcXG4gICAgICAgIHJldHVybiBlcnI7XFxuICAgICAgcmV0dXJuIGNhdXNlMjtcXG4gICAgfSkoKTtcXG4gICAgcmV0dXJuIG5ldyBDYWxsRXhlY3V0aW9uRXJyb3IoY2F1c2UsIHtcXG4gICAgICBkb2NzUGF0aDogZG9jc1BhdGg4LFxcbiAgICAgIC4uLmFyZ3NcXG4gICAgfSk7XFxuICB9XFxuICB2YXIgaW5pdF9nZXRDYWxsRXJyb3IgPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvZXJyb3JzL2dldENhbGxFcnJvci5qc1wiKCkge1xcbiAgICAgIGluaXRfY29udHJhY3QoKTtcXG4gICAgICBpbml0X25vZGUoKTtcXG4gICAgICBpbml0X2dldE5vZGVFcnJvcigpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL3Byb21pc2Uvd2l0aFJlc29sdmVycy5qc1xcbiAgZnVuY3Rpb24gd2l0aFJlc29sdmVycygpIHtcXG4gICAgbGV0IHJlc29sdmUgPSAoKSA9PiB2b2lkIDA7XFxuICAgIGxldCByZWplY3QgPSAoKSA9PiB2b2lkIDA7XFxuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZV8sIHJlamVjdF8pID0+IHtcXG4gICAgICByZXNvbHZlID0gcmVzb2x2ZV87XFxuICAgICAgcmVqZWN0ID0gcmVqZWN0XztcXG4gICAgfSk7XFxuICAgIHJldHVybiB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9O1xcbiAgfVxcbiAgdmFyIGluaXRfd2l0aFJlc29sdmVycyA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9wcm9taXNlL3dpdGhSZXNvbHZlcnMuanNcIigpIHtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9wcm9taXNlL2NyZWF0ZUJhdGNoU2NoZWR1bGVyLmpzXFxuICBmdW5jdGlvbiBjcmVhdGVCYXRjaFNjaGVkdWxlcih7IGZuLCBpZCwgc2hvdWxkU3BsaXRCYXRjaCwgd2FpdDogd2FpdDIgPSAwLCBzb3J0IH0pIHtcXG4gICAgY29uc3QgZXhlYyA9IGFzeW5jICgpID0+IHtcXG4gICAgICBjb25zdCBzY2hlZHVsZXIgPSBnZXRTY2hlZHVsZXIoKTtcXG4gICAgICBmbHVzaCgpO1xcbiAgICAgIGNvbnN0IGFyZ3MgPSBzY2hlZHVsZXIubWFwKCh7IGFyZ3M6IGFyZ3MyIH0pID0+IGFyZ3MyKTtcXG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApXFxuICAgICAgICByZXR1cm47XFxuICAgICAgZm4oYXJncykudGhlbigoZGF0YSkgPT4ge1xcbiAgICAgICAgaWYgKHNvcnQgJiYgQXJyYXkuaXNBcnJheShkYXRhKSlcXG4gICAgICAgICAgZGF0YS5zb3J0KHNvcnQpO1xcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlZHVsZXIubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgY29uc3QgeyByZXNvbHZlIH0gPSBzY2hlZHVsZXJbaV07XFxuICAgICAgICAgIHJlc29sdmU/LihbZGF0YVtpXSwgZGF0YV0pO1xcbiAgICAgICAgfVxcbiAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NoZWR1bGVyLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgIGNvbnN0IHsgcmVqZWN0IH0gPSBzY2hlZHVsZXJbaV07XFxuICAgICAgICAgIHJlamVjdD8uKGVycik7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH07XFxuICAgIGNvbnN0IGZsdXNoID0gKCkgPT4gc2NoZWR1bGVyQ2FjaGUuZGVsZXRlKGlkKTtcXG4gICAgY29uc3QgZ2V0QmF0Y2hlZEFyZ3MgPSAoKSA9PiBnZXRTY2hlZHVsZXIoKS5tYXAoKHsgYXJncyB9KSA9PiBhcmdzKTtcXG4gICAgY29uc3QgZ2V0U2NoZWR1bGVyID0gKCkgPT4gc2NoZWR1bGVyQ2FjaGUuZ2V0KGlkKSB8fCBbXTtcXG4gICAgY29uc3Qgc2V0U2NoZWR1bGVyID0gKGl0ZW0pID0+IHNjaGVkdWxlckNhY2hlLnNldChpZCwgWy4uLmdldFNjaGVkdWxlcigpLCBpdGVtXSk7XFxuICAgIHJldHVybiB7XFxuICAgICAgZmx1c2gsXFxuICAgICAgYXN5bmMgc2NoZWR1bGUoYXJncykge1xcbiAgICAgICAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlLCByZWplY3QgfSA9IHdpdGhSZXNvbHZlcnMoKTtcXG4gICAgICAgIGNvbnN0IHNwbGl0MyA9IHNob3VsZFNwbGl0QmF0Y2g/LihbLi4uZ2V0QmF0Y2hlZEFyZ3MoKSwgYXJnc10pO1xcbiAgICAgICAgaWYgKHNwbGl0MylcXG4gICAgICAgICAgZXhlYygpO1xcbiAgICAgICAgY29uc3QgaGFzQWN0aXZlU2NoZWR1bGVyID0gZ2V0U2NoZWR1bGVyKCkubGVuZ3RoID4gMDtcXG4gICAgICAgIGlmIChoYXNBY3RpdmVTY2hlZHVsZXIpIHtcXG4gICAgICAgICAgc2V0U2NoZWR1bGVyKHsgYXJncywgcmVzb2x2ZSwgcmVqZWN0IH0pO1xcbiAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHNldFNjaGVkdWxlcih7IGFyZ3MsIHJlc29sdmUsIHJlamVjdCB9KTtcXG4gICAgICAgIHNldFRpbWVvdXQoZXhlYywgd2FpdDIpO1xcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfVxcbiAgdmFyIHNjaGVkdWxlckNhY2hlO1xcbiAgdmFyIGluaXRfY3JlYXRlQmF0Y2hTY2hlZHVsZXIgPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvcHJvbWlzZS9jcmVhdGVCYXRjaFNjaGVkdWxlci5qc1wiKCkge1xcbiAgICAgIGluaXRfd2l0aFJlc29sdmVycygpO1xcbiAgICAgIHNjaGVkdWxlckNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9lcnJvcnMvY2NpcC5qc1xcbiAgdmFyIE9mZmNoYWluTG9va3VwRXJyb3IsIE9mZmNoYWluTG9va3VwUmVzcG9uc2VNYWxmb3JtZWRFcnJvciwgT2ZmY2hhaW5Mb29rdXBTZW5kZXJNaXNtYXRjaEVycm9yO1xcbiAgdmFyIGluaXRfY2NpcCA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9lcnJvcnMvY2NpcC5qc1wiKCkge1xcbiAgICAgIGluaXRfc3RyaW5naWZ5KCk7XFxuICAgICAgaW5pdF9iYXNlKCk7XFxuICAgICAgaW5pdF91dGlsczMoKTtcXG4gICAgICBPZmZjaGFpbkxvb2t1cEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IyIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKHsgY2FsbGJhY2tTZWxlY3RvciwgY2F1c2UsIGRhdGEsIGV4dHJhRGF0YSwgc2VuZGVyLCB1cmxzIH0pIHtcXG4gICAgICAgICAgc3VwZXIoY2F1c2Uuc2hvcnRNZXNzYWdlIHx8IFwiQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgZmV0Y2hpbmcgZm9yIGFuIG9mZmNoYWluIHJlc3VsdC5cIiwge1xcbiAgICAgICAgICAgIGNhdXNlLFxcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xcbiAgICAgICAgICAgICAgLi4uY2F1c2UubWV0YU1lc3NhZ2VzIHx8IFtdLFxcbiAgICAgICAgICAgICAgY2F1c2UubWV0YU1lc3NhZ2VzPy5sZW5ndGggPyBcIlwiIDogW10sXFxuICAgICAgICAgICAgICBcIk9mZmNoYWluIEdhdGV3YXkgQ2FsbDpcIixcXG4gICAgICAgICAgICAgIHVybHMgJiYgW1xcbiAgICAgICAgICAgICAgICBcIiAgR2F0ZXdheSBVUkwocyk6XCIsXFxuICAgICAgICAgICAgICAgIC4uLnVybHMubWFwKCh1cmwpID0+IGAgICAgJHtnZXRVcmwodXJsKX1gKVxcbiAgICAgICAgICAgICAgXSxcXG4gICAgICAgICAgICAgIGAgIFNlbmRlcjogJHtzZW5kZXJ9YCxcXG4gICAgICAgICAgICAgIGAgIERhdGE6ICR7ZGF0YX1gLFxcbiAgICAgICAgICAgICAgYCAgQ2FsbGJhY2sgc2VsZWN0b3I6ICR7Y2FsbGJhY2tTZWxlY3Rvcn1gLFxcbiAgICAgICAgICAgICAgYCAgRXh0cmEgZGF0YTogJHtleHRyYURhdGF9YFxcbiAgICAgICAgICAgIF0uZmxhdCgpLFxcbiAgICAgICAgICAgIG5hbWU6IFwiT2ZmY2hhaW5Mb29rdXBFcnJvclwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgT2ZmY2hhaW5Mb29rdXBSZXNwb25zZU1hbGZvcm1lZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IyIHtcXG4gICAgICAgIGNvbnN0cnVjdG9yKHsgcmVzdWx0LCB1cmwgfSkge1xcbiAgICAgICAgICBzdXBlcihcIk9mZmNoYWluIGdhdGV3YXkgcmVzcG9uc2UgaXMgbWFsZm9ybWVkLiBSZXNwb25zZSBkYXRhIG11c3QgYmUgYSBoZXggdmFsdWUuXCIsIHtcXG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcXG4gICAgICAgICAgICAgIGBHYXRld2F5IFVSTDogJHtnZXRVcmwodXJsKX1gLFxcbiAgICAgICAgICAgICAgYFJlc3BvbnNlOiAke3N0cmluZ2lmeShyZXN1bHQpfWBcXG4gICAgICAgICAgICBdLFxcbiAgICAgICAgICAgIG5hbWU6IFwiT2ZmY2hhaW5Mb29rdXBSZXNwb25zZU1hbGZvcm1lZEVycm9yXCJcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICBPZmZjaGFpbkxvb2t1cFNlbmRlck1pc21hdGNoRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjIge1xcbiAgICAgICAgY29uc3RydWN0b3IoeyBzZW5kZXIsIHRvIH0pIHtcXG4gICAgICAgICAgc3VwZXIoXCJSZXZlcnRlZCBzZW5kZXIgYWRkcmVzcyBkb2VzIG5vdCBtYXRjaCB0YXJnZXQgY29udHJhY3QgYWRkcmVzcyAoYHRvYCkuXCIsIHtcXG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcXG4gICAgICAgICAgICAgIGBDb250cmFjdCBhZGRyZXNzOiAke3RvfWAsXFxuICAgICAgICAgICAgICBgT2ZmY2hhaW5Mb29rdXAgc2VuZGVyIGFkZHJlc3M6ICR7c2VuZGVyfWBcXG4gICAgICAgICAgICBdLFxcbiAgICAgICAgICAgIG5hbWU6IFwiT2ZmY2hhaW5Mb29rdXBTZW5kZXJNaXNtYXRjaEVycm9yXCJcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9hYmkvZGVjb2RlRnVuY3Rpb25EYXRhLmpzXFxuICBmdW5jdGlvbiBkZWNvZGVGdW5jdGlvbkRhdGEocGFyYW1ldGVycykge1xcbiAgICBjb25zdCB7IGFiaTogYWJpMiwgZGF0YSB9ID0gcGFyYW1ldGVycztcXG4gICAgY29uc3Qgc2lnbmF0dXJlID0gc2xpY2UoZGF0YSwgMCwgNCk7XFxuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gYWJpMi5maW5kKCh4KSA9PiB4LnR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJiBzaWduYXR1cmUgPT09IHRvRnVuY3Rpb25TZWxlY3Rvcihmb3JtYXRBYmlJdGVtMih4KSkpO1xcbiAgICBpZiAoIWRlc2NyaXB0aW9uKVxcbiAgICAgIHRocm93IG5ldyBBYmlGdW5jdGlvblNpZ25hdHVyZU5vdEZvdW5kRXJyb3Ioc2lnbmF0dXJlLCB7XFxuICAgICAgICBkb2NzUGF0aDogXCIvZG9jcy9jb250cmFjdC9kZWNvZGVGdW5jdGlvbkRhdGFcIlxcbiAgICAgIH0pO1xcbiAgICByZXR1cm4ge1xcbiAgICAgIGZ1bmN0aW9uTmFtZTogZGVzY3JpcHRpb24ubmFtZSxcXG4gICAgICBhcmdzOiBcImlucHV0c1wiIGluIGRlc2NyaXB0aW9uICYmIGRlc2NyaXB0aW9uLmlucHV0cyAmJiBkZXNjcmlwdGlvbi5pbnB1dHMubGVuZ3RoID4gMCA/IGRlY29kZUFiaVBhcmFtZXRlcnMoZGVzY3JpcHRpb24uaW5wdXRzLCBzbGljZShkYXRhLCA0KSkgOiB2b2lkIDBcXG4gICAgfTtcXG4gIH1cXG4gIHZhciBpbml0X2RlY29kZUZ1bmN0aW9uRGF0YSA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9hYmkvZGVjb2RlRnVuY3Rpb25EYXRhLmpzXCIoKSB7XFxuICAgICAgaW5pdF9hYmkoKTtcXG4gICAgICBpbml0X3NsaWNlKCk7XFxuICAgICAgaW5pdF90b0Z1bmN0aW9uU2VsZWN0b3IoKTtcXG4gICAgICBpbml0X2RlY29kZUFiaVBhcmFtZXRlcnMoKTtcXG4gICAgICBpbml0X2Zvcm1hdEFiaUl0ZW0yKCk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvYWJpL2VuY29kZUVycm9yUmVzdWx0LmpzXFxuICBmdW5jdGlvbiBlbmNvZGVFcnJvclJlc3VsdChwYXJhbWV0ZXJzKSB7XFxuICAgIGNvbnN0IHsgYWJpOiBhYmkyLCBlcnJvck5hbWUsIGFyZ3MgfSA9IHBhcmFtZXRlcnM7XFxuICAgIGxldCBhYmlJdGVtID0gYWJpMlswXTtcXG4gICAgaWYgKGVycm9yTmFtZSkge1xcbiAgICAgIGNvbnN0IGl0ZW0gPSBnZXRBYmlJdGVtKHsgYWJpOiBhYmkyLCBhcmdzLCBuYW1lOiBlcnJvck5hbWUgfSk7XFxuICAgICAgaWYgKCFpdGVtKVxcbiAgICAgICAgdGhyb3cgbmV3IEFiaUVycm9yTm90Rm91bmRFcnJvcihlcnJvck5hbWUsIHsgZG9jc1BhdGg6IGRvY3NQYXRoNiB9KTtcXG4gICAgICBhYmlJdGVtID0gaXRlbTtcXG4gICAgfVxcbiAgICBpZiAoYWJpSXRlbS50eXBlICE9PSBcImVycm9yXCIpXFxuICAgICAgdGhyb3cgbmV3IEFiaUVycm9yTm90Rm91bmRFcnJvcih2b2lkIDAsIHsgZG9jc1BhdGg6IGRvY3NQYXRoNiB9KTtcXG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IGZvcm1hdEFiaUl0ZW0yKGFiaUl0ZW0pO1xcbiAgICBjb25zdCBzaWduYXR1cmUgPSB0b0Z1bmN0aW9uU2VsZWN0b3IoZGVmaW5pdGlvbik7XFxuICAgIGxldCBkYXRhID0gXCIweFwiO1xcbiAgICBpZiAoYXJncyAmJiBhcmdzLmxlbmd0aCA+IDApIHtcXG4gICAgICBpZiAoIWFiaUl0ZW0uaW5wdXRzKVxcbiAgICAgICAgdGhyb3cgbmV3IEFiaUVycm9ySW5wdXRzTm90Rm91bmRFcnJvcihhYmlJdGVtLm5hbWUsIHsgZG9jc1BhdGg6IGRvY3NQYXRoNiB9KTtcXG4gICAgICBkYXRhID0gZW5jb2RlQWJpUGFyYW1ldGVycyhhYmlJdGVtLmlucHV0cywgYXJncyk7XFxuICAgIH1cXG4gICAgcmV0dXJuIGNvbmNhdEhleChbc2lnbmF0dXJlLCBkYXRhXSk7XFxuICB9XFxuICB2YXIgZG9jc1BhdGg2O1xcbiAgdmFyIGluaXRfZW5jb2RlRXJyb3JSZXN1bHQgPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvYWJpL2VuY29kZUVycm9yUmVzdWx0LmpzXCIoKSB7XFxuICAgICAgaW5pdF9hYmkoKTtcXG4gICAgICBpbml0X2NvbmNhdCgpO1xcbiAgICAgIGluaXRfdG9GdW5jdGlvblNlbGVjdG9yKCk7XFxuICAgICAgaW5pdF9lbmNvZGVBYmlQYXJhbWV0ZXJzKCk7XFxuICAgICAgaW5pdF9mb3JtYXRBYmlJdGVtMigpO1xcbiAgICAgIGluaXRfZ2V0QWJpSXRlbSgpO1xcbiAgICAgIGRvY3NQYXRoNiA9IFwiL2RvY3MvY29udHJhY3QvZW5jb2RlRXJyb3JSZXN1bHRcIjtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9hYmkvZW5jb2RlRnVuY3Rpb25SZXN1bHQuanNcXG4gIGZ1bmN0aW9uIGVuY29kZUZ1bmN0aW9uUmVzdWx0KHBhcmFtZXRlcnMpIHtcXG4gICAgY29uc3QgeyBhYmk6IGFiaTIsIGZ1bmN0aW9uTmFtZSwgcmVzdWx0IH0gPSBwYXJhbWV0ZXJzO1xcbiAgICBsZXQgYWJpSXRlbSA9IGFiaTJbMF07XFxuICAgIGlmIChmdW5jdGlvbk5hbWUpIHtcXG4gICAgICBjb25zdCBpdGVtID0gZ2V0QWJpSXRlbSh7IGFiaTogYWJpMiwgbmFtZTogZnVuY3Rpb25OYW1lIH0pO1xcbiAgICAgIGlmICghaXRlbSlcXG4gICAgICAgIHRocm93IG5ldyBBYmlGdW5jdGlvbk5vdEZvdW5kRXJyb3IoZnVuY3Rpb25OYW1lLCB7IGRvY3NQYXRoOiBkb2NzUGF0aDcgfSk7XFxuICAgICAgYWJpSXRlbSA9IGl0ZW07XFxuICAgIH1cXG4gICAgaWYgKGFiaUl0ZW0udHlwZSAhPT0gXCJmdW5jdGlvblwiKVxcbiAgICAgIHRocm93IG5ldyBBYmlGdW5jdGlvbk5vdEZvdW5kRXJyb3Iodm9pZCAwLCB7IGRvY3NQYXRoOiBkb2NzUGF0aDcgfSk7XFxuICAgIGlmICghYWJpSXRlbS5vdXRwdXRzKVxcbiAgICAgIHRocm93IG5ldyBBYmlGdW5jdGlvbk91dHB1dHNOb3RGb3VuZEVycm9yKGFiaUl0ZW0ubmFtZSwgeyBkb2NzUGF0aDogZG9jc1BhdGg3IH0pO1xcbiAgICBjb25zdCB2YWx1ZXMgPSAoKCkgPT4ge1xcbiAgICAgIGlmIChhYmlJdGVtLm91dHB1dHMubGVuZ3RoID09PSAwKVxcbiAgICAgICAgcmV0dXJuIFtdO1xcbiAgICAgIGlmIChhYmlJdGVtLm91dHB1dHMubGVuZ3RoID09PSAxKVxcbiAgICAgICAgcmV0dXJuIFtyZXN1bHRdO1xcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpXFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJyYXlFcnJvcihyZXN1bHQpO1xcbiAgICB9KSgpO1xcbiAgICByZXR1cm4gZW5jb2RlQWJpUGFyYW1ldGVycyhhYmlJdGVtLm91dHB1dHMsIHZhbHVlcyk7XFxuICB9XFxuICB2YXIgZG9jc1BhdGg3O1xcbiAgdmFyIGluaXRfZW5jb2RlRnVuY3Rpb25SZXN1bHQgPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvYWJpL2VuY29kZUZ1bmN0aW9uUmVzdWx0LmpzXCIoKSB7XFxuICAgICAgaW5pdF9hYmkoKTtcXG4gICAgICBpbml0X2VuY29kZUFiaVBhcmFtZXRlcnMoKTtcXG4gICAgICBpbml0X2dldEFiaUl0ZW0oKTtcXG4gICAgICBkb2NzUGF0aDcgPSBcIi9kb2NzL2NvbnRyYWN0L2VuY29kZUZ1bmN0aW9uUmVzdWx0XCI7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvZW5zL2xvY2FsQmF0Y2hHYXRld2F5UmVxdWVzdC5qc1xcbiAgYXN5bmMgZnVuY3Rpb24gbG9jYWxCYXRjaEdhdGV3YXlSZXF1ZXN0KHBhcmFtZXRlcnMpIHtcXG4gICAgY29uc3QgeyBkYXRhLCBjY2lwUmVxdWVzdDogY2NpcFJlcXVlc3QyIH0gPSBwYXJhbWV0ZXJzO1xcbiAgICBjb25zdCB7IGFyZ3M6IFtxdWVyaWVzXSB9ID0gZGVjb2RlRnVuY3Rpb25EYXRhKHsgYWJpOiBiYXRjaEdhdGV3YXlBYmksIGRhdGEgfSk7XFxuICAgIGNvbnN0IGZhaWx1cmVzID0gW107XFxuICAgIGNvbnN0IHJlc3BvbnNlcyA9IFtdO1xcbiAgICBhd2FpdCBQcm9taXNlLmFsbChxdWVyaWVzLm1hcChhc3luYyAocXVlcnksIGkpID0+IHtcXG4gICAgICB0cnkge1xcbiAgICAgICAgcmVzcG9uc2VzW2ldID0gYXdhaXQgY2NpcFJlcXVlc3QyKHF1ZXJ5KTtcXG4gICAgICAgIGZhaWx1cmVzW2ldID0gZmFsc2U7XFxuICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICBmYWlsdXJlc1tpXSA9IHRydWU7XFxuICAgICAgICByZXNwb25zZXNbaV0gPSBlbmNvZGVFcnJvcihlcnIpO1xcbiAgICAgIH1cXG4gICAgfSkpO1xcbiAgICByZXR1cm4gZW5jb2RlRnVuY3Rpb25SZXN1bHQoe1xcbiAgICAgIGFiaTogYmF0Y2hHYXRld2F5QWJpLFxcbiAgICAgIGZ1bmN0aW9uTmFtZTogXCJxdWVyeVwiLFxcbiAgICAgIHJlc3VsdDogW2ZhaWx1cmVzLCByZXNwb25zZXNdXFxuICAgIH0pO1xcbiAgfVxcbiAgZnVuY3Rpb24gZW5jb2RlRXJyb3IoZXJyb3IpIHtcXG4gICAgaWYgKGVycm9yLm5hbWUgPT09IFwiSHR0cFJlcXVlc3RFcnJvclwiICYmIGVycm9yLnN0YXR1cylcXG4gICAgICByZXR1cm4gZW5jb2RlRXJyb3JSZXN1bHQoe1xcbiAgICAgICAgYWJpOiBiYXRjaEdhdGV3YXlBYmksXFxuICAgICAgICBlcnJvck5hbWU6IFwiSHR0cEVycm9yXCIsXFxuICAgICAgICBhcmdzOiBbZXJyb3Iuc3RhdHVzLCBlcnJvci5zaG9ydE1lc3NhZ2VdXFxuICAgICAgfSk7XFxuICAgIHJldHVybiBlbmNvZGVFcnJvclJlc3VsdCh7XFxuICAgICAgYWJpOiBbc29saWRpdHlFcnJvcl0sXFxuICAgICAgZXJyb3JOYW1lOiBcIkVycm9yXCIsXFxuICAgICAgYXJnczogW1wic2hvcnRNZXNzYWdlXCIgaW4gZXJyb3IgPyBlcnJvci5zaG9ydE1lc3NhZ2UgOiBlcnJvci5tZXNzYWdlXVxcbiAgICB9KTtcXG4gIH1cXG4gIHZhciBsb2NhbEJhdGNoR2F0ZXdheVVybDtcXG4gIHZhciBpbml0X2xvY2FsQmF0Y2hHYXRld2F5UmVxdWVzdCA9IF9fZXNtKHtcXG4gICAgXCIuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9lbnMvbG9jYWxCYXRjaEdhdGV3YXlSZXF1ZXN0LmpzXCIoKSB7XFxuICAgICAgaW5pdF9hYmlzKCk7XFxuICAgICAgaW5pdF9zb2xpZGl0eSgpO1xcbiAgICAgIGluaXRfZGVjb2RlRnVuY3Rpb25EYXRhKCk7XFxuICAgICAgaW5pdF9lbmNvZGVFcnJvclJlc3VsdCgpO1xcbiAgICAgIGluaXRfZW5jb2RlRnVuY3Rpb25SZXN1bHQoKTtcXG4gICAgICBsb2NhbEJhdGNoR2F0ZXdheVVybCA9IFwieC1iYXRjaC1nYXRld2F5OnRydWVcIjtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9jY2lwLmpzXFxuICB2YXIgY2NpcF9leHBvcnRzID0ge307XFxuICBfX2V4cG9ydChjY2lwX2V4cG9ydHMsIHtcXG4gICAgY2NpcFJlcXVlc3Q6ICgpID0+IGNjaXBSZXF1ZXN0LFxcbiAgICBvZmZjaGFpbkxvb2t1cDogKCkgPT4gb2ZmY2hhaW5Mb29rdXAsXFxuICAgIG9mZmNoYWluTG9va3VwQWJpSXRlbTogKCkgPT4gb2ZmY2hhaW5Mb29rdXBBYmlJdGVtLFxcbiAgICBvZmZjaGFpbkxvb2t1cFNpZ25hdHVyZTogKCkgPT4gb2ZmY2hhaW5Mb29rdXBTaWduYXR1cmVcXG4gIH0pO1xcbiAgYXN5bmMgZnVuY3Rpb24gb2ZmY2hhaW5Mb29rdXAoY2xpZW50LCB7IGJsb2NrTnVtYmVyLCBibG9ja1RhZywgZGF0YSwgdG8gfSkge1xcbiAgICBjb25zdCB7IGFyZ3MgfSA9IGRlY29kZUVycm9yUmVzdWx0KHtcXG4gICAgICBkYXRhLFxcbiAgICAgIGFiaTogW29mZmNoYWluTG9va3VwQWJpSXRlbV1cXG4gICAgfSk7XFxuICAgIGNvbnN0IFtzZW5kZXIsIHVybHMsIGNhbGxEYXRhLCBjYWxsYmFja1NlbGVjdG9yLCBleHRyYURhdGFdID0gYXJncztcXG4gICAgY29uc3QgeyBjY2lwUmVhZCB9ID0gY2xpZW50O1xcbiAgICBjb25zdCBjY2lwUmVxdWVzdF8gPSBjY2lwUmVhZCAmJiB0eXBlb2YgY2NpcFJlYWQ/LnJlcXVlc3QgPT09IFwiZnVuY3Rpb25cIiA/IGNjaXBSZWFkLnJlcXVlc3QgOiBjY2lwUmVxdWVzdDtcXG4gICAgdHJ5IHtcXG4gICAgICBpZiAoIWlzQWRkcmVzc0VxdWFsKHRvLCBzZW5kZXIpKVxcbiAgICAgICAgdGhyb3cgbmV3IE9mZmNoYWluTG9va3VwU2VuZGVyTWlzbWF0Y2hFcnJvcih7IHNlbmRlciwgdG8gfSk7XFxuICAgICAgY29uc3QgcmVzdWx0ID0gdXJscy5pbmNsdWRlcyhsb2NhbEJhdGNoR2F0ZXdheVVybCkgPyBhd2FpdCBsb2NhbEJhdGNoR2F0ZXdheVJlcXVlc3Qoe1xcbiAgICAgICAgZGF0YTogY2FsbERhdGEsXFxuICAgICAgICBjY2lwUmVxdWVzdDogY2NpcFJlcXVlc3RfXFxuICAgICAgfSkgOiBhd2FpdCBjY2lwUmVxdWVzdF8oeyBkYXRhOiBjYWxsRGF0YSwgc2VuZGVyLCB1cmxzIH0pO1xcbiAgICAgIGNvbnN0IHsgZGF0YTogZGF0YV8gfSA9IGF3YWl0IGNhbGwoY2xpZW50LCB7XFxuICAgICAgICBibG9ja051bWJlcixcXG4gICAgICAgIGJsb2NrVGFnLFxcbiAgICAgICAgZGF0YTogY29uY2F0KFtcXG4gICAgICAgICAgY2FsbGJhY2tTZWxlY3RvcixcXG4gICAgICAgICAgZW5jb2RlQWJpUGFyYW1ldGVycyhbeyB0eXBlOiBcImJ5dGVzXCIgfSwgeyB0eXBlOiBcImJ5dGVzXCIgfV0sIFtyZXN1bHQsIGV4dHJhRGF0YV0pXFxuICAgICAgICBdKSxcXG4gICAgICAgIHRvXFxuICAgICAgfSk7XFxuICAgICAgcmV0dXJuIGRhdGFfO1xcbiAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICB0aHJvdyBuZXcgT2ZmY2hhaW5Mb29rdXBFcnJvcih7XFxuICAgICAgICBjYWxsYmFja1NlbGVjdG9yLFxcbiAgICAgICAgY2F1c2U6IGVycixcXG4gICAgICAgIGRhdGEsXFxuICAgICAgICBleHRyYURhdGEsXFxuICAgICAgICBzZW5kZXIsXFxuICAgICAgICB1cmxzXFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH1cXG4gIGFzeW5jIGZ1bmN0aW9uIGNjaXBSZXF1ZXN0KHsgZGF0YSwgc2VuZGVyLCB1cmxzIH0pIHtcXG4gICAgbGV0IGVycm9yID0gbmV3IEVycm9yKFwiQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZC5cIik7XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXJscy5sZW5ndGg7IGkrKykge1xcbiAgICAgIGNvbnN0IHVybCA9IHVybHNbaV07XFxuICAgICAgY29uc3QgbWV0aG9kID0gdXJsLmluY2x1ZGVzKFwie2RhdGF9XCIpID8gXCJHRVRcIiA6IFwiUE9TVFwiO1xcbiAgICAgIGNvbnN0IGJvZHkgPSBtZXRob2QgPT09IFwiUE9TVFwiID8geyBkYXRhLCBzZW5kZXIgfSA6IHZvaWQgMDtcXG4gICAgICBjb25zdCBoZWFkZXJzID0gbWV0aG9kID09PSBcIlBPU1RcIiA/IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSA6IHt9O1xcbiAgICAgIHRyeSB7XFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybC5yZXBsYWNlKFwie3NlbmRlcn1cIiwgc2VuZGVyLnRvTG93ZXJDYXNlKCkpLnJlcGxhY2UoXCJ7ZGF0YX1cIiwgZGF0YSksIHtcXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXFxuICAgICAgICAgIGhlYWRlcnMsXFxuICAgICAgICAgIG1ldGhvZFxcbiAgICAgICAgfSk7XFxuICAgICAgICBsZXQgcmVzdWx0O1xcbiAgICAgICAgaWYgKHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpPy5zdGFydHNXaXRoKFwiYXBwbGljYXRpb24vanNvblwiKSkge1xcbiAgICAgICAgICByZXN1bHQgPSAoYXdhaXQgcmVzcG9uc2UuanNvbigpKS5kYXRhO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xcbiAgICAgICAgICBlcnJvciA9IG5ldyBIdHRwUmVxdWVzdEVycm9yKHtcXG4gICAgICAgICAgICBib2R5LFxcbiAgICAgICAgICAgIGRldGFpbHM6IHJlc3VsdD8uZXJyb3IgPyBzdHJpbmdpZnkocmVzdWx0LmVycm9yKSA6IHJlc3BvbnNlLnN0YXR1c1RleHQsXFxuICAgICAgICAgICAgaGVhZGVyczogcmVzcG9uc2UuaGVhZGVycyxcXG4gICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcXG4gICAgICAgICAgICB1cmxcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCFpc0hleChyZXN1bHQpKSB7XFxuICAgICAgICAgIGVycm9yID0gbmV3IE9mZmNoYWluTG9va3VwUmVzcG9uc2VNYWxmb3JtZWRFcnJvcih7XFxuICAgICAgICAgICAgcmVzdWx0LFxcbiAgICAgICAgICAgIHVybFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgICAgZXJyb3IgPSBuZXcgSHR0cFJlcXVlc3RFcnJvcih7XFxuICAgICAgICAgIGJvZHksXFxuICAgICAgICAgIGRldGFpbHM6IGVyci5tZXNzYWdlLFxcbiAgICAgICAgICB1cmxcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICB0aHJvdyBlcnJvcjtcXG4gIH1cXG4gIHZhciBvZmZjaGFpbkxvb2t1cFNpZ25hdHVyZSwgb2ZmY2hhaW5Mb29rdXBBYmlJdGVtO1xcbiAgdmFyIGluaXRfY2NpcDIgPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvY2NpcC5qc1wiKCkge1xcbiAgICAgIGluaXRfY2FsbCgpO1xcbiAgICAgIGluaXRfY2NpcCgpO1xcbiAgICAgIGluaXRfcmVxdWVzdCgpO1xcbiAgICAgIGluaXRfZGVjb2RlRXJyb3JSZXN1bHQoKTtcXG4gICAgICBpbml0X2VuY29kZUFiaVBhcmFtZXRlcnMoKTtcXG4gICAgICBpbml0X2lzQWRkcmVzc0VxdWFsKCk7XFxuICAgICAgaW5pdF9jb25jYXQoKTtcXG4gICAgICBpbml0X2lzSGV4KCk7XFxuICAgICAgaW5pdF9sb2NhbEJhdGNoR2F0ZXdheVJlcXVlc3QoKTtcXG4gICAgICBpbml0X3N0cmluZ2lmeSgpO1xcbiAgICAgIG9mZmNoYWluTG9va3VwU2lnbmF0dXJlID0gXCIweDU1NmYxODMwXCI7XFxuICAgICAgb2ZmY2hhaW5Mb29rdXBBYmlJdGVtID0ge1xcbiAgICAgICAgbmFtZTogXCJPZmZjaGFpbkxvb2t1cFwiLFxcbiAgICAgICAgdHlwZTogXCJlcnJvclwiLFxcbiAgICAgICAgaW5wdXRzOiBbXFxuICAgICAgICAgIHtcXG4gICAgICAgICAgICBuYW1lOiBcInNlbmRlclwiLFxcbiAgICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIHtcXG4gICAgICAgICAgICBuYW1lOiBcInVybHNcIixcXG4gICAgICAgICAgICB0eXBlOiBcInN0cmluZ1tdXCJcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAge1xcbiAgICAgICAgICAgIG5hbWU6IFwiY2FsbERhdGFcIixcXG4gICAgICAgICAgICB0eXBlOiBcImJ5dGVzXCJcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAge1xcbiAgICAgICAgICAgIG5hbWU6IFwiY2FsbGJhY2tGdW5jdGlvblwiLFxcbiAgICAgICAgICAgIHR5cGU6IFwiYnl0ZXM0XCJcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAge1xcbiAgICAgICAgICAgIG5hbWU6IFwiZXh0cmFEYXRhXCIsXFxuICAgICAgICAgICAgdHlwZTogXCJieXRlc1wiXFxuICAgICAgICAgIH1cXG4gICAgICAgIF1cXG4gICAgICB9O1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjdGlvbnMvcHVibGljL2NhbGwuanNcXG4gIGFzeW5jIGZ1bmN0aW9uIGNhbGwoY2xpZW50LCBhcmdzKSB7XFxuICAgIGNvbnN0IHsgYWNjb3VudDogYWNjb3VudF8gPSBjbGllbnQuYWNjb3VudCwgYmF0Y2ggPSBCb29sZWFuKGNsaWVudC5iYXRjaD8ubXVsdGljYWxsKSwgYmxvY2tOdW1iZXIsIGJsb2NrVGFnID0gXCJsYXRlc3RcIiwgYWNjZXNzTGlzdCwgYmxvYnMsIGNvZGUsIGRhdGE6IGRhdGFfLCBmYWN0b3J5LCBmYWN0b3J5RGF0YSwgZ2FzLCBnYXNQcmljZSwgbWF4RmVlUGVyQmxvYkdhcywgbWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhcywgbm9uY2UsIHRvLCB2YWx1ZSwgc3RhdGVPdmVycmlkZSwgLi4ucmVzdCB9ID0gYXJncztcXG4gICAgY29uc3QgYWNjb3VudCA9IGFjY291bnRfID8gcGFyc2VBY2NvdW50KGFjY291bnRfKSA6IHZvaWQgMDtcXG4gICAgaWYgKGNvZGUgJiYgKGZhY3RvcnkgfHwgZmFjdG9yeURhdGEpKVxcbiAgICAgIHRocm93IG5ldyBCYXNlRXJyb3IyKFwiQ2Fubm90IHByb3ZpZGUgYm90aCBgY29kZWAgJiBgZmFjdG9yeWAvYGZhY3RvcnlEYXRhYCBhcyBwYXJhbWV0ZXJzLlwiKTtcXG4gICAgaWYgKGNvZGUgJiYgdG8pXFxuICAgICAgdGhyb3cgbmV3IEJhc2VFcnJvcjIoXCJDYW5ub3QgcHJvdmlkZSBib3RoIGBjb2RlYCAmIGB0b2AgYXMgcGFyYW1ldGVycy5cIik7XFxuICAgIGNvbnN0IGRlcGxveWxlc3NDYWxsVmlhQnl0ZWNvZGUgPSBjb2RlICYmIGRhdGFfO1xcbiAgICBjb25zdCBkZXBsb3lsZXNzQ2FsbFZpYUZhY3RvcnkgPSBmYWN0b3J5ICYmIGZhY3RvcnlEYXRhICYmIHRvICYmIGRhdGFfO1xcbiAgICBjb25zdCBkZXBsb3lsZXNzQ2FsbCA9IGRlcGxveWxlc3NDYWxsVmlhQnl0ZWNvZGUgfHwgZGVwbG95bGVzc0NhbGxWaWFGYWN0b3J5O1xcbiAgICBjb25zdCBkYXRhID0gKCgpID0+IHtcXG4gICAgICBpZiAoZGVwbG95bGVzc0NhbGxWaWFCeXRlY29kZSlcXG4gICAgICAgIHJldHVybiB0b0RlcGxveWxlc3NDYWxsVmlhQnl0ZWNvZGVEYXRhKHtcXG4gICAgICAgICAgY29kZSxcXG4gICAgICAgICAgZGF0YTogZGF0YV9cXG4gICAgICAgIH0pO1xcbiAgICAgIGlmIChkZXBsb3lsZXNzQ2FsbFZpYUZhY3RvcnkpXFxuICAgICAgICByZXR1cm4gdG9EZXBsb3lsZXNzQ2FsbFZpYUZhY3RvcnlEYXRhKHtcXG4gICAgICAgICAgZGF0YTogZGF0YV8sXFxuICAgICAgICAgIGZhY3RvcnksXFxuICAgICAgICAgIGZhY3RvcnlEYXRhLFxcbiAgICAgICAgICB0b1xcbiAgICAgICAgfSk7XFxuICAgICAgcmV0dXJuIGRhdGFfO1xcbiAgICB9KSgpO1xcbiAgICB0cnkge1xcbiAgICAgIGFzc2VydFJlcXVlc3QoYXJncyk7XFxuICAgICAgY29uc3QgYmxvY2tOdW1iZXJIZXggPSBibG9ja051bWJlciA/IG51bWJlclRvSGV4KGJsb2NrTnVtYmVyKSA6IHZvaWQgMDtcXG4gICAgICBjb25zdCBibG9jayA9IGJsb2NrTnVtYmVySGV4IHx8IGJsb2NrVGFnO1xcbiAgICAgIGNvbnN0IHJwY1N0YXRlT3ZlcnJpZGUgPSBzZXJpYWxpemVTdGF0ZU92ZXJyaWRlKHN0YXRlT3ZlcnJpZGUpO1xcbiAgICAgIGNvbnN0IGNoYWluRm9ybWF0ID0gY2xpZW50LmNoYWluPy5mb3JtYXR0ZXJzPy50cmFuc2FjdGlvblJlcXVlc3Q/LmZvcm1hdDtcXG4gICAgICBjb25zdCBmb3JtYXQgPSBjaGFpbkZvcm1hdCB8fCBmb3JtYXRUcmFuc2FjdGlvblJlcXVlc3Q7XFxuICAgICAgY29uc3QgcmVxdWVzdCA9IGZvcm1hdCh7XFxuICAgICAgICAvLyBQaWNrIG91dCBleHRyYSBkYXRhIHRoYXQgbWlnaHQgZXhpc3Qgb24gdGhlIGNoYWluXFwncyB0cmFuc2FjdGlvbiByZXF1ZXN0IHR5cGUuXFxuICAgICAgICAuLi5leHRyYWN0KHJlc3QsIHsgZm9ybWF0OiBjaGFpbkZvcm1hdCB9KSxcXG4gICAgICAgIGZyb206IGFjY291bnQ/LmFkZHJlc3MsXFxuICAgICAgICBhY2Nlc3NMaXN0LFxcbiAgICAgICAgYmxvYnMsXFxuICAgICAgICBkYXRhLFxcbiAgICAgICAgZ2FzLFxcbiAgICAgICAgZ2FzUHJpY2UsXFxuICAgICAgICBtYXhGZWVQZXJCbG9iR2FzLFxcbiAgICAgICAgbWF4RmVlUGVyR2FzLFxcbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXMsXFxuICAgICAgICBub25jZSxcXG4gICAgICAgIHRvOiBkZXBsb3lsZXNzQ2FsbCA/IHZvaWQgMCA6IHRvLFxcbiAgICAgICAgdmFsdWVcXG4gICAgICB9KTtcXG4gICAgICBpZiAoYmF0Y2ggJiYgc2hvdWxkUGVyZm9ybU11bHRpY2FsbCh7IHJlcXVlc3QgfSkgJiYgIXJwY1N0YXRlT3ZlcnJpZGUpIHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIHJldHVybiBhd2FpdCBzY2hlZHVsZU11bHRpY2FsbChjbGllbnQsIHtcXG4gICAgICAgICAgICAuLi5yZXF1ZXN0LFxcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyLFxcbiAgICAgICAgICAgIGJsb2NrVGFnXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIENsaWVudENoYWluTm90Q29uZmlndXJlZEVycm9yKSAmJiAhKGVyciBpbnN0YW5jZW9mIENoYWluRG9lc05vdFN1cHBvcnRDb250cmFjdCkpXFxuICAgICAgICAgICAgdGhyb3cgZXJyO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNsaWVudC5yZXF1ZXN0KHtcXG4gICAgICAgIG1ldGhvZDogXCJldGhfY2FsbFwiLFxcbiAgICAgICAgcGFyYW1zOiBycGNTdGF0ZU92ZXJyaWRlID8gW1xcbiAgICAgICAgICByZXF1ZXN0LFxcbiAgICAgICAgICBibG9jayxcXG4gICAgICAgICAgcnBjU3RhdGVPdmVycmlkZVxcbiAgICAgICAgXSA6IFtyZXF1ZXN0LCBibG9ja11cXG4gICAgICB9KTtcXG4gICAgICBpZiAocmVzcG9uc2UgPT09IFwiMHhcIilcXG4gICAgICAgIHJldHVybiB7IGRhdGE6IHZvaWQgMCB9O1xcbiAgICAgIHJldHVybiB7IGRhdGE6IHJlc3BvbnNlIH07XFxuICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgIGNvbnN0IGRhdGEyID0gZ2V0UmV2ZXJ0RXJyb3JEYXRhKGVycik7XFxuICAgICAgY29uc3QgeyBvZmZjaGFpbkxvb2t1cDogb2ZmY2hhaW5Mb29rdXAyLCBvZmZjaGFpbkxvb2t1cFNpZ25hdHVyZTogb2ZmY2hhaW5Mb29rdXBTaWduYXR1cmUyIH0gPSBhd2FpdCBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IChpbml0X2NjaXAyKCksIGNjaXBfZXhwb3J0cykpO1xcbiAgICAgIGlmIChjbGllbnQuY2NpcFJlYWQgIT09IGZhbHNlICYmIGRhdGEyPy5zbGljZSgwLCAxMCkgPT09IG9mZmNoYWluTG9va3VwU2lnbmF0dXJlMiAmJiB0bylcXG4gICAgICAgIHJldHVybiB7IGRhdGE6IGF3YWl0IG9mZmNoYWluTG9va3VwMihjbGllbnQsIHsgZGF0YTogZGF0YTIsIHRvIH0pIH07XFxuICAgICAgaWYgKGRlcGxveWxlc3NDYWxsICYmIGRhdGEyPy5zbGljZSgwLCAxMCkgPT09IFwiMHgxMDFiYjk4ZFwiKVxcbiAgICAgICAgdGhyb3cgbmV3IENvdW50ZXJmYWN0dWFsRGVwbG95bWVudEZhaWxlZEVycm9yKHsgZmFjdG9yeSB9KTtcXG4gICAgICB0aHJvdyBnZXRDYWxsRXJyb3IoZXJyLCB7XFxuICAgICAgICAuLi5hcmdzLFxcbiAgICAgICAgYWNjb3VudCxcXG4gICAgICAgIGNoYWluOiBjbGllbnQuY2hhaW5cXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfVxcbiAgZnVuY3Rpb24gc2hvdWxkUGVyZm9ybU11bHRpY2FsbCh7IHJlcXVlc3QgfSkge1xcbiAgICBjb25zdCB7IGRhdGEsIHRvLCAuLi5yZXF1ZXN0XyB9ID0gcmVxdWVzdDtcXG4gICAgaWYgKCFkYXRhKVxcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgaWYgKGRhdGEuc3RhcnRzV2l0aChhZ2dyZWdhdGUzU2lnbmF0dXJlKSlcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIGlmICghdG8pXFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhyZXF1ZXN0XykuZmlsdGVyKCh4KSA9PiB0eXBlb2YgeCAhPT0gXCJ1bmRlZmluZWRcIikubGVuZ3RoID4gMClcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIHJldHVybiB0cnVlO1xcbiAgfVxcbiAgYXN5bmMgZnVuY3Rpb24gc2NoZWR1bGVNdWx0aWNhbGwoY2xpZW50LCBhcmdzKSB7XFxuICAgIGNvbnN0IHsgYmF0Y2hTaXplID0gMTAyNCwgd2FpdDogd2FpdDIgPSAwIH0gPSB0eXBlb2YgY2xpZW50LmJhdGNoPy5tdWx0aWNhbGwgPT09IFwib2JqZWN0XCIgPyBjbGllbnQuYmF0Y2gubXVsdGljYWxsIDoge307XFxuICAgIGNvbnN0IHsgYmxvY2tOdW1iZXIsIGJsb2NrVGFnID0gXCJsYXRlc3RcIiwgZGF0YSwgbXVsdGljYWxsQWRkcmVzczogbXVsdGljYWxsQWRkcmVzc18sIHRvIH0gPSBhcmdzO1xcbiAgICBsZXQgbXVsdGljYWxsQWRkcmVzcyA9IG11bHRpY2FsbEFkZHJlc3NfO1xcbiAgICBpZiAoIW11bHRpY2FsbEFkZHJlc3MpIHtcXG4gICAgICBpZiAoIWNsaWVudC5jaGFpbilcXG4gICAgICAgIHRocm93IG5ldyBDbGllbnRDaGFpbk5vdENvbmZpZ3VyZWRFcnJvcigpO1xcbiAgICAgIG11bHRpY2FsbEFkZHJlc3MgPSBnZXRDaGFpbkNvbnRyYWN0QWRkcmVzcyh7XFxuICAgICAgICBibG9ja051bWJlcixcXG4gICAgICAgIGNoYWluOiBjbGllbnQuY2hhaW4sXFxuICAgICAgICBjb250cmFjdDogXCJtdWx0aWNhbGwzXCJcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICBjb25zdCBibG9ja051bWJlckhleCA9IGJsb2NrTnVtYmVyID8gbnVtYmVyVG9IZXgoYmxvY2tOdW1iZXIpIDogdm9pZCAwO1xcbiAgICBjb25zdCBibG9jayA9IGJsb2NrTnVtYmVySGV4IHx8IGJsb2NrVGFnO1xcbiAgICBjb25zdCB7IHNjaGVkdWxlIH0gPSBjcmVhdGVCYXRjaFNjaGVkdWxlcih7XFxuICAgICAgaWQ6IGAke2NsaWVudC51aWR9LiR7YmxvY2t9YCxcXG4gICAgICB3YWl0OiB3YWl0MixcXG4gICAgICBzaG91bGRTcGxpdEJhdGNoKGFyZ3MyKSB7XFxuICAgICAgICBjb25zdCBzaXplNSA9IGFyZ3MyLnJlZHVjZSgoc2l6ZTYsIHsgZGF0YTogZGF0YTIgfSkgPT4gc2l6ZTYgKyAoZGF0YTIubGVuZ3RoIC0gMiksIDApO1xcbiAgICAgICAgcmV0dXJuIHNpemU1ID4gYmF0Y2hTaXplICogMjtcXG4gICAgICB9LFxcbiAgICAgIGZuOiBhc3luYyAocmVxdWVzdHMpID0+IHtcXG4gICAgICAgIGNvbnN0IGNhbGxzID0gcmVxdWVzdHMubWFwKChyZXF1ZXN0KSA9PiAoe1xcbiAgICAgICAgICBhbGxvd0ZhaWx1cmU6IHRydWUsXFxuICAgICAgICAgIGNhbGxEYXRhOiByZXF1ZXN0LmRhdGEsXFxuICAgICAgICAgIHRhcmdldDogcmVxdWVzdC50b1xcbiAgICAgICAgfSkpO1xcbiAgICAgICAgY29uc3QgY2FsbGRhdGEgPSBlbmNvZGVGdW5jdGlvbkRhdGEoe1xcbiAgICAgICAgICBhYmk6IG11bHRpY2FsbDNBYmksXFxuICAgICAgICAgIGFyZ3M6IFtjYWxsc10sXFxuICAgICAgICAgIGZ1bmN0aW9uTmFtZTogXCJhZ2dyZWdhdGUzXCJcXG4gICAgICAgIH0pO1xcbiAgICAgICAgY29uc3QgZGF0YTIgPSBhd2FpdCBjbGllbnQucmVxdWVzdCh7XFxuICAgICAgICAgIG1ldGhvZDogXCJldGhfY2FsbFwiLFxcbiAgICAgICAgICBwYXJhbXM6IFtcXG4gICAgICAgICAgICB7XFxuICAgICAgICAgICAgICBkYXRhOiBjYWxsZGF0YSxcXG4gICAgICAgICAgICAgIHRvOiBtdWx0aWNhbGxBZGRyZXNzXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBibG9ja1xcbiAgICAgICAgICBdXFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiBkZWNvZGVGdW5jdGlvblJlc3VsdCh7XFxuICAgICAgICAgIGFiaTogbXVsdGljYWxsM0FiaSxcXG4gICAgICAgICAgYXJnczogW2NhbGxzXSxcXG4gICAgICAgICAgZnVuY3Rpb25OYW1lOiBcImFnZ3JlZ2F0ZTNcIixcXG4gICAgICAgICAgZGF0YTogZGF0YTIgfHwgXCIweFwiXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgICBjb25zdCBbeyByZXR1cm5EYXRhLCBzdWNjZXNzIH1dID0gYXdhaXQgc2NoZWR1bGUoeyBkYXRhLCB0byB9KTtcXG4gICAgaWYgKCFzdWNjZXNzKVxcbiAgICAgIHRocm93IG5ldyBSYXdDb250cmFjdEVycm9yKHsgZGF0YTogcmV0dXJuRGF0YSB9KTtcXG4gICAgaWYgKHJldHVybkRhdGEgPT09IFwiMHhcIilcXG4gICAgICByZXR1cm4geyBkYXRhOiB2b2lkIDAgfTtcXG4gICAgcmV0dXJuIHsgZGF0YTogcmV0dXJuRGF0YSB9O1xcbiAgfVxcbiAgZnVuY3Rpb24gdG9EZXBsb3lsZXNzQ2FsbFZpYUJ5dGVjb2RlRGF0YShwYXJhbWV0ZXJzKSB7XFxuICAgIGNvbnN0IHsgY29kZSwgZGF0YSB9ID0gcGFyYW1ldGVycztcXG4gICAgcmV0dXJuIGVuY29kZURlcGxveURhdGEoe1xcbiAgICAgIGFiaTogcGFyc2VBYmkoW1wiY29uc3RydWN0b3IoYnl0ZXMsIGJ5dGVzKVwiXSksXFxuICAgICAgYnl0ZWNvZGU6IGRlcGxveWxlc3NDYWxsVmlhQnl0ZWNvZGVCeXRlY29kZSxcXG4gICAgICBhcmdzOiBbY29kZSwgZGF0YV1cXG4gICAgfSk7XFxuICB9XFxuICBmdW5jdGlvbiB0b0RlcGxveWxlc3NDYWxsVmlhRmFjdG9yeURhdGEocGFyYW1ldGVycykge1xcbiAgICBjb25zdCB7IGRhdGEsIGZhY3RvcnksIGZhY3RvcnlEYXRhLCB0byB9ID0gcGFyYW1ldGVycztcXG4gICAgcmV0dXJuIGVuY29kZURlcGxveURhdGEoe1xcbiAgICAgIGFiaTogcGFyc2VBYmkoW1wiY29uc3RydWN0b3IoYWRkcmVzcywgYnl0ZXMsIGFkZHJlc3MsIGJ5dGVzKVwiXSksXFxuICAgICAgYnl0ZWNvZGU6IGRlcGxveWxlc3NDYWxsVmlhRmFjdG9yeUJ5dGVjb2RlLFxcbiAgICAgIGFyZ3M6IFt0bywgZGF0YSwgZmFjdG9yeSwgZmFjdG9yeURhdGFdXFxuICAgIH0pO1xcbiAgfVxcbiAgZnVuY3Rpb24gZ2V0UmV2ZXJ0RXJyb3JEYXRhKGVycikge1xcbiAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBCYXNlRXJyb3IyKSlcXG4gICAgICByZXR1cm4gdm9pZCAwO1xcbiAgICBjb25zdCBlcnJvciA9IGVyci53YWxrKCk7XFxuICAgIHJldHVybiB0eXBlb2YgZXJyb3I/LmRhdGEgPT09IFwib2JqZWN0XCIgPyBlcnJvci5kYXRhPy5kYXRhIDogZXJyb3IuZGF0YTtcXG4gIH1cXG4gIHZhciBpbml0X2NhbGwgPSBfX2VzbSh7XFxuICAgIFwiLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vYWN0aW9ucy9wdWJsaWMvY2FsbC5qc1wiKCkge1xcbiAgICAgIGluaXRfZXhwb3J0cygpO1xcbiAgICAgIGluaXRfcGFyc2VBY2NvdW50KCk7XFxuICAgICAgaW5pdF9hYmlzKCk7XFxuICAgICAgaW5pdF9jb250cmFjdDIoKTtcXG4gICAgICBpbml0X2NvbnRyYWN0cygpO1xcbiAgICAgIGluaXRfYmFzZSgpO1xcbiAgICAgIGluaXRfY2hhaW4oKTtcXG4gICAgICBpbml0X2NvbnRyYWN0KCk7XFxuICAgICAgaW5pdF9kZWNvZGVGdW5jdGlvblJlc3VsdCgpO1xcbiAgICAgIGluaXRfZW5jb2RlRGVwbG95RGF0YSgpO1xcbiAgICAgIGluaXRfZW5jb2RlRnVuY3Rpb25EYXRhKCk7XFxuICAgICAgaW5pdF9nZXRDaGFpbkNvbnRyYWN0QWRkcmVzcygpO1xcbiAgICAgIGluaXRfdG9IZXgoKTtcXG4gICAgICBpbml0X2dldENhbGxFcnJvcigpO1xcbiAgICAgIGluaXRfZXh0cmFjdCgpO1xcbiAgICAgIGluaXRfdHJhbnNhY3Rpb25SZXF1ZXN0KCk7XFxuICAgICAgaW5pdF9jcmVhdGVCYXRjaFNjaGVkdWxlcigpO1xcbiAgICAgIGluaXRfc3RhdGVPdmVycmlkZTIoKTtcXG4gICAgICBpbml0X2Fzc2VydFJlcXVlc3QoKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9nZXRBY3Rpb24uanNcXG4gIGZ1bmN0aW9uIGdldEFjdGlvbihjbGllbnQsIGFjdGlvbkZuLCBuYW1lKSB7XFxuICAgIGNvbnN0IGFjdGlvbl9pbXBsaWNpdCA9IGNsaWVudFthY3Rpb25Gbi5uYW1lXTtcXG4gICAgaWYgKHR5cGVvZiBhY3Rpb25faW1wbGljaXQgPT09IFwiZnVuY3Rpb25cIilcXG4gICAgICByZXR1cm4gYWN0aW9uX2ltcGxpY2l0O1xcbiAgICBjb25zdCBhY3Rpb25fZXhwbGljaXQgPSBjbGllbnRbbmFtZV07XFxuICAgIGlmICh0eXBlb2YgYWN0aW9uX2V4cGxpY2l0ID09PSBcImZ1bmN0aW9uXCIpXFxuICAgICAgcmV0dXJuIGFjdGlvbl9leHBsaWNpdDtcXG4gICAgcmV0dXJuIChwYXJhbXMpID0+IGFjdGlvbkZuKGNsaWVudCwgcGFyYW1zKTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2FiaS9lbmNvZGVFdmVudFRvcGljcy5qc1xcbiAgaW5pdF9hYmkoKTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2Vycm9ycy9sb2cuanNcXG4gIGluaXRfYmFzZSgpO1xcbiAgdmFyIEZpbHRlclR5cGVOb3RTdXBwb3J0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgIGNvbnN0cnVjdG9yKHR5cGUpIHtcXG4gICAgICBzdXBlcihgRmlsdGVyIHR5cGUgXCIke3R5cGV9XCIgaXMgbm90IHN1cHBvcnRlZC5gLCB7XFxuICAgICAgICBuYW1lOiBcIkZpbHRlclR5cGVOb3RTdXBwb3J0ZWRFcnJvclwiXFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH07XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9hYmkvZW5jb2RlRXZlbnRUb3BpY3MuanNcXG4gIGluaXRfdG9CeXRlcygpO1xcbiAgaW5pdF9rZWNjYWsyNTYoKTtcXG4gIGluaXRfdG9FdmVudFNlbGVjdG9yKCk7XFxuICBpbml0X2VuY29kZUFiaVBhcmFtZXRlcnMoKTtcXG4gIGluaXRfZm9ybWF0QWJpSXRlbTIoKTtcXG4gIGluaXRfZ2V0QWJpSXRlbSgpO1xcbiAgdmFyIGRvY3NQYXRoID0gXCIvZG9jcy9jb250cmFjdC9lbmNvZGVFdmVudFRvcGljc1wiO1xcbiAgZnVuY3Rpb24gZW5jb2RlRXZlbnRUb3BpY3MocGFyYW1ldGVycykge1xcbiAgICBjb25zdCB7IGFiaTogYWJpMiwgZXZlbnROYW1lLCBhcmdzIH0gPSBwYXJhbWV0ZXJzO1xcbiAgICBsZXQgYWJpSXRlbSA9IGFiaTJbMF07XFxuICAgIGlmIChldmVudE5hbWUpIHtcXG4gICAgICBjb25zdCBpdGVtID0gZ2V0QWJpSXRlbSh7IGFiaTogYWJpMiwgbmFtZTogZXZlbnROYW1lIH0pO1xcbiAgICAgIGlmICghaXRlbSlcXG4gICAgICAgIHRocm93IG5ldyBBYmlFdmVudE5vdEZvdW5kRXJyb3IoZXZlbnROYW1lLCB7IGRvY3NQYXRoIH0pO1xcbiAgICAgIGFiaUl0ZW0gPSBpdGVtO1xcbiAgICB9XFxuICAgIGlmIChhYmlJdGVtLnR5cGUgIT09IFwiZXZlbnRcIilcXG4gICAgICB0aHJvdyBuZXcgQWJpRXZlbnROb3RGb3VuZEVycm9yKHZvaWQgMCwgeyBkb2NzUGF0aCB9KTtcXG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IGZvcm1hdEFiaUl0ZW0yKGFiaUl0ZW0pO1xcbiAgICBjb25zdCBzaWduYXR1cmUgPSB0b0V2ZW50U2VsZWN0b3IoZGVmaW5pdGlvbik7XFxuICAgIGxldCB0b3BpY3MgPSBbXTtcXG4gICAgaWYgKGFyZ3MgJiYgXCJpbnB1dHNcIiBpbiBhYmlJdGVtKSB7XFxuICAgICAgY29uc3QgaW5kZXhlZElucHV0cyA9IGFiaUl0ZW0uaW5wdXRzPy5maWx0ZXIoKHBhcmFtKSA9PiBcImluZGV4ZWRcIiBpbiBwYXJhbSAmJiBwYXJhbS5pbmRleGVkKTtcXG4gICAgICBjb25zdCBhcmdzXyA9IEFycmF5LmlzQXJyYXkoYXJncykgPyBhcmdzIDogT2JqZWN0LnZhbHVlcyhhcmdzKS5sZW5ndGggPiAwID8gaW5kZXhlZElucHV0cz8ubWFwKCh4KSA9PiBhcmdzW3gubmFtZV0pID8/IFtdIDogW107XFxuICAgICAgaWYgKGFyZ3NfLmxlbmd0aCA+IDApIHtcXG4gICAgICAgIHRvcGljcyA9IGluZGV4ZWRJbnB1dHM/Lm1hcCgocGFyYW0sIGkpID0+IHtcXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnc19baV0pKVxcbiAgICAgICAgICAgIHJldHVybiBhcmdzX1tpXS5tYXAoKF8sIGopID0+IGVuY29kZUFyZyh7IHBhcmFtLCB2YWx1ZTogYXJnc19baV1bal0gfSkpO1xcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIGFyZ3NfW2ldICE9PSBcInVuZGVmaW5lZFwiICYmIGFyZ3NfW2ldICE9PSBudWxsID8gZW5jb2RlQXJnKHsgcGFyYW0sIHZhbHVlOiBhcmdzX1tpXSB9KSA6IG51bGw7XFxuICAgICAgICB9KSA/PyBbXTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIFtzaWduYXR1cmUsIC4uLnRvcGljc107XFxuICB9XFxuICBmdW5jdGlvbiBlbmNvZGVBcmcoeyBwYXJhbSwgdmFsdWUgfSkge1xcbiAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBwYXJhbS50eXBlID09PSBcImJ5dGVzXCIpXFxuICAgICAgcmV0dXJuIGtlY2NhazI1Nih0b0J5dGVzKHZhbHVlKSk7XFxuICAgIGlmIChwYXJhbS50eXBlID09PSBcInR1cGxlXCIgfHwgcGFyYW0udHlwZS5tYXRjaCgvXiguKilcXFxcWyhcXFxcZCspP1xcXFxdJC8pKVxcbiAgICAgIHRocm93IG5ldyBGaWx0ZXJUeXBlTm90U3VwcG9ydGVkRXJyb3IocGFyYW0udHlwZSk7XFxuICAgIHJldHVybiBlbmNvZGVBYmlQYXJhbWV0ZXJzKFtwYXJhbV0sIFt2YWx1ZV0pO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vYWN0aW9ucy9wdWJsaWMvY3JlYXRlQ29udHJhY3RFdmVudEZpbHRlci5qc1xcbiAgaW5pdF90b0hleCgpO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvZmlsdGVycy9jcmVhdGVGaWx0ZXJSZXF1ZXN0U2NvcGUuanNcXG4gIGZ1bmN0aW9uIGNyZWF0ZUZpbHRlclJlcXVlc3RTY29wZShjbGllbnQsIHsgbWV0aG9kIH0pIHtcXG4gICAgY29uc3QgcmVxdWVzdE1hcCA9IHt9O1xcbiAgICBpZiAoY2xpZW50LnRyYW5zcG9ydC50eXBlID09PSBcImZhbGxiYWNrXCIpXFxuICAgICAgY2xpZW50LnRyYW5zcG9ydC5vblJlc3BvbnNlPy4oKHsgbWV0aG9kOiBtZXRob2RfLCByZXNwb25zZTogaWQsIHN0YXR1cywgdHJhbnNwb3J0IH0pID0+IHtcXG4gICAgICAgIGlmIChzdGF0dXMgPT09IFwic3VjY2Vzc1wiICYmIG1ldGhvZCA9PT0gbWV0aG9kXylcXG4gICAgICAgICAgcmVxdWVzdE1hcFtpZF0gPSB0cmFuc3BvcnQucmVxdWVzdDtcXG4gICAgICB9KTtcXG4gICAgcmV0dXJuIChpZCkgPT4gcmVxdWVzdE1hcFtpZF0gfHwgY2xpZW50LnJlcXVlc3Q7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL3B1YmxpYy9jcmVhdGVDb250cmFjdEV2ZW50RmlsdGVyLmpzXFxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVDb250cmFjdEV2ZW50RmlsdGVyKGNsaWVudCwgcGFyYW1ldGVycykge1xcbiAgICBjb25zdCB7IGFkZHJlc3MsIGFiaTogYWJpMiwgYXJncywgZXZlbnROYW1lLCBmcm9tQmxvY2ssIHN0cmljdCwgdG9CbG9jayB9ID0gcGFyYW1ldGVycztcXG4gICAgY29uc3QgZ2V0UmVxdWVzdCA9IGNyZWF0ZUZpbHRlclJlcXVlc3RTY29wZShjbGllbnQsIHtcXG4gICAgICBtZXRob2Q6IFwiZXRoX25ld0ZpbHRlclwiXFxuICAgIH0pO1xcbiAgICBjb25zdCB0b3BpY3MgPSBldmVudE5hbWUgPyBlbmNvZGVFdmVudFRvcGljcyh7XFxuICAgICAgYWJpOiBhYmkyLFxcbiAgICAgIGFyZ3MsXFxuICAgICAgZXZlbnROYW1lXFxuICAgIH0pIDogdm9pZCAwO1xcbiAgICBjb25zdCBpZCA9IGF3YWl0IGNsaWVudC5yZXF1ZXN0KHtcXG4gICAgICBtZXRob2Q6IFwiZXRoX25ld0ZpbHRlclwiLFxcbiAgICAgIHBhcmFtczogW1xcbiAgICAgICAge1xcbiAgICAgICAgICBhZGRyZXNzLFxcbiAgICAgICAgICBmcm9tQmxvY2s6IHR5cGVvZiBmcm9tQmxvY2sgPT09IFwiYmlnaW50XCIgPyBudW1iZXJUb0hleChmcm9tQmxvY2spIDogZnJvbUJsb2NrLFxcbiAgICAgICAgICB0b0Jsb2NrOiB0eXBlb2YgdG9CbG9jayA9PT0gXCJiaWdpbnRcIiA/IG51bWJlclRvSGV4KHRvQmxvY2spIDogdG9CbG9jayxcXG4gICAgICAgICAgdG9waWNzXFxuICAgICAgICB9XFxuICAgICAgXVxcbiAgICB9KTtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBhYmk6IGFiaTIsXFxuICAgICAgYXJncyxcXG4gICAgICBldmVudE5hbWUsXFxuICAgICAgaWQsXFxuICAgICAgcmVxdWVzdDogZ2V0UmVxdWVzdChpZCksXFxuICAgICAgc3RyaWN0OiBCb29sZWFuKHN0cmljdCksXFxuICAgICAgdHlwZTogXCJldmVudFwiXFxuICAgIH07XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL3B1YmxpYy9lc3RpbWF0ZUNvbnRyYWN0R2FzLmpzXFxuICBpbml0X3BhcnNlQWNjb3VudCgpO1xcbiAgaW5pdF9lbmNvZGVGdW5jdGlvbkRhdGEoKTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2Vycm9ycy9nZXRDb250cmFjdEVycm9yLmpzXFxuICBpbml0X2FiaSgpO1xcbiAgaW5pdF9iYXNlKCk7XFxuICBpbml0X2NvbnRyYWN0KCk7XFxuICBpbml0X3JlcXVlc3QoKTtcXG4gIGluaXRfcnBjKCk7XFxuICB2YXIgRVhFQ1VUSU9OX1JFVkVSVEVEX0VSUk9SX0NPREUgPSAzO1xcbiAgZnVuY3Rpb24gZ2V0Q29udHJhY3RFcnJvcihlcnIsIHsgYWJpOiBhYmkyLCBhZGRyZXNzLCBhcmdzLCBkb2NzUGF0aDogZG9jc1BhdGg4LCBmdW5jdGlvbk5hbWUsIHNlbmRlciB9KSB7XFxuICAgIGNvbnN0IGVycm9yID0gZXJyIGluc3RhbmNlb2YgUmF3Q29udHJhY3RFcnJvciA/IGVyciA6IGVyciBpbnN0YW5jZW9mIEJhc2VFcnJvcjIgPyBlcnIud2FsaygoZXJyMikgPT4gXCJkYXRhXCIgaW4gZXJyMikgfHwgZXJyLndhbGsoKSA6IHt9O1xcbiAgICBjb25zdCB7IGNvZGUsIGRhdGEsIGRldGFpbHMsIG1lc3NhZ2UsIHNob3J0TWVzc2FnZSB9ID0gZXJyb3I7XFxuICAgIGNvbnN0IGNhdXNlID0gKCgpID0+IHtcXG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQWJpRGVjb2RpbmdaZXJvRGF0YUVycm9yKVxcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdEZ1bmN0aW9uWmVyb0RhdGFFcnJvcih7IGZ1bmN0aW9uTmFtZSB9KTtcXG4gICAgICBpZiAoW0VYRUNVVElPTl9SRVZFUlRFRF9FUlJPUl9DT0RFLCBJbnRlcm5hbFJwY0Vycm9yLmNvZGVdLmluY2x1ZGVzKGNvZGUpICYmIChkYXRhIHx8IGRldGFpbHMgfHwgbWVzc2FnZSB8fCBzaG9ydE1lc3NhZ2UpKSB7XFxuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0RnVuY3Rpb25SZXZlcnRlZEVycm9yKHtcXG4gICAgICAgICAgYWJpOiBhYmkyLFxcbiAgICAgICAgICBkYXRhOiB0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIiA/IGRhdGEuZGF0YSA6IGRhdGEsXFxuICAgICAgICAgIGZ1bmN0aW9uTmFtZSxcXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IgaW5zdGFuY2VvZiBScGNSZXF1ZXN0RXJyb3IgPyBkZXRhaWxzIDogc2hvcnRNZXNzYWdlID8/IG1lc3NhZ2VcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gZXJyO1xcbiAgICB9KSgpO1xcbiAgICByZXR1cm4gbmV3IENvbnRyYWN0RnVuY3Rpb25FeGVjdXRpb25FcnJvcihjYXVzZSwge1xcbiAgICAgIGFiaTogYWJpMixcXG4gICAgICBhcmdzLFxcbiAgICAgIGNvbnRyYWN0QWRkcmVzczogYWRkcmVzcyxcXG4gICAgICBkb2NzUGF0aDogZG9jc1BhdGg4LFxcbiAgICAgIGZ1bmN0aW9uTmFtZSxcXG4gICAgICBzZW5kZXJcXG4gICAgfSk7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL3B1YmxpYy9lc3RpbWF0ZUdhcy5qc1xcbiAgaW5pdF9wYXJzZUFjY291bnQoKTtcXG4gIGluaXRfYmFzZSgpO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vYWNjb3VudHMvdXRpbHMvcHVibGljS2V5VG9BZGRyZXNzLmpzXFxuICBpbml0X2dldEFkZHJlc3MoKTtcXG4gIGluaXRfa2VjY2FrMjU2KCk7XFxuICBmdW5jdGlvbiBwdWJsaWNLZXlUb0FkZHJlc3MocHVibGljS2V5KSB7XFxuICAgIGNvbnN0IGFkZHJlc3MgPSBrZWNjYWsyNTYoYDB4JHtwdWJsaWNLZXkuc3Vic3RyaW5nKDQpfWApLnN1YnN0cmluZygyNik7XFxuICAgIHJldHVybiBjaGVja3N1bUFkZHJlc3MoYDB4JHthZGRyZXNzfWApO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvc2lnbmF0dXJlL3JlY292ZXJQdWJsaWNLZXkuanNcXG4gIGluaXRfaXNIZXgoKTtcXG4gIGluaXRfZnJvbUhleCgpO1xcbiAgaW5pdF90b0hleCgpO1xcbiAgYXN5bmMgZnVuY3Rpb24gcmVjb3ZlclB1YmxpY0tleSh7IGhhc2g6IGhhc2gyLCBzaWduYXR1cmUgfSkge1xcbiAgICBjb25zdCBoYXNoSGV4ID0gaXNIZXgoaGFzaDIpID8gaGFzaDIgOiB0b0hleChoYXNoMik7XFxuICAgIGNvbnN0IHsgc2VjcDI1NmsxOiBzZWNwMjU2azEyIH0gPSBhd2FpdCBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IChpbml0X3NlY3AyNTZrMSgpLCBzZWNwMjU2azFfZXhwb3J0cykpO1xcbiAgICBjb25zdCBzaWduYXR1cmVfID0gKCgpID0+IHtcXG4gICAgICBpZiAodHlwZW9mIHNpZ25hdHVyZSA9PT0gXCJvYmplY3RcIiAmJiBcInJcIiBpbiBzaWduYXR1cmUgJiYgXCJzXCIgaW4gc2lnbmF0dXJlKSB7XFxuICAgICAgICBjb25zdCB7IHIsIHMsIHYsIHlQYXJpdHkgfSA9IHNpZ25hdHVyZTtcXG4gICAgICAgIGNvbnN0IHlQYXJpdHlPclYyID0gTnVtYmVyKHlQYXJpdHkgPz8gdik7XFxuICAgICAgICBjb25zdCByZWNvdmVyeUJpdDIgPSB0b1JlY292ZXJ5Qml0KHlQYXJpdHlPclYyKTtcXG4gICAgICAgIHJldHVybiBuZXcgc2VjcDI1NmsxMi5TaWduYXR1cmUoaGV4VG9CaWdJbnQociksIGhleFRvQmlnSW50KHMpKS5hZGRSZWNvdmVyeUJpdChyZWNvdmVyeUJpdDIpO1xcbiAgICAgIH1cXG4gICAgICBjb25zdCBzaWduYXR1cmVIZXggPSBpc0hleChzaWduYXR1cmUpID8gc2lnbmF0dXJlIDogdG9IZXgoc2lnbmF0dXJlKTtcXG4gICAgICBjb25zdCB5UGFyaXR5T3JWID0gaGV4VG9OdW1iZXIoYDB4JHtzaWduYXR1cmVIZXguc2xpY2UoMTMwKX1gKTtcXG4gICAgICBjb25zdCByZWNvdmVyeUJpdCA9IHRvUmVjb3ZlcnlCaXQoeVBhcml0eU9yVik7XFxuICAgICAgcmV0dXJuIHNlY3AyNTZrMTIuU2lnbmF0dXJlLmZyb21Db21wYWN0KHNpZ25hdHVyZUhleC5zdWJzdHJpbmcoMiwgMTMwKSkuYWRkUmVjb3ZlcnlCaXQocmVjb3ZlcnlCaXQpO1xcbiAgICB9KSgpO1xcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBzaWduYXR1cmVfLnJlY292ZXJQdWJsaWNLZXkoaGFzaEhleC5zdWJzdHJpbmcoMikpLnRvSGV4KGZhbHNlKTtcXG4gICAgcmV0dXJuIGAweCR7cHVibGljS2V5fWA7XFxuICB9XFxuICBmdW5jdGlvbiB0b1JlY292ZXJ5Qml0KHlQYXJpdHlPclYpIHtcXG4gICAgaWYgKHlQYXJpdHlPclYgPT09IDAgfHwgeVBhcml0eU9yViA9PT0gMSlcXG4gICAgICByZXR1cm4geVBhcml0eU9yVjtcXG4gICAgaWYgKHlQYXJpdHlPclYgPT09IDI3KVxcbiAgICAgIHJldHVybiAwO1xcbiAgICBpZiAoeVBhcml0eU9yViA9PT0gMjgpXFxuICAgICAgcmV0dXJuIDE7XFxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgeVBhcml0eU9yViB2YWx1ZVwiKTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL3NpZ25hdHVyZS9yZWNvdmVyQWRkcmVzcy5qc1xcbiAgYXN5bmMgZnVuY3Rpb24gcmVjb3ZlckFkZHJlc3MoeyBoYXNoOiBoYXNoMiwgc2lnbmF0dXJlIH0pIHtcXG4gICAgcmV0dXJuIHB1YmxpY0tleVRvQWRkcmVzcyhhd2FpdCByZWNvdmVyUHVibGljS2V5KHsgaGFzaDogaGFzaDIsIHNpZ25hdHVyZSB9KSk7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9hdXRob3JpemF0aW9uL2hhc2hBdXRob3JpemF0aW9uLmpzXFxuICBpbml0X2NvbmNhdCgpO1xcbiAgaW5pdF90b0J5dGVzKCk7XFxuICBpbml0X3RvSGV4KCk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9lbmNvZGluZy90b1JscC5qc1xcbiAgaW5pdF9iYXNlKCk7XFxuICBpbml0X2N1cnNvcjIoKTtcXG4gIGluaXRfdG9CeXRlcygpO1xcbiAgaW5pdF90b0hleCgpO1xcbiAgZnVuY3Rpb24gdG9SbHAoYnl0ZXMsIHRvID0gXCJoZXhcIikge1xcbiAgICBjb25zdCBlbmNvZGFibGUgPSBnZXRFbmNvZGFibGUoYnl0ZXMpO1xcbiAgICBjb25zdCBjdXJzb3IgPSBjcmVhdGVDdXJzb3IobmV3IFVpbnQ4QXJyYXkoZW5jb2RhYmxlLmxlbmd0aCkpO1xcbiAgICBlbmNvZGFibGUuZW5jb2RlKGN1cnNvcik7XFxuICAgIGlmICh0byA9PT0gXCJoZXhcIilcXG4gICAgICByZXR1cm4gYnl0ZXNUb0hleChjdXJzb3IuYnl0ZXMpO1xcbiAgICByZXR1cm4gY3Vyc29yLmJ5dGVzO1xcbiAgfVxcbiAgZnVuY3Rpb24gZ2V0RW5jb2RhYmxlKGJ5dGVzKSB7XFxuICAgIGlmIChBcnJheS5pc0FycmF5KGJ5dGVzKSlcXG4gICAgICByZXR1cm4gZ2V0RW5jb2RhYmxlTGlzdChieXRlcy5tYXAoKHgpID0+IGdldEVuY29kYWJsZSh4KSkpO1xcbiAgICByZXR1cm4gZ2V0RW5jb2RhYmxlQnl0ZXMoYnl0ZXMpO1xcbiAgfVxcbiAgZnVuY3Rpb24gZ2V0RW5jb2RhYmxlTGlzdChsaXN0KSB7XFxuICAgIGNvbnN0IGJvZHlMZW5ndGggPSBsaXN0LnJlZHVjZSgoYWNjLCB4KSA9PiBhY2MgKyB4Lmxlbmd0aCwgMCk7XFxuICAgIGNvbnN0IHNpemVPZkJvZHlMZW5ndGggPSBnZXRTaXplT2ZMZW5ndGgoYm9keUxlbmd0aCk7XFxuICAgIGNvbnN0IGxlbmd0aCA9ICgoKSA9PiB7XFxuICAgICAgaWYgKGJvZHlMZW5ndGggPD0gNTUpXFxuICAgICAgICByZXR1cm4gMSArIGJvZHlMZW5ndGg7XFxuICAgICAgcmV0dXJuIDEgKyBzaXplT2ZCb2R5TGVuZ3RoICsgYm9keUxlbmd0aDtcXG4gICAgfSkoKTtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBsZW5ndGgsXFxuICAgICAgZW5jb2RlKGN1cnNvcikge1xcbiAgICAgICAgaWYgKGJvZHlMZW5ndGggPD0gNTUpIHtcXG4gICAgICAgICAgY3Vyc29yLnB1c2hCeXRlKDE5MiArIGJvZHlMZW5ndGgpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgY3Vyc29yLnB1c2hCeXRlKDE5MiArIDU1ICsgc2l6ZU9mQm9keUxlbmd0aCk7XFxuICAgICAgICAgIGlmIChzaXplT2ZCb2R5TGVuZ3RoID09PSAxKVxcbiAgICAgICAgICAgIGN1cnNvci5wdXNoVWludDgoYm9keUxlbmd0aCk7XFxuICAgICAgICAgIGVsc2UgaWYgKHNpemVPZkJvZHlMZW5ndGggPT09IDIpXFxuICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50MTYoYm9keUxlbmd0aCk7XFxuICAgICAgICAgIGVsc2UgaWYgKHNpemVPZkJvZHlMZW5ndGggPT09IDMpXFxuICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50MjQoYm9keUxlbmd0aCk7XFxuICAgICAgICAgIGVsc2VcXG4gICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQzMihib2R5TGVuZ3RoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGZvciAoY29uc3QgeyBlbmNvZGU6IGVuY29kZTQgfSBvZiBsaXN0KSB7XFxuICAgICAgICAgIGVuY29kZTQoY3Vyc29yKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuICBmdW5jdGlvbiBnZXRFbmNvZGFibGVCeXRlcyhieXRlc09ySGV4KSB7XFxuICAgIGNvbnN0IGJ5dGVzID0gdHlwZW9mIGJ5dGVzT3JIZXggPT09IFwic3RyaW5nXCIgPyBoZXhUb0J5dGVzKGJ5dGVzT3JIZXgpIDogYnl0ZXNPckhleDtcXG4gICAgY29uc3Qgc2l6ZU9mQnl0ZXNMZW5ndGggPSBnZXRTaXplT2ZMZW5ndGgoYnl0ZXMubGVuZ3RoKTtcXG4gICAgY29uc3QgbGVuZ3RoID0gKCgpID0+IHtcXG4gICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAxICYmIGJ5dGVzWzBdIDwgMTI4KVxcbiAgICAgICAgcmV0dXJuIDE7XFxuICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA8PSA1NSlcXG4gICAgICAgIHJldHVybiAxICsgYnl0ZXMubGVuZ3RoO1xcbiAgICAgIHJldHVybiAxICsgc2l6ZU9mQnl0ZXNMZW5ndGggKyBieXRlcy5sZW5ndGg7XFxuICAgIH0pKCk7XFxuICAgIHJldHVybiB7XFxuICAgICAgbGVuZ3RoLFxcbiAgICAgIGVuY29kZShjdXJzb3IpIHtcXG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDEgJiYgYnl0ZXNbMF0gPCAxMjgpIHtcXG4gICAgICAgICAgY3Vyc29yLnB1c2hCeXRlcyhieXRlcyk7XFxuICAgICAgICB9IGVsc2UgaWYgKGJ5dGVzLmxlbmd0aCA8PSA1NSkge1xcbiAgICAgICAgICBjdXJzb3IucHVzaEJ5dGUoMTI4ICsgYnl0ZXMubGVuZ3RoKTtcXG4gICAgICAgICAgY3Vyc29yLnB1c2hCeXRlcyhieXRlcyk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBjdXJzb3IucHVzaEJ5dGUoMTI4ICsgNTUgKyBzaXplT2ZCeXRlc0xlbmd0aCk7XFxuICAgICAgICAgIGlmIChzaXplT2ZCeXRlc0xlbmd0aCA9PT0gMSlcXG4gICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQ4KGJ5dGVzLmxlbmd0aCk7XFxuICAgICAgICAgIGVsc2UgaWYgKHNpemVPZkJ5dGVzTGVuZ3RoID09PSAyKVxcbiAgICAgICAgICAgIGN1cnNvci5wdXNoVWludDE2KGJ5dGVzLmxlbmd0aCk7XFxuICAgICAgICAgIGVsc2UgaWYgKHNpemVPZkJ5dGVzTGVuZ3RoID09PSAzKVxcbiAgICAgICAgICAgIGN1cnNvci5wdXNoVWludDI0KGJ5dGVzLmxlbmd0aCk7XFxuICAgICAgICAgIGVsc2VcXG4gICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQzMihieXRlcy5sZW5ndGgpO1xcbiAgICAgICAgICBjdXJzb3IucHVzaEJ5dGVzKGJ5dGVzKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuICBmdW5jdGlvbiBnZXRTaXplT2ZMZW5ndGgobGVuZ3RoKSB7XFxuICAgIGlmIChsZW5ndGggPCAyICoqIDgpXFxuICAgICAgcmV0dXJuIDE7XFxuICAgIGlmIChsZW5ndGggPCAyICoqIDE2KVxcbiAgICAgIHJldHVybiAyO1xcbiAgICBpZiAobGVuZ3RoIDwgMiAqKiAyNClcXG4gICAgICByZXR1cm4gMztcXG4gICAgaWYgKGxlbmd0aCA8IDIgKiogMzIpXFxuICAgICAgcmV0dXJuIDQ7XFxuICAgIHRocm93IG5ldyBCYXNlRXJyb3IyKFwiTGVuZ3RoIGlzIHRvbyBsYXJnZS5cIik7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9hdXRob3JpemF0aW9uL2hhc2hBdXRob3JpemF0aW9uLmpzXFxuICBpbml0X2tlY2NhazI1NigpO1xcbiAgZnVuY3Rpb24gaGFzaEF1dGhvcml6YXRpb24ocGFyYW1ldGVycykge1xcbiAgICBjb25zdCB7IGNoYWluSWQsIG5vbmNlLCB0byB9ID0gcGFyYW1ldGVycztcXG4gICAgY29uc3QgYWRkcmVzcyA9IHBhcmFtZXRlcnMuY29udHJhY3RBZGRyZXNzID8/IHBhcmFtZXRlcnMuYWRkcmVzcztcXG4gICAgY29uc3QgaGFzaDIgPSBrZWNjYWsyNTYoY29uY2F0SGV4KFtcXG4gICAgICBcIjB4MDVcIixcXG4gICAgICB0b1JscChbXFxuICAgICAgICBjaGFpbklkID8gbnVtYmVyVG9IZXgoY2hhaW5JZCkgOiBcIjB4XCIsXFxuICAgICAgICBhZGRyZXNzLFxcbiAgICAgICAgbm9uY2UgPyBudW1iZXJUb0hleChub25jZSkgOiBcIjB4XCJcXG4gICAgICBdKVxcbiAgICBdKSk7XFxuICAgIGlmICh0byA9PT0gXCJieXRlc1wiKVxcbiAgICAgIHJldHVybiBoZXhUb0J5dGVzKGhhc2gyKTtcXG4gICAgcmV0dXJuIGhhc2gyO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvYXV0aG9yaXphdGlvbi9yZWNvdmVyQXV0aG9yaXphdGlvbkFkZHJlc3MuanNcXG4gIGFzeW5jIGZ1bmN0aW9uIHJlY292ZXJBdXRob3JpemF0aW9uQWRkcmVzcyhwYXJhbWV0ZXJzKSB7XFxuICAgIGNvbnN0IHsgYXV0aG9yaXphdGlvbiwgc2lnbmF0dXJlIH0gPSBwYXJhbWV0ZXJzO1xcbiAgICByZXR1cm4gcmVjb3ZlckFkZHJlc3Moe1xcbiAgICAgIGhhc2g6IGhhc2hBdXRob3JpemF0aW9uKGF1dGhvcml6YXRpb24pLFxcbiAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlID8/IGF1dGhvcml6YXRpb25cXG4gICAgfSk7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL3B1YmxpYy9lc3RpbWF0ZUdhcy5qc1xcbiAgaW5pdF90b0hleCgpO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vZXJyb3JzL2VzdGltYXRlR2FzLmpzXFxuICBpbml0X2Zvcm1hdEV0aGVyKCk7XFxuICBpbml0X2Zvcm1hdEd3ZWkoKTtcXG4gIGluaXRfYmFzZSgpO1xcbiAgaW5pdF90cmFuc2FjdGlvbigpO1xcbiAgdmFyIEVzdGltYXRlR2FzRXhlY3V0aW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjIge1xcbiAgICBjb25zdHJ1Y3RvcihjYXVzZSwgeyBhY2NvdW50LCBkb2NzUGF0aDogZG9jc1BhdGg4LCBjaGFpbiwgZGF0YSwgZ2FzLCBnYXNQcmljZSwgbWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhcywgbm9uY2UsIHRvLCB2YWx1ZSB9KSB7XFxuICAgICAgY29uc3QgcHJldHR5QXJncyA9IHByZXR0eVByaW50KHtcXG4gICAgICAgIGZyb206IGFjY291bnQ/LmFkZHJlc3MsXFxuICAgICAgICB0byxcXG4gICAgICAgIHZhbHVlOiB0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIgJiYgYCR7Zm9ybWF0RXRoZXIodmFsdWUpfSAke2NoYWluPy5uYXRpdmVDdXJyZW5jeT8uc3ltYm9sIHx8IFwiRVRIXCJ9YCxcXG4gICAgICAgIGRhdGEsXFxuICAgICAgICBnYXMsXFxuICAgICAgICBnYXNQcmljZTogdHlwZW9mIGdhc1ByaWNlICE9PSBcInVuZGVmaW5lZFwiICYmIGAke2Zvcm1hdEd3ZWkoZ2FzUHJpY2UpfSBnd2VpYCxcXG4gICAgICAgIG1heEZlZVBlckdhczogdHlwZW9mIG1heEZlZVBlckdhcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBgJHtmb3JtYXRHd2VpKG1heEZlZVBlckdhcyl9IGd3ZWlgLFxcbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHR5cGVvZiBtYXhQcmlvcml0eUZlZVBlckdhcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBgJHtmb3JtYXRHd2VpKG1heFByaW9yaXR5RmVlUGVyR2FzKX0gZ3dlaWAsXFxuICAgICAgICBub25jZVxcbiAgICAgIH0pO1xcbiAgICAgIHN1cGVyKGNhdXNlLnNob3J0TWVzc2FnZSwge1xcbiAgICAgICAgY2F1c2UsXFxuICAgICAgICBkb2NzUGF0aDogZG9jc1BhdGg4LFxcbiAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXFxuICAgICAgICAgIC4uLmNhdXNlLm1ldGFNZXNzYWdlcyA/IFsuLi5jYXVzZS5tZXRhTWVzc2FnZXMsIFwiIFwiXSA6IFtdLFxcbiAgICAgICAgICBcIkVzdGltYXRlIEdhcyBBcmd1bWVudHM6XCIsXFxuICAgICAgICAgIHByZXR0eUFyZ3NcXG4gICAgICAgIF0uZmlsdGVyKEJvb2xlYW4pLFxcbiAgICAgICAgbmFtZTogXCJFc3RpbWF0ZUdhc0V4ZWN1dGlvbkVycm9yXCJcXG4gICAgICB9KTtcXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYXVzZVwiLCB7XFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICB2YWx1ZTogdm9pZCAwXFxuICAgICAgfSk7XFxuICAgICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xcbiAgICB9XFxuICB9O1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvZXJyb3JzL2dldEVzdGltYXRlR2FzRXJyb3IuanNcXG4gIGluaXRfbm9kZSgpO1xcbiAgaW5pdF9nZXROb2RlRXJyb3IoKTtcXG4gIGZ1bmN0aW9uIGdldEVzdGltYXRlR2FzRXJyb3IoZXJyLCB7IGRvY3NQYXRoOiBkb2NzUGF0aDgsIC4uLmFyZ3MgfSkge1xcbiAgICBjb25zdCBjYXVzZSA9ICgoKSA9PiB7XFxuICAgICAgY29uc3QgY2F1c2UyID0gZ2V0Tm9kZUVycm9yKGVyciwgYXJncyk7XFxuICAgICAgaWYgKGNhdXNlMiBpbnN0YW5jZW9mIFVua25vd25Ob2RlRXJyb3IpXFxuICAgICAgICByZXR1cm4gZXJyO1xcbiAgICAgIHJldHVybiBjYXVzZTI7XFxuICAgIH0pKCk7XFxuICAgIHJldHVybiBuZXcgRXN0aW1hdGVHYXNFeGVjdXRpb25FcnJvcihjYXVzZSwge1xcbiAgICAgIGRvY3NQYXRoOiBkb2NzUGF0aDgsXFxuICAgICAgLi4uYXJnc1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjdGlvbnMvcHVibGljL2VzdGltYXRlR2FzLmpzXFxuICBpbml0X2V4dHJhY3QoKTtcXG4gIGluaXRfdHJhbnNhY3Rpb25SZXF1ZXN0KCk7XFxuICBpbml0X3N0YXRlT3ZlcnJpZGUyKCk7XFxuICBpbml0X2Fzc2VydFJlcXVlc3QoKTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjdGlvbnMvd2FsbGV0L3ByZXBhcmVUcmFuc2FjdGlvblJlcXVlc3QuanNcXG4gIGluaXRfcGFyc2VBY2NvdW50KCk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9lcnJvcnMvZmVlLmpzXFxuICBpbml0X2Zvcm1hdEd3ZWkoKTtcXG4gIGluaXRfYmFzZSgpO1xcbiAgdmFyIEJhc2VGZWVTY2FsYXJFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgIGNvbnN0cnVjdG9yKCkge1xcbiAgICAgIHN1cGVyKFwiYGJhc2VGZWVNdWx0aXBsaWVyYCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAxLlwiLCB7XFxuICAgICAgICBuYW1lOiBcIkJhc2VGZWVTY2FsYXJFcnJvclwiXFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH07XFxuICB2YXIgRWlwMTU1OUZlZXNOb3RTdXBwb3J0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgIGNvbnN0cnVjdG9yKCkge1xcbiAgICAgIHN1cGVyKFwiQ2hhaW4gZG9lcyBub3Qgc3VwcG9ydCBFSVAtMTU1OSBmZWVzLlwiLCB7XFxuICAgICAgICBuYW1lOiBcIkVpcDE1NTlGZWVzTm90U3VwcG9ydGVkRXJyb3JcIlxcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9O1xcbiAgdmFyIE1heEZlZVBlckdhc1Rvb0xvd0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IyIHtcXG4gICAgY29uc3RydWN0b3IoeyBtYXhQcmlvcml0eUZlZVBlckdhcyB9KSB7XFxuICAgICAgc3VwZXIoYFxcXFxgbWF4RmVlUGVyR2FzXFxcXGAgY2Fubm90IGJlIGxlc3MgdGhhbiB0aGUgXFxcXGBtYXhQcmlvcml0eUZlZVBlckdhc1xcXFxgICgke2Zvcm1hdEd3ZWkobWF4UHJpb3JpdHlGZWVQZXJHYXMpfSBnd2VpKS5gLCB7IG5hbWU6IFwiTWF4RmVlUGVyR2FzVG9vTG93RXJyb3JcIiB9KTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjdGlvbnMvcHVibGljL2VzdGltYXRlTWF4UHJpb3JpdHlGZWVQZXJHYXMuanNcXG4gIGluaXRfZnJvbUhleCgpO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vZXJyb3JzL2Jsb2NrLmpzXFxuICBpbml0X2Jhc2UoKTtcXG4gIHZhciBCbG9ja05vdEZvdW5kRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjIge1xcbiAgICBjb25zdHJ1Y3Rvcih7IGJsb2NrSGFzaCwgYmxvY2tOdW1iZXIgfSkge1xcbiAgICAgIGxldCBpZGVudGlmaWVyID0gXCJCbG9ja1wiO1xcbiAgICAgIGlmIChibG9ja0hhc2gpXFxuICAgICAgICBpZGVudGlmaWVyID0gYEJsb2NrIGF0IGhhc2ggXCIke2Jsb2NrSGFzaH1cImA7XFxuICAgICAgaWYgKGJsb2NrTnVtYmVyKVxcbiAgICAgICAgaWRlbnRpZmllciA9IGBCbG9jayBhdCBudW1iZXIgXCIke2Jsb2NrTnVtYmVyfVwiYDtcXG4gICAgICBzdXBlcihgJHtpZGVudGlmaWVyfSBjb3VsZCBub3QgYmUgZm91bmQuYCwgeyBuYW1lOiBcIkJsb2NrTm90Rm91bmRFcnJvclwiIH0pO1xcbiAgICB9XFxuICB9O1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vYWN0aW9ucy9wdWJsaWMvZ2V0QmxvY2suanNcXG4gIGluaXRfdG9IZXgoKTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2Zvcm1hdHRlcnMvYmxvY2suanNcXG4gIGluaXRfZm9ybWF0dGVyKCk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9mb3JtYXR0ZXJzL3RyYW5zYWN0aW9uLmpzXFxuICBpbml0X2Zyb21IZXgoKTtcXG4gIGluaXRfZm9ybWF0dGVyKCk7XFxuICB2YXIgdHJhbnNhY3Rpb25UeXBlID0ge1xcbiAgICBcIjB4MFwiOiBcImxlZ2FjeVwiLFxcbiAgICBcIjB4MVwiOiBcImVpcDI5MzBcIixcXG4gICAgXCIweDJcIjogXCJlaXAxNTU5XCIsXFxuICAgIFwiMHgzXCI6IFwiZWlwNDg0NFwiLFxcbiAgICBcIjB4NFwiOiBcImVpcDc3MDJcIlxcbiAgfTtcXG4gIGZ1bmN0aW9uIGZvcm1hdFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XFxuICAgIGNvbnN0IHRyYW5zYWN0aW9uXyA9IHtcXG4gICAgICAuLi50cmFuc2FjdGlvbixcXG4gICAgICBibG9ja0hhc2g6IHRyYW5zYWN0aW9uLmJsb2NrSGFzaCA/IHRyYW5zYWN0aW9uLmJsb2NrSGFzaCA6IG51bGwsXFxuICAgICAgYmxvY2tOdW1iZXI6IHRyYW5zYWN0aW9uLmJsb2NrTnVtYmVyID8gQmlnSW50KHRyYW5zYWN0aW9uLmJsb2NrTnVtYmVyKSA6IG51bGwsXFxuICAgICAgY2hhaW5JZDogdHJhbnNhY3Rpb24uY2hhaW5JZCA/IGhleFRvTnVtYmVyKHRyYW5zYWN0aW9uLmNoYWluSWQpIDogdm9pZCAwLFxcbiAgICAgIGdhczogdHJhbnNhY3Rpb24uZ2FzID8gQmlnSW50KHRyYW5zYWN0aW9uLmdhcykgOiB2b2lkIDAsXFxuICAgICAgZ2FzUHJpY2U6IHRyYW5zYWN0aW9uLmdhc1ByaWNlID8gQmlnSW50KHRyYW5zYWN0aW9uLmdhc1ByaWNlKSA6IHZvaWQgMCxcXG4gICAgICBtYXhGZWVQZXJCbG9iR2FzOiB0cmFuc2FjdGlvbi5tYXhGZWVQZXJCbG9iR2FzID8gQmlnSW50KHRyYW5zYWN0aW9uLm1heEZlZVBlckJsb2JHYXMpIDogdm9pZCAwLFxcbiAgICAgIG1heEZlZVBlckdhczogdHJhbnNhY3Rpb24ubWF4RmVlUGVyR2FzID8gQmlnSW50KHRyYW5zYWN0aW9uLm1heEZlZVBlckdhcykgOiB2b2lkIDAsXFxuICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHRyYW5zYWN0aW9uLm1heFByaW9yaXR5RmVlUGVyR2FzID8gQmlnSW50KHRyYW5zYWN0aW9uLm1heFByaW9yaXR5RmVlUGVyR2FzKSA6IHZvaWQgMCxcXG4gICAgICBub25jZTogdHJhbnNhY3Rpb24ubm9uY2UgPyBoZXhUb051bWJlcih0cmFuc2FjdGlvbi5ub25jZSkgOiB2b2lkIDAsXFxuICAgICAgdG86IHRyYW5zYWN0aW9uLnRvID8gdHJhbnNhY3Rpb24udG8gOiBudWxsLFxcbiAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IHRyYW5zYWN0aW9uLnRyYW5zYWN0aW9uSW5kZXggPyBOdW1iZXIodHJhbnNhY3Rpb24udHJhbnNhY3Rpb25JbmRleCkgOiBudWxsLFxcbiAgICAgIHR5cGU6IHRyYW5zYWN0aW9uLnR5cGUgPyB0cmFuc2FjdGlvblR5cGVbdHJhbnNhY3Rpb24udHlwZV0gOiB2b2lkIDAsXFxuICAgICAgdHlwZUhleDogdHJhbnNhY3Rpb24udHlwZSA/IHRyYW5zYWN0aW9uLnR5cGUgOiB2b2lkIDAsXFxuICAgICAgdmFsdWU6IHRyYW5zYWN0aW9uLnZhbHVlID8gQmlnSW50KHRyYW5zYWN0aW9uLnZhbHVlKSA6IHZvaWQgMCxcXG4gICAgICB2OiB0cmFuc2FjdGlvbi52ID8gQmlnSW50KHRyYW5zYWN0aW9uLnYpIDogdm9pZCAwXFxuICAgIH07XFxuICAgIGlmICh0cmFuc2FjdGlvbi5hdXRob3JpemF0aW9uTGlzdClcXG4gICAgICB0cmFuc2FjdGlvbl8uYXV0aG9yaXphdGlvbkxpc3QgPSBmb3JtYXRBdXRob3JpemF0aW9uTGlzdDIodHJhbnNhY3Rpb24uYXV0aG9yaXphdGlvbkxpc3QpO1xcbiAgICB0cmFuc2FjdGlvbl8ueVBhcml0eSA9ICgoKSA9PiB7XFxuICAgICAgaWYgKHRyYW5zYWN0aW9uLnlQYXJpdHkpXFxuICAgICAgICByZXR1cm4gTnVtYmVyKHRyYW5zYWN0aW9uLnlQYXJpdHkpO1xcbiAgICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb25fLnYgPT09IFwiYmlnaW50XCIpIHtcXG4gICAgICAgIGlmICh0cmFuc2FjdGlvbl8udiA9PT0gMG4gfHwgdHJhbnNhY3Rpb25fLnYgPT09IDI3bilcXG4gICAgICAgICAgcmV0dXJuIDA7XFxuICAgICAgICBpZiAodHJhbnNhY3Rpb25fLnYgPT09IDFuIHx8IHRyYW5zYWN0aW9uXy52ID09PSAyOG4pXFxuICAgICAgICAgIHJldHVybiAxO1xcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uXy52ID49IDM1bilcXG4gICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uXy52ICUgMm4gPT09IDBuID8gMSA6IDA7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB2b2lkIDA7XFxuICAgIH0pKCk7XFxuICAgIGlmICh0cmFuc2FjdGlvbl8udHlwZSA9PT0gXCJsZWdhY3lcIikge1xcbiAgICAgIGRlbGV0ZSB0cmFuc2FjdGlvbl8uYWNjZXNzTGlzdDtcXG4gICAgICBkZWxldGUgdHJhbnNhY3Rpb25fLm1heEZlZVBlckJsb2JHYXM7XFxuICAgICAgZGVsZXRlIHRyYW5zYWN0aW9uXy5tYXhGZWVQZXJHYXM7XFxuICAgICAgZGVsZXRlIHRyYW5zYWN0aW9uXy5tYXhQcmlvcml0eUZlZVBlckdhcztcXG4gICAgICBkZWxldGUgdHJhbnNhY3Rpb25fLnlQYXJpdHk7XFxuICAgIH1cXG4gICAgaWYgKHRyYW5zYWN0aW9uXy50eXBlID09PSBcImVpcDI5MzBcIikge1xcbiAgICAgIGRlbGV0ZSB0cmFuc2FjdGlvbl8ubWF4RmVlUGVyQmxvYkdhcztcXG4gICAgICBkZWxldGUgdHJhbnNhY3Rpb25fLm1heEZlZVBlckdhcztcXG4gICAgICBkZWxldGUgdHJhbnNhY3Rpb25fLm1heFByaW9yaXR5RmVlUGVyR2FzO1xcbiAgICB9XFxuICAgIGlmICh0cmFuc2FjdGlvbl8udHlwZSA9PT0gXCJlaXAxNTU5XCIpIHtcXG4gICAgICBkZWxldGUgdHJhbnNhY3Rpb25fLm1heEZlZVBlckJsb2JHYXM7XFxuICAgIH1cXG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uXztcXG4gIH1cXG4gIHZhciBkZWZpbmVUcmFuc2FjdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyBkZWZpbmVGb3JtYXR0ZXIoXCJ0cmFuc2FjdGlvblwiLCBmb3JtYXRUcmFuc2FjdGlvbik7XFxuICBmdW5jdGlvbiBmb3JtYXRBdXRob3JpemF0aW9uTGlzdDIoYXV0aG9yaXphdGlvbkxpc3QpIHtcXG4gICAgcmV0dXJuIGF1dGhvcml6YXRpb25MaXN0Lm1hcCgoYXV0aG9yaXphdGlvbikgPT4gKHtcXG4gICAgICBhZGRyZXNzOiBhdXRob3JpemF0aW9uLmFkZHJlc3MsXFxuICAgICAgY2hhaW5JZDogTnVtYmVyKGF1dGhvcml6YXRpb24uY2hhaW5JZCksXFxuICAgICAgbm9uY2U6IE51bWJlcihhdXRob3JpemF0aW9uLm5vbmNlKSxcXG4gICAgICByOiBhdXRob3JpemF0aW9uLnIsXFxuICAgICAgczogYXV0aG9yaXphdGlvbi5zLFxcbiAgICAgIHlQYXJpdHk6IE51bWJlcihhdXRob3JpemF0aW9uLnlQYXJpdHkpXFxuICAgIH0pKTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2Zvcm1hdHRlcnMvYmxvY2suanNcXG4gIGZ1bmN0aW9uIGZvcm1hdEJsb2NrKGJsb2NrKSB7XFxuICAgIGNvbnN0IHRyYW5zYWN0aW9ucyA9IChibG9jay50cmFuc2FjdGlvbnMgPz8gW10pLm1hcCgodHJhbnNhY3Rpb24pID0+IHtcXG4gICAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uID09PSBcInN0cmluZ1wiKVxcbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xcbiAgICAgIHJldHVybiBmb3JtYXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XFxuICAgIH0pO1xcbiAgICByZXR1cm4ge1xcbiAgICAgIC4uLmJsb2NrLFxcbiAgICAgIGJhc2VGZWVQZXJHYXM6IGJsb2NrLmJhc2VGZWVQZXJHYXMgPyBCaWdJbnQoYmxvY2suYmFzZUZlZVBlckdhcykgOiBudWxsLFxcbiAgICAgIGJsb2JHYXNVc2VkOiBibG9jay5ibG9iR2FzVXNlZCA/IEJpZ0ludChibG9jay5ibG9iR2FzVXNlZCkgOiB2b2lkIDAsXFxuICAgICAgZGlmZmljdWx0eTogYmxvY2suZGlmZmljdWx0eSA/IEJpZ0ludChibG9jay5kaWZmaWN1bHR5KSA6IHZvaWQgMCxcXG4gICAgICBleGNlc3NCbG9iR2FzOiBibG9jay5leGNlc3NCbG9iR2FzID8gQmlnSW50KGJsb2NrLmV4Y2Vzc0Jsb2JHYXMpIDogdm9pZCAwLFxcbiAgICAgIGdhc0xpbWl0OiBibG9jay5nYXNMaW1pdCA/IEJpZ0ludChibG9jay5nYXNMaW1pdCkgOiB2b2lkIDAsXFxuICAgICAgZ2FzVXNlZDogYmxvY2suZ2FzVXNlZCA/IEJpZ0ludChibG9jay5nYXNVc2VkKSA6IHZvaWQgMCxcXG4gICAgICBoYXNoOiBibG9jay5oYXNoID8gYmxvY2suaGFzaCA6IG51bGwsXFxuICAgICAgbG9nc0Jsb29tOiBibG9jay5sb2dzQmxvb20gPyBibG9jay5sb2dzQmxvb20gOiBudWxsLFxcbiAgICAgIG5vbmNlOiBibG9jay5ub25jZSA/IGJsb2NrLm5vbmNlIDogbnVsbCxcXG4gICAgICBudW1iZXI6IGJsb2NrLm51bWJlciA/IEJpZ0ludChibG9jay5udW1iZXIpIDogbnVsbCxcXG4gICAgICBzaXplOiBibG9jay5zaXplID8gQmlnSW50KGJsb2NrLnNpemUpIDogdm9pZCAwLFxcbiAgICAgIHRpbWVzdGFtcDogYmxvY2sudGltZXN0YW1wID8gQmlnSW50KGJsb2NrLnRpbWVzdGFtcCkgOiB2b2lkIDAsXFxuICAgICAgdHJhbnNhY3Rpb25zLFxcbiAgICAgIHRvdGFsRGlmZmljdWx0eTogYmxvY2sudG90YWxEaWZmaWN1bHR5ID8gQmlnSW50KGJsb2NrLnRvdGFsRGlmZmljdWx0eSkgOiBudWxsXFxuICAgIH07XFxuICB9XFxuICB2YXIgZGVmaW5lQmxvY2sgPSAvKiBAX19QVVJFX18gKi8gZGVmaW5lRm9ybWF0dGVyKFwiYmxvY2tcIiwgZm9ybWF0QmxvY2spO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vYWN0aW9ucy9wdWJsaWMvZ2V0QmxvY2suanNcXG4gIGFzeW5jIGZ1bmN0aW9uIGdldEJsb2NrKGNsaWVudCwgeyBibG9ja0hhc2gsIGJsb2NrTnVtYmVyLCBibG9ja1RhZzogYmxvY2tUYWdfLCBpbmNsdWRlVHJhbnNhY3Rpb25zOiBpbmNsdWRlVHJhbnNhY3Rpb25zXyB9ID0ge30pIHtcXG4gICAgY29uc3QgYmxvY2tUYWcgPSBibG9ja1RhZ18gPz8gXCJsYXRlc3RcIjtcXG4gICAgY29uc3QgaW5jbHVkZVRyYW5zYWN0aW9ucyA9IGluY2x1ZGVUcmFuc2FjdGlvbnNfID8/IGZhbHNlO1xcbiAgICBjb25zdCBibG9ja051bWJlckhleCA9IGJsb2NrTnVtYmVyICE9PSB2b2lkIDAgPyBudW1iZXJUb0hleChibG9ja051bWJlcikgOiB2b2lkIDA7XFxuICAgIGxldCBibG9jayA9IG51bGw7XFxuICAgIGlmIChibG9ja0hhc2gpIHtcXG4gICAgICBibG9jayA9IGF3YWl0IGNsaWVudC5yZXF1ZXN0KHtcXG4gICAgICAgIG1ldGhvZDogXCJldGhfZ2V0QmxvY2tCeUhhc2hcIixcXG4gICAgICAgIHBhcmFtczogW2Jsb2NrSGFzaCwgaW5jbHVkZVRyYW5zYWN0aW9uc11cXG4gICAgICB9LCB7IGRlZHVwZTogdHJ1ZSB9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBibG9jayA9IGF3YWl0IGNsaWVudC5yZXF1ZXN0KHtcXG4gICAgICAgIG1ldGhvZDogXCJldGhfZ2V0QmxvY2tCeU51bWJlclwiLFxcbiAgICAgICAgcGFyYW1zOiBbYmxvY2tOdW1iZXJIZXggfHwgYmxvY2tUYWcsIGluY2x1ZGVUcmFuc2FjdGlvbnNdXFxuICAgICAgfSwgeyBkZWR1cGU6IEJvb2xlYW4oYmxvY2tOdW1iZXJIZXgpIH0pO1xcbiAgICB9XFxuICAgIGlmICghYmxvY2spXFxuICAgICAgdGhyb3cgbmV3IEJsb2NrTm90Rm91bmRFcnJvcih7IGJsb2NrSGFzaCwgYmxvY2tOdW1iZXIgfSk7XFxuICAgIGNvbnN0IGZvcm1hdCA9IGNsaWVudC5jaGFpbj8uZm9ybWF0dGVycz8uYmxvY2s/LmZvcm1hdCB8fCBmb3JtYXRCbG9jaztcXG4gICAgcmV0dXJuIGZvcm1hdChibG9jayk7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL3B1YmxpYy9nZXRHYXNQcmljZS5qc1xcbiAgYXN5bmMgZnVuY3Rpb24gZ2V0R2FzUHJpY2UoY2xpZW50KSB7XFxuICAgIGNvbnN0IGdhc1ByaWNlID0gYXdhaXQgY2xpZW50LnJlcXVlc3Qoe1xcbiAgICAgIG1ldGhvZDogXCJldGhfZ2FzUHJpY2VcIlxcbiAgICB9KTtcXG4gICAgcmV0dXJuIEJpZ0ludChnYXNQcmljZSk7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL3B1YmxpYy9lc3RpbWF0ZU1heFByaW9yaXR5RmVlUGVyR2FzLmpzXFxuICBhc3luYyBmdW5jdGlvbiBlc3RpbWF0ZU1heFByaW9yaXR5RmVlUGVyR2FzKGNsaWVudCwgYXJncykge1xcbiAgICByZXR1cm4gaW50ZXJuYWxfZXN0aW1hdGVNYXhQcmlvcml0eUZlZVBlckdhcyhjbGllbnQsIGFyZ3MpO1xcbiAgfVxcbiAgYXN5bmMgZnVuY3Rpb24gaW50ZXJuYWxfZXN0aW1hdGVNYXhQcmlvcml0eUZlZVBlckdhcyhjbGllbnQsIGFyZ3MpIHtcXG4gICAgY29uc3QgeyBibG9jazogYmxvY2tfLCBjaGFpbiA9IGNsaWVudC5jaGFpbiwgcmVxdWVzdCB9ID0gYXJncyB8fCB7fTtcXG4gICAgdHJ5IHtcXG4gICAgICBjb25zdCBtYXhQcmlvcml0eUZlZVBlckdhcyA9IGNoYWluPy5mZWVzPy5tYXhQcmlvcml0eUZlZVBlckdhcyA/PyBjaGFpbj8uZmVlcz8uZGVmYXVsdFByaW9yaXR5RmVlO1xcbiAgICAgIGlmICh0eXBlb2YgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPT09IFwiZnVuY3Rpb25cIikge1xcbiAgICAgICAgY29uc3QgYmxvY2sgPSBibG9ja18gfHwgYXdhaXQgZ2V0QWN0aW9uKGNsaWVudCwgZ2V0QmxvY2ssIFwiZ2V0QmxvY2tcIikoe30pO1xcbiAgICAgICAgY29uc3QgbWF4UHJpb3JpdHlGZWVQZXJHYXNfID0gYXdhaXQgbWF4UHJpb3JpdHlGZWVQZXJHYXMoe1xcbiAgICAgICAgICBibG9jayxcXG4gICAgICAgICAgY2xpZW50LFxcbiAgICAgICAgICByZXF1ZXN0XFxuICAgICAgICB9KTtcXG4gICAgICAgIGlmIChtYXhQcmlvcml0eUZlZVBlckdhc18gPT09IG51bGwpXFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xcbiAgICAgICAgcmV0dXJuIG1heFByaW9yaXR5RmVlUGVyR2FzXztcXG4gICAgICB9XFxuICAgICAgaWYgKHR5cGVvZiBtYXhQcmlvcml0eUZlZVBlckdhcyAhPT0gXCJ1bmRlZmluZWRcIilcXG4gICAgICAgIHJldHVybiBtYXhQcmlvcml0eUZlZVBlckdhcztcXG4gICAgICBjb25zdCBtYXhQcmlvcml0eUZlZVBlckdhc0hleCA9IGF3YWl0IGNsaWVudC5yZXF1ZXN0KHtcXG4gICAgICAgIG1ldGhvZDogXCJldGhfbWF4UHJpb3JpdHlGZWVQZXJHYXNcIlxcbiAgICAgIH0pO1xcbiAgICAgIHJldHVybiBoZXhUb0JpZ0ludChtYXhQcmlvcml0eUZlZVBlckdhc0hleCk7XFxuICAgIH0gY2F0Y2gge1xcbiAgICAgIGNvbnN0IFtibG9jaywgZ2FzUHJpY2VdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xcbiAgICAgICAgYmxvY2tfID8gUHJvbWlzZS5yZXNvbHZlKGJsb2NrXykgOiBnZXRBY3Rpb24oY2xpZW50LCBnZXRCbG9jaywgXCJnZXRCbG9ja1wiKSh7fSksXFxuICAgICAgICBnZXRBY3Rpb24oY2xpZW50LCBnZXRHYXNQcmljZSwgXCJnZXRHYXNQcmljZVwiKSh7fSlcXG4gICAgICBdKTtcXG4gICAgICBpZiAodHlwZW9mIGJsb2NrLmJhc2VGZWVQZXJHYXMgIT09IFwiYmlnaW50XCIpXFxuICAgICAgICB0aHJvdyBuZXcgRWlwMTU1OUZlZXNOb3RTdXBwb3J0ZWRFcnJvcigpO1xcbiAgICAgIGNvbnN0IG1heFByaW9yaXR5RmVlUGVyR2FzID0gZ2FzUHJpY2UgLSBibG9jay5iYXNlRmVlUGVyR2FzO1xcbiAgICAgIGlmIChtYXhQcmlvcml0eUZlZVBlckdhcyA8IDBuKVxcbiAgICAgICAgcmV0dXJuIDBuO1xcbiAgICAgIHJldHVybiBtYXhQcmlvcml0eUZlZVBlckdhcztcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vYWN0aW9ucy9wdWJsaWMvZXN0aW1hdGVGZWVzUGVyR2FzLmpzXFxuICBhc3luYyBmdW5jdGlvbiBlc3RpbWF0ZUZlZXNQZXJHYXMoY2xpZW50LCBhcmdzKSB7XFxuICAgIHJldHVybiBpbnRlcm5hbF9lc3RpbWF0ZUZlZXNQZXJHYXMoY2xpZW50LCBhcmdzKTtcXG4gIH1cXG4gIGFzeW5jIGZ1bmN0aW9uIGludGVybmFsX2VzdGltYXRlRmVlc1BlckdhcyhjbGllbnQsIGFyZ3MpIHtcXG4gICAgY29uc3QgeyBibG9jazogYmxvY2tfLCBjaGFpbiA9IGNsaWVudC5jaGFpbiwgcmVxdWVzdCwgdHlwZSA9IFwiZWlwMTU1OVwiIH0gPSBhcmdzIHx8IHt9O1xcbiAgICBjb25zdCBiYXNlRmVlTXVsdGlwbGllciA9IGF3YWl0IChhc3luYyAoKSA9PiB7XFxuICAgICAgaWYgKHR5cGVvZiBjaGFpbj8uZmVlcz8uYmFzZUZlZU11bHRpcGxpZXIgPT09IFwiZnVuY3Rpb25cIilcXG4gICAgICAgIHJldHVybiBjaGFpbi5mZWVzLmJhc2VGZWVNdWx0aXBsaWVyKHtcXG4gICAgICAgICAgYmxvY2s6IGJsb2NrXyxcXG4gICAgICAgICAgY2xpZW50LFxcbiAgICAgICAgICByZXF1ZXN0XFxuICAgICAgICB9KTtcXG4gICAgICByZXR1cm4gY2hhaW4/LmZlZXM/LmJhc2VGZWVNdWx0aXBsaWVyID8/IDEuMjtcXG4gICAgfSkoKTtcXG4gICAgaWYgKGJhc2VGZWVNdWx0aXBsaWVyIDwgMSlcXG4gICAgICB0aHJvdyBuZXcgQmFzZUZlZVNjYWxhckVycm9yKCk7XFxuICAgIGNvbnN0IGRlY2ltYWxzID0gYmFzZUZlZU11bHRpcGxpZXIudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV0/Lmxlbmd0aCA/PyAwO1xcbiAgICBjb25zdCBkZW5vbWluYXRvciA9IDEwICoqIGRlY2ltYWxzO1xcbiAgICBjb25zdCBtdWx0aXBseSA9IChiYXNlMikgPT4gYmFzZTIgKiBCaWdJbnQoTWF0aC5jZWlsKGJhc2VGZWVNdWx0aXBsaWVyICogZGVub21pbmF0b3IpKSAvIEJpZ0ludChkZW5vbWluYXRvcik7XFxuICAgIGNvbnN0IGJsb2NrID0gYmxvY2tfID8gYmxvY2tfIDogYXdhaXQgZ2V0QWN0aW9uKGNsaWVudCwgZ2V0QmxvY2ssIFwiZ2V0QmxvY2tcIikoe30pO1xcbiAgICBpZiAodHlwZW9mIGNoYWluPy5mZWVzPy5lc3RpbWF0ZUZlZXNQZXJHYXMgPT09IFwiZnVuY3Rpb25cIikge1xcbiAgICAgIGNvbnN0IGZlZXMgPSBhd2FpdCBjaGFpbi5mZWVzLmVzdGltYXRlRmVlc1Blckdhcyh7XFxuICAgICAgICBibG9jazogYmxvY2tfLFxcbiAgICAgICAgY2xpZW50LFxcbiAgICAgICAgbXVsdGlwbHksXFxuICAgICAgICByZXF1ZXN0LFxcbiAgICAgICAgdHlwZVxcbiAgICAgIH0pO1xcbiAgICAgIGlmIChmZWVzICE9PSBudWxsKVxcbiAgICAgICAgcmV0dXJuIGZlZXM7XFxuICAgIH1cXG4gICAgaWYgKHR5cGUgPT09IFwiZWlwMTU1OVwiKSB7XFxuICAgICAgaWYgKHR5cGVvZiBibG9jay5iYXNlRmVlUGVyR2FzICE9PSBcImJpZ2ludFwiKVxcbiAgICAgICAgdGhyb3cgbmV3IEVpcDE1NTlGZWVzTm90U3VwcG9ydGVkRXJyb3IoKTtcXG4gICAgICBjb25zdCBtYXhQcmlvcml0eUZlZVBlckdhcyA9IHR5cGVvZiByZXF1ZXN0Py5tYXhQcmlvcml0eUZlZVBlckdhcyA9PT0gXCJiaWdpbnRcIiA/IHJlcXVlc3QubWF4UHJpb3JpdHlGZWVQZXJHYXMgOiBhd2FpdCBpbnRlcm5hbF9lc3RpbWF0ZU1heFByaW9yaXR5RmVlUGVyR2FzKGNsaWVudCwge1xcbiAgICAgICAgYmxvY2ssXFxuICAgICAgICBjaGFpbixcXG4gICAgICAgIHJlcXVlc3RcXG4gICAgICB9KTtcXG4gICAgICBjb25zdCBiYXNlRmVlUGVyR2FzID0gbXVsdGlwbHkoYmxvY2suYmFzZUZlZVBlckdhcyk7XFxuICAgICAgY29uc3QgbWF4RmVlUGVyR2FzID0gcmVxdWVzdD8ubWF4RmVlUGVyR2FzID8/IGJhc2VGZWVQZXJHYXMgKyBtYXhQcmlvcml0eUZlZVBlckdhcztcXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgbWF4RmVlUGVyR2FzLFxcbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXNcXG4gICAgICB9O1xcbiAgICB9XFxuICAgIGNvbnN0IGdhc1ByaWNlID0gcmVxdWVzdD8uZ2FzUHJpY2UgPz8gbXVsdGlwbHkoYXdhaXQgZ2V0QWN0aW9uKGNsaWVudCwgZ2V0R2FzUHJpY2UsIFwiZ2V0R2FzUHJpY2VcIikoe30pKTtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBnYXNQcmljZVxcbiAgICB9O1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vYWN0aW9ucy9wdWJsaWMvZ2V0VHJhbnNhY3Rpb25Db3VudC5qc1xcbiAgaW5pdF9mcm9tSGV4KCk7XFxuICBpbml0X3RvSGV4KCk7XFxuICBhc3luYyBmdW5jdGlvbiBnZXRUcmFuc2FjdGlvbkNvdW50KGNsaWVudCwgeyBhZGRyZXNzLCBibG9ja1RhZyA9IFwibGF0ZXN0XCIsIGJsb2NrTnVtYmVyIH0pIHtcXG4gICAgY29uc3QgY291bnQgPSBhd2FpdCBjbGllbnQucmVxdWVzdCh7XFxuICAgICAgbWV0aG9kOiBcImV0aF9nZXRUcmFuc2FjdGlvbkNvdW50XCIsXFxuICAgICAgcGFyYW1zOiBbYWRkcmVzcywgYmxvY2tOdW1iZXIgPyBudW1iZXJUb0hleChibG9ja051bWJlcikgOiBibG9ja1RhZ11cXG4gICAgfSwgeyBkZWR1cGU6IEJvb2xlYW4oYmxvY2tOdW1iZXIpIH0pO1xcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoY291bnQpO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvYmxvYi9ibG9ic1RvQ29tbWl0bWVudHMuanNcXG4gIGluaXRfdG9CeXRlcygpO1xcbiAgaW5pdF90b0hleCgpO1xcbiAgZnVuY3Rpb24gYmxvYnNUb0NvbW1pdG1lbnRzKHBhcmFtZXRlcnMpIHtcXG4gICAgY29uc3QgeyBremcgfSA9IHBhcmFtZXRlcnM7XFxuICAgIGNvbnN0IHRvID0gcGFyYW1ldGVycy50byA/PyAodHlwZW9mIHBhcmFtZXRlcnMuYmxvYnNbMF0gPT09IFwic3RyaW5nXCIgPyBcImhleFwiIDogXCJieXRlc1wiKTtcXG4gICAgY29uc3QgYmxvYnMgPSB0eXBlb2YgcGFyYW1ldGVycy5ibG9ic1swXSA9PT0gXCJzdHJpbmdcIiA/IHBhcmFtZXRlcnMuYmxvYnMubWFwKCh4KSA9PiBoZXhUb0J5dGVzKHgpKSA6IHBhcmFtZXRlcnMuYmxvYnM7XFxuICAgIGNvbnN0IGNvbW1pdG1lbnRzID0gW107XFxuICAgIGZvciAoY29uc3QgYmxvYiBvZiBibG9icylcXG4gICAgICBjb21taXRtZW50cy5wdXNoKFVpbnQ4QXJyYXkuZnJvbShremcuYmxvYlRvS3pnQ29tbWl0bWVudChibG9iKSkpO1xcbiAgICByZXR1cm4gdG8gPT09IFwiYnl0ZXNcIiA/IGNvbW1pdG1lbnRzIDogY29tbWl0bWVudHMubWFwKCh4KSA9PiBieXRlc1RvSGV4KHgpKTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2Jsb2IvYmxvYnNUb1Byb29mcy5qc1xcbiAgaW5pdF90b0J5dGVzKCk7XFxuICBpbml0X3RvSGV4KCk7XFxuICBmdW5jdGlvbiBibG9ic1RvUHJvb2ZzKHBhcmFtZXRlcnMpIHtcXG4gICAgY29uc3QgeyBremcgfSA9IHBhcmFtZXRlcnM7XFxuICAgIGNvbnN0IHRvID0gcGFyYW1ldGVycy50byA/PyAodHlwZW9mIHBhcmFtZXRlcnMuYmxvYnNbMF0gPT09IFwic3RyaW5nXCIgPyBcImhleFwiIDogXCJieXRlc1wiKTtcXG4gICAgY29uc3QgYmxvYnMgPSB0eXBlb2YgcGFyYW1ldGVycy5ibG9ic1swXSA9PT0gXCJzdHJpbmdcIiA/IHBhcmFtZXRlcnMuYmxvYnMubWFwKCh4KSA9PiBoZXhUb0J5dGVzKHgpKSA6IHBhcmFtZXRlcnMuYmxvYnM7XFxuICAgIGNvbnN0IGNvbW1pdG1lbnRzID0gdHlwZW9mIHBhcmFtZXRlcnMuY29tbWl0bWVudHNbMF0gPT09IFwic3RyaW5nXCIgPyBwYXJhbWV0ZXJzLmNvbW1pdG1lbnRzLm1hcCgoeCkgPT4gaGV4VG9CeXRlcyh4KSkgOiBwYXJhbWV0ZXJzLmNvbW1pdG1lbnRzO1xcbiAgICBjb25zdCBwcm9vZnMgPSBbXTtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9icy5sZW5ndGg7IGkrKykge1xcbiAgICAgIGNvbnN0IGJsb2IgPSBibG9ic1tpXTtcXG4gICAgICBjb25zdCBjb21taXRtZW50ID0gY29tbWl0bWVudHNbaV07XFxuICAgICAgcHJvb2ZzLnB1c2goVWludDhBcnJheS5mcm9tKGt6Zy5jb21wdXRlQmxvYkt6Z1Byb29mKGJsb2IsIGNvbW1pdG1lbnQpKSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHRvID09PSBcImJ5dGVzXCIgPyBwcm9vZnMgOiBwcm9vZnMubWFwKCh4KSA9PiBieXRlc1RvSGV4KHgpKTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2Jsb2IvY29tbWl0bWVudFRvVmVyc2lvbmVkSGFzaC5qc1xcbiAgaW5pdF90b0hleCgpO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvaGFzaC9zaGEyNTYuanNcXG4gIGluaXRfc2hhMjU2KCk7XFxuICBpbml0X2lzSGV4KCk7XFxuICBpbml0X3RvQnl0ZXMoKTtcXG4gIGluaXRfdG9IZXgoKTtcXG4gIGZ1bmN0aW9uIHNoYTI1NjIodmFsdWUsIHRvXykge1xcbiAgICBjb25zdCB0byA9IHRvXyB8fCBcImhleFwiO1xcbiAgICBjb25zdCBieXRlcyA9IHNoYTI1Nihpc0hleCh2YWx1ZSwgeyBzdHJpY3Q6IGZhbHNlIH0pID8gdG9CeXRlcyh2YWx1ZSkgOiB2YWx1ZSk7XFxuICAgIGlmICh0byA9PT0gXCJieXRlc1wiKVxcbiAgICAgIHJldHVybiBieXRlcztcXG4gICAgcmV0dXJuIHRvSGV4KGJ5dGVzKTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2Jsb2IvY29tbWl0bWVudFRvVmVyc2lvbmVkSGFzaC5qc1xcbiAgZnVuY3Rpb24gY29tbWl0bWVudFRvVmVyc2lvbmVkSGFzaChwYXJhbWV0ZXJzKSB7XFxuICAgIGNvbnN0IHsgY29tbWl0bWVudCwgdmVyc2lvbjogdmVyc2lvbjQgPSAxIH0gPSBwYXJhbWV0ZXJzO1xcbiAgICBjb25zdCB0byA9IHBhcmFtZXRlcnMudG8gPz8gKHR5cGVvZiBjb21taXRtZW50ID09PSBcInN0cmluZ1wiID8gXCJoZXhcIiA6IFwiYnl0ZXNcIik7XFxuICAgIGNvbnN0IHZlcnNpb25lZEhhc2ggPSBzaGEyNTYyKGNvbW1pdG1lbnQsIFwiYnl0ZXNcIik7XFxuICAgIHZlcnNpb25lZEhhc2guc2V0KFt2ZXJzaW9uNF0sIDApO1xcbiAgICByZXR1cm4gdG8gPT09IFwiYnl0ZXNcIiA/IHZlcnNpb25lZEhhc2ggOiBieXRlc1RvSGV4KHZlcnNpb25lZEhhc2gpO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvYmxvYi9jb21taXRtZW50c1RvVmVyc2lvbmVkSGFzaGVzLmpzXFxuICBmdW5jdGlvbiBjb21taXRtZW50c1RvVmVyc2lvbmVkSGFzaGVzKHBhcmFtZXRlcnMpIHtcXG4gICAgY29uc3QgeyBjb21taXRtZW50cywgdmVyc2lvbjogdmVyc2lvbjQgfSA9IHBhcmFtZXRlcnM7XFxuICAgIGNvbnN0IHRvID0gcGFyYW1ldGVycy50byA/PyAodHlwZW9mIGNvbW1pdG1lbnRzWzBdID09PSBcInN0cmluZ1wiID8gXCJoZXhcIiA6IFwiYnl0ZXNcIik7XFxuICAgIGNvbnN0IGhhc2hlcyA9IFtdO1xcbiAgICBmb3IgKGNvbnN0IGNvbW1pdG1lbnQgb2YgY29tbWl0bWVudHMpIHtcXG4gICAgICBoYXNoZXMucHVzaChjb21taXRtZW50VG9WZXJzaW9uZWRIYXNoKHtcXG4gICAgICAgIGNvbW1pdG1lbnQsXFxuICAgICAgICB0byxcXG4gICAgICAgIHZlcnNpb246IHZlcnNpb240XFxuICAgICAgfSkpO1xcbiAgICB9XFxuICAgIHJldHVybiBoYXNoZXM7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9jb25zdGFudHMvYmxvYi5qc1xcbiAgdmFyIGJsb2JzUGVyVHJhbnNhY3Rpb24gPSA2O1xcbiAgdmFyIGJ5dGVzUGVyRmllbGRFbGVtZW50ID0gMzI7XFxuICB2YXIgZmllbGRFbGVtZW50c1BlckJsb2IgPSA0MDk2O1xcbiAgdmFyIGJ5dGVzUGVyQmxvYiA9IGJ5dGVzUGVyRmllbGRFbGVtZW50ICogZmllbGRFbGVtZW50c1BlckJsb2I7XFxuICB2YXIgbWF4Qnl0ZXNQZXJUcmFuc2FjdGlvbiA9IGJ5dGVzUGVyQmxvYiAqIGJsb2JzUGVyVHJhbnNhY3Rpb24gLSAvLyB0ZXJtaW5hdG9yIGJ5dGUgKDB4ODApLlxcbiAgMSAtIC8vIHplcm8gYnl0ZSAoMHgwMCkgYXBwZW5kZWQgdG8gZWFjaCBmaWVsZCBlbGVtZW50LlxcbiAgMSAqIGZpZWxkRWxlbWVudHNQZXJCbG9iICogYmxvYnNQZXJUcmFuc2FjdGlvbjtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2NvbnN0YW50cy9remcuanNcXG4gIHZhciB2ZXJzaW9uZWRIYXNoVmVyc2lvbkt6ZyA9IDE7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9lcnJvcnMvYmxvYi5qc1xcbiAgaW5pdF9iYXNlKCk7XFxuICB2YXIgQmxvYlNpemVUb29MYXJnZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IyIHtcXG4gICAgY29uc3RydWN0b3IoeyBtYXhTaXplLCBzaXplOiBzaXplNSB9KSB7XFxuICAgICAgc3VwZXIoXCJCbG9iIHNpemUgaXMgdG9vIGxhcmdlLlwiLCB7XFxuICAgICAgICBtZXRhTWVzc2FnZXM6IFtgTWF4OiAke21heFNpemV9IGJ5dGVzYCwgYEdpdmVuOiAke3NpemU1fSBieXRlc2BdLFxcbiAgICAgICAgbmFtZTogXCJCbG9iU2l6ZVRvb0xhcmdlRXJyb3JcIlxcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9O1xcbiAgdmFyIEVtcHR5QmxvYkVycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IyIHtcXG4gICAgY29uc3RydWN0b3IoKSB7XFxuICAgICAgc3VwZXIoXCJCbG9iIGRhdGEgbXVzdCBub3QgYmUgZW1wdHkuXCIsIHsgbmFtZTogXCJFbXB0eUJsb2JFcnJvclwiIH0pO1xcbiAgICB9XFxuICB9O1xcbiAgdmFyIEludmFsaWRWZXJzaW9uZWRIYXNoU2l6ZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IyIHtcXG4gICAgY29uc3RydWN0b3IoeyBoYXNoOiBoYXNoMiwgc2l6ZTogc2l6ZTUgfSkge1xcbiAgICAgIHN1cGVyKGBWZXJzaW9uZWQgaGFzaCBcIiR7aGFzaDJ9XCIgc2l6ZSBpcyBpbnZhbGlkLmAsIHtcXG4gICAgICAgIG1ldGFNZXNzYWdlczogW1wiRXhwZWN0ZWQ6IDMyXCIsIGBSZWNlaXZlZDogJHtzaXplNX1gXSxcXG4gICAgICAgIG5hbWU6IFwiSW52YWxpZFZlcnNpb25lZEhhc2hTaXplRXJyb3JcIlxcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9O1xcbiAgdmFyIEludmFsaWRWZXJzaW9uZWRIYXNoVmVyc2lvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IyIHtcXG4gICAgY29uc3RydWN0b3IoeyBoYXNoOiBoYXNoMiwgdmVyc2lvbjogdmVyc2lvbjQgfSkge1xcbiAgICAgIHN1cGVyKGBWZXJzaW9uZWQgaGFzaCBcIiR7aGFzaDJ9XCIgdmVyc2lvbiBpcyBpbnZhbGlkLmAsIHtcXG4gICAgICAgIG1ldGFNZXNzYWdlczogW1xcbiAgICAgICAgICBgRXhwZWN0ZWQ6ICR7dmVyc2lvbmVkSGFzaFZlcnNpb25Lemd9YCxcXG4gICAgICAgICAgYFJlY2VpdmVkOiAke3ZlcnNpb240fWBcXG4gICAgICAgIF0sXFxuICAgICAgICBuYW1lOiBcIkludmFsaWRWZXJzaW9uZWRIYXNoVmVyc2lvbkVycm9yXCJcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2Jsb2IvdG9CbG9icy5qc1xcbiAgaW5pdF9jdXJzb3IyKCk7XFxuICBpbml0X3NpemUoKTtcXG4gIGluaXRfdG9CeXRlcygpO1xcbiAgaW5pdF90b0hleCgpO1xcbiAgZnVuY3Rpb24gdG9CbG9icyhwYXJhbWV0ZXJzKSB7XFxuICAgIGNvbnN0IHRvID0gcGFyYW1ldGVycy50byA/PyAodHlwZW9mIHBhcmFtZXRlcnMuZGF0YSA9PT0gXCJzdHJpbmdcIiA/IFwiaGV4XCIgOiBcImJ5dGVzXCIpO1xcbiAgICBjb25zdCBkYXRhID0gdHlwZW9mIHBhcmFtZXRlcnMuZGF0YSA9PT0gXCJzdHJpbmdcIiA/IGhleFRvQnl0ZXMocGFyYW1ldGVycy5kYXRhKSA6IHBhcmFtZXRlcnMuZGF0YTtcXG4gICAgY29uc3Qgc2l6ZV8gPSBzaXplKGRhdGEpO1xcbiAgICBpZiAoIXNpemVfKVxcbiAgICAgIHRocm93IG5ldyBFbXB0eUJsb2JFcnJvcigpO1xcbiAgICBpZiAoc2l6ZV8gPiBtYXhCeXRlc1BlclRyYW5zYWN0aW9uKVxcbiAgICAgIHRocm93IG5ldyBCbG9iU2l6ZVRvb0xhcmdlRXJyb3Ioe1xcbiAgICAgICAgbWF4U2l6ZTogbWF4Qnl0ZXNQZXJUcmFuc2FjdGlvbixcXG4gICAgICAgIHNpemU6IHNpemVfXFxuICAgICAgfSk7XFxuICAgIGNvbnN0IGJsb2JzID0gW107XFxuICAgIGxldCBhY3RpdmUgPSB0cnVlO1xcbiAgICBsZXQgcG9zaXRpb24gPSAwO1xcbiAgICB3aGlsZSAoYWN0aXZlKSB7XFxuICAgICAgY29uc3QgYmxvYiA9IGNyZWF0ZUN1cnNvcihuZXcgVWludDhBcnJheShieXRlc1BlckJsb2IpKTtcXG4gICAgICBsZXQgc2l6ZTUgPSAwO1xcbiAgICAgIHdoaWxlIChzaXplNSA8IGZpZWxkRWxlbWVudHNQZXJCbG9iKSB7XFxuICAgICAgICBjb25zdCBieXRlcyA9IGRhdGEuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgKGJ5dGVzUGVyRmllbGRFbGVtZW50IC0gMSkpO1xcbiAgICAgICAgYmxvYi5wdXNoQnl0ZSgwKTtcXG4gICAgICAgIGJsb2IucHVzaEJ5dGVzKGJ5dGVzKTtcXG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggPCAzMSkge1xcbiAgICAgICAgICBibG9iLnB1c2hCeXRlKDEyOCk7XFxuICAgICAgICAgIGFjdGl2ZSA9IGZhbHNlO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICAgIHNpemU1Kys7XFxuICAgICAgICBwb3NpdGlvbiArPSAzMTtcXG4gICAgICB9XFxuICAgICAgYmxvYnMucHVzaChibG9iKTtcXG4gICAgfVxcbiAgICByZXR1cm4gdG8gPT09IFwiYnl0ZXNcIiA/IGJsb2JzLm1hcCgoeCkgPT4geC5ieXRlcykgOiBibG9icy5tYXAoKHgpID0+IGJ5dGVzVG9IZXgoeC5ieXRlcykpO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvYmxvYi90b0Jsb2JTaWRlY2Fycy5qc1xcbiAgZnVuY3Rpb24gdG9CbG9iU2lkZWNhcnMocGFyYW1ldGVycykge1xcbiAgICBjb25zdCB7IGRhdGEsIGt6ZywgdG8gfSA9IHBhcmFtZXRlcnM7XFxuICAgIGNvbnN0IGJsb2JzID0gcGFyYW1ldGVycy5ibG9icyA/PyB0b0Jsb2JzKHsgZGF0YSwgdG8gfSk7XFxuICAgIGNvbnN0IGNvbW1pdG1lbnRzID0gcGFyYW1ldGVycy5jb21taXRtZW50cyA/PyBibG9ic1RvQ29tbWl0bWVudHMoeyBibG9icywga3pnLCB0byB9KTtcXG4gICAgY29uc3QgcHJvb2ZzID0gcGFyYW1ldGVycy5wcm9vZnMgPz8gYmxvYnNUb1Byb29mcyh7IGJsb2JzLCBjb21taXRtZW50cywga3pnLCB0byB9KTtcXG4gICAgY29uc3Qgc2lkZWNhcnMgPSBbXTtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9icy5sZW5ndGg7IGkrKylcXG4gICAgICBzaWRlY2Fycy5wdXNoKHtcXG4gICAgICAgIGJsb2I6IGJsb2JzW2ldLFxcbiAgICAgICAgY29tbWl0bWVudDogY29tbWl0bWVudHNbaV0sXFxuICAgICAgICBwcm9vZjogcHJvb2ZzW2ldXFxuICAgICAgfSk7XFxuICAgIHJldHVybiBzaWRlY2FycztcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjdGlvbnMvd2FsbGV0L3ByZXBhcmVUcmFuc2FjdGlvblJlcXVlc3QuanNcXG4gIGluaXRfYXNzZXJ0UmVxdWVzdCgpO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvdHJhbnNhY3Rpb24vZ2V0VHJhbnNhY3Rpb25UeXBlLmpzXFxuICBpbml0X3RyYW5zYWN0aW9uKCk7XFxuICBmdW5jdGlvbiBnZXRUcmFuc2FjdGlvblR5cGUodHJhbnNhY3Rpb24pIHtcXG4gICAgaWYgKHRyYW5zYWN0aW9uLnR5cGUpXFxuICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uLnR5cGU7XFxuICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb24uYXV0aG9yaXphdGlvbkxpc3QgIT09IFwidW5kZWZpbmVkXCIpXFxuICAgICAgcmV0dXJuIFwiZWlwNzcwMlwiO1xcbiAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uLmJsb2JzICE9PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiB0cmFuc2FjdGlvbi5ibG9iVmVyc2lvbmVkSGFzaGVzICE9PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiB0cmFuc2FjdGlvbi5tYXhGZWVQZXJCbG9iR2FzICE9PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiB0cmFuc2FjdGlvbi5zaWRlY2FycyAhPT0gXCJ1bmRlZmluZWRcIilcXG4gICAgICByZXR1cm4gXCJlaXA0ODQ0XCI7XFxuICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb24ubWF4RmVlUGVyR2FzICE9PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiB0cmFuc2FjdGlvbi5tYXhQcmlvcml0eUZlZVBlckdhcyAhPT0gXCJ1bmRlZmluZWRcIikge1xcbiAgICAgIHJldHVybiBcImVpcDE1NTlcIjtcXG4gICAgfVxcbiAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uLmdhc1ByaWNlICE9PSBcInVuZGVmaW5lZFwiKSB7XFxuICAgICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0ICE9PSBcInVuZGVmaW5lZFwiKVxcbiAgICAgICAgcmV0dXJuIFwiZWlwMjkzMFwiO1xcbiAgICAgIHJldHVybiBcImxlZ2FjeVwiO1xcbiAgICB9XFxuICAgIHRocm93IG5ldyBJbnZhbGlkU2VyaWFsaXphYmxlVHJhbnNhY3Rpb25FcnJvcih7IHRyYW5zYWN0aW9uIH0pO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vYWN0aW9ucy9wdWJsaWMvZ2V0Q2hhaW5JZC5qc1xcbiAgaW5pdF9mcm9tSGV4KCk7XFxuICBhc3luYyBmdW5jdGlvbiBnZXRDaGFpbklkKGNsaWVudCkge1xcbiAgICBjb25zdCBjaGFpbklkSGV4ID0gYXdhaXQgY2xpZW50LnJlcXVlc3Qoe1xcbiAgICAgIG1ldGhvZDogXCJldGhfY2hhaW5JZFwiXFxuICAgIH0sIHsgZGVkdXBlOiB0cnVlIH0pO1xcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoY2hhaW5JZEhleCk7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL3dhbGxldC9wcmVwYXJlVHJhbnNhY3Rpb25SZXF1ZXN0LmpzXFxuICB2YXIgZGVmYXVsdFBhcmFtZXRlcnMgPSBbXFxuICAgIFwiYmxvYlZlcnNpb25lZEhhc2hlc1wiLFxcbiAgICBcImNoYWluSWRcIixcXG4gICAgXCJmZWVzXCIsXFxuICAgIFwiZ2FzXCIsXFxuICAgIFwibm9uY2VcIixcXG4gICAgXCJ0eXBlXCJcXG4gIF07XFxuICB2YXIgZWlwMTU1OU5ldHdvcmtDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XFxuICBhc3luYyBmdW5jdGlvbiBwcmVwYXJlVHJhbnNhY3Rpb25SZXF1ZXN0KGNsaWVudCwgYXJncykge1xcbiAgICBjb25zdCB7IGFjY291bnQ6IGFjY291bnRfID0gY2xpZW50LmFjY291bnQsIGJsb2JzLCBjaGFpbiwgZ2FzLCBremcsIG5vbmNlLCBub25jZU1hbmFnZXIsIHBhcmFtZXRlcnMgPSBkZWZhdWx0UGFyYW1ldGVycywgdHlwZSB9ID0gYXJncztcXG4gICAgY29uc3QgYWNjb3VudCA9IGFjY291bnRfID8gcGFyc2VBY2NvdW50KGFjY291bnRfKSA6IGFjY291bnRfO1xcbiAgICBjb25zdCByZXF1ZXN0ID0geyAuLi5hcmdzLCAuLi5hY2NvdW50ID8geyBmcm9tOiBhY2NvdW50Py5hZGRyZXNzIH0gOiB7fSB9O1xcbiAgICBsZXQgYmxvY2s7XFxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldEJsb2NrMigpIHtcXG4gICAgICBpZiAoYmxvY2spXFxuICAgICAgICByZXR1cm4gYmxvY2s7XFxuICAgICAgYmxvY2sgPSBhd2FpdCBnZXRBY3Rpb24oY2xpZW50LCBnZXRCbG9jaywgXCJnZXRCbG9ja1wiKSh7IGJsb2NrVGFnOiBcImxhdGVzdFwiIH0pO1xcbiAgICAgIHJldHVybiBibG9jaztcXG4gICAgfVxcbiAgICBsZXQgY2hhaW5JZDtcXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0Q2hhaW5JZDIoKSB7XFxuICAgICAgaWYgKGNoYWluSWQpXFxuICAgICAgICByZXR1cm4gY2hhaW5JZDtcXG4gICAgICBpZiAoY2hhaW4pXFxuICAgICAgICByZXR1cm4gY2hhaW4uaWQ7XFxuICAgICAgaWYgKHR5cGVvZiBhcmdzLmNoYWluSWQgIT09IFwidW5kZWZpbmVkXCIpXFxuICAgICAgICByZXR1cm4gYXJncy5jaGFpbklkO1xcbiAgICAgIGNvbnN0IGNoYWluSWRfID0gYXdhaXQgZ2V0QWN0aW9uKGNsaWVudCwgZ2V0Q2hhaW5JZCwgXCJnZXRDaGFpbklkXCIpKHt9KTtcXG4gICAgICBjaGFpbklkID0gY2hhaW5JZF87XFxuICAgICAgcmV0dXJuIGNoYWluSWQ7XFxuICAgIH1cXG4gICAgaWYgKHBhcmFtZXRlcnMuaW5jbHVkZXMoXCJub25jZVwiKSAmJiB0eXBlb2Ygbm9uY2UgPT09IFwidW5kZWZpbmVkXCIgJiYgYWNjb3VudCkge1xcbiAgICAgIGlmIChub25jZU1hbmFnZXIpIHtcXG4gICAgICAgIGNvbnN0IGNoYWluSWQyID0gYXdhaXQgZ2V0Q2hhaW5JZDIoKTtcXG4gICAgICAgIHJlcXVlc3Qubm9uY2UgPSBhd2FpdCBub25jZU1hbmFnZXIuY29uc3VtZSh7XFxuICAgICAgICAgIGFkZHJlc3M6IGFjY291bnQuYWRkcmVzcyxcXG4gICAgICAgICAgY2hhaW5JZDogY2hhaW5JZDIsXFxuICAgICAgICAgIGNsaWVudFxcbiAgICAgICAgfSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJlcXVlc3Qubm9uY2UgPSBhd2FpdCBnZXRBY3Rpb24oY2xpZW50LCBnZXRUcmFuc2FjdGlvbkNvdW50LCBcImdldFRyYW5zYWN0aW9uQ291bnRcIikoe1xcbiAgICAgICAgICBhZGRyZXNzOiBhY2NvdW50LmFkZHJlc3MsXFxuICAgICAgICAgIGJsb2NrVGFnOiBcInBlbmRpbmdcIlxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmICgocGFyYW1ldGVycy5pbmNsdWRlcyhcImJsb2JWZXJzaW9uZWRIYXNoZXNcIikgfHwgcGFyYW1ldGVycy5pbmNsdWRlcyhcInNpZGVjYXJzXCIpKSAmJiBibG9icyAmJiBremcpIHtcXG4gICAgICBjb25zdCBjb21taXRtZW50cyA9IGJsb2JzVG9Db21taXRtZW50cyh7IGJsb2JzLCBremcgfSk7XFxuICAgICAgaWYgKHBhcmFtZXRlcnMuaW5jbHVkZXMoXCJibG9iVmVyc2lvbmVkSGFzaGVzXCIpKSB7XFxuICAgICAgICBjb25zdCB2ZXJzaW9uZWRIYXNoZXMgPSBjb21taXRtZW50c1RvVmVyc2lvbmVkSGFzaGVzKHtcXG4gICAgICAgICAgY29tbWl0bWVudHMsXFxuICAgICAgICAgIHRvOiBcImhleFwiXFxuICAgICAgICB9KTtcXG4gICAgICAgIHJlcXVlc3QuYmxvYlZlcnNpb25lZEhhc2hlcyA9IHZlcnNpb25lZEhhc2hlcztcXG4gICAgICB9XFxuICAgICAgaWYgKHBhcmFtZXRlcnMuaW5jbHVkZXMoXCJzaWRlY2Fyc1wiKSkge1xcbiAgICAgICAgY29uc3QgcHJvb2ZzID0gYmxvYnNUb1Byb29mcyh7IGJsb2JzLCBjb21taXRtZW50cywga3pnIH0pO1xcbiAgICAgICAgY29uc3Qgc2lkZWNhcnMgPSB0b0Jsb2JTaWRlY2Fycyh7XFxuICAgICAgICAgIGJsb2JzLFxcbiAgICAgICAgICBjb21taXRtZW50cyxcXG4gICAgICAgICAgcHJvb2ZzLFxcbiAgICAgICAgICB0bzogXCJoZXhcIlxcbiAgICAgICAgfSk7XFxuICAgICAgICByZXF1ZXN0LnNpZGVjYXJzID0gc2lkZWNhcnM7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmIChwYXJhbWV0ZXJzLmluY2x1ZGVzKFwiY2hhaW5JZFwiKSlcXG4gICAgICByZXF1ZXN0LmNoYWluSWQgPSBhd2FpdCBnZXRDaGFpbklkMigpO1xcbiAgICBpZiAoKHBhcmFtZXRlcnMuaW5jbHVkZXMoXCJmZWVzXCIpIHx8IHBhcmFtZXRlcnMuaW5jbHVkZXMoXCJ0eXBlXCIpKSAmJiB0eXBlb2YgdHlwZSA9PT0gXCJ1bmRlZmluZWRcIikge1xcbiAgICAgIHRyeSB7XFxuICAgICAgICByZXF1ZXN0LnR5cGUgPSBnZXRUcmFuc2FjdGlvblR5cGUocmVxdWVzdCk7XFxuICAgICAgfSBjYXRjaCB7XFxuICAgICAgICBsZXQgaXNFaXAxNTU5TmV0d29yayA9IGVpcDE1NTlOZXR3b3JrQ2FjaGUuZ2V0KGNsaWVudC51aWQpO1xcbiAgICAgICAgaWYgKHR5cGVvZiBpc0VpcDE1NTlOZXR3b3JrID09PSBcInVuZGVmaW5lZFwiKSB7XFxuICAgICAgICAgIGNvbnN0IGJsb2NrMiA9IGF3YWl0IGdldEJsb2NrMigpO1xcbiAgICAgICAgICBpc0VpcDE1NTlOZXR3b3JrID0gdHlwZW9mIGJsb2NrMj8uYmFzZUZlZVBlckdhcyA9PT0gXCJiaWdpbnRcIjtcXG4gICAgICAgICAgZWlwMTU1OU5ldHdvcmtDYWNoZS5zZXQoY2xpZW50LnVpZCwgaXNFaXAxNTU5TmV0d29yayk7XFxuICAgICAgICB9XFxuICAgICAgICByZXF1ZXN0LnR5cGUgPSBpc0VpcDE1NTlOZXR3b3JrID8gXCJlaXAxNTU5XCIgOiBcImxlZ2FjeVwiO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBpZiAocGFyYW1ldGVycy5pbmNsdWRlcyhcImZlZXNcIikpIHtcXG4gICAgICBpZiAocmVxdWVzdC50eXBlICE9PSBcImxlZ2FjeVwiICYmIHJlcXVlc3QudHlwZSAhPT0gXCJlaXAyOTMwXCIpIHtcXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdC5tYXhGZWVQZXJHYXMgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIHJlcXVlc3QubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT09IFwidW5kZWZpbmVkXCIpIHtcXG4gICAgICAgICAgY29uc3QgYmxvY2syID0gYXdhaXQgZ2V0QmxvY2syKCk7XFxuICAgICAgICAgIGNvbnN0IHsgbWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhcyB9ID0gYXdhaXQgaW50ZXJuYWxfZXN0aW1hdGVGZWVzUGVyR2FzKGNsaWVudCwge1xcbiAgICAgICAgICAgIGJsb2NrOiBibG9jazIsXFxuICAgICAgICAgICAgY2hhaW4sXFxuICAgICAgICAgICAgcmVxdWVzdFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgaWYgKHR5cGVvZiBhcmdzLm1heFByaW9yaXR5RmVlUGVyR2FzID09PSBcInVuZGVmaW5lZFwiICYmIGFyZ3MubWF4RmVlUGVyR2FzICYmIGFyZ3MubWF4RmVlUGVyR2FzIDwgbWF4UHJpb3JpdHlGZWVQZXJHYXMpXFxuICAgICAgICAgICAgdGhyb3cgbmV3IE1heEZlZVBlckdhc1Rvb0xvd0Vycm9yKHtcXG4gICAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIHJlcXVlc3QubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBtYXhQcmlvcml0eUZlZVBlckdhcztcXG4gICAgICAgICAgcmVxdWVzdC5tYXhGZWVQZXJHYXMgPSBtYXhGZWVQZXJHYXM7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGlmICh0eXBlb2YgYXJncy5tYXhGZWVQZXJHYXMgIT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIGFyZ3MubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT09IFwidW5kZWZpbmVkXCIpXFxuICAgICAgICAgIHRocm93IG5ldyBFaXAxNTU5RmVlc05vdFN1cHBvcnRlZEVycm9yKCk7XFxuICAgICAgICBpZiAodHlwZW9mIGFyZ3MuZ2FzUHJpY2UgPT09IFwidW5kZWZpbmVkXCIpIHtcXG4gICAgICAgICAgY29uc3QgYmxvY2syID0gYXdhaXQgZ2V0QmxvY2syKCk7XFxuICAgICAgICAgIGNvbnN0IHsgZ2FzUHJpY2U6IGdhc1ByaWNlXyB9ID0gYXdhaXQgaW50ZXJuYWxfZXN0aW1hdGVGZWVzUGVyR2FzKGNsaWVudCwge1xcbiAgICAgICAgICAgIGJsb2NrOiBibG9jazIsXFxuICAgICAgICAgICAgY2hhaW4sXFxuICAgICAgICAgICAgcmVxdWVzdCxcXG4gICAgICAgICAgICB0eXBlOiBcImxlZ2FjeVwiXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICByZXF1ZXN0Lmdhc1ByaWNlID0gZ2FzUHJpY2VfO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICBpZiAocGFyYW1ldGVycy5pbmNsdWRlcyhcImdhc1wiKSAmJiB0eXBlb2YgZ2FzID09PSBcInVuZGVmaW5lZFwiKVxcbiAgICAgIHJlcXVlc3QuZ2FzID0gYXdhaXQgZ2V0QWN0aW9uKGNsaWVudCwgZXN0aW1hdGVHYXMsIFwiZXN0aW1hdGVHYXNcIikoe1xcbiAgICAgICAgLi4ucmVxdWVzdCxcXG4gICAgICAgIGFjY291bnQ6IGFjY291bnQgPyB7IGFkZHJlc3M6IGFjY291bnQuYWRkcmVzcywgdHlwZTogXCJqc29uLXJwY1wiIH0gOiBhY2NvdW50XFxuICAgICAgfSk7XFxuICAgIGFzc2VydFJlcXVlc3QocmVxdWVzdCk7XFxuICAgIGRlbGV0ZSByZXF1ZXN0LnBhcmFtZXRlcnM7XFxuICAgIHJldHVybiByZXF1ZXN0O1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vYWN0aW9ucy9wdWJsaWMvZ2V0QmFsYW5jZS5qc1xcbiAgaW5pdF90b0hleCgpO1xcbiAgYXN5bmMgZnVuY3Rpb24gZ2V0QmFsYW5jZShjbGllbnQsIHsgYWRkcmVzcywgYmxvY2tOdW1iZXIsIGJsb2NrVGFnID0gXCJsYXRlc3RcIiB9KSB7XFxuICAgIGNvbnN0IGJsb2NrTnVtYmVySGV4ID0gYmxvY2tOdW1iZXIgPyBudW1iZXJUb0hleChibG9ja051bWJlcikgOiB2b2lkIDA7XFxuICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBjbGllbnQucmVxdWVzdCh7XFxuICAgICAgbWV0aG9kOiBcImV0aF9nZXRCYWxhbmNlXCIsXFxuICAgICAgcGFyYW1zOiBbYWRkcmVzcywgYmxvY2tOdW1iZXJIZXggfHwgYmxvY2tUYWddXFxuICAgIH0pO1xcbiAgICByZXR1cm4gQmlnSW50KGJhbGFuY2UpO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vYWN0aW9ucy9wdWJsaWMvZXN0aW1hdGVHYXMuanNcXG4gIGFzeW5jIGZ1bmN0aW9uIGVzdGltYXRlR2FzKGNsaWVudCwgYXJncykge1xcbiAgICBjb25zdCB7IGFjY291bnQ6IGFjY291bnRfID0gY2xpZW50LmFjY291bnQgfSA9IGFyZ3M7XFxuICAgIGNvbnN0IGFjY291bnQgPSBhY2NvdW50XyA/IHBhcnNlQWNjb3VudChhY2NvdW50XykgOiB2b2lkIDA7XFxuICAgIHRyeSB7XFxuICAgICAgbGV0IGVzdGltYXRlR2FzX3JwYyA9IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcXG4gICAgICAgIGNvbnN0IHsgYmxvY2s6IGJsb2NrMiwgcmVxdWVzdDogcmVxdWVzdDIsIHJwY1N0YXRlT3ZlcnJpZGU6IHJwY1N0YXRlT3ZlcnJpZGUyIH0gPSBwYXJhbWV0ZXJzO1xcbiAgICAgICAgcmV0dXJuIGNsaWVudC5yZXF1ZXN0KHtcXG4gICAgICAgICAgbWV0aG9kOiBcImV0aF9lc3RpbWF0ZUdhc1wiLFxcbiAgICAgICAgICBwYXJhbXM6IHJwY1N0YXRlT3ZlcnJpZGUyID8gW3JlcXVlc3QyLCBibG9jazIgPz8gXCJsYXRlc3RcIiwgcnBjU3RhdGVPdmVycmlkZTJdIDogYmxvY2syID8gW3JlcXVlc3QyLCBibG9jazJdIDogW3JlcXVlc3QyXVxcbiAgICAgICAgfSk7XFxuICAgICAgfTtcXG4gICAgICBjb25zdCB7IGFjY2Vzc0xpc3QsIGF1dGhvcml6YXRpb25MaXN0LCBibG9icywgYmxvYlZlcnNpb25lZEhhc2hlcywgYmxvY2tOdW1iZXIsIGJsb2NrVGFnLCBkYXRhLCBnYXMsIGdhc1ByaWNlLCBtYXhGZWVQZXJCbG9iR2FzLCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzLCBub25jZSwgdmFsdWUsIHN0YXRlT3ZlcnJpZGUsIC4uLnJlc3QgfSA9IGF3YWl0IHByZXBhcmVUcmFuc2FjdGlvblJlcXVlc3QoY2xpZW50LCB7XFxuICAgICAgICAuLi5hcmdzLFxcbiAgICAgICAgcGFyYW1ldGVyczogKFxcbiAgICAgICAgICAvLyBTb21lIFJQQyBQcm92aWRlcnMgZG8gbm90IGNvbXB1dGUgdmVyc2lvbmVkIGhhc2hlcyBmcm9tIGJsb2JzLiBXZSB3aWxsIG5lZWRcXG4gICAgICAgICAgLy8gdG8gY29tcHV0ZSB0aGVtLlxcbiAgICAgICAgICBhY2NvdW50Py50eXBlID09PSBcImxvY2FsXCIgPyB2b2lkIDAgOiBbXCJibG9iVmVyc2lvbmVkSGFzaGVzXCJdXFxuICAgICAgICApXFxuICAgICAgfSk7XFxuICAgICAgY29uc3QgYmxvY2tOdW1iZXJIZXggPSBibG9ja051bWJlciA/IG51bWJlclRvSGV4KGJsb2NrTnVtYmVyKSA6IHZvaWQgMDtcXG4gICAgICBjb25zdCBibG9jayA9IGJsb2NrTnVtYmVySGV4IHx8IGJsb2NrVGFnO1xcbiAgICAgIGNvbnN0IHJwY1N0YXRlT3ZlcnJpZGUgPSBzZXJpYWxpemVTdGF0ZU92ZXJyaWRlKHN0YXRlT3ZlcnJpZGUpO1xcbiAgICAgIGNvbnN0IHRvID0gYXdhaXQgKGFzeW5jICgpID0+IHtcXG4gICAgICAgIGlmIChyZXN0LnRvKVxcbiAgICAgICAgICByZXR1cm4gcmVzdC50bztcXG4gICAgICAgIGlmIChhdXRob3JpemF0aW9uTGlzdCAmJiBhdXRob3JpemF0aW9uTGlzdC5sZW5ndGggPiAwKVxcbiAgICAgICAgICByZXR1cm4gYXdhaXQgcmVjb3ZlckF1dGhvcml6YXRpb25BZGRyZXNzKHtcXG4gICAgICAgICAgICBhdXRob3JpemF0aW9uOiBhdXRob3JpemF0aW9uTGlzdFswXVxcbiAgICAgICAgICB9KS5jYXRjaCgoKSA9PiB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEJhc2VFcnJvcjIoXCJgdG9gIGlzIHJlcXVpcmVkLiBDb3VsZCBub3QgaW5mZXIgZnJvbSBgYXV0aG9yaXphdGlvbkxpc3RgXCIpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiB2b2lkIDA7XFxuICAgICAgfSkoKTtcXG4gICAgICBhc3NlcnRSZXF1ZXN0KGFyZ3MpO1xcbiAgICAgIGNvbnN0IGNoYWluRm9ybWF0ID0gY2xpZW50LmNoYWluPy5mb3JtYXR0ZXJzPy50cmFuc2FjdGlvblJlcXVlc3Q/LmZvcm1hdDtcXG4gICAgICBjb25zdCBmb3JtYXQgPSBjaGFpbkZvcm1hdCB8fCBmb3JtYXRUcmFuc2FjdGlvblJlcXVlc3Q7XFxuICAgICAgY29uc3QgcmVxdWVzdCA9IGZvcm1hdCh7XFxuICAgICAgICAvLyBQaWNrIG91dCBleHRyYSBkYXRhIHRoYXQgbWlnaHQgZXhpc3Qgb24gdGhlIGNoYWluXFwncyB0cmFuc2FjdGlvbiByZXF1ZXN0IHR5cGUuXFxuICAgICAgICAuLi5leHRyYWN0KHJlc3QsIHsgZm9ybWF0OiBjaGFpbkZvcm1hdCB9KSxcXG4gICAgICAgIGZyb206IGFjY291bnQ/LmFkZHJlc3MsXFxuICAgICAgICBhY2Nlc3NMaXN0LFxcbiAgICAgICAgYXV0aG9yaXphdGlvbkxpc3QsXFxuICAgICAgICBibG9icyxcXG4gICAgICAgIGJsb2JWZXJzaW9uZWRIYXNoZXMsXFxuICAgICAgICBkYXRhLFxcbiAgICAgICAgZ2FzLFxcbiAgICAgICAgZ2FzUHJpY2UsXFxuICAgICAgICBtYXhGZWVQZXJCbG9iR2FzLFxcbiAgICAgICAgbWF4RmVlUGVyR2FzLFxcbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXMsXFxuICAgICAgICBub25jZSxcXG4gICAgICAgIHRvLFxcbiAgICAgICAgdmFsdWVcXG4gICAgICB9KTtcXG4gICAgICBsZXQgZXN0aW1hdGUgPSBCaWdJbnQoYXdhaXQgZXN0aW1hdGVHYXNfcnBjKHsgYmxvY2ssIHJlcXVlc3QsIHJwY1N0YXRlT3ZlcnJpZGUgfSkpO1xcbiAgICAgIGlmIChhdXRob3JpemF0aW9uTGlzdCkge1xcbiAgICAgICAgY29uc3QgdmFsdWUyID0gYXdhaXQgZ2V0QmFsYW5jZShjbGllbnQsIHsgYWRkcmVzczogcmVxdWVzdC5mcm9tIH0pO1xcbiAgICAgICAgY29uc3QgZXN0aW1hdGVzID0gYXdhaXQgUHJvbWlzZS5hbGwoYXV0aG9yaXphdGlvbkxpc3QubWFwKGFzeW5jIChhdXRob3JpemF0aW9uKSA9PiB7XFxuICAgICAgICAgIGNvbnN0IHsgYWRkcmVzcyB9ID0gYXV0aG9yaXphdGlvbjtcXG4gICAgICAgICAgY29uc3QgZXN0aW1hdGUyID0gYXdhaXQgZXN0aW1hdGVHYXNfcnBjKHtcXG4gICAgICAgICAgICBibG9jayxcXG4gICAgICAgICAgICByZXF1ZXN0OiB7XFxuICAgICAgICAgICAgICBhdXRob3JpemF0aW9uTGlzdDogdm9pZCAwLFxcbiAgICAgICAgICAgICAgZGF0YSxcXG4gICAgICAgICAgICAgIGZyb206IGFjY291bnQ/LmFkZHJlc3MsXFxuICAgICAgICAgICAgICB0bzogYWRkcmVzcyxcXG4gICAgICAgICAgICAgIHZhbHVlOiBudW1iZXJUb0hleCh2YWx1ZTIpXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBycGNTdGF0ZU92ZXJyaWRlXFxuICAgICAgICAgIH0pLmNhdGNoKCgpID0+IDEwMDAwMG4pO1xcbiAgICAgICAgICByZXR1cm4gMm4gKiBCaWdJbnQoZXN0aW1hdGUyKTtcXG4gICAgICAgIH0pKTtcXG4gICAgICAgIGVzdGltYXRlICs9IGVzdGltYXRlcy5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjICsgY3VyciwgMG4pO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gZXN0aW1hdGU7XFxuICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgIHRocm93IGdldEVzdGltYXRlR2FzRXJyb3IoZXJyLCB7XFxuICAgICAgICAuLi5hcmdzLFxcbiAgICAgICAgYWNjb3VudCxcXG4gICAgICAgIGNoYWluOiBjbGllbnQuY2hhaW5cXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vYWN0aW9ucy9wdWJsaWMvZXN0aW1hdGVDb250cmFjdEdhcy5qc1xcbiAgYXN5bmMgZnVuY3Rpb24gZXN0aW1hdGVDb250cmFjdEdhcyhjbGllbnQsIHBhcmFtZXRlcnMpIHtcXG4gICAgY29uc3QgeyBhYmk6IGFiaTIsIGFkZHJlc3MsIGFyZ3MsIGZ1bmN0aW9uTmFtZSwgZGF0YVN1ZmZpeCwgLi4ucmVxdWVzdCB9ID0gcGFyYW1ldGVycztcXG4gICAgY29uc3QgZGF0YSA9IGVuY29kZUZ1bmN0aW9uRGF0YSh7XFxuICAgICAgYWJpOiBhYmkyLFxcbiAgICAgIGFyZ3MsXFxuICAgICAgZnVuY3Rpb25OYW1lXFxuICAgIH0pO1xcbiAgICB0cnkge1xcbiAgICAgIGNvbnN0IGdhcyA9IGF3YWl0IGdldEFjdGlvbihjbGllbnQsIGVzdGltYXRlR2FzLCBcImVzdGltYXRlR2FzXCIpKHtcXG4gICAgICAgIGRhdGE6IGAke2RhdGF9JHtkYXRhU3VmZml4ID8gZGF0YVN1ZmZpeC5yZXBsYWNlKFwiMHhcIiwgXCJcIikgOiBcIlwifWAsXFxuICAgICAgICB0bzogYWRkcmVzcyxcXG4gICAgICAgIC4uLnJlcXVlc3RcXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gZ2FzO1xcbiAgICB9IGNhdGNoIChlcnJvcikge1xcbiAgICAgIGNvbnN0IGFjY291bnQgPSByZXF1ZXN0LmFjY291bnQgPyBwYXJzZUFjY291bnQocmVxdWVzdC5hY2NvdW50KSA6IHZvaWQgMDtcXG4gICAgICB0aHJvdyBnZXRDb250cmFjdEVycm9yKGVycm9yLCB7XFxuICAgICAgICBhYmk6IGFiaTIsXFxuICAgICAgICBhZGRyZXNzLFxcbiAgICAgICAgYXJncyxcXG4gICAgICAgIGRvY3NQYXRoOiBcIi9kb2NzL2NvbnRyYWN0L2VzdGltYXRlQ29udHJhY3RHYXNcIixcXG4gICAgICAgIGZ1bmN0aW9uTmFtZSxcXG4gICAgICAgIHNlbmRlcjogYWNjb3VudD8uYWRkcmVzc1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL3B1YmxpYy9nZXRDb250cmFjdEV2ZW50cy5qc1xcbiAgaW5pdF9nZXRBYmlJdGVtKCk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9hYmkvcGFyc2VFdmVudExvZ3MuanNcXG4gIGluaXRfYWJpKCk7XFxuICBpbml0X2lzQWRkcmVzc0VxdWFsKCk7XFxuICBpbml0X3RvQnl0ZXMoKTtcXG4gIGluaXRfa2VjY2FrMjU2KCk7XFxuICBpbml0X3RvRXZlbnRTZWxlY3RvcigpO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvYWJpL2RlY29kZUV2ZW50TG9nLmpzXFxuICBpbml0X2FiaSgpO1xcbiAgaW5pdF9zaXplKCk7XFxuICBpbml0X3RvRXZlbnRTZWxlY3RvcigpO1xcbiAgaW5pdF9jdXJzb3IoKTtcXG4gIGluaXRfZGVjb2RlQWJpUGFyYW1ldGVycygpO1xcbiAgaW5pdF9mb3JtYXRBYmlJdGVtMigpO1xcbiAgdmFyIGRvY3NQYXRoMyA9IFwiL2RvY3MvY29udHJhY3QvZGVjb2RlRXZlbnRMb2dcIjtcXG4gIGZ1bmN0aW9uIGRlY29kZUV2ZW50TG9nKHBhcmFtZXRlcnMpIHtcXG4gICAgY29uc3QgeyBhYmk6IGFiaTIsIGRhdGEsIHN0cmljdDogc3RyaWN0XywgdG9waWNzIH0gPSBwYXJhbWV0ZXJzO1xcbiAgICBjb25zdCBzdHJpY3QgPSBzdHJpY3RfID8/IHRydWU7XFxuICAgIGNvbnN0IFtzaWduYXR1cmUsIC4uLmFyZ1RvcGljc10gPSB0b3BpY3M7XFxuICAgIGlmICghc2lnbmF0dXJlKVxcbiAgICAgIHRocm93IG5ldyBBYmlFdmVudFNpZ25hdHVyZUVtcHR5VG9waWNzRXJyb3IoeyBkb2NzUGF0aDogZG9jc1BhdGgzIH0pO1xcbiAgICBjb25zdCBhYmlJdGVtID0gKCgpID0+IHtcXG4gICAgICBpZiAoYWJpMi5sZW5ndGggPT09IDEpXFxuICAgICAgICByZXR1cm4gYWJpMlswXTtcXG4gICAgICByZXR1cm4gYWJpMi5maW5kKCh4KSA9PiB4LnR5cGUgPT09IFwiZXZlbnRcIiAmJiBzaWduYXR1cmUgPT09IHRvRXZlbnRTZWxlY3Rvcihmb3JtYXRBYmlJdGVtMih4KSkpO1xcbiAgICB9KSgpO1xcbiAgICBpZiAoIShhYmlJdGVtICYmIFwibmFtZVwiIGluIGFiaUl0ZW0pIHx8IGFiaUl0ZW0udHlwZSAhPT0gXCJldmVudFwiKVxcbiAgICAgIHRocm93IG5ldyBBYmlFdmVudFNpZ25hdHVyZU5vdEZvdW5kRXJyb3Ioc2lnbmF0dXJlLCB7IGRvY3NQYXRoOiBkb2NzUGF0aDMgfSk7XFxuICAgIGNvbnN0IHsgbmFtZSwgaW5wdXRzIH0gPSBhYmlJdGVtO1xcbiAgICBjb25zdCBpc1VubmFtZWQgPSBpbnB1dHM/LnNvbWUoKHgpID0+ICEoXCJuYW1lXCIgaW4geCAmJiB4Lm5hbWUpKTtcXG4gICAgbGV0IGFyZ3MgPSBpc1VubmFtZWQgPyBbXSA6IHt9O1xcbiAgICBjb25zdCBpbmRleGVkSW5wdXRzID0gaW5wdXRzLmZpbHRlcigoeCkgPT4gXCJpbmRleGVkXCIgaW4geCAmJiB4LmluZGV4ZWQpO1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4ZWRJbnB1dHMubGVuZ3RoOyBpKyspIHtcXG4gICAgICBjb25zdCBwYXJhbSA9IGluZGV4ZWRJbnB1dHNbaV07XFxuICAgICAgY29uc3QgdG9waWMgPSBhcmdUb3BpY3NbaV07XFxuICAgICAgaWYgKCF0b3BpYylcXG4gICAgICAgIHRocm93IG5ldyBEZWNvZGVMb2dUb3BpY3NNaXNtYXRjaCh7XFxuICAgICAgICAgIGFiaUl0ZW0sXFxuICAgICAgICAgIHBhcmFtXFxuICAgICAgICB9KTtcXG4gICAgICBhcmdzW2lzVW5uYW1lZCA/IGkgOiBwYXJhbS5uYW1lIHx8IGldID0gZGVjb2RlVG9waWMoeyBwYXJhbSwgdmFsdWU6IHRvcGljIH0pO1xcbiAgICB9XFxuICAgIGNvbnN0IG5vbkluZGV4ZWRJbnB1dHMgPSBpbnB1dHMuZmlsdGVyKCh4KSA9PiAhKFwiaW5kZXhlZFwiIGluIHggJiYgeC5pbmRleGVkKSk7XFxuICAgIGlmIChub25JbmRleGVkSW5wdXRzLmxlbmd0aCA+IDApIHtcXG4gICAgICBpZiAoZGF0YSAmJiBkYXRhICE9PSBcIjB4XCIpIHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIGNvbnN0IGRlY29kZWREYXRhID0gZGVjb2RlQWJpUGFyYW1ldGVycyhub25JbmRleGVkSW5wdXRzLCBkYXRhKTtcXG4gICAgICAgICAgaWYgKGRlY29kZWREYXRhKSB7XFxuICAgICAgICAgICAgaWYgKGlzVW5uYW1lZClcXG4gICAgICAgICAgICAgIGFyZ3MgPSBbLi4uYXJncywgLi4uZGVjb2RlZERhdGFdO1xcbiAgICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub25JbmRleGVkSW5wdXRzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIGFyZ3Nbbm9uSW5kZXhlZElucHV0c1tpXS5uYW1lXSA9IGRlY29kZWREYXRhW2ldO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICAgIGlmIChzdHJpY3QpIHtcXG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQWJpRGVjb2RpbmdEYXRhU2l6ZVRvb1NtYWxsRXJyb3IgfHwgZXJyIGluc3RhbmNlb2YgUG9zaXRpb25PdXRPZkJvdW5kc0Vycm9yKVxcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IERlY29kZUxvZ0RhdGFNaXNtYXRjaCh7XFxuICAgICAgICAgICAgICAgIGFiaUl0ZW0sXFxuICAgICAgICAgICAgICAgIGRhdGEsXFxuICAgICAgICAgICAgICAgIHBhcmFtczogbm9uSW5kZXhlZElucHV0cyxcXG4gICAgICAgICAgICAgICAgc2l6ZTogc2l6ZShkYXRhKVxcbiAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgdGhyb3cgZXJyO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIGlmIChzdHJpY3QpIHtcXG4gICAgICAgIHRocm93IG5ldyBEZWNvZGVMb2dEYXRhTWlzbWF0Y2goe1xcbiAgICAgICAgICBhYmlJdGVtLFxcbiAgICAgICAgICBkYXRhOiBcIjB4XCIsXFxuICAgICAgICAgIHBhcmFtczogbm9uSW5kZXhlZElucHV0cyxcXG4gICAgICAgICAgc2l6ZTogMFxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiB7XFxuICAgICAgZXZlbnROYW1lOiBuYW1lLFxcbiAgICAgIGFyZ3M6IE9iamVjdC52YWx1ZXMoYXJncykubGVuZ3RoID4gMCA/IGFyZ3MgOiB2b2lkIDBcXG4gICAgfTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGRlY29kZVRvcGljKHsgcGFyYW0sIHZhbHVlIH0pIHtcXG4gICAgaWYgKHBhcmFtLnR5cGUgPT09IFwic3RyaW5nXCIgfHwgcGFyYW0udHlwZSA9PT0gXCJieXRlc1wiIHx8IHBhcmFtLnR5cGUgPT09IFwidHVwbGVcIiB8fCBwYXJhbS50eXBlLm1hdGNoKC9eKC4qKVxcXFxbKFxcXFxkKyk/XFxcXF0kLykpXFxuICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICBjb25zdCBkZWNvZGVkQXJnID0gZGVjb2RlQWJpUGFyYW1ldGVycyhbcGFyYW1dLCB2YWx1ZSkgfHwgW107XFxuICAgIHJldHVybiBkZWNvZGVkQXJnWzBdO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvYWJpL3BhcnNlRXZlbnRMb2dzLmpzXFxuICBmdW5jdGlvbiBwYXJzZUV2ZW50TG9ncyhwYXJhbWV0ZXJzKSB7XFxuICAgIGNvbnN0IHsgYWJpOiBhYmkyLCBhcmdzLCBsb2dzLCBzdHJpY3QgPSB0cnVlIH0gPSBwYXJhbWV0ZXJzO1xcbiAgICBjb25zdCBldmVudE5hbWUgPSAoKCkgPT4ge1xcbiAgICAgIGlmICghcGFyYW1ldGVycy5ldmVudE5hbWUpXFxuICAgICAgICByZXR1cm4gdm9pZCAwO1xcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcnMuZXZlbnROYW1lKSlcXG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLmV2ZW50TmFtZTtcXG4gICAgICByZXR1cm4gW3BhcmFtZXRlcnMuZXZlbnROYW1lXTtcXG4gICAgfSkoKTtcXG4gICAgcmV0dXJuIGxvZ3MubWFwKChsb2cpID0+IHtcXG4gICAgICB0cnkge1xcbiAgICAgICAgY29uc3QgYWJpSXRlbSA9IGFiaTIuZmluZCgoYWJpSXRlbTIpID0+IGFiaUl0ZW0yLnR5cGUgPT09IFwiZXZlbnRcIiAmJiBsb2cudG9waWNzWzBdID09PSB0b0V2ZW50U2VsZWN0b3IoYWJpSXRlbTIpKTtcXG4gICAgICAgIGlmICghYWJpSXRlbSlcXG4gICAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgICBjb25zdCBldmVudCA9IGRlY29kZUV2ZW50TG9nKHtcXG4gICAgICAgICAgLi4ubG9nLFxcbiAgICAgICAgICBhYmk6IFthYmlJdGVtXSxcXG4gICAgICAgICAgc3RyaWN0XFxuICAgICAgICB9KTtcXG4gICAgICAgIGlmIChldmVudE5hbWUgJiYgIWV2ZW50TmFtZS5pbmNsdWRlcyhldmVudC5ldmVudE5hbWUpKVxcbiAgICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICAgIGlmICghaW5jbHVkZXNBcmdzKHtcXG4gICAgICAgICAgYXJnczogZXZlbnQuYXJncyxcXG4gICAgICAgICAgaW5wdXRzOiBhYmlJdGVtLmlucHV0cyxcXG4gICAgICAgICAgbWF0Y2hBcmdzOiBhcmdzXFxuICAgICAgICB9KSlcXG4gICAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgICByZXR1cm4geyAuLi5ldmVudCwgLi4ubG9nIH07XFxuICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICBsZXQgZXZlbnROYW1lMjtcXG4gICAgICAgIGxldCBpc1VubmFtZWQ7XFxuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQWJpRXZlbnRTaWduYXR1cmVOb3RGb3VuZEVycm9yKVxcbiAgICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBEZWNvZGVMb2dEYXRhTWlzbWF0Y2ggfHwgZXJyIGluc3RhbmNlb2YgRGVjb2RlTG9nVG9waWNzTWlzbWF0Y2gpIHtcXG4gICAgICAgICAgaWYgKHN0cmljdClcXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICAgICAgZXZlbnROYW1lMiA9IGVyci5hYmlJdGVtLm5hbWU7XFxuICAgICAgICAgIGlzVW5uYW1lZCA9IGVyci5hYmlJdGVtLmlucHV0cz8uc29tZSgoeCkgPT4gIShcIm5hbWVcIiBpbiB4ICYmIHgubmFtZSkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHsgLi4ubG9nLCBhcmdzOiBpc1VubmFtZWQgPyBbXSA6IHt9LCBldmVudE5hbWU6IGV2ZW50TmFtZTIgfTtcXG4gICAgICB9XFxuICAgIH0pLmZpbHRlcihCb29sZWFuKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGluY2x1ZGVzQXJncyhwYXJhbWV0ZXJzKSB7XFxuICAgIGNvbnN0IHsgYXJncywgaW5wdXRzLCBtYXRjaEFyZ3MgfSA9IHBhcmFtZXRlcnM7XFxuICAgIGlmICghbWF0Y2hBcmdzKVxcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICBpZiAoIWFyZ3MpXFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICBmdW5jdGlvbiBpc0VxdWFsKGlucHV0LCB2YWx1ZSwgYXJnKSB7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIGlmIChpbnB1dC50eXBlID09PSBcImFkZHJlc3NcIilcXG4gICAgICAgICAgcmV0dXJuIGlzQWRkcmVzc0VxdWFsKHZhbHVlLCBhcmcpO1xcbiAgICAgICAgaWYgKGlucHV0LnR5cGUgPT09IFwic3RyaW5nXCIgfHwgaW5wdXQudHlwZSA9PT0gXCJieXRlc1wiKVxcbiAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHRvQnl0ZXModmFsdWUpKSA9PT0gYXJnO1xcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBhcmc7XFxuICAgICAgfSBjYXRjaCB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIEFycmF5LmlzQXJyYXkobWF0Y2hBcmdzKSkge1xcbiAgICAgIHJldHVybiBtYXRjaEFyZ3MuZXZlcnkoKHZhbHVlLCBpbmRleDIpID0+IHtcXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwKVxcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIGNvbnN0IGlucHV0ID0gaW5wdXRzW2luZGV4Ml07XFxuICAgICAgICBpZiAoIWlucHV0KVxcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICBjb25zdCB2YWx1ZV8gPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcXG4gICAgICAgIHJldHVybiB2YWx1ZV8uc29tZSgodmFsdWUyKSA9PiBpc0VxdWFsKGlucHV0LCB2YWx1ZTIsIGFyZ3NbaW5kZXgyXSkpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIGlmICh0eXBlb2YgYXJncyA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShhcmdzKSAmJiB0eXBlb2YgbWF0Y2hBcmdzID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KG1hdGNoQXJncykpXFxuICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKG1hdGNoQXJncykuZXZlcnkoKFtrZXksIHZhbHVlXSkgPT4ge1xcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDApXFxuICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgY29uc3QgaW5wdXQgPSBpbnB1dHMuZmluZCgoaW5wdXQyKSA9PiBpbnB1dDIubmFtZSA9PT0ga2V5KTtcXG4gICAgICAgIGlmICghaW5wdXQpXFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIGNvbnN0IHZhbHVlXyA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xcbiAgICAgICAgcmV0dXJuIHZhbHVlXy5zb21lKCh2YWx1ZTIpID0+IGlzRXF1YWwoaW5wdXQsIHZhbHVlMiwgYXJnc1trZXldKSk7XFxuICAgICAgfSk7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjdGlvbnMvcHVibGljL2dldExvZ3MuanNcXG4gIGluaXRfdG9IZXgoKTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2Zvcm1hdHRlcnMvbG9nLmpzXFxuICBmdW5jdGlvbiBmb3JtYXRMb2cobG9nLCB7IGFyZ3MsIGV2ZW50TmFtZSB9ID0ge30pIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICAuLi5sb2csXFxuICAgICAgYmxvY2tIYXNoOiBsb2cuYmxvY2tIYXNoID8gbG9nLmJsb2NrSGFzaCA6IG51bGwsXFxuICAgICAgYmxvY2tOdW1iZXI6IGxvZy5ibG9ja051bWJlciA/IEJpZ0ludChsb2cuYmxvY2tOdW1iZXIpIDogbnVsbCxcXG4gICAgICBsb2dJbmRleDogbG9nLmxvZ0luZGV4ID8gTnVtYmVyKGxvZy5sb2dJbmRleCkgOiBudWxsLFxcbiAgICAgIHRyYW5zYWN0aW9uSGFzaDogbG9nLnRyYW5zYWN0aW9uSGFzaCA/IGxvZy50cmFuc2FjdGlvbkhhc2ggOiBudWxsLFxcbiAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IGxvZy50cmFuc2FjdGlvbkluZGV4ID8gTnVtYmVyKGxvZy50cmFuc2FjdGlvbkluZGV4KSA6IG51bGwsXFxuICAgICAgLi4uZXZlbnROYW1lID8geyBhcmdzLCBldmVudE5hbWUgfSA6IHt9XFxuICAgIH07XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL3B1YmxpYy9nZXRMb2dzLmpzXFxuICBhc3luYyBmdW5jdGlvbiBnZXRMb2dzKGNsaWVudCwgeyBhZGRyZXNzLCBibG9ja0hhc2gsIGZyb21CbG9jaywgdG9CbG9jaywgZXZlbnQsIGV2ZW50czogZXZlbnRzXywgYXJncywgc3RyaWN0OiBzdHJpY3RfIH0gPSB7fSkge1xcbiAgICBjb25zdCBzdHJpY3QgPSBzdHJpY3RfID8/IGZhbHNlO1xcbiAgICBjb25zdCBldmVudHMgPSBldmVudHNfID8/IChldmVudCA/IFtldmVudF0gOiB2b2lkIDApO1xcbiAgICBsZXQgdG9waWNzID0gW107XFxuICAgIGlmIChldmVudHMpIHtcXG4gICAgICBjb25zdCBlbmNvZGVkID0gZXZlbnRzLmZsYXRNYXAoKGV2ZW50MikgPT4gZW5jb2RlRXZlbnRUb3BpY3Moe1xcbiAgICAgICAgYWJpOiBbZXZlbnQyXSxcXG4gICAgICAgIGV2ZW50TmFtZTogZXZlbnQyLm5hbWUsXFxuICAgICAgICBhcmdzOiBldmVudHNfID8gdm9pZCAwIDogYXJnc1xcbiAgICAgIH0pKTtcXG4gICAgICB0b3BpY3MgPSBbZW5jb2RlZF07XFxuICAgICAgaWYgKGV2ZW50KVxcbiAgICAgICAgdG9waWNzID0gdG9waWNzWzBdO1xcbiAgICB9XFxuICAgIGxldCBsb2dzO1xcbiAgICBpZiAoYmxvY2tIYXNoKSB7XFxuICAgICAgbG9ncyA9IGF3YWl0IGNsaWVudC5yZXF1ZXN0KHtcXG4gICAgICAgIG1ldGhvZDogXCJldGhfZ2V0TG9nc1wiLFxcbiAgICAgICAgcGFyYW1zOiBbeyBhZGRyZXNzLCB0b3BpY3MsIGJsb2NrSGFzaCB9XVxcbiAgICAgIH0pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGxvZ3MgPSBhd2FpdCBjbGllbnQucmVxdWVzdCh7XFxuICAgICAgICBtZXRob2Q6IFwiZXRoX2dldExvZ3NcIixcXG4gICAgICAgIHBhcmFtczogW1xcbiAgICAgICAgICB7XFxuICAgICAgICAgICAgYWRkcmVzcyxcXG4gICAgICAgICAgICB0b3BpY3MsXFxuICAgICAgICAgICAgZnJvbUJsb2NrOiB0eXBlb2YgZnJvbUJsb2NrID09PSBcImJpZ2ludFwiID8gbnVtYmVyVG9IZXgoZnJvbUJsb2NrKSA6IGZyb21CbG9jayxcXG4gICAgICAgICAgICB0b0Jsb2NrOiB0eXBlb2YgdG9CbG9jayA9PT0gXCJiaWdpbnRcIiA/IG51bWJlclRvSGV4KHRvQmxvY2spIDogdG9CbG9ja1xcbiAgICAgICAgICB9XFxuICAgICAgICBdXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgY29uc3QgZm9ybWF0dGVkTG9ncyA9IGxvZ3MubWFwKChsb2cpID0+IGZvcm1hdExvZyhsb2cpKTtcXG4gICAgaWYgKCFldmVudHMpXFxuICAgICAgcmV0dXJuIGZvcm1hdHRlZExvZ3M7XFxuICAgIHJldHVybiBwYXJzZUV2ZW50TG9ncyh7XFxuICAgICAgYWJpOiBldmVudHMsXFxuICAgICAgYXJncyxcXG4gICAgICBsb2dzOiBmb3JtYXR0ZWRMb2dzLFxcbiAgICAgIHN0cmljdFxcbiAgICB9KTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjdGlvbnMvcHVibGljL2dldENvbnRyYWN0RXZlbnRzLmpzXFxuICBhc3luYyBmdW5jdGlvbiBnZXRDb250cmFjdEV2ZW50cyhjbGllbnQsIHBhcmFtZXRlcnMpIHtcXG4gICAgY29uc3QgeyBhYmk6IGFiaTIsIGFkZHJlc3MsIGFyZ3MsIGJsb2NrSGFzaCwgZXZlbnROYW1lLCBmcm9tQmxvY2ssIHRvQmxvY2ssIHN0cmljdCB9ID0gcGFyYW1ldGVycztcXG4gICAgY29uc3QgZXZlbnQgPSBldmVudE5hbWUgPyBnZXRBYmlJdGVtKHsgYWJpOiBhYmkyLCBuYW1lOiBldmVudE5hbWUgfSkgOiB2b2lkIDA7XFxuICAgIGNvbnN0IGV2ZW50cyA9ICFldmVudCA/IGFiaTIuZmlsdGVyKCh4KSA9PiB4LnR5cGUgPT09IFwiZXZlbnRcIikgOiB2b2lkIDA7XFxuICAgIHJldHVybiBnZXRBY3Rpb24oY2xpZW50LCBnZXRMb2dzLCBcImdldExvZ3NcIikoe1xcbiAgICAgIGFkZHJlc3MsXFxuICAgICAgYXJncyxcXG4gICAgICBibG9ja0hhc2gsXFxuICAgICAgZXZlbnQsXFxuICAgICAgZXZlbnRzLFxcbiAgICAgIGZyb21CbG9jayxcXG4gICAgICB0b0Jsb2NrLFxcbiAgICAgIHN0cmljdFxcbiAgICB9KTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjdGlvbnMvcHVibGljL3JlYWRDb250cmFjdC5qc1xcbiAgaW5pdF9kZWNvZGVGdW5jdGlvblJlc3VsdCgpO1xcbiAgaW5pdF9lbmNvZGVGdW5jdGlvbkRhdGEoKTtcXG4gIGluaXRfY2FsbCgpO1xcbiAgYXN5bmMgZnVuY3Rpb24gcmVhZENvbnRyYWN0KGNsaWVudCwgcGFyYW1ldGVycykge1xcbiAgICBjb25zdCB7IGFiaTogYWJpMiwgYWRkcmVzcywgYXJncywgZnVuY3Rpb25OYW1lLCAuLi5yZXN0IH0gPSBwYXJhbWV0ZXJzO1xcbiAgICBjb25zdCBjYWxsZGF0YSA9IGVuY29kZUZ1bmN0aW9uRGF0YSh7XFxuICAgICAgYWJpOiBhYmkyLFxcbiAgICAgIGFyZ3MsXFxuICAgICAgZnVuY3Rpb25OYW1lXFxuICAgIH0pO1xcbiAgICB0cnkge1xcbiAgICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgZ2V0QWN0aW9uKGNsaWVudCwgY2FsbCwgXCJjYWxsXCIpKHtcXG4gICAgICAgIC4uLnJlc3QsXFxuICAgICAgICBkYXRhOiBjYWxsZGF0YSxcXG4gICAgICAgIHRvOiBhZGRyZXNzXFxuICAgICAgfSk7XFxuICAgICAgcmV0dXJuIGRlY29kZUZ1bmN0aW9uUmVzdWx0KHtcXG4gICAgICAgIGFiaTogYWJpMixcXG4gICAgICAgIGFyZ3MsXFxuICAgICAgICBmdW5jdGlvbk5hbWUsXFxuICAgICAgICBkYXRhOiBkYXRhIHx8IFwiMHhcIlxcbiAgICAgIH0pO1xcbiAgICB9IGNhdGNoIChlcnJvcikge1xcbiAgICAgIHRocm93IGdldENvbnRyYWN0RXJyb3IoZXJyb3IsIHtcXG4gICAgICAgIGFiaTogYWJpMixcXG4gICAgICAgIGFkZHJlc3MsXFxuICAgICAgICBhcmdzLFxcbiAgICAgICAgZG9jc1BhdGg6IFwiL2RvY3MvY29udHJhY3QvcmVhZENvbnRyYWN0XCIsXFxuICAgICAgICBmdW5jdGlvbk5hbWVcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vYWN0aW9ucy9wdWJsaWMvc2ltdWxhdGVDb250cmFjdC5qc1xcbiAgaW5pdF9wYXJzZUFjY291bnQoKTtcXG4gIGluaXRfZGVjb2RlRnVuY3Rpb25SZXN1bHQoKTtcXG4gIGluaXRfZW5jb2RlRnVuY3Rpb25EYXRhKCk7XFxuICBpbml0X2NhbGwoKTtcXG4gIGFzeW5jIGZ1bmN0aW9uIHNpbXVsYXRlQ29udHJhY3QoY2xpZW50LCBwYXJhbWV0ZXJzKSB7XFxuICAgIGNvbnN0IHsgYWJpOiBhYmkyLCBhZGRyZXNzLCBhcmdzLCBkYXRhU3VmZml4LCBmdW5jdGlvbk5hbWUsIC4uLmNhbGxSZXF1ZXN0IH0gPSBwYXJhbWV0ZXJzO1xcbiAgICBjb25zdCBhY2NvdW50ID0gY2FsbFJlcXVlc3QuYWNjb3VudCA/IHBhcnNlQWNjb3VudChjYWxsUmVxdWVzdC5hY2NvdW50KSA6IGNsaWVudC5hY2NvdW50O1xcbiAgICBjb25zdCBjYWxsZGF0YSA9IGVuY29kZUZ1bmN0aW9uRGF0YSh7IGFiaTogYWJpMiwgYXJncywgZnVuY3Rpb25OYW1lIH0pO1xcbiAgICB0cnkge1xcbiAgICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgZ2V0QWN0aW9uKGNsaWVudCwgY2FsbCwgXCJjYWxsXCIpKHtcXG4gICAgICAgIGJhdGNoOiBmYWxzZSxcXG4gICAgICAgIGRhdGE6IGAke2NhbGxkYXRhfSR7ZGF0YVN1ZmZpeCA/IGRhdGFTdWZmaXgucmVwbGFjZShcIjB4XCIsIFwiXCIpIDogXCJcIn1gLFxcbiAgICAgICAgdG86IGFkZHJlc3MsXFxuICAgICAgICAuLi5jYWxsUmVxdWVzdCxcXG4gICAgICAgIGFjY291bnRcXG4gICAgICB9KTtcXG4gICAgICBjb25zdCByZXN1bHQgPSBkZWNvZGVGdW5jdGlvblJlc3VsdCh7XFxuICAgICAgICBhYmk6IGFiaTIsXFxuICAgICAgICBhcmdzLFxcbiAgICAgICAgZnVuY3Rpb25OYW1lLFxcbiAgICAgICAgZGF0YTogZGF0YSB8fCBcIjB4XCJcXG4gICAgICB9KTtcXG4gICAgICBjb25zdCBtaW5pbWl6ZWRBYmkgPSBhYmkyLmZpbHRlcigoYWJpSXRlbSkgPT4gXCJuYW1lXCIgaW4gYWJpSXRlbSAmJiBhYmlJdGVtLm5hbWUgPT09IHBhcmFtZXRlcnMuZnVuY3Rpb25OYW1lKTtcXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgcmVzdWx0LFxcbiAgICAgICAgcmVxdWVzdDoge1xcbiAgICAgICAgICBhYmk6IG1pbmltaXplZEFiaSxcXG4gICAgICAgICAgYWRkcmVzcyxcXG4gICAgICAgICAgYXJncyxcXG4gICAgICAgICAgZGF0YVN1ZmZpeCxcXG4gICAgICAgICAgZnVuY3Rpb25OYW1lLFxcbiAgICAgICAgICAuLi5jYWxsUmVxdWVzdCxcXG4gICAgICAgICAgYWNjb3VudFxcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XFxuICAgICAgdGhyb3cgZ2V0Q29udHJhY3RFcnJvcihlcnJvciwge1xcbiAgICAgICAgYWJpOiBhYmkyLFxcbiAgICAgICAgYWRkcmVzcyxcXG4gICAgICAgIGFyZ3MsXFxuICAgICAgICBkb2NzUGF0aDogXCIvZG9jcy9jb250cmFjdC9zaW11bGF0ZUNvbnRyYWN0XCIsXFxuICAgICAgICBmdW5jdGlvbk5hbWUsXFxuICAgICAgICBzZW5kZXI6IGFjY291bnQ/LmFkZHJlc3NcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vYWN0aW9ucy9wdWJsaWMvd2F0Y2hDb250cmFjdEV2ZW50LmpzXFxuICBpbml0X2FiaSgpO1xcbiAgaW5pdF9ycGMoKTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL29ic2VydmUuanNcXG4gIHZhciBsaXN0ZW5lcnNDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XFxuICB2YXIgY2xlYW51cENhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcXG4gIHZhciBjYWxsYmFja0NvdW50ID0gMDtcXG4gIGZ1bmN0aW9uIG9ic2VydmUob2JzZXJ2ZXJJZCwgY2FsbGJhY2tzLCBmbikge1xcbiAgICBjb25zdCBjYWxsYmFja0lkID0gKytjYWxsYmFja0NvdW50O1xcbiAgICBjb25zdCBnZXRMaXN0ZW5lcnMgPSAoKSA9PiBsaXN0ZW5lcnNDYWNoZS5nZXQob2JzZXJ2ZXJJZCkgfHwgW107XFxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gKCkgPT4ge1xcbiAgICAgIGNvbnN0IGxpc3RlbmVyczIgPSBnZXRMaXN0ZW5lcnMoKTtcXG4gICAgICBsaXN0ZW5lcnNDYWNoZS5zZXQob2JzZXJ2ZXJJZCwgbGlzdGVuZXJzMi5maWx0ZXIoKGNiKSA9PiBjYi5pZCAhPT0gY2FsbGJhY2tJZCkpO1xcbiAgICB9O1xcbiAgICBjb25zdCB1bndhdGNoID0gKCkgPT4ge1xcbiAgICAgIGNvbnN0IGxpc3RlbmVyczIgPSBnZXRMaXN0ZW5lcnMoKTtcXG4gICAgICBpZiAoIWxpc3RlbmVyczIuc29tZSgoY2IpID0+IGNiLmlkID09PSBjYWxsYmFja0lkKSlcXG4gICAgICAgIHJldHVybjtcXG4gICAgICBjb25zdCBjbGVhbnVwMiA9IGNsZWFudXBDYWNoZS5nZXQob2JzZXJ2ZXJJZCk7XFxuICAgICAgaWYgKGxpc3RlbmVyczIubGVuZ3RoID09PSAxICYmIGNsZWFudXAyKVxcbiAgICAgICAgY2xlYW51cDIoKTtcXG4gICAgICB1bnN1YnNjcmliZSgpO1xcbiAgICB9O1xcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBnZXRMaXN0ZW5lcnMoKTtcXG4gICAgbGlzdGVuZXJzQ2FjaGUuc2V0KG9ic2VydmVySWQsIFtcXG4gICAgICAuLi5saXN0ZW5lcnMsXFxuICAgICAgeyBpZDogY2FsbGJhY2tJZCwgZm5zOiBjYWxsYmFja3MgfVxcbiAgICBdKTtcXG4gICAgaWYgKGxpc3RlbmVycyAmJiBsaXN0ZW5lcnMubGVuZ3RoID4gMClcXG4gICAgICByZXR1cm4gdW53YXRjaDtcXG4gICAgY29uc3QgZW1pdCA9IHt9O1xcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjYWxsYmFja3MpIHtcXG4gICAgICBlbWl0W2tleV0gPSAoLi4uYXJncykgPT4ge1xcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzMiA9IGdldExpc3RlbmVycygpO1xcbiAgICAgICAgaWYgKGxpc3RlbmVyczIubGVuZ3RoID09PSAwKVxcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIGxpc3RlbmVyczIpXFxuICAgICAgICAgIGxpc3RlbmVyLmZuc1trZXldPy4oLi4uYXJncyk7XFxuICAgICAgfTtcXG4gICAgfVxcbiAgICBjb25zdCBjbGVhbnVwID0gZm4oZW1pdCk7XFxuICAgIGlmICh0eXBlb2YgY2xlYW51cCA9PT0gXCJmdW5jdGlvblwiKVxcbiAgICAgIGNsZWFudXBDYWNoZS5zZXQob2JzZXJ2ZXJJZCwgY2xlYW51cCk7XFxuICAgIHJldHVybiB1bndhdGNoO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvd2FpdC5qc1xcbiAgYXN5bmMgZnVuY3Rpb24gd2FpdCh0aW1lKSB7XFxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzKSA9PiBzZXRUaW1lb3V0KHJlcywgdGltZSkpO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvcG9sbC5qc1xcbiAgZnVuY3Rpb24gcG9sbChmbiwgeyBlbWl0T25CZWdpbiwgaW5pdGlhbFdhaXRUaW1lLCBpbnRlcnZhbCB9KSB7XFxuICAgIGxldCBhY3RpdmUgPSB0cnVlO1xcbiAgICBjb25zdCB1bndhdGNoID0gKCkgPT4gYWN0aXZlID0gZmFsc2U7XFxuICAgIGNvbnN0IHdhdGNoID0gYXN5bmMgKCkgPT4ge1xcbiAgICAgIGxldCBkYXRhID0gdm9pZCAwO1xcbiAgICAgIGlmIChlbWl0T25CZWdpbilcXG4gICAgICAgIGRhdGEgPSBhd2FpdCBmbih7IHVucG9sbDogdW53YXRjaCB9KTtcXG4gICAgICBjb25zdCBpbml0aWFsV2FpdCA9IGF3YWl0IGluaXRpYWxXYWl0VGltZT8uKGRhdGEpID8/IGludGVydmFsO1xcbiAgICAgIGF3YWl0IHdhaXQoaW5pdGlhbFdhaXQpO1xcbiAgICAgIGNvbnN0IHBvbGwyID0gYXN5bmMgKCkgPT4ge1xcbiAgICAgICAgaWYgKCFhY3RpdmUpXFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIGF3YWl0IGZuKHsgdW5wb2xsOiB1bndhdGNoIH0pO1xcbiAgICAgICAgYXdhaXQgd2FpdChpbnRlcnZhbCk7XFxuICAgICAgICBwb2xsMigpO1xcbiAgICAgIH07XFxuICAgICAgcG9sbDIoKTtcXG4gICAgfTtcXG4gICAgd2F0Y2goKTtcXG4gICAgcmV0dXJuIHVud2F0Y2g7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL3B1YmxpYy93YXRjaENvbnRyYWN0RXZlbnQuanNcXG4gIGluaXRfc3RyaW5naWZ5KCk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9wcm9taXNlL3dpdGhDYWNoZS5qc1xcbiAgdmFyIHByb21pc2VDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XFxuICB2YXIgcmVzcG9uc2VDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XFxuICBmdW5jdGlvbiBnZXRDYWNoZShjYWNoZUtleTIpIHtcXG4gICAgY29uc3QgYnVpbGRDYWNoZSA9IChjYWNoZUtleTMsIGNhY2hlKSA9PiAoe1xcbiAgICAgIGNsZWFyOiAoKSA9PiBjYWNoZS5kZWxldGUoY2FjaGVLZXkzKSxcXG4gICAgICBnZXQ6ICgpID0+IGNhY2hlLmdldChjYWNoZUtleTMpLFxcbiAgICAgIHNldDogKGRhdGEpID0+IGNhY2hlLnNldChjYWNoZUtleTMsIGRhdGEpXFxuICAgIH0pO1xcbiAgICBjb25zdCBwcm9taXNlID0gYnVpbGRDYWNoZShjYWNoZUtleTIsIHByb21pc2VDYWNoZSk7XFxuICAgIGNvbnN0IHJlc3BvbnNlID0gYnVpbGRDYWNoZShjYWNoZUtleTIsIHJlc3BvbnNlQ2FjaGUpO1xcbiAgICByZXR1cm4ge1xcbiAgICAgIGNsZWFyOiAoKSA9PiB7XFxuICAgICAgICBwcm9taXNlLmNsZWFyKCk7XFxuICAgICAgICByZXNwb25zZS5jbGVhcigpO1xcbiAgICAgIH0sXFxuICAgICAgcHJvbWlzZSxcXG4gICAgICByZXNwb25zZVxcbiAgICB9O1xcbiAgfVxcbiAgYXN5bmMgZnVuY3Rpb24gd2l0aENhY2hlKGZuLCB7IGNhY2hlS2V5OiBjYWNoZUtleTIsIGNhY2hlVGltZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB9KSB7XFxuICAgIGNvbnN0IGNhY2hlID0gZ2V0Q2FjaGUoY2FjaGVLZXkyKTtcXG4gICAgY29uc3QgcmVzcG9uc2UgPSBjYWNoZS5yZXNwb25zZS5nZXQoKTtcXG4gICAgaWYgKHJlc3BvbnNlICYmIGNhY2hlVGltZSA+IDApIHtcXG4gICAgICBjb25zdCBhZ2UgPSAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHJlc3BvbnNlLmNyZWF0ZWQuZ2V0VGltZSgpO1xcbiAgICAgIGlmIChhZ2UgPCBjYWNoZVRpbWUpXFxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcXG4gICAgfVxcbiAgICBsZXQgcHJvbWlzZSA9IGNhY2hlLnByb21pc2UuZ2V0KCk7XFxuICAgIGlmICghcHJvbWlzZSkge1xcbiAgICAgIHByb21pc2UgPSBmbigpO1xcbiAgICAgIGNhY2hlLnByb21pc2Uuc2V0KHByb21pc2UpO1xcbiAgICB9XFxuICAgIHRyeSB7XFxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHByb21pc2U7XFxuICAgICAgY2FjaGUucmVzcG9uc2Uuc2V0KHsgY3JlYXRlZDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIGRhdGEgfSk7XFxuICAgICAgcmV0dXJuIGRhdGE7XFxuICAgIH0gZmluYWxseSB7XFxuICAgICAgY2FjaGUucHJvbWlzZS5jbGVhcigpO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL3B1YmxpYy9nZXRCbG9ja051bWJlci5qc1xcbiAgdmFyIGNhY2hlS2V5ID0gKGlkKSA9PiBgYmxvY2tOdW1iZXIuJHtpZH1gO1xcbiAgYXN5bmMgZnVuY3Rpb24gZ2V0QmxvY2tOdW1iZXIoY2xpZW50LCB7IGNhY2hlVGltZSA9IGNsaWVudC5jYWNoZVRpbWUgfSA9IHt9KSB7XFxuICAgIGNvbnN0IGJsb2NrTnVtYmVySGV4ID0gYXdhaXQgd2l0aENhY2hlKCgpID0+IGNsaWVudC5yZXF1ZXN0KHtcXG4gICAgICBtZXRob2Q6IFwiZXRoX2Jsb2NrTnVtYmVyXCJcXG4gICAgfSksIHsgY2FjaGVLZXk6IGNhY2hlS2V5KGNsaWVudC51aWQpLCBjYWNoZVRpbWUgfSk7XFxuICAgIHJldHVybiBCaWdJbnQoYmxvY2tOdW1iZXJIZXgpO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vYWN0aW9ucy9wdWJsaWMvZ2V0RmlsdGVyQ2hhbmdlcy5qc1xcbiAgYXN5bmMgZnVuY3Rpb24gZ2V0RmlsdGVyQ2hhbmdlcyhfY2xpZW50LCB7IGZpbHRlciB9KSB7XFxuICAgIGNvbnN0IHN0cmljdCA9IFwic3RyaWN0XCIgaW4gZmlsdGVyICYmIGZpbHRlci5zdHJpY3Q7XFxuICAgIGNvbnN0IGxvZ3MgPSBhd2FpdCBmaWx0ZXIucmVxdWVzdCh7XFxuICAgICAgbWV0aG9kOiBcImV0aF9nZXRGaWx0ZXJDaGFuZ2VzXCIsXFxuICAgICAgcGFyYW1zOiBbZmlsdGVyLmlkXVxcbiAgICB9KTtcXG4gICAgaWYgKHR5cGVvZiBsb2dzWzBdID09PSBcInN0cmluZ1wiKVxcbiAgICAgIHJldHVybiBsb2dzO1xcbiAgICBjb25zdCBmb3JtYXR0ZWRMb2dzID0gbG9ncy5tYXAoKGxvZykgPT4gZm9ybWF0TG9nKGxvZykpO1xcbiAgICBpZiAoIShcImFiaVwiIGluIGZpbHRlcikgfHwgIWZpbHRlci5hYmkpXFxuICAgICAgcmV0dXJuIGZvcm1hdHRlZExvZ3M7XFxuICAgIHJldHVybiBwYXJzZUV2ZW50TG9ncyh7XFxuICAgICAgYWJpOiBmaWx0ZXIuYWJpLFxcbiAgICAgIGxvZ3M6IGZvcm1hdHRlZExvZ3MsXFxuICAgICAgc3RyaWN0XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vYWN0aW9ucy9wdWJsaWMvdW5pbnN0YWxsRmlsdGVyLmpzXFxuICBhc3luYyBmdW5jdGlvbiB1bmluc3RhbGxGaWx0ZXIoX2NsaWVudCwgeyBmaWx0ZXIgfSkge1xcbiAgICByZXR1cm4gZmlsdGVyLnJlcXVlc3Qoe1xcbiAgICAgIG1ldGhvZDogXCJldGhfdW5pbnN0YWxsRmlsdGVyXCIsXFxuICAgICAgcGFyYW1zOiBbZmlsdGVyLmlkXVxcbiAgICB9KTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjdGlvbnMvcHVibGljL3dhdGNoQ29udHJhY3RFdmVudC5qc1xcbiAgZnVuY3Rpb24gd2F0Y2hDb250cmFjdEV2ZW50KGNsaWVudCwgcGFyYW1ldGVycykge1xcbiAgICBjb25zdCB7IGFiaTogYWJpMiwgYWRkcmVzcywgYXJncywgYmF0Y2ggPSB0cnVlLCBldmVudE5hbWUsIGZyb21CbG9jaywgb25FcnJvciwgb25Mb2dzLCBwb2xsOiBwb2xsXywgcG9sbGluZ0ludGVydmFsID0gY2xpZW50LnBvbGxpbmdJbnRlcnZhbCwgc3RyaWN0OiBzdHJpY3RfIH0gPSBwYXJhbWV0ZXJzO1xcbiAgICBjb25zdCBlbmFibGVQb2xsaW5nID0gKCgpID0+IHtcXG4gICAgICBpZiAodHlwZW9mIHBvbGxfICE9PSBcInVuZGVmaW5lZFwiKVxcbiAgICAgICAgcmV0dXJuIHBvbGxfO1xcbiAgICAgIGlmICh0eXBlb2YgZnJvbUJsb2NrID09PSBcImJpZ2ludFwiKVxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgaWYgKGNsaWVudC50cmFuc3BvcnQudHlwZSA9PT0gXCJ3ZWJTb2NrZXRcIilcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICBpZiAoY2xpZW50LnRyYW5zcG9ydC50eXBlID09PSBcImZhbGxiYWNrXCIgJiYgY2xpZW50LnRyYW5zcG9ydC50cmFuc3BvcnRzWzBdLmNvbmZpZy50eXBlID09PSBcIndlYlNvY2tldFwiKVxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9KSgpO1xcbiAgICBjb25zdCBwb2xsQ29udHJhY3RFdmVudCA9ICgpID0+IHtcXG4gICAgICBjb25zdCBzdHJpY3QgPSBzdHJpY3RfID8/IGZhbHNlO1xcbiAgICAgIGNvbnN0IG9ic2VydmVySWQgPSBzdHJpbmdpZnkoW1xcbiAgICAgICAgXCJ3YXRjaENvbnRyYWN0RXZlbnRcIixcXG4gICAgICAgIGFkZHJlc3MsXFxuICAgICAgICBhcmdzLFxcbiAgICAgICAgYmF0Y2gsXFxuICAgICAgICBjbGllbnQudWlkLFxcbiAgICAgICAgZXZlbnROYW1lLFxcbiAgICAgICAgcG9sbGluZ0ludGVydmFsLFxcbiAgICAgICAgc3RyaWN0LFxcbiAgICAgICAgZnJvbUJsb2NrXFxuICAgICAgXSk7XFxuICAgICAgcmV0dXJuIG9ic2VydmUob2JzZXJ2ZXJJZCwgeyBvbkxvZ3MsIG9uRXJyb3IgfSwgKGVtaXQpID0+IHtcXG4gICAgICAgIGxldCBwcmV2aW91c0Jsb2NrTnVtYmVyO1xcbiAgICAgICAgaWYgKGZyb21CbG9jayAhPT0gdm9pZCAwKVxcbiAgICAgICAgICBwcmV2aW91c0Jsb2NrTnVtYmVyID0gZnJvbUJsb2NrIC0gMW47XFxuICAgICAgICBsZXQgZmlsdGVyO1xcbiAgICAgICAgbGV0IGluaXRpYWxpemVkID0gZmFsc2U7XFxuICAgICAgICBjb25zdCB1bndhdGNoID0gcG9sbChhc3luYyAoKSA9PiB7XFxuICAgICAgICAgIGlmICghaW5pdGlhbGl6ZWQpIHtcXG4gICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgZmlsdGVyID0gYXdhaXQgZ2V0QWN0aW9uKGNsaWVudCwgY3JlYXRlQ29udHJhY3RFdmVudEZpbHRlciwgXCJjcmVhdGVDb250cmFjdEV2ZW50RmlsdGVyXCIpKHtcXG4gICAgICAgICAgICAgICAgYWJpOiBhYmkyLFxcbiAgICAgICAgICAgICAgICBhZGRyZXNzLFxcbiAgICAgICAgICAgICAgICBhcmdzLFxcbiAgICAgICAgICAgICAgICBldmVudE5hbWUsXFxuICAgICAgICAgICAgICAgIHN0cmljdCxcXG4gICAgICAgICAgICAgICAgZnJvbUJsb2NrXFxuICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9IGNhdGNoIHtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGxldCBsb2dzO1xcbiAgICAgICAgICAgIGlmIChmaWx0ZXIpIHtcXG4gICAgICAgICAgICAgIGxvZ3MgPSBhd2FpdCBnZXRBY3Rpb24oY2xpZW50LCBnZXRGaWx0ZXJDaGFuZ2VzLCBcImdldEZpbHRlckNoYW5nZXNcIikoeyBmaWx0ZXIgfSk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gYXdhaXQgZ2V0QWN0aW9uKGNsaWVudCwgZ2V0QmxvY2tOdW1iZXIsIFwiZ2V0QmxvY2tOdW1iZXJcIikoe30pO1xcbiAgICAgICAgICAgICAgaWYgKHByZXZpb3VzQmxvY2tOdW1iZXIgJiYgcHJldmlvdXNCbG9ja051bWJlciA8IGJsb2NrTnVtYmVyKSB7XFxuICAgICAgICAgICAgICAgIGxvZ3MgPSBhd2FpdCBnZXRBY3Rpb24oY2xpZW50LCBnZXRDb250cmFjdEV2ZW50cywgXCJnZXRDb250cmFjdEV2ZW50c1wiKSh7XFxuICAgICAgICAgICAgICAgICAgYWJpOiBhYmkyLFxcbiAgICAgICAgICAgICAgICAgIGFkZHJlc3MsXFxuICAgICAgICAgICAgICAgICAgYXJncyxcXG4gICAgICAgICAgICAgICAgICBldmVudE5hbWUsXFxuICAgICAgICAgICAgICAgICAgZnJvbUJsb2NrOiBwcmV2aW91c0Jsb2NrTnVtYmVyICsgMW4sXFxuICAgICAgICAgICAgICAgICAgdG9CbG9jazogYmxvY2tOdW1iZXIsXFxuICAgICAgICAgICAgICAgICAgc3RyaWN0XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgbG9ncyA9IFtdO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgcHJldmlvdXNCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAobG9ncy5sZW5ndGggPT09IDApXFxuICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgaWYgKGJhdGNoKVxcbiAgICAgICAgICAgICAgZW1pdC5vbkxvZ3MobG9ncyk7XFxuICAgICAgICAgICAgZWxzZVxcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBsb2cgb2YgbG9ncylcXG4gICAgICAgICAgICAgICAgZW1pdC5vbkxvZ3MoW2xvZ10pO1xcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAgICAgICBpZiAoZmlsdGVyICYmIGVyciBpbnN0YW5jZW9mIEludmFsaWRJbnB1dFJwY0Vycm9yKVxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcXG4gICAgICAgICAgICBlbWl0Lm9uRXJyb3I/LihlcnIpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9LCB7XFxuICAgICAgICAgIGVtaXRPbkJlZ2luOiB0cnVlLFxcbiAgICAgICAgICBpbnRlcnZhbDogcG9sbGluZ0ludGVydmFsXFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiBhc3luYyAoKSA9PiB7XFxuICAgICAgICAgIGlmIChmaWx0ZXIpXFxuICAgICAgICAgICAgYXdhaXQgZ2V0QWN0aW9uKGNsaWVudCwgdW5pbnN0YWxsRmlsdGVyLCBcInVuaW5zdGFsbEZpbHRlclwiKSh7IGZpbHRlciB9KTtcXG4gICAgICAgICAgdW53YXRjaCgpO1xcbiAgICAgICAgfTtcXG4gICAgICB9KTtcXG4gICAgfTtcXG4gICAgY29uc3Qgc3Vic2NyaWJlQ29udHJhY3RFdmVudCA9ICgpID0+IHtcXG4gICAgICBjb25zdCBzdHJpY3QgPSBzdHJpY3RfID8/IGZhbHNlO1xcbiAgICAgIGNvbnN0IG9ic2VydmVySWQgPSBzdHJpbmdpZnkoW1xcbiAgICAgICAgXCJ3YXRjaENvbnRyYWN0RXZlbnRcIixcXG4gICAgICAgIGFkZHJlc3MsXFxuICAgICAgICBhcmdzLFxcbiAgICAgICAgYmF0Y2gsXFxuICAgICAgICBjbGllbnQudWlkLFxcbiAgICAgICAgZXZlbnROYW1lLFxcbiAgICAgICAgcG9sbGluZ0ludGVydmFsLFxcbiAgICAgICAgc3RyaWN0XFxuICAgICAgXSk7XFxuICAgICAgbGV0IGFjdGl2ZSA9IHRydWU7XFxuICAgICAgbGV0IHVuc3Vic2NyaWJlID0gKCkgPT4gYWN0aXZlID0gZmFsc2U7XFxuICAgICAgcmV0dXJuIG9ic2VydmUob2JzZXJ2ZXJJZCwgeyBvbkxvZ3MsIG9uRXJyb3IgfSwgKGVtaXQpID0+IHtcXG4gICAgICAgIDtcXG4gICAgICAgIChhc3luYyAoKSA9PiB7XFxuICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgY29uc3QgdHJhbnNwb3J0ID0gKCgpID0+IHtcXG4gICAgICAgICAgICAgIGlmIChjbGllbnQudHJhbnNwb3J0LnR5cGUgPT09IFwiZmFsbGJhY2tcIikge1xcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc3BvcnQyID0gY2xpZW50LnRyYW5zcG9ydC50cmFuc3BvcnRzLmZpbmQoKHRyYW5zcG9ydDMpID0+IHRyYW5zcG9ydDMuY29uZmlnLnR5cGUgPT09IFwid2ViU29ja2V0XCIpO1xcbiAgICAgICAgICAgICAgICBpZiAoIXRyYW5zcG9ydDIpXFxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsaWVudC50cmFuc3BvcnQ7XFxuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc3BvcnQyLnZhbHVlO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgcmV0dXJuIGNsaWVudC50cmFuc3BvcnQ7XFxuICAgICAgICAgICAgfSkoKTtcXG4gICAgICAgICAgICBjb25zdCB0b3BpY3MgPSBldmVudE5hbWUgPyBlbmNvZGVFdmVudFRvcGljcyh7XFxuICAgICAgICAgICAgICBhYmk6IGFiaTIsXFxuICAgICAgICAgICAgICBldmVudE5hbWUsXFxuICAgICAgICAgICAgICBhcmdzXFxuICAgICAgICAgICAgfSkgOiBbXTtcXG4gICAgICAgICAgICBjb25zdCB7IHVuc3Vic2NyaWJlOiB1bnN1YnNjcmliZV8gfSA9IGF3YWl0IHRyYW5zcG9ydC5zdWJzY3JpYmUoe1xcbiAgICAgICAgICAgICAgcGFyYW1zOiBbXCJsb2dzXCIsIHsgYWRkcmVzcywgdG9waWNzIH1dLFxcbiAgICAgICAgICAgICAgb25EYXRhKGRhdGEpIHtcXG4gICAgICAgICAgICAgICAgaWYgKCFhY3RpdmUpXFxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgICAgICBjb25zdCBsb2cgPSBkYXRhLnJlc3VsdDtcXG4gICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICBjb25zdCB7IGV2ZW50TmFtZTogZXZlbnROYW1lMiwgYXJnczogYXJnczIgfSA9IGRlY29kZUV2ZW50TG9nKHtcXG4gICAgICAgICAgICAgICAgICAgIGFiaTogYWJpMixcXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGxvZy5kYXRhLFxcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzOiBsb2cudG9waWNzLFxcbiAgICAgICAgICAgICAgICAgICAgc3RyaWN0OiBzdHJpY3RfXFxuICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkID0gZm9ybWF0TG9nKGxvZywge1xcbiAgICAgICAgICAgICAgICAgICAgYXJnczogYXJnczIsXFxuICAgICAgICAgICAgICAgICAgICBldmVudE5hbWU6IGV2ZW50TmFtZTJcXG4gICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgICBlbWl0Lm9uTG9ncyhbZm9ybWF0dGVkXSk7XFxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgICAgICAgICAgICAgIGxldCBldmVudE5hbWUyO1xcbiAgICAgICAgICAgICAgICAgIGxldCBpc1VubmFtZWQ7XFxuICAgICAgICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIERlY29kZUxvZ0RhdGFNaXNtYXRjaCB8fCBlcnIgaW5zdGFuY2VvZiBEZWNvZGVMb2dUb3BpY3NNaXNtYXRjaCkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmljdF8pXFxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZTIgPSBlcnIuYWJpSXRlbS5uYW1lO1xcbiAgICAgICAgICAgICAgICAgICAgaXNVbm5hbWVkID0gZXJyLmFiaUl0ZW0uaW5wdXRzPy5zb21lKCh4KSA9PiAhKFwibmFtZVwiIGluIHggJiYgeC5uYW1lKSk7XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZCA9IGZvcm1hdExvZyhsb2csIHtcXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IGlzVW5uYW1lZCA/IFtdIDoge30sXFxuICAgICAgICAgICAgICAgICAgICBldmVudE5hbWU6IGV2ZW50TmFtZTJcXG4gICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgICBlbWl0Lm9uTG9ncyhbZm9ybWF0dGVkXSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICBvbkVycm9yKGVycm9yKSB7XFxuICAgICAgICAgICAgICAgIGVtaXQub25FcnJvcj8uKGVycm9yKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB1bnN1YnNjcmliZSA9IHVuc3Vic2NyaWJlXztcXG4gICAgICAgICAgICBpZiAoIWFjdGl2ZSlcXG4gICAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XFxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgICAgICAgIG9uRXJyb3I/LihlcnIpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KSgpO1xcbiAgICAgICAgcmV0dXJuICgpID0+IHVuc3Vic2NyaWJlKCk7XFxuICAgICAgfSk7XFxuICAgIH07XFxuICAgIHJldHVybiBlbmFibGVQb2xsaW5nID8gcG9sbENvbnRyYWN0RXZlbnQoKSA6IHN1YnNjcmliZUNvbnRyYWN0RXZlbnQoKTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjdGlvbnMvd2FsbGV0L3dyaXRlQ29udHJhY3QuanNcXG4gIGluaXRfcGFyc2VBY2NvdW50KCk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9lcnJvcnMvYWNjb3VudC5qc1xcbiAgaW5pdF9iYXNlKCk7XFxuICB2YXIgQWNjb3VudE5vdEZvdW5kRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjIge1xcbiAgICBjb25zdHJ1Y3Rvcih7IGRvY3NQYXRoOiBkb2NzUGF0aDggfSA9IHt9KSB7XFxuICAgICAgc3VwZXIoW1xcbiAgICAgICAgXCJDb3VsZCBub3QgZmluZCBhbiBBY2NvdW50IHRvIGV4ZWN1dGUgd2l0aCB0aGlzIEFjdGlvbi5cIixcXG4gICAgICAgIFwiUGxlYXNlIHByb3ZpZGUgYW4gQWNjb3VudCB3aXRoIHRoZSBgYWNjb3VudGAgYXJndW1lbnQgb24gdGhlIEFjdGlvbiwgb3IgYnkgc3VwcGx5aW5nIGFuIGBhY2NvdW50YCB0byB0aGUgQ2xpZW50LlwiXFxuICAgICAgXS5qb2luKFwiXFxcXG5cIiksIHtcXG4gICAgICAgIGRvY3NQYXRoOiBkb2NzUGF0aDgsXFxuICAgICAgICBkb2NzU2x1ZzogXCJhY2NvdW50XCIsXFxuICAgICAgICBuYW1lOiBcIkFjY291bnROb3RGb3VuZEVycm9yXCJcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfTtcXG4gIHZhciBBY2NvdW50VHlwZU5vdFN1cHBvcnRlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IyIHtcXG4gICAgY29uc3RydWN0b3IoeyBkb2NzUGF0aDogZG9jc1BhdGg4LCBtZXRhTWVzc2FnZXMsIHR5cGUgfSkge1xcbiAgICAgIHN1cGVyKGBBY2NvdW50IHR5cGUgXCIke3R5cGV9XCIgaXMgbm90IHN1cHBvcnRlZC5gLCB7XFxuICAgICAgICBkb2NzUGF0aDogZG9jc1BhdGg4LFxcbiAgICAgICAgbWV0YU1lc3NhZ2VzLFxcbiAgICAgICAgbmFtZTogXCJBY2NvdW50VHlwZU5vdFN1cHBvcnRlZEVycm9yXCJcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjdGlvbnMvd2FsbGV0L3dyaXRlQ29udHJhY3QuanNcXG4gIGluaXRfZW5jb2RlRnVuY3Rpb25EYXRhKCk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL3dhbGxldC9zZW5kVHJhbnNhY3Rpb24uanNcXG4gIGluaXRfcGFyc2VBY2NvdW50KCk7XFxuICBpbml0X2Jhc2UoKTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2NoYWluL2Fzc2VydEN1cnJlbnRDaGFpbi5qc1xcbiAgaW5pdF9jaGFpbigpO1xcbiAgZnVuY3Rpb24gYXNzZXJ0Q3VycmVudENoYWluKHsgY2hhaW4sIGN1cnJlbnRDaGFpbklkIH0pIHtcXG4gICAgaWYgKCFjaGFpbilcXG4gICAgICB0aHJvdyBuZXcgQ2hhaW5Ob3RGb3VuZEVycm9yKCk7XFxuICAgIGlmIChjdXJyZW50Q2hhaW5JZCAhPT0gY2hhaW4uaWQpXFxuICAgICAgdGhyb3cgbmV3IENoYWluTWlzbWF0Y2hFcnJvcih7IGNoYWluLCBjdXJyZW50Q2hhaW5JZCB9KTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2Vycm9ycy9nZXRUcmFuc2FjdGlvbkVycm9yLmpzXFxuICBpbml0X25vZGUoKTtcXG4gIGluaXRfdHJhbnNhY3Rpb24oKTtcXG4gIGluaXRfZ2V0Tm9kZUVycm9yKCk7XFxuICBmdW5jdGlvbiBnZXRUcmFuc2FjdGlvbkVycm9yKGVyciwgeyBkb2NzUGF0aDogZG9jc1BhdGg4LCAuLi5hcmdzIH0pIHtcXG4gICAgY29uc3QgY2F1c2UgPSAoKCkgPT4ge1xcbiAgICAgIGNvbnN0IGNhdXNlMiA9IGdldE5vZGVFcnJvcihlcnIsIGFyZ3MpO1xcbiAgICAgIGlmIChjYXVzZTIgaW5zdGFuY2VvZiBVbmtub3duTm9kZUVycm9yKVxcbiAgICAgICAgcmV0dXJuIGVycjtcXG4gICAgICByZXR1cm4gY2F1c2UyO1xcbiAgICB9KSgpO1xcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uRXhlY3V0aW9uRXJyb3IoY2F1c2UsIHtcXG4gICAgICBkb2NzUGF0aDogZG9jc1BhdGg4LFxcbiAgICAgIC4uLmFyZ3NcXG4gICAgfSk7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL3dhbGxldC9zZW5kVHJhbnNhY3Rpb24uanNcXG4gIGluaXRfZXh0cmFjdCgpO1xcbiAgaW5pdF90cmFuc2FjdGlvblJlcXVlc3QoKTtcXG4gIGluaXRfbHJ1KCk7XFxuICBpbml0X2Fzc2VydFJlcXVlc3QoKTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjdGlvbnMvd2FsbGV0L3NlbmRSYXdUcmFuc2FjdGlvbi5qc1xcbiAgYXN5bmMgZnVuY3Rpb24gc2VuZFJhd1RyYW5zYWN0aW9uKGNsaWVudCwgeyBzZXJpYWxpemVkVHJhbnNhY3Rpb24gfSkge1xcbiAgICByZXR1cm4gY2xpZW50LnJlcXVlc3Qoe1xcbiAgICAgIG1ldGhvZDogXCJldGhfc2VuZFJhd1RyYW5zYWN0aW9uXCIsXFxuICAgICAgcGFyYW1zOiBbc2VyaWFsaXplZFRyYW5zYWN0aW9uXVxcbiAgICB9LCB7IHJldHJ5Q291bnQ6IDAgfSk7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL3dhbGxldC9zZW5kVHJhbnNhY3Rpb24uanNcXG4gIHZhciBzdXBwb3J0c1dhbGxldE5hbWVzcGFjZSA9IG5ldyBMcnVNYXAoMTI4KTtcXG4gIGFzeW5jIGZ1bmN0aW9uIHNlbmRUcmFuc2FjdGlvbihjbGllbnQsIHBhcmFtZXRlcnMpIHtcXG4gICAgY29uc3QgeyBhY2NvdW50OiBhY2NvdW50XyA9IGNsaWVudC5hY2NvdW50LCBjaGFpbiA9IGNsaWVudC5jaGFpbiwgYWNjZXNzTGlzdCwgYXV0aG9yaXphdGlvbkxpc3QsIGJsb2JzLCBkYXRhLCBnYXMsIGdhc1ByaWNlLCBtYXhGZWVQZXJCbG9iR2FzLCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzLCBub25jZSwgdmFsdWUsIC4uLnJlc3QgfSA9IHBhcmFtZXRlcnM7XFxuICAgIGlmICh0eXBlb2YgYWNjb3VudF8gPT09IFwidW5kZWZpbmVkXCIpXFxuICAgICAgdGhyb3cgbmV3IEFjY291bnROb3RGb3VuZEVycm9yKHtcXG4gICAgICAgIGRvY3NQYXRoOiBcIi9kb2NzL2FjdGlvbnMvd2FsbGV0L3NlbmRUcmFuc2FjdGlvblwiXFxuICAgICAgfSk7XFxuICAgIGNvbnN0IGFjY291bnQgPSBhY2NvdW50XyA/IHBhcnNlQWNjb3VudChhY2NvdW50XykgOiBudWxsO1xcbiAgICB0cnkge1xcbiAgICAgIGFzc2VydFJlcXVlc3QocGFyYW1ldGVycyk7XFxuICAgICAgY29uc3QgdG8gPSBhd2FpdCAoYXN5bmMgKCkgPT4ge1xcbiAgICAgICAgaWYgKHBhcmFtZXRlcnMudG8pXFxuICAgICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLnRvO1xcbiAgICAgICAgaWYgKHBhcmFtZXRlcnMudG8gPT09IG51bGwpXFxuICAgICAgICAgIHJldHVybiB2b2lkIDA7XFxuICAgICAgICBpZiAoYXV0aG9yaXphdGlvbkxpc3QgJiYgYXV0aG9yaXphdGlvbkxpc3QubGVuZ3RoID4gMClcXG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHJlY292ZXJBdXRob3JpemF0aW9uQWRkcmVzcyh7XFxuICAgICAgICAgICAgYXV0aG9yaXphdGlvbjogYXV0aG9yaXphdGlvbkxpc3RbMF1cXG4gICAgICAgICAgfSkuY2F0Y2goKCkgPT4ge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBCYXNlRXJyb3IyKFwiYHRvYCBpcyByZXF1aXJlZC4gQ291bGQgbm90IGluZmVyIGZyb20gYGF1dGhvcml6YXRpb25MaXN0YC5cIik7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcXG4gICAgICB9KSgpO1xcbiAgICAgIGlmIChhY2NvdW50Py50eXBlID09PSBcImpzb24tcnBjXCIgfHwgYWNjb3VudCA9PT0gbnVsbCkge1xcbiAgICAgICAgbGV0IGNoYWluSWQ7XFxuICAgICAgICBpZiAoY2hhaW4gIT09IG51bGwpIHtcXG4gICAgICAgICAgY2hhaW5JZCA9IGF3YWl0IGdldEFjdGlvbihjbGllbnQsIGdldENoYWluSWQsIFwiZ2V0Q2hhaW5JZFwiKSh7fSk7XFxuICAgICAgICAgIGFzc2VydEN1cnJlbnRDaGFpbih7XFxuICAgICAgICAgICAgY3VycmVudENoYWluSWQ6IGNoYWluSWQsXFxuICAgICAgICAgICAgY2hhaW5cXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgICBjb25zdCBjaGFpbkZvcm1hdCA9IGNsaWVudC5jaGFpbj8uZm9ybWF0dGVycz8udHJhbnNhY3Rpb25SZXF1ZXN0Py5mb3JtYXQ7XFxuICAgICAgICBjb25zdCBmb3JtYXQgPSBjaGFpbkZvcm1hdCB8fCBmb3JtYXRUcmFuc2FjdGlvblJlcXVlc3Q7XFxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gZm9ybWF0KHtcXG4gICAgICAgICAgLy8gUGljayBvdXQgZXh0cmEgZGF0YSB0aGF0IG1pZ2h0IGV4aXN0IG9uIHRoZSBjaGFpblxcJ3MgdHJhbnNhY3Rpb24gcmVxdWVzdCB0eXBlLlxcbiAgICAgICAgICAuLi5leHRyYWN0KHJlc3QsIHsgZm9ybWF0OiBjaGFpbkZvcm1hdCB9KSxcXG4gICAgICAgICAgYWNjZXNzTGlzdCxcXG4gICAgICAgICAgYXV0aG9yaXphdGlvbkxpc3QsXFxuICAgICAgICAgIGJsb2JzLFxcbiAgICAgICAgICBjaGFpbklkLFxcbiAgICAgICAgICBkYXRhLFxcbiAgICAgICAgICBmcm9tOiBhY2NvdW50Py5hZGRyZXNzLFxcbiAgICAgICAgICBnYXMsXFxuICAgICAgICAgIGdhc1ByaWNlLFxcbiAgICAgICAgICBtYXhGZWVQZXJCbG9iR2FzLFxcbiAgICAgICAgICBtYXhGZWVQZXJHYXMsXFxuICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzLFxcbiAgICAgICAgICBub25jZSxcXG4gICAgICAgICAgdG8sXFxuICAgICAgICAgIHZhbHVlXFxuICAgICAgICB9KTtcXG4gICAgICAgIGNvbnN0IGlzV2FsbGV0TmFtZXNwYWNlU3VwcG9ydGVkID0gc3VwcG9ydHNXYWxsZXROYW1lc3BhY2UuZ2V0KGNsaWVudC51aWQpO1xcbiAgICAgICAgY29uc3QgbWV0aG9kID0gaXNXYWxsZXROYW1lc3BhY2VTdXBwb3J0ZWQgPyBcIndhbGxldF9zZW5kVHJhbnNhY3Rpb25cIiA6IFwiZXRoX3NlbmRUcmFuc2FjdGlvblwiO1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgcmV0dXJuIGF3YWl0IGNsaWVudC5yZXF1ZXN0KHtcXG4gICAgICAgICAgICBtZXRob2QsXFxuICAgICAgICAgICAgcGFyYW1zOiBbcmVxdWVzdF1cXG4gICAgICAgICAgfSwgeyByZXRyeUNvdW50OiAwIH0pO1xcbiAgICAgICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgICBpZiAoaXNXYWxsZXROYW1lc3BhY2VTdXBwb3J0ZWQgPT09IGZhbHNlKVxcbiAgICAgICAgICAgIHRocm93IGU7XFxuICAgICAgICAgIGNvbnN0IGVycm9yID0gZTtcXG4gICAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09IFwiSW52YWxpZElucHV0UnBjRXJyb3JcIiB8fCBlcnJvci5uYW1lID09PSBcIkludmFsaWRQYXJhbXNScGNFcnJvclwiIHx8IGVycm9yLm5hbWUgPT09IFwiTWV0aG9kTm90Rm91bmRScGNFcnJvclwiIHx8IGVycm9yLm5hbWUgPT09IFwiTWV0aG9kTm90U3VwcG9ydGVkUnBjRXJyb3JcIikge1xcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBjbGllbnQucmVxdWVzdCh7XFxuICAgICAgICAgICAgICBtZXRob2Q6IFwid2FsbGV0X3NlbmRUcmFuc2FjdGlvblwiLFxcbiAgICAgICAgICAgICAgcGFyYW1zOiBbcmVxdWVzdF1cXG4gICAgICAgICAgICB9LCB7IHJldHJ5Q291bnQ6IDAgfSkudGhlbigoaGFzaDIpID0+IHtcXG4gICAgICAgICAgICAgIHN1cHBvcnRzV2FsbGV0TmFtZXNwYWNlLnNldChjbGllbnQudWlkLCB0cnVlKTtcXG4gICAgICAgICAgICAgIHJldHVybiBoYXNoMjtcXG4gICAgICAgICAgICB9KS5jYXRjaCgoZTIpID0+IHtcXG4gICAgICAgICAgICAgIGNvbnN0IHdhbGxldE5hbWVzcGFjZUVycm9yID0gZTI7XFxuICAgICAgICAgICAgICBpZiAod2FsbGV0TmFtZXNwYWNlRXJyb3IubmFtZSA9PT0gXCJNZXRob2ROb3RGb3VuZFJwY0Vycm9yXCIgfHwgd2FsbGV0TmFtZXNwYWNlRXJyb3IubmFtZSA9PT0gXCJNZXRob2ROb3RTdXBwb3J0ZWRScGNFcnJvclwiKSB7XFxuICAgICAgICAgICAgICAgIHN1cHBvcnRzV2FsbGV0TmFtZXNwYWNlLnNldChjbGllbnQudWlkLCBmYWxzZSk7XFxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgdGhyb3cgd2FsbGV0TmFtZXNwYWNlRXJyb3I7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgdGhyb3cgZXJyb3I7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGlmIChhY2NvdW50Py50eXBlID09PSBcImxvY2FsXCIpIHtcXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBhd2FpdCBnZXRBY3Rpb24oY2xpZW50LCBwcmVwYXJlVHJhbnNhY3Rpb25SZXF1ZXN0LCBcInByZXBhcmVUcmFuc2FjdGlvblJlcXVlc3RcIikoe1xcbiAgICAgICAgICBhY2NvdW50LFxcbiAgICAgICAgICBhY2Nlc3NMaXN0LFxcbiAgICAgICAgICBhdXRob3JpemF0aW9uTGlzdCxcXG4gICAgICAgICAgYmxvYnMsXFxuICAgICAgICAgIGNoYWluLFxcbiAgICAgICAgICBkYXRhLFxcbiAgICAgICAgICBnYXMsXFxuICAgICAgICAgIGdhc1ByaWNlLFxcbiAgICAgICAgICBtYXhGZWVQZXJCbG9iR2FzLFxcbiAgICAgICAgICBtYXhGZWVQZXJHYXMsXFxuICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzLFxcbiAgICAgICAgICBub25jZSxcXG4gICAgICAgICAgbm9uY2VNYW5hZ2VyOiBhY2NvdW50Lm5vbmNlTWFuYWdlcixcXG4gICAgICAgICAgcGFyYW1ldGVyczogWy4uLmRlZmF1bHRQYXJhbWV0ZXJzLCBcInNpZGVjYXJzXCJdLFxcbiAgICAgICAgICB2YWx1ZSxcXG4gICAgICAgICAgLi4ucmVzdCxcXG4gICAgICAgICAgdG9cXG4gICAgICAgIH0pO1xcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplciA9IGNoYWluPy5zZXJpYWxpemVycz8udHJhbnNhY3Rpb247XFxuICAgICAgICBjb25zdCBzZXJpYWxpemVkVHJhbnNhY3Rpb24gPSBhd2FpdCBhY2NvdW50LnNpZ25UcmFuc2FjdGlvbihyZXF1ZXN0LCB7XFxuICAgICAgICAgIHNlcmlhbGl6ZXJcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIGF3YWl0IGdldEFjdGlvbihjbGllbnQsIHNlbmRSYXdUcmFuc2FjdGlvbiwgXCJzZW5kUmF3VHJhbnNhY3Rpb25cIikoe1xcbiAgICAgICAgICBzZXJpYWxpemVkVHJhbnNhY3Rpb25cXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgICBpZiAoYWNjb3VudD8udHlwZSA9PT0gXCJzbWFydFwiKVxcbiAgICAgICAgdGhyb3cgbmV3IEFjY291bnRUeXBlTm90U3VwcG9ydGVkRXJyb3Ioe1xcbiAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcXG4gICAgICAgICAgICBcIkNvbnNpZGVyIHVzaW5nIHRoZSBgc2VuZFVzZXJPcGVyYXRpb25gIEFjdGlvbiBpbnN0ZWFkLlwiXFxuICAgICAgICAgIF0sXFxuICAgICAgICAgIGRvY3NQYXRoOiBcIi9kb2NzL2FjdGlvbnMvYnVuZGxlci9zZW5kVXNlck9wZXJhdGlvblwiLFxcbiAgICAgICAgICB0eXBlOiBcInNtYXJ0XCJcXG4gICAgICAgIH0pO1xcbiAgICAgIHRocm93IG5ldyBBY2NvdW50VHlwZU5vdFN1cHBvcnRlZEVycm9yKHtcXG4gICAgICAgIGRvY3NQYXRoOiBcIi9kb2NzL2FjdGlvbnMvd2FsbGV0L3NlbmRUcmFuc2FjdGlvblwiLFxcbiAgICAgICAgdHlwZTogYWNjb3VudD8udHlwZVxcbiAgICAgIH0pO1xcbiAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQWNjb3VudFR5cGVOb3RTdXBwb3J0ZWRFcnJvcilcXG4gICAgICAgIHRocm93IGVycjtcXG4gICAgICB0aHJvdyBnZXRUcmFuc2FjdGlvbkVycm9yKGVyciwge1xcbiAgICAgICAgLi4ucGFyYW1ldGVycyxcXG4gICAgICAgIGFjY291bnQsXFxuICAgICAgICBjaGFpbjogcGFyYW1ldGVycy5jaGFpbiB8fCB2b2lkIDBcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vYWN0aW9ucy93YWxsZXQvd3JpdGVDb250cmFjdC5qc1xcbiAgYXN5bmMgZnVuY3Rpb24gd3JpdGVDb250cmFjdChjbGllbnQsIHBhcmFtZXRlcnMpIHtcXG4gICAgY29uc3QgeyBhYmk6IGFiaTIsIGFjY291bnQ6IGFjY291bnRfID0gY2xpZW50LmFjY291bnQsIGFkZHJlc3MsIGFyZ3MsIGRhdGFTdWZmaXgsIGZ1bmN0aW9uTmFtZSwgLi4ucmVxdWVzdCB9ID0gcGFyYW1ldGVycztcXG4gICAgaWYgKHR5cGVvZiBhY2NvdW50XyA9PT0gXCJ1bmRlZmluZWRcIilcXG4gICAgICB0aHJvdyBuZXcgQWNjb3VudE5vdEZvdW5kRXJyb3Ioe1xcbiAgICAgICAgZG9jc1BhdGg6IFwiL2RvY3MvY29udHJhY3Qvd3JpdGVDb250cmFjdFwiXFxuICAgICAgfSk7XFxuICAgIGNvbnN0IGFjY291bnQgPSBhY2NvdW50XyA/IHBhcnNlQWNjb3VudChhY2NvdW50XykgOiBudWxsO1xcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRnVuY3Rpb25EYXRhKHtcXG4gICAgICBhYmk6IGFiaTIsXFxuICAgICAgYXJncyxcXG4gICAgICBmdW5jdGlvbk5hbWVcXG4gICAgfSk7XFxuICAgIHRyeSB7XFxuICAgICAgcmV0dXJuIGF3YWl0IGdldEFjdGlvbihjbGllbnQsIHNlbmRUcmFuc2FjdGlvbiwgXCJzZW5kVHJhbnNhY3Rpb25cIikoe1xcbiAgICAgICAgZGF0YTogYCR7ZGF0YX0ke2RhdGFTdWZmaXggPyBkYXRhU3VmZml4LnJlcGxhY2UoXCIweFwiLCBcIlwiKSA6IFwiXCJ9YCxcXG4gICAgICAgIHRvOiBhZGRyZXNzLFxcbiAgICAgICAgYWNjb3VudCxcXG4gICAgICAgIC4uLnJlcXVlc3RcXG4gICAgICB9KTtcXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcXG4gICAgICB0aHJvdyBnZXRDb250cmFjdEVycm9yKGVycm9yLCB7XFxuICAgICAgICBhYmk6IGFiaTIsXFxuICAgICAgICBhZGRyZXNzLFxcbiAgICAgICAgYXJncyxcXG4gICAgICAgIGRvY3NQYXRoOiBcIi9kb2NzL2NvbnRyYWN0L3dyaXRlQ29udHJhY3RcIixcXG4gICAgICAgIGZ1bmN0aW9uTmFtZSxcXG4gICAgICAgIHNlbmRlcjogYWNjb3VudD8uYWRkcmVzc1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9jbGllbnRzL2NyZWF0ZUNsaWVudC5qc1xcbiAgaW5pdF9wYXJzZUFjY291bnQoKTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL3VpZC5qc1xcbiAgdmFyIHNpemUyID0gMjU2O1xcbiAgdmFyIGluZGV4ID0gc2l6ZTI7XFxuICB2YXIgYnVmZmVyO1xcbiAgZnVuY3Rpb24gdWlkKGxlbmd0aCA9IDExKSB7XFxuICAgIGlmICghYnVmZmVyIHx8IGluZGV4ICsgbGVuZ3RoID4gc2l6ZTIgKiAyKSB7XFxuICAgICAgYnVmZmVyID0gXCJcIjtcXG4gICAgICBpbmRleCA9IDA7XFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplMjsgaSsrKSB7XFxuICAgICAgICBidWZmZXIgKz0gKDI1NiArIE1hdGgucmFuZG9tKCkgKiAyNTYgfCAwKS50b1N0cmluZygxNikuc3Vic3RyaW5nKDEpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gYnVmZmVyLnN1YnN0cmluZyhpbmRleCwgaW5kZXgrKyArIGxlbmd0aCk7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9jbGllbnRzL2NyZWF0ZUNsaWVudC5qc1xcbiAgZnVuY3Rpb24gY3JlYXRlQ2xpZW50KHBhcmFtZXRlcnMpIHtcXG4gICAgY29uc3QgeyBiYXRjaCwgY2FjaGVUaW1lID0gcGFyYW1ldGVycy5wb2xsaW5nSW50ZXJ2YWwgPz8gNGUzLCBjY2lwUmVhZCwga2V5ID0gXCJiYXNlXCIsIG5hbWUgPSBcIkJhc2UgQ2xpZW50XCIsIHBvbGxpbmdJbnRlcnZhbCA9IDRlMywgdHlwZSA9IFwiYmFzZVwiIH0gPSBwYXJhbWV0ZXJzO1xcbiAgICBjb25zdCBjaGFpbiA9IHBhcmFtZXRlcnMuY2hhaW47XFxuICAgIGNvbnN0IGFjY291bnQgPSBwYXJhbWV0ZXJzLmFjY291bnQgPyBwYXJzZUFjY291bnQocGFyYW1ldGVycy5hY2NvdW50KSA6IHZvaWQgMDtcXG4gICAgY29uc3QgeyBjb25maWc6IGNvbmZpZzIsIHJlcXVlc3QsIHZhbHVlIH0gPSBwYXJhbWV0ZXJzLnRyYW5zcG9ydCh7XFxuICAgICAgY2hhaW4sXFxuICAgICAgcG9sbGluZ0ludGVydmFsXFxuICAgIH0pO1xcbiAgICBjb25zdCB0cmFuc3BvcnQgPSB7IC4uLmNvbmZpZzIsIC4uLnZhbHVlIH07XFxuICAgIGNvbnN0IGNsaWVudCA9IHtcXG4gICAgICBhY2NvdW50LFxcbiAgICAgIGJhdGNoLFxcbiAgICAgIGNhY2hlVGltZSxcXG4gICAgICBjY2lwUmVhZCxcXG4gICAgICBjaGFpbixcXG4gICAgICBrZXksXFxuICAgICAgbmFtZSxcXG4gICAgICBwb2xsaW5nSW50ZXJ2YWwsXFxuICAgICAgcmVxdWVzdCxcXG4gICAgICB0cmFuc3BvcnQsXFxuICAgICAgdHlwZSxcXG4gICAgICB1aWQ6IHVpZCgpXFxuICAgIH07XFxuICAgIGZ1bmN0aW9uIGV4dGVuZChiYXNlMikge1xcbiAgICAgIHJldHVybiAoZXh0ZW5kRm4pID0+IHtcXG4gICAgICAgIGNvbnN0IGV4dGVuZGVkID0gZXh0ZW5kRm4oYmFzZTIpO1xcbiAgICAgICAgZm9yIChjb25zdCBrZXkyIGluIGNsaWVudClcXG4gICAgICAgICAgZGVsZXRlIGV4dGVuZGVkW2tleTJdO1xcbiAgICAgICAgY29uc3QgY29tYmluZWQgPSB7IC4uLmJhc2UyLCAuLi5leHRlbmRlZCB9O1xcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oY29tYmluZWQsIHsgZXh0ZW5kOiBleHRlbmQoY29tYmluZWQpIH0pO1xcbiAgICAgIH07XFxuICAgIH1cXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oY2xpZW50LCB7IGV4dGVuZDogZXh0ZW5kKGNsaWVudCkgfSk7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9idWlsZFJlcXVlc3QuanNcXG4gIGluaXRfYmFzZSgpO1xcbiAgaW5pdF9yZXF1ZXN0KCk7XFxuICBpbml0X3JwYygpO1xcbiAgaW5pdF90b0hleCgpO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvcHJvbWlzZS93aXRoRGVkdXBlLmpzXFxuICBpbml0X2xydSgpO1xcbiAgdmFyIHByb21pc2VDYWNoZTIgPSAvKiBAX19QVVJFX18gKi8gbmV3IExydU1hcCg4MTkyKTtcXG4gIGZ1bmN0aW9uIHdpdGhEZWR1cGUoZm4sIHsgZW5hYmxlZCA9IHRydWUsIGlkIH0pIHtcXG4gICAgaWYgKCFlbmFibGVkIHx8ICFpZClcXG4gICAgICByZXR1cm4gZm4oKTtcXG4gICAgaWYgKHByb21pc2VDYWNoZTIuZ2V0KGlkKSlcXG4gICAgICByZXR1cm4gcHJvbWlzZUNhY2hlMi5nZXQoaWQpO1xcbiAgICBjb25zdCBwcm9taXNlID0gZm4oKS5maW5hbGx5KCgpID0+IHByb21pc2VDYWNoZTIuZGVsZXRlKGlkKSk7XFxuICAgIHByb21pc2VDYWNoZTIuc2V0KGlkLCBwcm9taXNlKTtcXG4gICAgcmV0dXJuIHByb21pc2U7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9wcm9taXNlL3dpdGhSZXRyeS5qc1xcbiAgZnVuY3Rpb24gd2l0aFJldHJ5KGZuLCB7IGRlbGF5OiBkZWxheV8gPSAxMDAsIHJldHJ5Q291bnQgPSAyLCBzaG91bGRSZXRyeTogc2hvdWxkUmV0cnkyID0gKCkgPT4gdHJ1ZSB9ID0ge30pIHtcXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcXG4gICAgICBjb25zdCBhdHRlbXB0UmV0cnkgPSBhc3luYyAoeyBjb3VudCA9IDAgfSA9IHt9KSA9PiB7XFxuICAgICAgICBjb25zdCByZXRyeSA9IGFzeW5jICh7IGVycm9yIH0pID0+IHtcXG4gICAgICAgICAgY29uc3QgZGVsYXkgPSB0eXBlb2YgZGVsYXlfID09PSBcImZ1bmN0aW9uXCIgPyBkZWxheV8oeyBjb3VudCwgZXJyb3IgfSkgOiBkZWxheV87XFxuICAgICAgICAgIGlmIChkZWxheSlcXG4gICAgICAgICAgICBhd2FpdCB3YWl0KGRlbGF5KTtcXG4gICAgICAgICAgYXR0ZW1wdFJldHJ5KHsgY291bnQ6IGNvdW50ICsgMSB9KTtcXG4gICAgICAgIH07XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgZm4oKTtcXG4gICAgICAgICAgcmVzb2x2ZShkYXRhKTtcXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgICAgICBpZiAoY291bnQgPCByZXRyeUNvdW50ICYmIGF3YWl0IHNob3VsZFJldHJ5Mih7IGNvdW50LCBlcnJvcjogZXJyIH0pKVxcbiAgICAgICAgICAgIHJldHVybiByZXRyeSh7IGVycm9yOiBlcnIgfSk7XFxuICAgICAgICAgIHJlamVjdChlcnIpO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgICAgYXR0ZW1wdFJldHJ5KCk7XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvYnVpbGRSZXF1ZXN0LmpzXFxuICBpbml0X3N0cmluZ2lmeSgpO1xcbiAgZnVuY3Rpb24gYnVpbGRSZXF1ZXN0KHJlcXVlc3QsIG9wdGlvbnMgPSB7fSkge1xcbiAgICByZXR1cm4gYXN5bmMgKGFyZ3MsIG92ZXJyaWRlT3B0aW9ucyA9IHt9KSA9PiB7XFxuICAgICAgY29uc3QgeyBkZWR1cGUgPSBmYWxzZSwgbWV0aG9kcywgcmV0cnlEZWxheSA9IDE1MCwgcmV0cnlDb3VudCA9IDMsIHVpZDogdWlkMiB9ID0ge1xcbiAgICAgICAgLi4ub3B0aW9ucyxcXG4gICAgICAgIC4uLm92ZXJyaWRlT3B0aW9uc1xcbiAgICAgIH07XFxuICAgICAgY29uc3QgeyBtZXRob2QgfSA9IGFyZ3M7XFxuICAgICAgaWYgKG1ldGhvZHM/LmV4Y2x1ZGU/LmluY2x1ZGVzKG1ldGhvZCkpXFxuICAgICAgICB0aHJvdyBuZXcgTWV0aG9kTm90U3VwcG9ydGVkUnBjRXJyb3IobmV3IEVycm9yKFwibWV0aG9kIG5vdCBzdXBwb3J0ZWRcIiksIHtcXG4gICAgICAgICAgbWV0aG9kXFxuICAgICAgICB9KTtcXG4gICAgICBpZiAobWV0aG9kcz8uaW5jbHVkZSAmJiAhbWV0aG9kcy5pbmNsdWRlLmluY2x1ZGVzKG1ldGhvZCkpXFxuICAgICAgICB0aHJvdyBuZXcgTWV0aG9kTm90U3VwcG9ydGVkUnBjRXJyb3IobmV3IEVycm9yKFwibWV0aG9kIG5vdCBzdXBwb3J0ZWRcIiksIHtcXG4gICAgICAgICAgbWV0aG9kXFxuICAgICAgICB9KTtcXG4gICAgICBjb25zdCByZXF1ZXN0SWQgPSBkZWR1cGUgPyBzdHJpbmdUb0hleChgJHt1aWQyfS4ke3N0cmluZ2lmeShhcmdzKX1gKSA6IHZvaWQgMDtcXG4gICAgICByZXR1cm4gd2l0aERlZHVwZSgoKSA9PiB3aXRoUmV0cnkoYXN5bmMgKCkgPT4ge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHJlcXVlc3QoYXJncyk7XFxuICAgICAgICB9IGNhdGNoIChlcnJfKSB7XFxuICAgICAgICAgIGNvbnN0IGVyciA9IGVycl87XFxuICAgICAgICAgIHN3aXRjaCAoZXJyLmNvZGUpIHtcXG4gICAgICAgICAgICAvLyAtMzI3MDBcXG4gICAgICAgICAgICBjYXNlIFBhcnNlUnBjRXJyb3IuY29kZTpcXG4gICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZVJwY0Vycm9yKGVycik7XFxuICAgICAgICAgICAgLy8gLTMyNjAwXFxuICAgICAgICAgICAgY2FzZSBJbnZhbGlkUmVxdWVzdFJwY0Vycm9yLmNvZGU6XFxuICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFJlcXVlc3RScGNFcnJvcihlcnIpO1xcbiAgICAgICAgICAgIC8vIC0zMjYwMVxcbiAgICAgICAgICAgIGNhc2UgTWV0aG9kTm90Rm91bmRScGNFcnJvci5jb2RlOlxcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IE1ldGhvZE5vdEZvdW5kUnBjRXJyb3IoZXJyLCB7IG1ldGhvZDogYXJncy5tZXRob2QgfSk7XFxuICAgICAgICAgICAgLy8gLTMyNjAyXFxuICAgICAgICAgICAgY2FzZSBJbnZhbGlkUGFyYW1zUnBjRXJyb3IuY29kZTpcXG4gICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUGFyYW1zUnBjRXJyb3IoZXJyKTtcXG4gICAgICAgICAgICAvLyAtMzI2MDNcXG4gICAgICAgICAgICBjYXNlIEludGVybmFsUnBjRXJyb3IuY29kZTpcXG4gICAgICAgICAgICAgIHRocm93IG5ldyBJbnRlcm5hbFJwY0Vycm9yKGVycik7XFxuICAgICAgICAgICAgLy8gLTMyMDAwXFxuICAgICAgICAgICAgY2FzZSBJbnZhbGlkSW5wdXRScGNFcnJvci5jb2RlOlxcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRJbnB1dFJwY0Vycm9yKGVycik7XFxuICAgICAgICAgICAgLy8gLTMyMDAxXFxuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZU5vdEZvdW5kUnBjRXJyb3IuY29kZTpcXG4gICAgICAgICAgICAgIHRocm93IG5ldyBSZXNvdXJjZU5vdEZvdW5kUnBjRXJyb3IoZXJyKTtcXG4gICAgICAgICAgICAvLyAtMzIwMDJcXG4gICAgICAgICAgICBjYXNlIFJlc291cmNlVW5hdmFpbGFibGVScGNFcnJvci5jb2RlOlxcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlc291cmNlVW5hdmFpbGFibGVScGNFcnJvcihlcnIpO1xcbiAgICAgICAgICAgIC8vIC0zMjAwM1xcbiAgICAgICAgICAgIGNhc2UgVHJhbnNhY3Rpb25SZWplY3RlZFJwY0Vycm9yLmNvZGU6XFxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25SZWplY3RlZFJwY0Vycm9yKGVycik7XFxuICAgICAgICAgICAgLy8gLTMyMDA0XFxuICAgICAgICAgICAgY2FzZSBNZXRob2ROb3RTdXBwb3J0ZWRScGNFcnJvci5jb2RlOlxcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IE1ldGhvZE5vdFN1cHBvcnRlZFJwY0Vycm9yKGVyciwge1xcbiAgICAgICAgICAgICAgICBtZXRob2Q6IGFyZ3MubWV0aG9kXFxuICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAvLyAtMzIwMDVcXG4gICAgICAgICAgICBjYXNlIExpbWl0RXhjZWVkZWRScGNFcnJvci5jb2RlOlxcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IExpbWl0RXhjZWVkZWRScGNFcnJvcihlcnIpO1xcbiAgICAgICAgICAgIC8vIC0zMjAwNlxcbiAgICAgICAgICAgIGNhc2UgSnNvblJwY1ZlcnNpb25VbnN1cHBvcnRlZEVycm9yLmNvZGU6XFxuICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblJwY1ZlcnNpb25VbnN1cHBvcnRlZEVycm9yKGVycik7XFxuICAgICAgICAgICAgLy8gNDAwMVxcbiAgICAgICAgICAgIGNhc2UgVXNlclJlamVjdGVkUmVxdWVzdEVycm9yLmNvZGU6XFxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVXNlclJlamVjdGVkUmVxdWVzdEVycm9yKGVycik7XFxuICAgICAgICAgICAgLy8gNDEwMFxcbiAgICAgICAgICAgIGNhc2UgVW5hdXRob3JpemVkUHJvdmlkZXJFcnJvci5jb2RlOlxcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuYXV0aG9yaXplZFByb3ZpZGVyRXJyb3IoZXJyKTtcXG4gICAgICAgICAgICAvLyA0MjAwXFxuICAgICAgICAgICAgY2FzZSBVbnN1cHBvcnRlZFByb3ZpZGVyTWV0aG9kRXJyb3IuY29kZTpcXG4gICAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZFByb3ZpZGVyTWV0aG9kRXJyb3IoZXJyKTtcXG4gICAgICAgICAgICAvLyA0OTAwXFxuICAgICAgICAgICAgY2FzZSBQcm92aWRlckRpc2Nvbm5lY3RlZEVycm9yLmNvZGU6XFxuICAgICAgICAgICAgICB0aHJvdyBuZXcgUHJvdmlkZXJEaXNjb25uZWN0ZWRFcnJvcihlcnIpO1xcbiAgICAgICAgICAgIC8vIDQ5MDFcXG4gICAgICAgICAgICBjYXNlIENoYWluRGlzY29ubmVjdGVkRXJyb3IuY29kZTpcXG4gICAgICAgICAgICAgIHRocm93IG5ldyBDaGFpbkRpc2Nvbm5lY3RlZEVycm9yKGVycik7XFxuICAgICAgICAgICAgLy8gNDkwMlxcbiAgICAgICAgICAgIGNhc2UgU3dpdGNoQ2hhaW5FcnJvci5jb2RlOlxcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFN3aXRjaENoYWluRXJyb3IoZXJyKTtcXG4gICAgICAgICAgICAvLyA1NzAwXFxuICAgICAgICAgICAgY2FzZSBVbnN1cHBvcnRlZE5vbk9wdGlvbmFsQ2FwYWJpbGl0eUVycm9yLmNvZGU6XFxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWROb25PcHRpb25hbENhcGFiaWxpdHlFcnJvcihlcnIpO1xcbiAgICAgICAgICAgIC8vIDU3MTBcXG4gICAgICAgICAgICBjYXNlIFVuc3VwcG9ydGVkQ2hhaW5JZEVycm9yLmNvZGU6XFxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRDaGFpbklkRXJyb3IoZXJyKTtcXG4gICAgICAgICAgICAvLyA1NzIwXFxuICAgICAgICAgICAgY2FzZSBEdXBsaWNhdGVJZEVycm9yLmNvZGU6XFxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRHVwbGljYXRlSWRFcnJvcihlcnIpO1xcbiAgICAgICAgICAgIC8vIDU3MzBcXG4gICAgICAgICAgICBjYXNlIFVua25vd25CdW5kbGVJZEVycm9yLmNvZGU6XFxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5rbm93bkJ1bmRsZUlkRXJyb3IoZXJyKTtcXG4gICAgICAgICAgICAvLyA1NzQwXFxuICAgICAgICAgICAgY2FzZSBCdW5kbGVUb29MYXJnZUVycm9yLmNvZGU6XFxuICAgICAgICAgICAgICB0aHJvdyBuZXcgQnVuZGxlVG9vTGFyZ2VFcnJvcihlcnIpO1xcbiAgICAgICAgICAgIC8vIDU3NTBcXG4gICAgICAgICAgICBjYXNlIEF0b21pY1JlYWR5V2FsbGV0UmVqZWN0ZWRVcGdyYWRlRXJyb3IuY29kZTpcXG4gICAgICAgICAgICAgIHRocm93IG5ldyBBdG9taWNSZWFkeVdhbGxldFJlamVjdGVkVXBncmFkZUVycm9yKGVycik7XFxuICAgICAgICAgICAgLy8gNTc2MFxcbiAgICAgICAgICAgIGNhc2UgQXRvbWljaXR5Tm90U3VwcG9ydGVkRXJyb3IuY29kZTpcXG4gICAgICAgICAgICAgIHRocm93IG5ldyBBdG9taWNpdHlOb3RTdXBwb3J0ZWRFcnJvcihlcnIpO1xcbiAgICAgICAgICAgIC8vIENBSVAtMjU6IFVzZXIgUmVqZWN0ZWQgRXJyb3JcXG4gICAgICAgICAgICAvLyBodHRwczovL2RvY3Mud2FsbGV0Y29ubmVjdC5jb20vMi4wL3NwZWNzL2NsaWVudHMvc2lnbi9lcnJvci1jb2RlcyNyZWplY3RlZC1jYWlwLTI1XFxuICAgICAgICAgICAgY2FzZSA1ZTM6XFxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVXNlclJlamVjdGVkUmVxdWVzdEVycm9yKGVycik7XFxuICAgICAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgICAgIGlmIChlcnJfIGluc3RhbmNlb2YgQmFzZUVycm9yMilcXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyXztcXG4gICAgICAgICAgICAgIHRocm93IG5ldyBVbmtub3duUnBjRXJyb3IoZXJyKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0sIHtcXG4gICAgICAgIGRlbGF5OiAoeyBjb3VudCwgZXJyb3IgfSkgPT4ge1xcbiAgICAgICAgICBpZiAoZXJyb3IgJiYgZXJyb3IgaW5zdGFuY2VvZiBIdHRwUmVxdWVzdEVycm9yKSB7XFxuICAgICAgICAgICAgY29uc3QgcmV0cnlBZnRlciA9IGVycm9yPy5oZWFkZXJzPy5nZXQoXCJSZXRyeS1BZnRlclwiKTtcXG4gICAgICAgICAgICBpZiAocmV0cnlBZnRlcj8ubWF0Y2goL1xcXFxkLykpXFxuICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KHJldHJ5QWZ0ZXIpICogMWUzO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHJldHVybiB+figxIDw8IGNvdW50KSAqIHJldHJ5RGVsYXk7XFxuICAgICAgICB9LFxcbiAgICAgICAgcmV0cnlDb3VudCxcXG4gICAgICAgIHNob3VsZFJldHJ5OiAoeyBlcnJvciB9KSA9PiBzaG91bGRSZXRyeShlcnJvcilcXG4gICAgICB9KSwgeyBlbmFibGVkOiBkZWR1cGUsIGlkOiByZXF1ZXN0SWQgfSk7XFxuICAgIH07XFxuICB9XFxuICBmdW5jdGlvbiBzaG91bGRSZXRyeShlcnJvcikge1xcbiAgICBpZiAoXCJjb2RlXCIgaW4gZXJyb3IgJiYgdHlwZW9mIGVycm9yLmNvZGUgPT09IFwibnVtYmVyXCIpIHtcXG4gICAgICBpZiAoZXJyb3IuY29kZSA9PT0gLTEpXFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICBpZiAoZXJyb3IuY29kZSA9PT0gTGltaXRFeGNlZWRlZFJwY0Vycm9yLmNvZGUpXFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICBpZiAoZXJyb3IuY29kZSA9PT0gSW50ZXJuYWxScGNFcnJvci5jb2RlKVxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEh0dHBSZXF1ZXN0RXJyb3IgJiYgZXJyb3Iuc3RhdHVzKSB7XFxuICAgICAgaWYgKGVycm9yLnN0YXR1cyA9PT0gNDAzKVxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgaWYgKGVycm9yLnN0YXR1cyA9PT0gNDA4KVxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgaWYgKGVycm9yLnN0YXR1cyA9PT0gNDEzKVxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgaWYgKGVycm9yLnN0YXR1cyA9PT0gNDI5KVxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgaWYgKGVycm9yLnN0YXR1cyA9PT0gNTAwKVxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgaWYgKGVycm9yLnN0YXR1cyA9PT0gNTAyKVxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgaWYgKGVycm9yLnN0YXR1cyA9PT0gNTAzKVxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgaWYgKGVycm9yLnN0YXR1cyA9PT0gNTA0KVxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICAgIHJldHVybiB0cnVlO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vY2xpZW50cy90cmFuc3BvcnRzL2NyZWF0ZVRyYW5zcG9ydC5qc1xcbiAgZnVuY3Rpb24gY3JlYXRlVHJhbnNwb3J0KHsga2V5LCBtZXRob2RzLCBuYW1lLCByZXF1ZXN0LCByZXRyeUNvdW50ID0gMywgcmV0cnlEZWxheSA9IDE1MCwgdGltZW91dCwgdHlwZSB9LCB2YWx1ZSkge1xcbiAgICBjb25zdCB1aWQyID0gdWlkKCk7XFxuICAgIHJldHVybiB7XFxuICAgICAgY29uZmlnOiB7XFxuICAgICAgICBrZXksXFxuICAgICAgICBtZXRob2RzLFxcbiAgICAgICAgbmFtZSxcXG4gICAgICAgIHJlcXVlc3QsXFxuICAgICAgICByZXRyeUNvdW50LFxcbiAgICAgICAgcmV0cnlEZWxheSxcXG4gICAgICAgIHRpbWVvdXQsXFxuICAgICAgICB0eXBlXFxuICAgICAgfSxcXG4gICAgICByZXF1ZXN0OiBidWlsZFJlcXVlc3QocmVxdWVzdCwgeyBtZXRob2RzLCByZXRyeUNvdW50LCByZXRyeURlbGF5LCB1aWQ6IHVpZDIgfSksXFxuICAgICAgdmFsdWVcXG4gICAgfTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2NsaWVudHMvdHJhbnNwb3J0cy9jdXN0b20uanNcXG4gIGZ1bmN0aW9uIGN1c3RvbShwcm92aWRlciwgY29uZmlnMiA9IHt9KSB7XFxuICAgIGNvbnN0IHsga2V5ID0gXCJjdXN0b21cIiwgbWV0aG9kcywgbmFtZSA9IFwiQ3VzdG9tIFByb3ZpZGVyXCIsIHJldHJ5RGVsYXkgfSA9IGNvbmZpZzI7XFxuICAgIHJldHVybiAoeyByZXRyeUNvdW50OiBkZWZhdWx0UmV0cnlDb3VudCB9KSA9PiBjcmVhdGVUcmFuc3BvcnQoe1xcbiAgICAgIGtleSxcXG4gICAgICBtZXRob2RzLFxcbiAgICAgIG5hbWUsXFxuICAgICAgcmVxdWVzdDogcHJvdmlkZXIucmVxdWVzdC5iaW5kKHByb3ZpZGVyKSxcXG4gICAgICByZXRyeUNvdW50OiBjb25maWcyLnJldHJ5Q291bnQgPz8gZGVmYXVsdFJldHJ5Q291bnQsXFxuICAgICAgcmV0cnlEZWxheSxcXG4gICAgICB0eXBlOiBcImN1c3RvbVwiXFxuICAgIH0pO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vY2xpZW50cy90cmFuc3BvcnRzL2h0dHAuanNcXG4gIGluaXRfcmVxdWVzdCgpO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vZXJyb3JzL3RyYW5zcG9ydC5qc1xcbiAgaW5pdF9iYXNlKCk7XFxuICB2YXIgVXJsUmVxdWlyZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgIGNvbnN0cnVjdG9yKCkge1xcbiAgICAgIHN1cGVyKFwiTm8gVVJMIHdhcyBwcm92aWRlZCB0byB0aGUgVHJhbnNwb3J0LiBQbGVhc2UgcHJvdmlkZSBhIHZhbGlkIFJQQyBVUkwgdG8gdGhlIFRyYW5zcG9ydC5cIiwge1xcbiAgICAgICAgZG9jc1BhdGg6IFwiL2RvY3MvY2xpZW50cy9pbnRyb1wiLFxcbiAgICAgICAgbmFtZTogXCJVcmxSZXF1aXJlZEVycm9yXCJcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2NsaWVudHMvdHJhbnNwb3J0cy9odHRwLmpzXFxuICBpbml0X2NyZWF0ZUJhdGNoU2NoZWR1bGVyKCk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9ycGMvaHR0cC5qc1xcbiAgaW5pdF9yZXF1ZXN0KCk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9wcm9taXNlL3dpdGhUaW1lb3V0LmpzXFxuICBmdW5jdGlvbiB3aXRoVGltZW91dChmbiwgeyBlcnJvckluc3RhbmNlID0gbmV3IEVycm9yKFwidGltZWQgb3V0XCIpLCB0aW1lb3V0LCBzaWduYWwgfSkge1xcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xcbiAgICAgIDtcXG4gICAgICAoYXN5bmMgKCkgPT4ge1xcbiAgICAgICAgbGV0IHRpbWVvdXRJZDtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XFxuICAgICAgICAgIGlmICh0aW1lb3V0ID4gMCkge1xcbiAgICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xcbiAgICAgICAgICAgICAgaWYgKHNpZ25hbCkge1xcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3JJbnN0YW5jZSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSwgdGltZW91dCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgcmVzb2x2ZShhd2FpdCBmbih7IHNpZ25hbDogY29udHJvbGxlcj8uc2lnbmFsIHx8IG51bGwgfSkpO1xcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICAgIGlmIChlcnI/Lm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKVxcbiAgICAgICAgICAgIHJlamVjdChlcnJvckluc3RhbmNlKTtcXG4gICAgICAgICAgcmVqZWN0KGVycik7XFxuICAgICAgICB9IGZpbmFsbHkge1xcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcXG4gICAgICAgIH1cXG4gICAgICB9KSgpO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL3JwYy9odHRwLmpzXFxuICBpbml0X3N0cmluZ2lmeSgpO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvcnBjL2lkLmpzXFxuICBmdW5jdGlvbiBjcmVhdGVJZFN0b3JlKCkge1xcbiAgICByZXR1cm4ge1xcbiAgICAgIGN1cnJlbnQ6IDAsXFxuICAgICAgdGFrZSgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnQrKztcXG4gICAgICB9LFxcbiAgICAgIHJlc2V0KCkge1xcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gMDtcXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuICB2YXIgaWRDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVJZFN0b3JlKCk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9ycGMvaHR0cC5qc1xcbiAgZnVuY3Rpb24gZ2V0SHR0cFJwY0NsaWVudCh1cmwsIG9wdGlvbnMgPSB7fSkge1xcbiAgICByZXR1cm4ge1xcbiAgICAgIGFzeW5jIHJlcXVlc3QocGFyYW1zKSB7XFxuICAgICAgICBjb25zdCB7IGJvZHksIG9uUmVxdWVzdCA9IG9wdGlvbnMub25SZXF1ZXN0LCBvblJlc3BvbnNlID0gb3B0aW9ucy5vblJlc3BvbnNlLCB0aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0ID8/IDFlNCB9ID0gcGFyYW1zO1xcbiAgICAgICAgY29uc3QgZmV0Y2hPcHRpb25zID0ge1xcbiAgICAgICAgICAuLi5vcHRpb25zLmZldGNoT3B0aW9ucyA/PyB7fSxcXG4gICAgICAgICAgLi4ucGFyYW1zLmZldGNoT3B0aW9ucyA/PyB7fVxcbiAgICAgICAgfTtcXG4gICAgICAgIGNvbnN0IHsgaGVhZGVycywgbWV0aG9kLCBzaWduYWw6IHNpZ25hbF8gfSA9IGZldGNoT3B0aW9ucztcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgd2l0aFRpbWVvdXQoYXN5bmMgKHsgc2lnbmFsIH0pID0+IHtcXG4gICAgICAgICAgICBjb25zdCBpbml0ID0ge1xcbiAgICAgICAgICAgICAgLi4uZmV0Y2hPcHRpb25zLFxcbiAgICAgICAgICAgICAgYm9keTogQXJyYXkuaXNBcnJheShib2R5KSA/IHN0cmluZ2lmeShib2R5Lm1hcCgoYm9keTIpID0+ICh7XFxuICAgICAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXFxuICAgICAgICAgICAgICAgIGlkOiBib2R5Mi5pZCA/PyBpZENhY2hlLnRha2UoKSxcXG4gICAgICAgICAgICAgICAgLi4uYm9keTJcXG4gICAgICAgICAgICAgIH0pKSkgOiBzdHJpbmdpZnkoe1xcbiAgICAgICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxcbiAgICAgICAgICAgICAgICBpZDogYm9keS5pZCA/PyBpZENhY2hlLnRha2UoKSxcXG4gICAgICAgICAgICAgICAgLi4uYm9keVxcbiAgICAgICAgICAgICAgfSksXFxuICAgICAgICAgICAgICBoZWFkZXJzOiB7XFxuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxcbiAgICAgICAgICAgICAgICAuLi5oZWFkZXJzXFxuICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QgfHwgXCJQT1NUXCIsXFxuICAgICAgICAgICAgICBzaWduYWw6IHNpZ25hbF8gfHwgKHRpbWVvdXQgPiAwID8gc2lnbmFsIDogbnVsbClcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCh1cmwsIGluaXQpO1xcbiAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBhd2FpdCBvblJlcXVlc3Q/LihyZXF1ZXN0LCBpbml0KSA/PyB7IC4uLmluaXQsIHVybCB9O1xcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlMiA9IGF3YWl0IGZldGNoKGFyZ3MudXJsID8/IHVybCwgYXJncyk7XFxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlMjtcXG4gICAgICAgICAgfSwge1xcbiAgICAgICAgICAgIGVycm9ySW5zdGFuY2U6IG5ldyBUaW1lb3V0RXJyb3IoeyBib2R5LCB1cmwgfSksXFxuICAgICAgICAgICAgdGltZW91dCxcXG4gICAgICAgICAgICBzaWduYWw6IHRydWVcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIGlmIChvblJlc3BvbnNlKVxcbiAgICAgICAgICAgIGF3YWl0IG9uUmVzcG9uc2UocmVzcG9uc2UpO1xcbiAgICAgICAgICBsZXQgZGF0YTtcXG4gICAgICAgICAgaWYgKHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpPy5zdGFydHNXaXRoKFwiYXBwbGljYXRpb24vanNvblwiKSlcXG4gICAgICAgICAgICBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xcbiAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICBkYXRhID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xcbiAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhIHx8IFwie31cIik7XFxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uub2spXFxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcXG4gICAgICAgICAgICAgIGRhdGEgPSB7IGVycm9yOiBkYXRhIH07XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgSHR0cFJlcXVlc3RFcnJvcih7XFxuICAgICAgICAgICAgICBib2R5LFxcbiAgICAgICAgICAgICAgZGV0YWlsczogc3RyaW5naWZ5KGRhdGEuZXJyb3IpIHx8IHJlc3BvbnNlLnN0YXR1c1RleHQsXFxuICAgICAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxcbiAgICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXFxuICAgICAgICAgICAgICB1cmxcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICByZXR1cm4gZGF0YTtcXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgSHR0cFJlcXVlc3RFcnJvcilcXG4gICAgICAgICAgICB0aHJvdyBlcnI7XFxuICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBUaW1lb3V0RXJyb3IpXFxuICAgICAgICAgICAgdGhyb3cgZXJyO1xcbiAgICAgICAgICB0aHJvdyBuZXcgSHR0cFJlcXVlc3RFcnJvcih7XFxuICAgICAgICAgICAgYm9keSxcXG4gICAgICAgICAgICBjYXVzZTogZXJyLFxcbiAgICAgICAgICAgIHVybFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9jbGllbnRzL3RyYW5zcG9ydHMvaHR0cC5qc1xcbiAgZnVuY3Rpb24gaHR0cCh1cmwsIGNvbmZpZzIgPSB7fSkge1xcbiAgICBjb25zdCB7IGJhdGNoLCBmZXRjaE9wdGlvbnMsIGtleSA9IFwiaHR0cFwiLCBtZXRob2RzLCBuYW1lID0gXCJIVFRQIEpTT04tUlBDXCIsIG9uRmV0Y2hSZXF1ZXN0LCBvbkZldGNoUmVzcG9uc2UsIHJldHJ5RGVsYXksIHJhdyB9ID0gY29uZmlnMjtcXG4gICAgcmV0dXJuICh7IGNoYWluLCByZXRyeUNvdW50OiByZXRyeUNvdW50XywgdGltZW91dDogdGltZW91dF8gfSkgPT4ge1xcbiAgICAgIGNvbnN0IHsgYmF0Y2hTaXplID0gMWUzLCB3YWl0OiB3YWl0MiA9IDAgfSA9IHR5cGVvZiBiYXRjaCA9PT0gXCJvYmplY3RcIiA/IGJhdGNoIDoge307XFxuICAgICAgY29uc3QgcmV0cnlDb3VudCA9IGNvbmZpZzIucmV0cnlDb3VudCA/PyByZXRyeUNvdW50XztcXG4gICAgICBjb25zdCB0aW1lb3V0ID0gdGltZW91dF8gPz8gY29uZmlnMi50aW1lb3V0ID8/IDFlNDtcXG4gICAgICBjb25zdCB1cmxfID0gdXJsIHx8IGNoYWluPy5ycGNVcmxzLmRlZmF1bHQuaHR0cFswXTtcXG4gICAgICBpZiAoIXVybF8pXFxuICAgICAgICB0aHJvdyBuZXcgVXJsUmVxdWlyZWRFcnJvcigpO1xcbiAgICAgIGNvbnN0IHJwY0NsaWVudCA9IGdldEh0dHBScGNDbGllbnQodXJsXywge1xcbiAgICAgICAgZmV0Y2hPcHRpb25zLFxcbiAgICAgICAgb25SZXF1ZXN0OiBvbkZldGNoUmVxdWVzdCxcXG4gICAgICAgIG9uUmVzcG9uc2U6IG9uRmV0Y2hSZXNwb25zZSxcXG4gICAgICAgIHRpbWVvdXRcXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gY3JlYXRlVHJhbnNwb3J0KHtcXG4gICAgICAgIGtleSxcXG4gICAgICAgIG1ldGhvZHMsXFxuICAgICAgICBuYW1lLFxcbiAgICAgICAgYXN5bmMgcmVxdWVzdCh7IG1ldGhvZCwgcGFyYW1zIH0pIHtcXG4gICAgICAgICAgY29uc3QgYm9keSA9IHsgbWV0aG9kLCBwYXJhbXMgfTtcXG4gICAgICAgICAgY29uc3QgeyBzY2hlZHVsZSB9ID0gY3JlYXRlQmF0Y2hTY2hlZHVsZXIoe1xcbiAgICAgICAgICAgIGlkOiB1cmxfLFxcbiAgICAgICAgICAgIHdhaXQ6IHdhaXQyLFxcbiAgICAgICAgICAgIHNob3VsZFNwbGl0QmF0Y2gocmVxdWVzdHMpIHtcXG4gICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0cy5sZW5ndGggPiBiYXRjaFNpemU7XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBmbjogKGJvZHkyKSA9PiBycGNDbGllbnQucmVxdWVzdCh7XFxuICAgICAgICAgICAgICBib2R5OiBib2R5MlxcbiAgICAgICAgICAgIH0pLFxcbiAgICAgICAgICAgIHNvcnQ6IChhLCBiKSA9PiBhLmlkIC0gYi5pZFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgY29uc3QgZm4gPSBhc3luYyAoYm9keTIpID0+IGJhdGNoID8gc2NoZWR1bGUoYm9keTIpIDogW1xcbiAgICAgICAgICAgIGF3YWl0IHJwY0NsaWVudC5yZXF1ZXN0KHtcXG4gICAgICAgICAgICAgIGJvZHk6IGJvZHkyXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgICAgXTtcXG4gICAgICAgICAgY29uc3QgW3sgZXJyb3IsIHJlc3VsdCB9XSA9IGF3YWl0IGZuKGJvZHkpO1xcbiAgICAgICAgICBpZiAocmF3KVxcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yLCByZXN1bHQgfTtcXG4gICAgICAgICAgaWYgKGVycm9yKVxcbiAgICAgICAgICAgIHRocm93IG5ldyBScGNSZXF1ZXN0RXJyb3Ioe1xcbiAgICAgICAgICAgICAgYm9keSxcXG4gICAgICAgICAgICAgIGVycm9yLFxcbiAgICAgICAgICAgICAgdXJsOiB1cmxfXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgICB9LFxcbiAgICAgICAgcmV0cnlDb3VudCxcXG4gICAgICAgIHJldHJ5RGVsYXksXFxuICAgICAgICB0aW1lb3V0LFxcbiAgICAgICAgdHlwZTogXCJodHRwXCJcXG4gICAgICB9LCB7XFxuICAgICAgICBmZXRjaE9wdGlvbnMsXFxuICAgICAgICB1cmw6IHVybF9cXG4gICAgICB9KTtcXG4gICAgfTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjdGlvbnMvZW5zL2dldEVuc0FkZHJlc3MuanNcXG4gIGluaXRfYWJpcygpO1xcbiAgaW5pdF9kZWNvZGVGdW5jdGlvblJlc3VsdCgpO1xcbiAgaW5pdF9lbmNvZGVGdW5jdGlvbkRhdGEoKTtcXG4gIGluaXRfZ2V0Q2hhaW5Db250cmFjdEFkZHJlc3MoKTtcXG4gIGluaXRfdHJpbSgpO1xcbiAgaW5pdF90b0hleCgpO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvZW5zL2Vycm9ycy5qc1xcbiAgaW5pdF9zb2xpZGl0eSgpO1xcbiAgaW5pdF9iYXNlKCk7XFxuICBpbml0X2NvbnRyYWN0KCk7XFxuICBmdW5jdGlvbiBpc051bGxVbml2ZXJzYWxSZXNvbHZlckVycm9yKGVyciwgY2FsbFR5cGUpIHtcXG4gICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgQmFzZUVycm9yMikpXFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICBjb25zdCBjYXVzZSA9IGVyci53YWxrKChlKSA9PiBlIGluc3RhbmNlb2YgQ29udHJhY3RGdW5jdGlvblJldmVydGVkRXJyb3IpO1xcbiAgICBpZiAoIShjYXVzZSBpbnN0YW5jZW9mIENvbnRyYWN0RnVuY3Rpb25SZXZlcnRlZEVycm9yKSlcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIGlmIChjYXVzZS5kYXRhPy5lcnJvck5hbWUgPT09IFwiUmVzb2x2ZXJOb3RGb3VuZFwiKVxcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICBpZiAoY2F1c2UuZGF0YT8uZXJyb3JOYW1lID09PSBcIlJlc29sdmVyV2lsZGNhcmROb3RTdXBwb3J0ZWRcIilcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgaWYgKGNhdXNlLmRhdGE/LmVycm9yTmFtZSA9PT0gXCJSZXNvbHZlck5vdENvbnRyYWN0XCIpXFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIGlmIChjYXVzZS5kYXRhPy5lcnJvck5hbWUgPT09IFwiUmVzb2x2ZXJFcnJvclwiKVxcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICBpZiAoY2F1c2UuZGF0YT8uZXJyb3JOYW1lID09PSBcIkh0dHBFcnJvclwiKVxcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICBpZiAoY2F1c2UucmVhc29uPy5pbmNsdWRlcyhcIldpbGRjYXJkIG9uIG5vbi1leHRlbmRlZCByZXNvbHZlcnMgaXMgbm90IHN1cHBvcnRlZFwiKSlcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgaWYgKGNhbGxUeXBlID09PSBcInJldmVyc2VcIiAmJiBjYXVzZS5yZWFzb24gPT09IHBhbmljUmVhc29uc1s1MF0pXFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjdGlvbnMvZW5zL2dldEVuc0FkZHJlc3MuanNcXG4gIGluaXRfbG9jYWxCYXRjaEdhdGV3YXlSZXF1ZXN0KCk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9lbnMvbmFtZWhhc2guanNcXG4gIGluaXRfY29uY2F0KCk7XFxuICBpbml0X3RvQnl0ZXMoKTtcXG4gIGluaXRfdG9IZXgoKTtcXG4gIGluaXRfa2VjY2FrMjU2KCk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9lbnMvZW5jb2RlZExhYmVsVG9MYWJlbGhhc2guanNcXG4gIGluaXRfaXNIZXgoKTtcXG4gIGZ1bmN0aW9uIGVuY29kZWRMYWJlbFRvTGFiZWxoYXNoKGxhYmVsKSB7XFxuICAgIGlmIChsYWJlbC5sZW5ndGggIT09IDY2KVxcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICBpZiAobGFiZWwuaW5kZXhPZihcIltcIikgIT09IDApXFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIGlmIChsYWJlbC5pbmRleE9mKFwiXVwiKSAhPT0gNjUpXFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIGNvbnN0IGhhc2gyID0gYDB4JHtsYWJlbC5zbGljZSgxLCA2NSl9YDtcXG4gICAgaWYgKCFpc0hleChoYXNoMikpXFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIHJldHVybiBoYXNoMjtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2Vucy9uYW1laGFzaC5qc1xcbiAgZnVuY3Rpb24gbmFtZWhhc2gobmFtZSkge1xcbiAgICBsZXQgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoMzIpLmZpbGwoMCk7XFxuICAgIGlmICghbmFtZSlcXG4gICAgICByZXR1cm4gYnl0ZXNUb0hleChyZXN1bHQpO1xcbiAgICBjb25zdCBsYWJlbHMgPSBuYW1lLnNwbGl0KFwiLlwiKTtcXG4gICAgZm9yIChsZXQgaSA9IGxhYmVscy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xcbiAgICAgIGNvbnN0IGhhc2hGcm9tRW5jb2RlZExhYmVsID0gZW5jb2RlZExhYmVsVG9MYWJlbGhhc2gobGFiZWxzW2ldKTtcXG4gICAgICBjb25zdCBoYXNoZWQgPSBoYXNoRnJvbUVuY29kZWRMYWJlbCA/IHRvQnl0ZXMoaGFzaEZyb21FbmNvZGVkTGFiZWwpIDoga2VjY2FrMjU2KHN0cmluZ1RvQnl0ZXMobGFiZWxzW2ldKSwgXCJieXRlc1wiKTtcXG4gICAgICByZXN1bHQgPSBrZWNjYWsyNTYoY29uY2F0KFtyZXN1bHQsIGhhc2hlZF0pLCBcImJ5dGVzXCIpO1xcbiAgICB9XFxuICAgIHJldHVybiBieXRlc1RvSGV4KHJlc3VsdCk7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9lbnMvcGFja2V0VG9CeXRlcy5qc1xcbiAgaW5pdF90b0J5dGVzKCk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9lbnMvZW5jb2RlTGFiZWxoYXNoLmpzXFxuICBmdW5jdGlvbiBlbmNvZGVMYWJlbGhhc2goaGFzaDIpIHtcXG4gICAgcmV0dXJuIGBbJHtoYXNoMi5zbGljZSgyKX1dYDtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2Vucy9sYWJlbGhhc2guanNcXG4gIGluaXRfdG9CeXRlcygpO1xcbiAgaW5pdF90b0hleCgpO1xcbiAgaW5pdF9rZWNjYWsyNTYoKTtcXG4gIGZ1bmN0aW9uIGxhYmVsaGFzaChsYWJlbCkge1xcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSgzMikuZmlsbCgwKTtcXG4gICAgaWYgKCFsYWJlbClcXG4gICAgICByZXR1cm4gYnl0ZXNUb0hleChyZXN1bHQpO1xcbiAgICByZXR1cm4gZW5jb2RlZExhYmVsVG9MYWJlbGhhc2gobGFiZWwpIHx8IGtlY2NhazI1NihzdHJpbmdUb0J5dGVzKGxhYmVsKSk7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9lbnMvcGFja2V0VG9CeXRlcy5qc1xcbiAgZnVuY3Rpb24gcGFja2V0VG9CeXRlcyhwYWNrZXQpIHtcXG4gICAgY29uc3QgdmFsdWUgPSBwYWNrZXQucmVwbGFjZSgvXlxcXFwufFxcXFwuJC9nbSwgXCJcIik7XFxuICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApXFxuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDEpO1xcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KHN0cmluZ1RvQnl0ZXModmFsdWUpLmJ5dGVMZW5ndGggKyAyKTtcXG4gICAgbGV0IG9mZnNldCA9IDA7XFxuICAgIGNvbnN0IGxpc3QgPSB2YWx1ZS5zcGxpdChcIi5cIik7XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xcbiAgICAgIGxldCBlbmNvZGVkID0gc3RyaW5nVG9CeXRlcyhsaXN0W2ldKTtcXG4gICAgICBpZiAoZW5jb2RlZC5ieXRlTGVuZ3RoID4gMjU1KVxcbiAgICAgICAgZW5jb2RlZCA9IHN0cmluZ1RvQnl0ZXMoZW5jb2RlTGFiZWxoYXNoKGxhYmVsaGFzaChsaXN0W2ldKSkpO1xcbiAgICAgIGJ5dGVzW29mZnNldF0gPSBlbmNvZGVkLmxlbmd0aDtcXG4gICAgICBieXRlcy5zZXQoZW5jb2RlZCwgb2Zmc2V0ICsgMSk7XFxuICAgICAgb2Zmc2V0ICs9IGVuY29kZWQubGVuZ3RoICsgMTtcXG4gICAgfVxcbiAgICBpZiAoYnl0ZXMuYnl0ZUxlbmd0aCAhPT0gb2Zmc2V0ICsgMSlcXG4gICAgICByZXR1cm4gYnl0ZXMuc2xpY2UoMCwgb2Zmc2V0ICsgMSk7XFxuICAgIHJldHVybiBieXRlcztcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjdGlvbnMvZW5zL2dldEVuc0FkZHJlc3MuanNcXG4gIGFzeW5jIGZ1bmN0aW9uIGdldEVuc0FkZHJlc3MoY2xpZW50LCBwYXJhbWV0ZXJzKSB7XFxuICAgIGNvbnN0IHsgYmxvY2tOdW1iZXIsIGJsb2NrVGFnLCBjb2luVHlwZSwgbmFtZSwgZ2F0ZXdheVVybHMsIHN0cmljdCB9ID0gcGFyYW1ldGVycztcXG4gICAgY29uc3QgeyBjaGFpbiB9ID0gY2xpZW50O1xcbiAgICBjb25zdCB1bml2ZXJzYWxSZXNvbHZlckFkZHJlc3MgPSAoKCkgPT4ge1xcbiAgICAgIGlmIChwYXJhbWV0ZXJzLnVuaXZlcnNhbFJlc29sdmVyQWRkcmVzcylcXG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLnVuaXZlcnNhbFJlc29sdmVyQWRkcmVzcztcXG4gICAgICBpZiAoIWNoYWluKVxcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2xpZW50IGNoYWluIG5vdCBjb25maWd1cmVkLiB1bml2ZXJzYWxSZXNvbHZlckFkZHJlc3MgaXMgcmVxdWlyZWQuXCIpO1xcbiAgICAgIHJldHVybiBnZXRDaGFpbkNvbnRyYWN0QWRkcmVzcyh7XFxuICAgICAgICBibG9ja051bWJlcixcXG4gICAgICAgIGNoYWluLFxcbiAgICAgICAgY29udHJhY3Q6IFwiZW5zVW5pdmVyc2FsUmVzb2x2ZXJcIlxcbiAgICAgIH0pO1xcbiAgICB9KSgpO1xcbiAgICBjb25zdCB0bGRzID0gY2hhaW4/LmVuc1RsZHM7XFxuICAgIGlmICh0bGRzICYmICF0bGRzLnNvbWUoKHRsZCkgPT4gbmFtZS5lbmRzV2l0aCh0bGQpKSlcXG4gICAgICByZXR1cm4gbnVsbDtcXG4gICAgdHJ5IHtcXG4gICAgICBjb25zdCBmdW5jdGlvbkRhdGEgPSBlbmNvZGVGdW5jdGlvbkRhdGEoe1xcbiAgICAgICAgYWJpOiBhZGRyZXNzUmVzb2x2ZXJBYmksXFxuICAgICAgICBmdW5jdGlvbk5hbWU6IFwiYWRkclwiLFxcbiAgICAgICAgLi4uY29pblR5cGUgIT0gbnVsbCA/IHsgYXJnczogW25hbWVoYXNoKG5hbWUpLCBCaWdJbnQoY29pblR5cGUpXSB9IDogeyBhcmdzOiBbbmFtZWhhc2gobmFtZSldIH1cXG4gICAgICB9KTtcXG4gICAgICBjb25zdCByZWFkQ29udHJhY3RQYXJhbWV0ZXJzID0ge1xcbiAgICAgICAgYWRkcmVzczogdW5pdmVyc2FsUmVzb2x2ZXJBZGRyZXNzLFxcbiAgICAgICAgYWJpOiB1bml2ZXJzYWxSZXNvbHZlclJlc29sdmVBYmksXFxuICAgICAgICBmdW5jdGlvbk5hbWU6IFwicmVzb2x2ZVwiLFxcbiAgICAgICAgYXJnczogW1xcbiAgICAgICAgICB0b0hleChwYWNrZXRUb0J5dGVzKG5hbWUpKSxcXG4gICAgICAgICAgZnVuY3Rpb25EYXRhLFxcbiAgICAgICAgICBnYXRld2F5VXJscyA/PyBbbG9jYWxCYXRjaEdhdGV3YXlVcmxdXFxuICAgICAgICBdLFxcbiAgICAgICAgYmxvY2tOdW1iZXIsXFxuICAgICAgICBibG9ja1RhZ1xcbiAgICAgIH07XFxuICAgICAgY29uc3QgcmVhZENvbnRyYWN0QWN0aW9uID0gZ2V0QWN0aW9uKGNsaWVudCwgcmVhZENvbnRyYWN0LCBcInJlYWRDb250cmFjdFwiKTtcXG4gICAgICBjb25zdCByZXMgPSBhd2FpdCByZWFkQ29udHJhY3RBY3Rpb24ocmVhZENvbnRyYWN0UGFyYW1ldGVycyk7XFxuICAgICAgaWYgKHJlc1swXSA9PT0gXCIweFwiKVxcbiAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgY29uc3QgYWRkcmVzcyA9IGRlY29kZUZ1bmN0aW9uUmVzdWx0KHtcXG4gICAgICAgIGFiaTogYWRkcmVzc1Jlc29sdmVyQWJpLFxcbiAgICAgICAgYXJnczogY29pblR5cGUgIT0gbnVsbCA/IFtuYW1laGFzaChuYW1lKSwgQmlnSW50KGNvaW5UeXBlKV0gOiB2b2lkIDAsXFxuICAgICAgICBmdW5jdGlvbk5hbWU6IFwiYWRkclwiLFxcbiAgICAgICAgZGF0YTogcmVzWzBdXFxuICAgICAgfSk7XFxuICAgICAgaWYgKGFkZHJlc3MgPT09IFwiMHhcIilcXG4gICAgICAgIHJldHVybiBudWxsO1xcbiAgICAgIGlmICh0cmltKGFkZHJlc3MpID09PSBcIjB4MDBcIilcXG4gICAgICAgIHJldHVybiBudWxsO1xcbiAgICAgIHJldHVybiBhZGRyZXNzO1xcbiAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICBpZiAoc3RyaWN0KVxcbiAgICAgICAgdGhyb3cgZXJyO1xcbiAgICAgIGlmIChpc051bGxVbml2ZXJzYWxSZXNvbHZlckVycm9yKGVyciwgXCJyZXNvbHZlXCIpKVxcbiAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgdGhyb3cgZXJyO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9lcnJvcnMvZW5zLmpzXFxuICBpbml0X2Jhc2UoKTtcXG4gIHZhciBFbnNBdmF0YXJJbnZhbGlkTWV0YWRhdGFFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgIGNvbnN0cnVjdG9yKHsgZGF0YSB9KSB7XFxuICAgICAgc3VwZXIoXCJVbmFibGUgdG8gZXh0cmFjdCBpbWFnZSBmcm9tIG1ldGFkYXRhLiBUaGUgbWV0YWRhdGEgbWF5IGJlIG1hbGZvcm1lZCBvciBpbnZhbGlkLlwiLCB7XFxuICAgICAgICBtZXRhTWVzc2FnZXM6IFtcXG4gICAgICAgICAgXCItIE1ldGFkYXRhIG11c3QgYmUgYSBKU09OIG9iamVjdCB3aXRoIGF0IGxlYXN0IGFuIGBpbWFnZWAsIGBpbWFnZV91cmxgIG9yIGBpbWFnZV9kYXRhYCBwcm9wZXJ0eS5cIixcXG4gICAgICAgICAgXCJcIixcXG4gICAgICAgICAgYFByb3ZpZGVkIGRhdGE6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSl9YFxcbiAgICAgICAgXSxcXG4gICAgICAgIG5hbWU6IFwiRW5zQXZhdGFySW52YWxpZE1ldGFkYXRhRXJyb3JcIlxcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9O1xcbiAgdmFyIEVuc0F2YXRhckludmFsaWROZnRVcmlFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgIGNvbnN0cnVjdG9yKHsgcmVhc29uIH0pIHtcXG4gICAgICBzdXBlcihgRU5TIE5GVCBhdmF0YXIgVVJJIGlzIGludmFsaWQuICR7cmVhc29ufWAsIHtcXG4gICAgICAgIG5hbWU6IFwiRW5zQXZhdGFySW52YWxpZE5mdFVyaUVycm9yXCJcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfTtcXG4gIHZhciBFbnNBdmF0YXJVcmlSZXNvbHV0aW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjIge1xcbiAgICBjb25zdHJ1Y3Rvcih7IHVyaSB9KSB7XFxuICAgICAgc3VwZXIoYFVuYWJsZSB0byByZXNvbHZlIEVOUyBhdmF0YXIgVVJJIFwiJHt1cml9XCIuIFRoZSBVUkkgbWF5IGJlIG1hbGZvcm1lZCwgaW52YWxpZCwgb3IgZG9lcyBub3QgcmVzcG9uZCB3aXRoIGEgdmFsaWQgaW1hZ2UuYCwgeyBuYW1lOiBcIkVuc0F2YXRhclVyaVJlc29sdXRpb25FcnJvclwiIH0pO1xcbiAgICB9XFxuICB9O1xcbiAgdmFyIEVuc0F2YXRhclVuc3VwcG9ydGVkTmFtZXNwYWNlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjIge1xcbiAgICBjb25zdHJ1Y3Rvcih7IG5hbWVzcGFjZSB9KSB7XFxuICAgICAgc3VwZXIoYEVOUyBORlQgYXZhdGFyIG5hbWVzcGFjZSBcIiR7bmFtZXNwYWNlfVwiIGlzIG5vdCBzdXBwb3J0ZWQuIE11c3QgYmUgXCJlcmM3MjFcIiBvciBcImVyYzExNTVcIi5gLCB7IG5hbWU6IFwiRW5zQXZhdGFyVW5zdXBwb3J0ZWROYW1lc3BhY2VFcnJvclwiIH0pO1xcbiAgICB9XFxuICB9O1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvZW5zL2F2YXRhci91dGlscy5qc1xcbiAgdmFyIG5ldHdvcmtSZWdleCA9IC8oPzxwcm90b2NvbD5odHRwcz86XFxcXC9cXFxcL1teXFxcXC9dKnxpcGZzOlxcXFwvfGlwbnM6XFxcXC98YXI6XFxcXC8pPyg/PHJvb3Q+XFxcXC8pPyg/PHN1YnBhdGg+aXBmc1xcXFwvfGlwbnNcXFxcLyk/KD88dGFyZ2V0PltcXFxcd1xcXFwtLl0rKSg/PHN1YnRhcmdldD5cXFxcLy4qKT8vO1xcbiAgdmFyIGlwZnNIYXNoUmVnZXggPSAvXihRbVsxLTlBLUhKLU5QLVphLWttLXpdezQ0LH18YltBLVphLXoyLTddezU4LH18QltBLVoyLTddezU4LH18elsxLTlBLUhKLU5QLVphLWttLXpdezQ4LH18RlswLTlBLUZdezUwLH0pKFxcXFwvKD88dGFyZ2V0PltcXFxcd1xcXFwtLl0rKSk/KD88c3VidGFyZ2V0PlxcXFwvLiopPyQvO1xcbiAgdmFyIGJhc2U2NFJlZ2V4ID0gL15kYXRhOihbYS16QS1aXFxcXC0vK10qKTtiYXNlNjQsKFteXCJdLiopLztcXG4gIHZhciBkYXRhVVJJUmVnZXggPSAvXmRhdGE6KFthLXpBLVpcXFxcLS8rXSopPyg7W2EtekEtWjAtOV0uKj8pPygsKS87XFxuICBhc3luYyBmdW5jdGlvbiBpc0ltYWdlVXJpKHVyaSkge1xcbiAgICB0cnkge1xcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHVyaSwgeyBtZXRob2Q6IFwiSEVBRFwiIH0pO1xcbiAgICAgIGlmIChyZXMuc3RhdHVzID09PSAyMDApIHtcXG4gICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpO1xcbiAgICAgICAgcmV0dXJuIGNvbnRlbnRUeXBlPy5zdGFydHNXaXRoKFwiaW1hZ2UvXCIpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XFxuICAgICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZXJyb3IucmVzcG9uc2UgIT09IFwidW5kZWZpbmVkXCIpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuICAgICAgaWYgKCFnbG9iYWxUaGlzLmhhc093blByb3BlcnR5KFwiSW1hZ2VcIikpXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XFxuICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcXG4gICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XFxuICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XFxuICAgICAgICB9O1xcbiAgICAgICAgaW1nLm9uZXJyb3IgPSAoKSA9PiB7XFxuICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xcbiAgICAgICAgfTtcXG4gICAgICAgIGltZy5zcmMgPSB1cmk7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH1cXG4gIGZ1bmN0aW9uIGdldEdhdGV3YXkoY3VzdG9tMywgZGVmYXVsdEdhdGV3YXkpIHtcXG4gICAgaWYgKCFjdXN0b20zKVxcbiAgICAgIHJldHVybiBkZWZhdWx0R2F0ZXdheTtcXG4gICAgaWYgKGN1c3RvbTMuZW5kc1dpdGgoXCIvXCIpKVxcbiAgICAgIHJldHVybiBjdXN0b20zLnNsaWNlKDAsIC0xKTtcXG4gICAgcmV0dXJuIGN1c3RvbTM7XFxuICB9XFxuICBmdW5jdGlvbiByZXNvbHZlQXZhdGFyVXJpKHsgdXJpLCBnYXRld2F5VXJscyB9KSB7XFxuICAgIGNvbnN0IGlzRW5jb2RlZCA9IGJhc2U2NFJlZ2V4LnRlc3QodXJpKTtcXG4gICAgaWYgKGlzRW5jb2RlZClcXG4gICAgICByZXR1cm4geyB1cmksIGlzT25DaGFpbjogdHJ1ZSwgaXNFbmNvZGVkIH07XFxuICAgIGNvbnN0IGlwZnNHYXRld2F5ID0gZ2V0R2F0ZXdheShnYXRld2F5VXJscz8uaXBmcywgXCJodHRwczovL2lwZnMuaW9cIik7XFxuICAgIGNvbnN0IGFyd2VhdmVHYXRld2F5ID0gZ2V0R2F0ZXdheShnYXRld2F5VXJscz8uYXJ3ZWF2ZSwgXCJodHRwczovL2Fyd2VhdmUubmV0XCIpO1xcbiAgICBjb25zdCBuZXR3b3JrUmVnZXhNYXRjaCA9IHVyaS5tYXRjaChuZXR3b3JrUmVnZXgpO1xcbiAgICBjb25zdCB7IHByb3RvY29sLCBzdWJwYXRoLCB0YXJnZXQsIHN1YnRhcmdldCA9IFwiXCIgfSA9IG5ldHdvcmtSZWdleE1hdGNoPy5ncm91cHMgfHwge307XFxuICAgIGNvbnN0IGlzSVBOUyA9IHByb3RvY29sID09PSBcImlwbnM6L1wiIHx8IHN1YnBhdGggPT09IFwiaXBucy9cIjtcXG4gICAgY29uc3QgaXNJUEZTID0gcHJvdG9jb2wgPT09IFwiaXBmczovXCIgfHwgc3VicGF0aCA9PT0gXCJpcGZzL1wiIHx8IGlwZnNIYXNoUmVnZXgudGVzdCh1cmkpO1xcbiAgICBpZiAodXJpLnN0YXJ0c1dpdGgoXCJodHRwXCIpICYmICFpc0lQTlMgJiYgIWlzSVBGUykge1xcbiAgICAgIGxldCByZXBsYWNlZFVyaSA9IHVyaTtcXG4gICAgICBpZiAoZ2F0ZXdheVVybHM/LmFyd2VhdmUpXFxuICAgICAgICByZXBsYWNlZFVyaSA9IHVyaS5yZXBsYWNlKC9odHRwczpcXFxcL1xcXFwvYXJ3ZWF2ZS5uZXQvZywgZ2F0ZXdheVVybHM/LmFyd2VhdmUpO1xcbiAgICAgIHJldHVybiB7IHVyaTogcmVwbGFjZWRVcmksIGlzT25DaGFpbjogZmFsc2UsIGlzRW5jb2RlZDogZmFsc2UgfTtcXG4gICAgfVxcbiAgICBpZiAoKGlzSVBOUyB8fCBpc0lQRlMpICYmIHRhcmdldCkge1xcbiAgICAgIHJldHVybiB7XFxuICAgICAgICB1cmk6IGAke2lwZnNHYXRld2F5fS8ke2lzSVBOUyA/IFwiaXBuc1wiIDogXCJpcGZzXCJ9LyR7dGFyZ2V0fSR7c3VidGFyZ2V0fWAsXFxuICAgICAgICBpc09uQ2hhaW46IGZhbHNlLFxcbiAgICAgICAgaXNFbmNvZGVkOiBmYWxzZVxcbiAgICAgIH07XFxuICAgIH1cXG4gICAgaWYgKHByb3RvY29sID09PSBcImFyOi9cIiAmJiB0YXJnZXQpIHtcXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgdXJpOiBgJHthcndlYXZlR2F0ZXdheX0vJHt0YXJnZXR9JHtzdWJ0YXJnZXQgfHwgXCJcIn1gLFxcbiAgICAgICAgaXNPbkNoYWluOiBmYWxzZSxcXG4gICAgICAgIGlzRW5jb2RlZDogZmFsc2VcXG4gICAgICB9O1xcbiAgICB9XFxuICAgIGxldCBwYXJzZWRVcmkgPSB1cmkucmVwbGFjZShkYXRhVVJJUmVnZXgsIFwiXCIpO1xcbiAgICBpZiAocGFyc2VkVXJpLnN0YXJ0c1dpdGgoXCI8c3ZnXCIpKSB7XFxuICAgICAgcGFyc2VkVXJpID0gYGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsJHtidG9hKHBhcnNlZFVyaSl9YDtcXG4gICAgfVxcbiAgICBpZiAocGFyc2VkVXJpLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSB8fCBwYXJzZWRVcmkuc3RhcnRzV2l0aChcIntcIikpIHtcXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgdXJpOiBwYXJzZWRVcmksXFxuICAgICAgICBpc09uQ2hhaW46IHRydWUsXFxuICAgICAgICBpc0VuY29kZWQ6IGZhbHNlXFxuICAgICAgfTtcXG4gICAgfVxcbiAgICB0aHJvdyBuZXcgRW5zQXZhdGFyVXJpUmVzb2x1dGlvbkVycm9yKHsgdXJpIH0pO1xcbiAgfVxcbiAgZnVuY3Rpb24gZ2V0SnNvbkltYWdlKGRhdGEpIHtcXG4gICAgaWYgKHR5cGVvZiBkYXRhICE9PSBcIm9iamVjdFwiIHx8ICEoXCJpbWFnZVwiIGluIGRhdGEpICYmICEoXCJpbWFnZV91cmxcIiBpbiBkYXRhKSAmJiAhKFwiaW1hZ2VfZGF0YVwiIGluIGRhdGEpKSB7XFxuICAgICAgdGhyb3cgbmV3IEVuc0F2YXRhckludmFsaWRNZXRhZGF0YUVycm9yKHsgZGF0YSB9KTtcXG4gICAgfVxcbiAgICByZXR1cm4gZGF0YS5pbWFnZSB8fCBkYXRhLmltYWdlX3VybCB8fCBkYXRhLmltYWdlX2RhdGE7XFxuICB9XFxuICBhc3luYyBmdW5jdGlvbiBnZXRNZXRhZGF0YUF2YXRhclVyaSh7IGdhdGV3YXlVcmxzLCB1cmkgfSkge1xcbiAgICB0cnkge1xcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHVyaSkudGhlbigocmVzMikgPT4gcmVzMi5qc29uKCkpO1xcbiAgICAgIGNvbnN0IGltYWdlID0gYXdhaXQgcGFyc2VBdmF0YXJVcmkoe1xcbiAgICAgICAgZ2F0ZXdheVVybHMsXFxuICAgICAgICB1cmk6IGdldEpzb25JbWFnZShyZXMpXFxuICAgICAgfSk7XFxuICAgICAgcmV0dXJuIGltYWdlO1xcbiAgICB9IGNhdGNoIHtcXG4gICAgICB0aHJvdyBuZXcgRW5zQXZhdGFyVXJpUmVzb2x1dGlvbkVycm9yKHsgdXJpIH0pO1xcbiAgICB9XFxuICB9XFxuICBhc3luYyBmdW5jdGlvbiBwYXJzZUF2YXRhclVyaSh7IGdhdGV3YXlVcmxzLCB1cmkgfSkge1xcbiAgICBjb25zdCB7IHVyaTogcmVzb2x2ZWRVUkksIGlzT25DaGFpbiB9ID0gcmVzb2x2ZUF2YXRhclVyaSh7IHVyaSwgZ2F0ZXdheVVybHMgfSk7XFxuICAgIGlmIChpc09uQ2hhaW4pXFxuICAgICAgcmV0dXJuIHJlc29sdmVkVVJJO1xcbiAgICBjb25zdCBpc0ltYWdlID0gYXdhaXQgaXNJbWFnZVVyaShyZXNvbHZlZFVSSSk7XFxuICAgIGlmIChpc0ltYWdlKVxcbiAgICAgIHJldHVybiByZXNvbHZlZFVSSTtcXG4gICAgdGhyb3cgbmV3IEVuc0F2YXRhclVyaVJlc29sdXRpb25FcnJvcih7IHVyaSB9KTtcXG4gIH1cXG4gIGZ1bmN0aW9uIHBhcnNlTmZ0VXJpKHVyaV8pIHtcXG4gICAgbGV0IHVyaSA9IHVyaV87XFxuICAgIGlmICh1cmkuc3RhcnRzV2l0aChcImRpZDpuZnQ6XCIpKSB7XFxuICAgICAgdXJpID0gdXJpLnJlcGxhY2UoXCJkaWQ6bmZ0OlwiLCBcIlwiKS5yZXBsYWNlKC9fL2csIFwiL1wiKTtcXG4gICAgfVxcbiAgICBjb25zdCBbcmVmZXJlbmNlLCBhc3NldF9uYW1lc3BhY2UsIHRva2VuSURdID0gdXJpLnNwbGl0KFwiL1wiKTtcXG4gICAgY29uc3QgW2VpcF9uYW1lc3BhY2UsIGNoYWluSURdID0gcmVmZXJlbmNlLnNwbGl0KFwiOlwiKTtcXG4gICAgY29uc3QgW2VyY19uYW1lc3BhY2UsIGNvbnRyYWN0QWRkcmVzc10gPSBhc3NldF9uYW1lc3BhY2Uuc3BsaXQoXCI6XCIpO1xcbiAgICBpZiAoIWVpcF9uYW1lc3BhY2UgfHwgZWlwX25hbWVzcGFjZS50b0xvd2VyQ2FzZSgpICE9PSBcImVpcDE1NVwiKVxcbiAgICAgIHRocm93IG5ldyBFbnNBdmF0YXJJbnZhbGlkTmZ0VXJpRXJyb3IoeyByZWFzb246IFwiT25seSBFSVAtMTU1IHN1cHBvcnRlZFwiIH0pO1xcbiAgICBpZiAoIWNoYWluSUQpXFxuICAgICAgdGhyb3cgbmV3IEVuc0F2YXRhckludmFsaWROZnRVcmlFcnJvcih7IHJlYXNvbjogXCJDaGFpbiBJRCBub3QgZm91bmRcIiB9KTtcXG4gICAgaWYgKCFjb250cmFjdEFkZHJlc3MpXFxuICAgICAgdGhyb3cgbmV3IEVuc0F2YXRhckludmFsaWROZnRVcmlFcnJvcih7XFxuICAgICAgICByZWFzb246IFwiQ29udHJhY3QgYWRkcmVzcyBub3QgZm91bmRcIlxcbiAgICAgIH0pO1xcbiAgICBpZiAoIXRva2VuSUQpXFxuICAgICAgdGhyb3cgbmV3IEVuc0F2YXRhckludmFsaWROZnRVcmlFcnJvcih7IHJlYXNvbjogXCJUb2tlbiBJRCBub3QgZm91bmRcIiB9KTtcXG4gICAgaWYgKCFlcmNfbmFtZXNwYWNlKVxcbiAgICAgIHRocm93IG5ldyBFbnNBdmF0YXJJbnZhbGlkTmZ0VXJpRXJyb3IoeyByZWFzb246IFwiRVJDIG5hbWVzcGFjZSBub3QgZm91bmRcIiB9KTtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBjaGFpbklEOiBOdW1iZXIucGFyc2VJbnQoY2hhaW5JRCksXFxuICAgICAgbmFtZXNwYWNlOiBlcmNfbmFtZXNwYWNlLnRvTG93ZXJDYXNlKCksXFxuICAgICAgY29udHJhY3RBZGRyZXNzLFxcbiAgICAgIHRva2VuSURcXG4gICAgfTtcXG4gIH1cXG4gIGFzeW5jIGZ1bmN0aW9uIGdldE5mdFRva2VuVXJpKGNsaWVudCwgeyBuZnQgfSkge1xcbiAgICBpZiAobmZ0Lm5hbWVzcGFjZSA9PT0gXCJlcmM3MjFcIikge1xcbiAgICAgIHJldHVybiByZWFkQ29udHJhY3QoY2xpZW50LCB7XFxuICAgICAgICBhZGRyZXNzOiBuZnQuY29udHJhY3RBZGRyZXNzLFxcbiAgICAgICAgYWJpOiBbXFxuICAgICAgICAgIHtcXG4gICAgICAgICAgICBuYW1lOiBcInRva2VuVVJJXCIsXFxuICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxcbiAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXFxuICAgICAgICAgICAgaW5wdXRzOiBbeyBuYW1lOiBcInRva2VuSWRcIiwgdHlwZTogXCJ1aW50MjU2XCIgfV0sXFxuICAgICAgICAgICAgb3V0cHV0czogW3sgbmFtZTogXCJcIiwgdHlwZTogXCJzdHJpbmdcIiB9XVxcbiAgICAgICAgICB9XFxuICAgICAgICBdLFxcbiAgICAgICAgZnVuY3Rpb25OYW1lOiBcInRva2VuVVJJXCIsXFxuICAgICAgICBhcmdzOiBbQmlnSW50KG5mdC50b2tlbklEKV1cXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICBpZiAobmZ0Lm5hbWVzcGFjZSA9PT0gXCJlcmMxMTU1XCIpIHtcXG4gICAgICByZXR1cm4gcmVhZENvbnRyYWN0KGNsaWVudCwge1xcbiAgICAgICAgYWRkcmVzczogbmZ0LmNvbnRyYWN0QWRkcmVzcyxcXG4gICAgICAgIGFiaTogW1xcbiAgICAgICAgICB7XFxuICAgICAgICAgICAgbmFtZTogXCJ1cmlcIixcXG4gICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXFxuICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcXG4gICAgICAgICAgICBpbnB1dHM6IFt7IG5hbWU6IFwiX2lkXCIsIHR5cGU6IFwidWludDI1NlwiIH1dLFxcbiAgICAgICAgICAgIG91dHB1dHM6IFt7IG5hbWU6IFwiXCIsIHR5cGU6IFwic3RyaW5nXCIgfV1cXG4gICAgICAgICAgfVxcbiAgICAgICAgXSxcXG4gICAgICAgIGZ1bmN0aW9uTmFtZTogXCJ1cmlcIixcXG4gICAgICAgIGFyZ3M6IFtCaWdJbnQobmZ0LnRva2VuSUQpXVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIHRocm93IG5ldyBFbnNBdmF0YXJVbnN1cHBvcnRlZE5hbWVzcGFjZUVycm9yKHsgbmFtZXNwYWNlOiBuZnQubmFtZXNwYWNlIH0pO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvZW5zL2F2YXRhci9wYXJzZUF2YXRhclJlY29yZC5qc1xcbiAgYXN5bmMgZnVuY3Rpb24gcGFyc2VBdmF0YXJSZWNvcmQoY2xpZW50LCB7IGdhdGV3YXlVcmxzLCByZWNvcmQgfSkge1xcbiAgICBpZiAoL2VpcDE1NTovaS50ZXN0KHJlY29yZCkpXFxuICAgICAgcmV0dXJuIHBhcnNlTmZ0QXZhdGFyVXJpKGNsaWVudCwgeyBnYXRld2F5VXJscywgcmVjb3JkIH0pO1xcbiAgICByZXR1cm4gcGFyc2VBdmF0YXJVcmkoeyB1cmk6IHJlY29yZCwgZ2F0ZXdheVVybHMgfSk7XFxuICB9XFxuICBhc3luYyBmdW5jdGlvbiBwYXJzZU5mdEF2YXRhclVyaShjbGllbnQsIHsgZ2F0ZXdheVVybHMsIHJlY29yZCB9KSB7XFxuICAgIGNvbnN0IG5mdCA9IHBhcnNlTmZ0VXJpKHJlY29yZCk7XFxuICAgIGNvbnN0IG5mdFVyaSA9IGF3YWl0IGdldE5mdFRva2VuVXJpKGNsaWVudCwgeyBuZnQgfSk7XFxuICAgIGNvbnN0IHsgdXJpOiByZXNvbHZlZE5mdFVyaSwgaXNPbkNoYWluLCBpc0VuY29kZWQgfSA9IHJlc29sdmVBdmF0YXJVcmkoeyB1cmk6IG5mdFVyaSwgZ2F0ZXdheVVybHMgfSk7XFxuICAgIGlmIChpc09uQ2hhaW4gJiYgKHJlc29sdmVkTmZ0VXJpLmluY2x1ZGVzKFwiZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIikgfHwgcmVzb2x2ZWROZnRVcmkuc3RhcnRzV2l0aChcIntcIikpKSB7XFxuICAgICAgY29uc3QgZW5jb2RlZEpzb24gPSBpc0VuY29kZWQgPyAoXFxuICAgICAgICAvLyBpZiBpdCBpcyBlbmNvZGVkLCBkZWNvZGUgaXRcXG4gICAgICAgIGF0b2IocmVzb2x2ZWROZnRVcmkucmVwbGFjZShcImRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIsIFwiXCIpKVxcbiAgICAgICkgOiAoXFxuICAgICAgICAvLyBpZiBpdCBpc25cXCd0IGVuY29kZWQgYXNzdW1lIGl0IGlzIGEgSlNPTiBzdHJpbmcsIGJ1dCBpdCBjb3VsZCBiZSBhbnl0aGluZyAoaXQgd2lsbCBlcnJvciBpZiBpdCBpcylcXG4gICAgICAgIHJlc29sdmVkTmZ0VXJpXFxuICAgICAgKTtcXG4gICAgICBjb25zdCBkZWNvZGVkID0gSlNPTi5wYXJzZShlbmNvZGVkSnNvbik7XFxuICAgICAgcmV0dXJuIHBhcnNlQXZhdGFyVXJpKHsgdXJpOiBnZXRKc29uSW1hZ2UoZGVjb2RlZCksIGdhdGV3YXlVcmxzIH0pO1xcbiAgICB9XFxuICAgIGxldCB1cmlUb2tlbklkID0gbmZ0LnRva2VuSUQ7XFxuICAgIGlmIChuZnQubmFtZXNwYWNlID09PSBcImVyYzExNTVcIilcXG4gICAgICB1cmlUb2tlbklkID0gdXJpVG9rZW5JZC5yZXBsYWNlKFwiMHhcIiwgXCJcIikucGFkU3RhcnQoNjQsIFwiMFwiKTtcXG4gICAgcmV0dXJuIGdldE1ldGFkYXRhQXZhdGFyVXJpKHtcXG4gICAgICBnYXRld2F5VXJscyxcXG4gICAgICB1cmk6IHJlc29sdmVkTmZ0VXJpLnJlcGxhY2UoLyg/OjB4KT97aWR9LywgdXJpVG9rZW5JZClcXG4gICAgfSk7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL2Vucy9nZXRFbnNUZXh0LmpzXFxuICBpbml0X2FiaXMoKTtcXG4gIGluaXRfZGVjb2RlRnVuY3Rpb25SZXN1bHQoKTtcXG4gIGluaXRfZW5jb2RlRnVuY3Rpb25EYXRhKCk7XFxuICBpbml0X2dldENoYWluQ29udHJhY3RBZGRyZXNzKCk7XFxuICBpbml0X3RvSGV4KCk7XFxuICBpbml0X2xvY2FsQmF0Y2hHYXRld2F5UmVxdWVzdCgpO1xcbiAgYXN5bmMgZnVuY3Rpb24gZ2V0RW5zVGV4dChjbGllbnQsIHBhcmFtZXRlcnMpIHtcXG4gICAgY29uc3QgeyBibG9ja051bWJlciwgYmxvY2tUYWcsIGtleSwgbmFtZSwgZ2F0ZXdheVVybHMsIHN0cmljdCB9ID0gcGFyYW1ldGVycztcXG4gICAgY29uc3QgeyBjaGFpbiB9ID0gY2xpZW50O1xcbiAgICBjb25zdCB1bml2ZXJzYWxSZXNvbHZlckFkZHJlc3MgPSAoKCkgPT4ge1xcbiAgICAgIGlmIChwYXJhbWV0ZXJzLnVuaXZlcnNhbFJlc29sdmVyQWRkcmVzcylcXG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzLnVuaXZlcnNhbFJlc29sdmVyQWRkcmVzcztcXG4gICAgICBpZiAoIWNoYWluKVxcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2xpZW50IGNoYWluIG5vdCBjb25maWd1cmVkLiB1bml2ZXJzYWxSZXNvbHZlckFkZHJlc3MgaXMgcmVxdWlyZWQuXCIpO1xcbiAgICAgIHJldHVybiBnZXRDaGFpbkNvbnRyYWN0QWRkcmVzcyh7XFxuICAgICAgICBibG9ja051bWJlcixcXG4gICAgICAgIGNoYWluLFxcbiAgICAgICAgY29udHJhY3Q6IFwiZW5zVW5pdmVyc2FsUmVzb2x2ZXJcIlxcbiAgICAgIH0pO1xcbiAgICB9KSgpO1xcbiAgICBjb25zdCB0bGRzID0gY2hhaW4/LmVuc1RsZHM7XFxuICAgIGlmICh0bGRzICYmICF0bGRzLnNvbWUoKHRsZCkgPT4gbmFtZS5lbmRzV2l0aCh0bGQpKSlcXG4gICAgICByZXR1cm4gbnVsbDtcXG4gICAgdHJ5IHtcXG4gICAgICBjb25zdCByZWFkQ29udHJhY3RQYXJhbWV0ZXJzID0ge1xcbiAgICAgICAgYWRkcmVzczogdW5pdmVyc2FsUmVzb2x2ZXJBZGRyZXNzLFxcbiAgICAgICAgYWJpOiB1bml2ZXJzYWxSZXNvbHZlclJlc29sdmVBYmksXFxuICAgICAgICBmdW5jdGlvbk5hbWU6IFwicmVzb2x2ZVwiLFxcbiAgICAgICAgYXJnczogW1xcbiAgICAgICAgICB0b0hleChwYWNrZXRUb0J5dGVzKG5hbWUpKSxcXG4gICAgICAgICAgZW5jb2RlRnVuY3Rpb25EYXRhKHtcXG4gICAgICAgICAgICBhYmk6IHRleHRSZXNvbHZlckFiaSxcXG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6IFwidGV4dFwiLFxcbiAgICAgICAgICAgIGFyZ3M6IFtuYW1laGFzaChuYW1lKSwga2V5XVxcbiAgICAgICAgICB9KSxcXG4gICAgICAgICAgZ2F0ZXdheVVybHMgPz8gW2xvY2FsQmF0Y2hHYXRld2F5VXJsXVxcbiAgICAgICAgXSxcXG4gICAgICAgIGJsb2NrTnVtYmVyLFxcbiAgICAgICAgYmxvY2tUYWdcXG4gICAgICB9O1xcbiAgICAgIGNvbnN0IHJlYWRDb250cmFjdEFjdGlvbiA9IGdldEFjdGlvbihjbGllbnQsIHJlYWRDb250cmFjdCwgXCJyZWFkQ29udHJhY3RcIik7XFxuICAgICAgY29uc3QgcmVzID0gYXdhaXQgcmVhZENvbnRyYWN0QWN0aW9uKHJlYWRDb250cmFjdFBhcmFtZXRlcnMpO1xcbiAgICAgIGlmIChyZXNbMF0gPT09IFwiMHhcIilcXG4gICAgICAgIHJldHVybiBudWxsO1xcbiAgICAgIGNvbnN0IHJlY29yZCA9IGRlY29kZUZ1bmN0aW9uUmVzdWx0KHtcXG4gICAgICAgIGFiaTogdGV4dFJlc29sdmVyQWJpLFxcbiAgICAgICAgZnVuY3Rpb25OYW1lOiBcInRleHRcIixcXG4gICAgICAgIGRhdGE6IHJlc1swXVxcbiAgICAgIH0pO1xcbiAgICAgIHJldHVybiByZWNvcmQgPT09IFwiXCIgPyBudWxsIDogcmVjb3JkO1xcbiAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICBpZiAoc3RyaWN0KVxcbiAgICAgICAgdGhyb3cgZXJyO1xcbiAgICAgIGlmIChpc051bGxVbml2ZXJzYWxSZXNvbHZlckVycm9yKGVyciwgXCJyZXNvbHZlXCIpKVxcbiAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgdGhyb3cgZXJyO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL2Vucy9nZXRFbnNBdmF0YXIuanNcXG4gIGFzeW5jIGZ1bmN0aW9uIGdldEVuc0F2YXRhcihjbGllbnQsIHsgYmxvY2tOdW1iZXIsIGJsb2NrVGFnLCBhc3NldEdhdGV3YXlVcmxzLCBuYW1lLCBnYXRld2F5VXJscywgc3RyaWN0LCB1bml2ZXJzYWxSZXNvbHZlckFkZHJlc3MgfSkge1xcbiAgICBjb25zdCByZWNvcmQgPSBhd2FpdCBnZXRBY3Rpb24oY2xpZW50LCBnZXRFbnNUZXh0LCBcImdldEVuc1RleHRcIikoe1xcbiAgICAgIGJsb2NrTnVtYmVyLFxcbiAgICAgIGJsb2NrVGFnLFxcbiAgICAgIGtleTogXCJhdmF0YXJcIixcXG4gICAgICBuYW1lLFxcbiAgICAgIHVuaXZlcnNhbFJlc29sdmVyQWRkcmVzcyxcXG4gICAgICBnYXRld2F5VXJscyxcXG4gICAgICBzdHJpY3RcXG4gICAgfSk7XFxuICAgIGlmICghcmVjb3JkKVxcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICB0cnkge1xcbiAgICAgIHJldHVybiBhd2FpdCBwYXJzZUF2YXRhclJlY29yZChjbGllbnQsIHtcXG4gICAgICAgIHJlY29yZCxcXG4gICAgICAgIGdhdGV3YXlVcmxzOiBhc3NldEdhdGV3YXlVcmxzXFxuICAgICAgfSk7XFxuICAgIH0gY2F0Y2gge1xcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL2Vucy9nZXRFbnNOYW1lLmpzXFxuICBpbml0X2FiaXMoKTtcXG4gIGluaXRfZ2V0Q2hhaW5Db250cmFjdEFkZHJlc3MoKTtcXG4gIGluaXRfdG9IZXgoKTtcXG4gIGFzeW5jIGZ1bmN0aW9uIGdldEVuc05hbWUoY2xpZW50LCB7IGFkZHJlc3MsIGJsb2NrTnVtYmVyLCBibG9ja1RhZywgZ2F0ZXdheVVybHMsIHN0cmljdCwgdW5pdmVyc2FsUmVzb2x2ZXJBZGRyZXNzOiB1bml2ZXJzYWxSZXNvbHZlckFkZHJlc3NfIH0pIHtcXG4gICAgbGV0IHVuaXZlcnNhbFJlc29sdmVyQWRkcmVzcyA9IHVuaXZlcnNhbFJlc29sdmVyQWRkcmVzc187XFxuICAgIGlmICghdW5pdmVyc2FsUmVzb2x2ZXJBZGRyZXNzKSB7XFxuICAgICAgaWYgKCFjbGllbnQuY2hhaW4pXFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjbGllbnQgY2hhaW4gbm90IGNvbmZpZ3VyZWQuIHVuaXZlcnNhbFJlc29sdmVyQWRkcmVzcyBpcyByZXF1aXJlZC5cIik7XFxuICAgICAgdW5pdmVyc2FsUmVzb2x2ZXJBZGRyZXNzID0gZ2V0Q2hhaW5Db250cmFjdEFkZHJlc3Moe1xcbiAgICAgICAgYmxvY2tOdW1iZXIsXFxuICAgICAgICBjaGFpbjogY2xpZW50LmNoYWluLFxcbiAgICAgICAgY29udHJhY3Q6IFwiZW5zVW5pdmVyc2FsUmVzb2x2ZXJcIlxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIGNvbnN0IHJldmVyc2VOb2RlID0gYCR7YWRkcmVzcy50b0xvd2VyQ2FzZSgpLnN1YnN0cmluZygyKX0uYWRkci5yZXZlcnNlYDtcXG4gICAgdHJ5IHtcXG4gICAgICBjb25zdCByZWFkQ29udHJhY3RQYXJhbWV0ZXJzID0ge1xcbiAgICAgICAgYWRkcmVzczogdW5pdmVyc2FsUmVzb2x2ZXJBZGRyZXNzLFxcbiAgICAgICAgYWJpOiB1bml2ZXJzYWxSZXNvbHZlclJldmVyc2VBYmksXFxuICAgICAgICBmdW5jdGlvbk5hbWU6IFwicmV2ZXJzZVwiLFxcbiAgICAgICAgYXJnczogW3RvSGV4KHBhY2tldFRvQnl0ZXMocmV2ZXJzZU5vZGUpKV0sXFxuICAgICAgICBibG9ja051bWJlcixcXG4gICAgICAgIGJsb2NrVGFnXFxuICAgICAgfTtcXG4gICAgICBjb25zdCByZWFkQ29udHJhY3RBY3Rpb24gPSBnZXRBY3Rpb24oY2xpZW50LCByZWFkQ29udHJhY3QsIFwicmVhZENvbnRyYWN0XCIpO1xcbiAgICAgIGNvbnN0IFtuYW1lLCByZXNvbHZlZEFkZHJlc3NdID0gZ2F0ZXdheVVybHMgPyBhd2FpdCByZWFkQ29udHJhY3RBY3Rpb24oe1xcbiAgICAgICAgLi4ucmVhZENvbnRyYWN0UGFyYW1ldGVycyxcXG4gICAgICAgIGFyZ3M6IFsuLi5yZWFkQ29udHJhY3RQYXJhbWV0ZXJzLmFyZ3MsIGdhdGV3YXlVcmxzXVxcbiAgICAgIH0pIDogYXdhaXQgcmVhZENvbnRyYWN0QWN0aW9uKHJlYWRDb250cmFjdFBhcmFtZXRlcnMpO1xcbiAgICAgIGlmIChhZGRyZXNzLnRvTG93ZXJDYXNlKCkgIT09IHJlc29sdmVkQWRkcmVzcy50b0xvd2VyQ2FzZSgpKVxcbiAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgcmV0dXJuIG5hbWU7XFxuICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgIGlmIChzdHJpY3QpXFxuICAgICAgICB0aHJvdyBlcnI7XFxuICAgICAgaWYgKGlzTnVsbFVuaXZlcnNhbFJlc29sdmVyRXJyb3IoZXJyLCBcInJldmVyc2VcIikpXFxuICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICB0aHJvdyBlcnI7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjdGlvbnMvZW5zL2dldEVuc1Jlc29sdmVyLmpzXFxuICBpbml0X2dldENoYWluQ29udHJhY3RBZGRyZXNzKCk7XFxuICBpbml0X3RvSGV4KCk7XFxuICBhc3luYyBmdW5jdGlvbiBnZXRFbnNSZXNvbHZlcihjbGllbnQsIHBhcmFtZXRlcnMpIHtcXG4gICAgY29uc3QgeyBibG9ja051bWJlciwgYmxvY2tUYWcsIG5hbWUgfSA9IHBhcmFtZXRlcnM7XFxuICAgIGNvbnN0IHsgY2hhaW4gfSA9IGNsaWVudDtcXG4gICAgY29uc3QgdW5pdmVyc2FsUmVzb2x2ZXJBZGRyZXNzID0gKCgpID0+IHtcXG4gICAgICBpZiAocGFyYW1ldGVycy51bml2ZXJzYWxSZXNvbHZlckFkZHJlc3MpXFxuICAgICAgICByZXR1cm4gcGFyYW1ldGVycy51bml2ZXJzYWxSZXNvbHZlckFkZHJlc3M7XFxuICAgICAgaWYgKCFjaGFpbilcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNsaWVudCBjaGFpbiBub3QgY29uZmlndXJlZC4gdW5pdmVyc2FsUmVzb2x2ZXJBZGRyZXNzIGlzIHJlcXVpcmVkLlwiKTtcXG4gICAgICByZXR1cm4gZ2V0Q2hhaW5Db250cmFjdEFkZHJlc3Moe1xcbiAgICAgICAgYmxvY2tOdW1iZXIsXFxuICAgICAgICBjaGFpbixcXG4gICAgICAgIGNvbnRyYWN0OiBcImVuc1VuaXZlcnNhbFJlc29sdmVyXCJcXG4gICAgICB9KTtcXG4gICAgfSkoKTtcXG4gICAgY29uc3QgdGxkcyA9IGNoYWluPy5lbnNUbGRzO1xcbiAgICBpZiAodGxkcyAmJiAhdGxkcy5zb21lKCh0bGQpID0+IG5hbWUuZW5kc1dpdGgodGxkKSkpXFxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke25hbWV9IGlzIG5vdCBhIHZhbGlkIEVOUyBUTEQgKCR7dGxkcz8uam9pbihcIiwgXCIpfSkgZm9yIGNoYWluIFwiJHtjaGFpbi5uYW1lfVwiIChpZDogJHtjaGFpbi5pZH0pLmApO1xcbiAgICBjb25zdCBbcmVzb2x2ZXJBZGRyZXNzXSA9IGF3YWl0IGdldEFjdGlvbihjbGllbnQsIHJlYWRDb250cmFjdCwgXCJyZWFkQ29udHJhY3RcIikoe1xcbiAgICAgIGFkZHJlc3M6IHVuaXZlcnNhbFJlc29sdmVyQWRkcmVzcyxcXG4gICAgICBhYmk6IFtcXG4gICAgICAgIHtcXG4gICAgICAgICAgaW5wdXRzOiBbeyB0eXBlOiBcImJ5dGVzXCIgfV0sXFxuICAgICAgICAgIG5hbWU6IFwiZmluZFJlc29sdmVyXCIsXFxuICAgICAgICAgIG91dHB1dHM6IFt7IHR5cGU6IFwiYWRkcmVzc1wiIH0sIHsgdHlwZTogXCJieXRlczMyXCIgfV0sXFxuICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXFxuICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxcbiAgICAgICAgfVxcbiAgICAgIF0sXFxuICAgICAgZnVuY3Rpb25OYW1lOiBcImZpbmRSZXNvbHZlclwiLFxcbiAgICAgIGFyZ3M6IFt0b0hleChwYWNrZXRUb0J5dGVzKG5hbWUpKV0sXFxuICAgICAgYmxvY2tOdW1iZXIsXFxuICAgICAgYmxvY2tUYWdcXG4gICAgfSk7XFxuICAgIHJldHVybiByZXNvbHZlckFkZHJlc3M7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9jbGllbnRzL2RlY29yYXRvcnMvcHVibGljLmpzXFxuICBpbml0X2NhbGwoKTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjdGlvbnMvcHVibGljL2NyZWF0ZUFjY2Vzc0xpc3QuanNcXG4gIGluaXRfcGFyc2VBY2NvdW50KCk7XFxuICBpbml0X3RvSGV4KCk7XFxuICBpbml0X2dldENhbGxFcnJvcigpO1xcbiAgaW5pdF9leHRyYWN0KCk7XFxuICBpbml0X3RyYW5zYWN0aW9uUmVxdWVzdCgpO1xcbiAgaW5pdF9hc3NlcnRSZXF1ZXN0KCk7XFxuICBhc3luYyBmdW5jdGlvbiBjcmVhdGVBY2Nlc3NMaXN0KGNsaWVudCwgYXJncykge1xcbiAgICBjb25zdCB7IGFjY291bnQ6IGFjY291bnRfID0gY2xpZW50LmFjY291bnQsIGJsb2NrTnVtYmVyLCBibG9ja1RhZyA9IFwibGF0ZXN0XCIsIGJsb2JzLCBkYXRhLCBnYXMsIGdhc1ByaWNlLCBtYXhGZWVQZXJCbG9iR2FzLCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzLCB0bywgdmFsdWUsIC4uLnJlc3QgfSA9IGFyZ3M7XFxuICAgIGNvbnN0IGFjY291bnQgPSBhY2NvdW50XyA/IHBhcnNlQWNjb3VudChhY2NvdW50XykgOiB2b2lkIDA7XFxuICAgIHRyeSB7XFxuICAgICAgYXNzZXJ0UmVxdWVzdChhcmdzKTtcXG4gICAgICBjb25zdCBibG9ja051bWJlckhleCA9IGJsb2NrTnVtYmVyID8gbnVtYmVyVG9IZXgoYmxvY2tOdW1iZXIpIDogdm9pZCAwO1xcbiAgICAgIGNvbnN0IGJsb2NrID0gYmxvY2tOdW1iZXJIZXggfHwgYmxvY2tUYWc7XFxuICAgICAgY29uc3QgY2hhaW5Gb3JtYXQgPSBjbGllbnQuY2hhaW4/LmZvcm1hdHRlcnM/LnRyYW5zYWN0aW9uUmVxdWVzdD8uZm9ybWF0O1xcbiAgICAgIGNvbnN0IGZvcm1hdCA9IGNoYWluRm9ybWF0IHx8IGZvcm1hdFRyYW5zYWN0aW9uUmVxdWVzdDtcXG4gICAgICBjb25zdCByZXF1ZXN0ID0gZm9ybWF0KHtcXG4gICAgICAgIC8vIFBpY2sgb3V0IGV4dHJhIGRhdGEgdGhhdCBtaWdodCBleGlzdCBvbiB0aGUgY2hhaW5cXCdzIHRyYW5zYWN0aW9uIHJlcXVlc3QgdHlwZS5cXG4gICAgICAgIC4uLmV4dHJhY3QocmVzdCwgeyBmb3JtYXQ6IGNoYWluRm9ybWF0IH0pLFxcbiAgICAgICAgZnJvbTogYWNjb3VudD8uYWRkcmVzcyxcXG4gICAgICAgIGJsb2JzLFxcbiAgICAgICAgZGF0YSxcXG4gICAgICAgIGdhcyxcXG4gICAgICAgIGdhc1ByaWNlLFxcbiAgICAgICAgbWF4RmVlUGVyQmxvYkdhcyxcXG4gICAgICAgIG1heEZlZVBlckdhcyxcXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzLFxcbiAgICAgICAgdG8sXFxuICAgICAgICB2YWx1ZVxcbiAgICAgIH0pO1xcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2xpZW50LnJlcXVlc3Qoe1xcbiAgICAgICAgbWV0aG9kOiBcImV0aF9jcmVhdGVBY2Nlc3NMaXN0XCIsXFxuICAgICAgICBwYXJhbXM6IFtyZXF1ZXN0LCBibG9ja11cXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgYWNjZXNzTGlzdDogcmVzcG9uc2UuYWNjZXNzTGlzdCxcXG4gICAgICAgIGdhc1VzZWQ6IEJpZ0ludChyZXNwb25zZS5nYXNVc2VkKVxcbiAgICAgIH07XFxuICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgIHRocm93IGdldENhbGxFcnJvcihlcnIsIHtcXG4gICAgICAgIC4uLmFyZ3MsXFxuICAgICAgICBhY2NvdW50LFxcbiAgICAgICAgY2hhaW46IGNsaWVudC5jaGFpblxcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL3B1YmxpYy9jcmVhdGVCbG9ja0ZpbHRlci5qc1xcbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQmxvY2tGaWx0ZXIoY2xpZW50KSB7XFxuICAgIGNvbnN0IGdldFJlcXVlc3QgPSBjcmVhdGVGaWx0ZXJSZXF1ZXN0U2NvcGUoY2xpZW50LCB7XFxuICAgICAgbWV0aG9kOiBcImV0aF9uZXdCbG9ja0ZpbHRlclwiXFxuICAgIH0pO1xcbiAgICBjb25zdCBpZCA9IGF3YWl0IGNsaWVudC5yZXF1ZXN0KHtcXG4gICAgICBtZXRob2Q6IFwiZXRoX25ld0Jsb2NrRmlsdGVyXCJcXG4gICAgfSk7XFxuICAgIHJldHVybiB7IGlkLCByZXF1ZXN0OiBnZXRSZXF1ZXN0KGlkKSwgdHlwZTogXCJibG9ja1wiIH07XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL3B1YmxpYy9jcmVhdGVFdmVudEZpbHRlci5qc1xcbiAgaW5pdF90b0hleCgpO1xcbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlRXZlbnRGaWx0ZXIoY2xpZW50LCB7IGFkZHJlc3MsIGFyZ3MsIGV2ZW50LCBldmVudHM6IGV2ZW50c18sIGZyb21CbG9jaywgc3RyaWN0LCB0b0Jsb2NrIH0gPSB7fSkge1xcbiAgICBjb25zdCBldmVudHMgPSBldmVudHNfID8/IChldmVudCA/IFtldmVudF0gOiB2b2lkIDApO1xcbiAgICBjb25zdCBnZXRSZXF1ZXN0ID0gY3JlYXRlRmlsdGVyUmVxdWVzdFNjb3BlKGNsaWVudCwge1xcbiAgICAgIG1ldGhvZDogXCJldGhfbmV3RmlsdGVyXCJcXG4gICAgfSk7XFxuICAgIGxldCB0b3BpY3MgPSBbXTtcXG4gICAgaWYgKGV2ZW50cykge1xcbiAgICAgIGNvbnN0IGVuY29kZWQgPSBldmVudHMuZmxhdE1hcCgoZXZlbnQyKSA9PiBlbmNvZGVFdmVudFRvcGljcyh7XFxuICAgICAgICBhYmk6IFtldmVudDJdLFxcbiAgICAgICAgZXZlbnROYW1lOiBldmVudDIubmFtZSxcXG4gICAgICAgIGFyZ3NcXG4gICAgICB9KSk7XFxuICAgICAgdG9waWNzID0gW2VuY29kZWRdO1xcbiAgICAgIGlmIChldmVudClcXG4gICAgICAgIHRvcGljcyA9IHRvcGljc1swXTtcXG4gICAgfVxcbiAgICBjb25zdCBpZCA9IGF3YWl0IGNsaWVudC5yZXF1ZXN0KHtcXG4gICAgICBtZXRob2Q6IFwiZXRoX25ld0ZpbHRlclwiLFxcbiAgICAgIHBhcmFtczogW1xcbiAgICAgICAge1xcbiAgICAgICAgICBhZGRyZXNzLFxcbiAgICAgICAgICBmcm9tQmxvY2s6IHR5cGVvZiBmcm9tQmxvY2sgPT09IFwiYmlnaW50XCIgPyBudW1iZXJUb0hleChmcm9tQmxvY2spIDogZnJvbUJsb2NrLFxcbiAgICAgICAgICB0b0Jsb2NrOiB0eXBlb2YgdG9CbG9jayA9PT0gXCJiaWdpbnRcIiA/IG51bWJlclRvSGV4KHRvQmxvY2spIDogdG9CbG9jayxcXG4gICAgICAgICAgLi4udG9waWNzLmxlbmd0aCA/IHsgdG9waWNzIH0gOiB7fVxcbiAgICAgICAgfVxcbiAgICAgIF1cXG4gICAgfSk7XFxuICAgIHJldHVybiB7XFxuICAgICAgYWJpOiBldmVudHMsXFxuICAgICAgYXJncyxcXG4gICAgICBldmVudE5hbWU6IGV2ZW50ID8gZXZlbnQubmFtZSA6IHZvaWQgMCxcXG4gICAgICBmcm9tQmxvY2ssXFxuICAgICAgaWQsXFxuICAgICAgcmVxdWVzdDogZ2V0UmVxdWVzdChpZCksXFxuICAgICAgc3RyaWN0OiBCb29sZWFuKHN0cmljdCksXFxuICAgICAgdG9CbG9jayxcXG4gICAgICB0eXBlOiBcImV2ZW50XCJcXG4gICAgfTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjdGlvbnMvcHVibGljL2NyZWF0ZVBlbmRpbmdUcmFuc2FjdGlvbkZpbHRlci5qc1xcbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlUGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyKGNsaWVudCkge1xcbiAgICBjb25zdCBnZXRSZXF1ZXN0ID0gY3JlYXRlRmlsdGVyUmVxdWVzdFNjb3BlKGNsaWVudCwge1xcbiAgICAgIG1ldGhvZDogXCJldGhfbmV3UGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyXCJcXG4gICAgfSk7XFxuICAgIGNvbnN0IGlkID0gYXdhaXQgY2xpZW50LnJlcXVlc3Qoe1xcbiAgICAgIG1ldGhvZDogXCJldGhfbmV3UGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyXCJcXG4gICAgfSk7XFxuICAgIHJldHVybiB7IGlkLCByZXF1ZXN0OiBnZXRSZXF1ZXN0KGlkKSwgdHlwZTogXCJ0cmFuc2FjdGlvblwiIH07XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL3B1YmxpYy9nZXRCbG9iQmFzZUZlZS5qc1xcbiAgYXN5bmMgZnVuY3Rpb24gZ2V0QmxvYkJhc2VGZWUoY2xpZW50KSB7XFxuICAgIGNvbnN0IGJhc2VGZWUgPSBhd2FpdCBjbGllbnQucmVxdWVzdCh7XFxuICAgICAgbWV0aG9kOiBcImV0aF9ibG9iQmFzZUZlZVwiXFxuICAgIH0pO1xcbiAgICByZXR1cm4gQmlnSW50KGJhc2VGZWUpO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vYWN0aW9ucy9wdWJsaWMvZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50LmpzXFxuICBpbml0X2Zyb21IZXgoKTtcXG4gIGluaXRfdG9IZXgoKTtcXG4gIGFzeW5jIGZ1bmN0aW9uIGdldEJsb2NrVHJhbnNhY3Rpb25Db3VudChjbGllbnQsIHsgYmxvY2tIYXNoLCBibG9ja051bWJlciwgYmxvY2tUYWcgPSBcImxhdGVzdFwiIH0gPSB7fSkge1xcbiAgICBjb25zdCBibG9ja051bWJlckhleCA9IGJsb2NrTnVtYmVyICE9PSB2b2lkIDAgPyBudW1iZXJUb0hleChibG9ja051bWJlcikgOiB2b2lkIDA7XFxuICAgIGxldCBjb3VudDtcXG4gICAgaWYgKGJsb2NrSGFzaCkge1xcbiAgICAgIGNvdW50ID0gYXdhaXQgY2xpZW50LnJlcXVlc3Qoe1xcbiAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRCbG9ja1RyYW5zYWN0aW9uQ291bnRCeUhhc2hcIixcXG4gICAgICAgIHBhcmFtczogW2Jsb2NrSGFzaF1cXG4gICAgICB9LCB7IGRlZHVwZTogdHJ1ZSB9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBjb3VudCA9IGF3YWl0IGNsaWVudC5yZXF1ZXN0KHtcXG4gICAgICAgIG1ldGhvZDogXCJldGhfZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50QnlOdW1iZXJcIixcXG4gICAgICAgIHBhcmFtczogW2Jsb2NrTnVtYmVySGV4IHx8IGJsb2NrVGFnXVxcbiAgICAgIH0sIHsgZGVkdXBlOiBCb29sZWFuKGJsb2NrTnVtYmVySGV4KSB9KTtcXG4gICAgfVxcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoY291bnQpO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vYWN0aW9ucy9wdWJsaWMvZ2V0Q29kZS5qc1xcbiAgaW5pdF90b0hleCgpO1xcbiAgYXN5bmMgZnVuY3Rpb24gZ2V0Q29kZShjbGllbnQsIHsgYWRkcmVzcywgYmxvY2tOdW1iZXIsIGJsb2NrVGFnID0gXCJsYXRlc3RcIiB9KSB7XFxuICAgIGNvbnN0IGJsb2NrTnVtYmVySGV4ID0gYmxvY2tOdW1iZXIgIT09IHZvaWQgMCA/IG51bWJlclRvSGV4KGJsb2NrTnVtYmVyKSA6IHZvaWQgMDtcXG4gICAgY29uc3QgaGV4ID0gYXdhaXQgY2xpZW50LnJlcXVlc3Qoe1xcbiAgICAgIG1ldGhvZDogXCJldGhfZ2V0Q29kZVwiLFxcbiAgICAgIHBhcmFtczogW2FkZHJlc3MsIGJsb2NrTnVtYmVySGV4IHx8IGJsb2NrVGFnXVxcbiAgICB9LCB7IGRlZHVwZTogQm9vbGVhbihibG9ja051bWJlckhleCkgfSk7XFxuICAgIGlmIChoZXggPT09IFwiMHhcIilcXG4gICAgICByZXR1cm4gdm9pZCAwO1xcbiAgICByZXR1cm4gaGV4O1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vZXJyb3JzL2VpcDcxMi5qc1xcbiAgaW5pdF9iYXNlKCk7XFxuICB2YXIgRWlwNzEyRG9tYWluTm90Rm91bmRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgIGNvbnN0cnVjdG9yKHsgYWRkcmVzcyB9KSB7XFxuICAgICAgc3VwZXIoYE5vIEVJUC03MTIgZG9tYWluIGZvdW5kIG9uIGNvbnRyYWN0IFwiJHthZGRyZXNzfVwiLmAsIHtcXG4gICAgICAgIG1ldGFNZXNzYWdlczogW1xcbiAgICAgICAgICBcIkVuc3VyZSB0aGF0OlwiLFxcbiAgICAgICAgICBgLSBUaGUgY29udHJhY3QgaXMgZGVwbG95ZWQgYXQgdGhlIGFkZHJlc3MgXCIke2FkZHJlc3N9XCIuYCxcXG4gICAgICAgICAgXCItIGBlaXA3MTJEb21haW4oKWAgZnVuY3Rpb24gZXhpc3RzIG9uIHRoZSBjb250cmFjdC5cIixcXG4gICAgICAgICAgXCItIGBlaXA3MTJEb21haW4oKWAgZnVuY3Rpb24gbWF0Y2hlcyBzaWduYXR1cmUgdG8gRVJDLTUyNjcgc3BlY2lmaWNhdGlvbi5cIlxcbiAgICAgICAgXSxcXG4gICAgICAgIG5hbWU6IFwiRWlwNzEyRG9tYWluTm90Rm91bmRFcnJvclwiXFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH07XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL3B1YmxpYy9nZXRFaXA3MTJEb21haW4uanNcXG4gIGFzeW5jIGZ1bmN0aW9uIGdldEVpcDcxMkRvbWFpbihjbGllbnQsIHBhcmFtZXRlcnMpIHtcXG4gICAgY29uc3QgeyBhZGRyZXNzLCBmYWN0b3J5LCBmYWN0b3J5RGF0YSB9ID0gcGFyYW1ldGVycztcXG4gICAgdHJ5IHtcXG4gICAgICBjb25zdCBbZmllbGRzLCBuYW1lLCB2ZXJzaW9uNCwgY2hhaW5JZCwgdmVyaWZ5aW5nQ29udHJhY3QsIHNhbHQsIGV4dGVuc2lvbnNdID0gYXdhaXQgZ2V0QWN0aW9uKGNsaWVudCwgcmVhZENvbnRyYWN0LCBcInJlYWRDb250cmFjdFwiKSh7XFxuICAgICAgICBhYmksXFxuICAgICAgICBhZGRyZXNzLFxcbiAgICAgICAgZnVuY3Rpb25OYW1lOiBcImVpcDcxMkRvbWFpblwiLFxcbiAgICAgICAgZmFjdG9yeSxcXG4gICAgICAgIGZhY3RvcnlEYXRhXFxuICAgICAgfSk7XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIGRvbWFpbjoge1xcbiAgICAgICAgICBuYW1lLFxcbiAgICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uNCxcXG4gICAgICAgICAgY2hhaW5JZDogTnVtYmVyKGNoYWluSWQpLFxcbiAgICAgICAgICB2ZXJpZnlpbmdDb250cmFjdCxcXG4gICAgICAgICAgc2FsdFxcbiAgICAgICAgfSxcXG4gICAgICAgIGV4dGVuc2lvbnMsXFxuICAgICAgICBmaWVsZHNcXG4gICAgICB9O1xcbiAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgY29uc3QgZXJyb3IgPSBlO1xcbiAgICAgIGlmIChlcnJvci5uYW1lID09PSBcIkNvbnRyYWN0RnVuY3Rpb25FeGVjdXRpb25FcnJvclwiICYmIGVycm9yLmNhdXNlLm5hbWUgPT09IFwiQ29udHJhY3RGdW5jdGlvblplcm9EYXRhRXJyb3JcIikge1xcbiAgICAgICAgdGhyb3cgbmV3IEVpcDcxMkRvbWFpbk5vdEZvdW5kRXJyb3IoeyBhZGRyZXNzIH0pO1xcbiAgICAgIH1cXG4gICAgICB0aHJvdyBlcnJvcjtcXG4gICAgfVxcbiAgfVxcbiAgdmFyIGFiaSA9IFtcXG4gICAge1xcbiAgICAgIGlucHV0czogW10sXFxuICAgICAgbmFtZTogXCJlaXA3MTJEb21haW5cIixcXG4gICAgICBvdXRwdXRzOiBbXFxuICAgICAgICB7IG5hbWU6IFwiZmllbGRzXCIsIHR5cGU6IFwiYnl0ZXMxXCIgfSxcXG4gICAgICAgIHsgbmFtZTogXCJuYW1lXCIsIHR5cGU6IFwic3RyaW5nXCIgfSxcXG4gICAgICAgIHsgbmFtZTogXCJ2ZXJzaW9uXCIsIHR5cGU6IFwic3RyaW5nXCIgfSxcXG4gICAgICAgIHsgbmFtZTogXCJjaGFpbklkXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXFxuICAgICAgICB7IG5hbWU6IFwidmVyaWZ5aW5nQ29udHJhY3RcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcXG4gICAgICAgIHsgbmFtZTogXCJzYWx0XCIsIHR5cGU6IFwiYnl0ZXMzMlwiIH0sXFxuICAgICAgICB7IG5hbWU6IFwiZXh0ZW5zaW9uc1wiLCB0eXBlOiBcInVpbnQyNTZbXVwiIH1cXG4gICAgICBdLFxcbiAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXFxuICAgICAgdHlwZTogXCJmdW5jdGlvblwiXFxuICAgIH1cXG4gIF07XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL3B1YmxpYy9nZXRGZWVIaXN0b3J5LmpzXFxuICBpbml0X3RvSGV4KCk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9mb3JtYXR0ZXJzL2ZlZUhpc3RvcnkuanNcXG4gIGZ1bmN0aW9uIGZvcm1hdEZlZUhpc3RvcnkoZmVlSGlzdG9yeSkge1xcbiAgICByZXR1cm4ge1xcbiAgICAgIGJhc2VGZWVQZXJHYXM6IGZlZUhpc3RvcnkuYmFzZUZlZVBlckdhcy5tYXAoKHZhbHVlKSA9PiBCaWdJbnQodmFsdWUpKSxcXG4gICAgICBnYXNVc2VkUmF0aW86IGZlZUhpc3RvcnkuZ2FzVXNlZFJhdGlvLFxcbiAgICAgIG9sZGVzdEJsb2NrOiBCaWdJbnQoZmVlSGlzdG9yeS5vbGRlc3RCbG9jayksXFxuICAgICAgcmV3YXJkOiBmZWVIaXN0b3J5LnJld2FyZD8ubWFwKChyZXdhcmQpID0+IHJld2FyZC5tYXAoKHZhbHVlKSA9PiBCaWdJbnQodmFsdWUpKSlcXG4gICAgfTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjdGlvbnMvcHVibGljL2dldEZlZUhpc3RvcnkuanNcXG4gIGFzeW5jIGZ1bmN0aW9uIGdldEZlZUhpc3RvcnkoY2xpZW50LCB7IGJsb2NrQ291bnQsIGJsb2NrTnVtYmVyLCBibG9ja1RhZyA9IFwibGF0ZXN0XCIsIHJld2FyZFBlcmNlbnRpbGVzIH0pIHtcXG4gICAgY29uc3QgYmxvY2tOdW1iZXJIZXggPSBibG9ja051bWJlciA/IG51bWJlclRvSGV4KGJsb2NrTnVtYmVyKSA6IHZvaWQgMDtcXG4gICAgY29uc3QgZmVlSGlzdG9yeSA9IGF3YWl0IGNsaWVudC5yZXF1ZXN0KHtcXG4gICAgICBtZXRob2Q6IFwiZXRoX2ZlZUhpc3RvcnlcIixcXG4gICAgICBwYXJhbXM6IFtcXG4gICAgICAgIG51bWJlclRvSGV4KGJsb2NrQ291bnQpLFxcbiAgICAgICAgYmxvY2tOdW1iZXJIZXggfHwgYmxvY2tUYWcsXFxuICAgICAgICByZXdhcmRQZXJjZW50aWxlc1xcbiAgICAgIF1cXG4gICAgfSwgeyBkZWR1cGU6IEJvb2xlYW4oYmxvY2tOdW1iZXJIZXgpIH0pO1xcbiAgICByZXR1cm4gZm9ybWF0RmVlSGlzdG9yeShmZWVIaXN0b3J5KTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjdGlvbnMvcHVibGljL2dldEZpbHRlckxvZ3MuanNcXG4gIGFzeW5jIGZ1bmN0aW9uIGdldEZpbHRlckxvZ3MoX2NsaWVudCwgeyBmaWx0ZXIgfSkge1xcbiAgICBjb25zdCBzdHJpY3QgPSBmaWx0ZXIuc3RyaWN0ID8/IGZhbHNlO1xcbiAgICBjb25zdCBsb2dzID0gYXdhaXQgZmlsdGVyLnJlcXVlc3Qoe1xcbiAgICAgIG1ldGhvZDogXCJldGhfZ2V0RmlsdGVyTG9nc1wiLFxcbiAgICAgIHBhcmFtczogW2ZpbHRlci5pZF1cXG4gICAgfSk7XFxuICAgIGNvbnN0IGZvcm1hdHRlZExvZ3MgPSBsb2dzLm1hcCgobG9nKSA9PiBmb3JtYXRMb2cobG9nKSk7XFxuICAgIGlmICghZmlsdGVyLmFiaSlcXG4gICAgICByZXR1cm4gZm9ybWF0dGVkTG9ncztcXG4gICAgcmV0dXJuIHBhcnNlRXZlbnRMb2dzKHtcXG4gICAgICBhYmk6IGZpbHRlci5hYmksXFxuICAgICAgbG9nczogZm9ybWF0dGVkTG9ncyxcXG4gICAgICBzdHJpY3RcXG4gICAgfSk7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL3B1YmxpYy9nZXRQcm9vZi5qc1xcbiAgaW5pdF90b0hleCgpO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvY2hhaW4vZGVmaW5lQ2hhaW4uanNcXG4gIGZ1bmN0aW9uIGRlZmluZUNoYWluKGNoYWluKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgZm9ybWF0dGVyczogdm9pZCAwLFxcbiAgICAgIGZlZXM6IHZvaWQgMCxcXG4gICAgICBzZXJpYWxpemVyczogdm9pZCAwLFxcbiAgICAgIC4uLmNoYWluXFxuICAgIH07XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy90eXBlZERhdGEuanNcXG4gIGluaXRfYWJpKCk7XFxuICBpbml0X2FkZHJlc3MoKTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2Vycm9ycy90eXBlZERhdGEuanNcXG4gIGluaXRfc3RyaW5naWZ5KCk7XFxuICBpbml0X2Jhc2UoKTtcXG4gIHZhciBJbnZhbGlkRG9tYWluRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjIge1xcbiAgICBjb25zdHJ1Y3Rvcih7IGRvbWFpbiB9KSB7XFxuICAgICAgc3VwZXIoYEludmFsaWQgZG9tYWluIFwiJHtzdHJpbmdpZnkoZG9tYWluKX1cIi5gLCB7XFxuICAgICAgICBtZXRhTWVzc2FnZXM6IFtcIk11c3QgYmUgYSB2YWxpZCBFSVAtNzEyIGRvbWFpbi5cIl1cXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfTtcXG4gIHZhciBJbnZhbGlkUHJpbWFyeVR5cGVFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMiB7XFxuICAgIGNvbnN0cnVjdG9yKHsgcHJpbWFyeVR5cGUsIHR5cGVzIH0pIHtcXG4gICAgICBzdXBlcihgSW52YWxpZCBwcmltYXJ5IHR5cGUgXFxcXGAke3ByaW1hcnlUeXBlfVxcXFxgIG11c3QgYmUgb25lIG9mIFxcXFxgJHtKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyh0eXBlcykpfVxcXFxgLmAsIHtcXG4gICAgICAgIGRvY3NQYXRoOiBcIi9hcGkvZ2xvc3NhcnkvRXJyb3JzI3R5cGVkZGF0YWludmFsaWRwcmltYXJ5dHlwZWVycm9yXCIsXFxuICAgICAgICBtZXRhTWVzc2FnZXM6IFtcIkNoZWNrIHRoYXQgdGhlIHByaW1hcnkgdHlwZSBpcyBhIGtleSBpbiBgdHlwZXNgLlwiXVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9O1xcbiAgdmFyIEludmFsaWRTdHJ1Y3RUeXBlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjIge1xcbiAgICBjb25zdHJ1Y3Rvcih7IHR5cGUgfSkge1xcbiAgICAgIHN1cGVyKGBTdHJ1Y3QgdHlwZSBcIiR7dHlwZX1cIiBpcyBpbnZhbGlkLmAsIHtcXG4gICAgICAgIG1ldGFNZXNzYWdlczogW1wiU3RydWN0IHR5cGUgbXVzdCBub3QgYmUgYSBTb2xpZGl0eSB0eXBlLlwiXSxcXG4gICAgICAgIG5hbWU6IFwiSW52YWxpZFN0cnVjdFR5cGVFcnJvclwiXFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH07XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy90eXBlZERhdGEuanNcXG4gIGluaXRfaXNBZGRyZXNzKCk7XFxuICBpbml0X3NpemUoKTtcXG4gIGluaXRfdG9IZXgoKTtcXG4gIGluaXRfcmVnZXgyKCk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9zaWduYXR1cmUvaGFzaFR5cGVkRGF0YS5qc1xcbiAgaW5pdF9lbmNvZGVBYmlQYXJhbWV0ZXJzKCk7XFxuICBpbml0X2NvbmNhdCgpO1xcbiAgaW5pdF90b0hleCgpO1xcbiAgaW5pdF9rZWNjYWsyNTYoKTtcXG4gIGZ1bmN0aW9uIGhhc2hUeXBlZERhdGEocGFyYW1ldGVycykge1xcbiAgICBjb25zdCB7IGRvbWFpbiA9IHt9LCBtZXNzYWdlLCBwcmltYXJ5VHlwZSB9ID0gcGFyYW1ldGVycztcXG4gICAgY29uc3QgdHlwZXMgPSB7XFxuICAgICAgRUlQNzEyRG9tYWluOiBnZXRUeXBlc0ZvckVJUDcxMkRvbWFpbih7IGRvbWFpbiB9KSxcXG4gICAgICAuLi5wYXJhbWV0ZXJzLnR5cGVzXFxuICAgIH07XFxuICAgIHZhbGlkYXRlVHlwZWREYXRhKHtcXG4gICAgICBkb21haW4sXFxuICAgICAgbWVzc2FnZSxcXG4gICAgICBwcmltYXJ5VHlwZSxcXG4gICAgICB0eXBlc1xcbiAgICB9KTtcXG4gICAgY29uc3QgcGFydHMgPSBbXCIweDE5MDFcIl07XFxuICAgIGlmIChkb21haW4pXFxuICAgICAgcGFydHMucHVzaChoYXNoRG9tYWluKHtcXG4gICAgICAgIGRvbWFpbixcXG4gICAgICAgIHR5cGVzXFxuICAgICAgfSkpO1xcbiAgICBpZiAocHJpbWFyeVR5cGUgIT09IFwiRUlQNzEyRG9tYWluXCIpXFxuICAgICAgcGFydHMucHVzaChoYXNoU3RydWN0KHtcXG4gICAgICAgIGRhdGE6IG1lc3NhZ2UsXFxuICAgICAgICBwcmltYXJ5VHlwZSxcXG4gICAgICAgIHR5cGVzXFxuICAgICAgfSkpO1xcbiAgICByZXR1cm4ga2VjY2FrMjU2KGNvbmNhdChwYXJ0cykpO1xcbiAgfVxcbiAgZnVuY3Rpb24gaGFzaERvbWFpbih7IGRvbWFpbiwgdHlwZXMgfSkge1xcbiAgICByZXR1cm4gaGFzaFN0cnVjdCh7XFxuICAgICAgZGF0YTogZG9tYWluLFxcbiAgICAgIHByaW1hcnlUeXBlOiBcIkVJUDcxMkRvbWFpblwiLFxcbiAgICAgIHR5cGVzXFxuICAgIH0pO1xcbiAgfVxcbiAgZnVuY3Rpb24gaGFzaFN0cnVjdCh7IGRhdGEsIHByaW1hcnlUeXBlLCB0eXBlcyB9KSB7XFxuICAgIGNvbnN0IGVuY29kZWQgPSBlbmNvZGVEYXRhKHtcXG4gICAgICBkYXRhLFxcbiAgICAgIHByaW1hcnlUeXBlLFxcbiAgICAgIHR5cGVzXFxuICAgIH0pO1xcbiAgICByZXR1cm4ga2VjY2FrMjU2KGVuY29kZWQpO1xcbiAgfVxcbiAgZnVuY3Rpb24gZW5jb2RlRGF0YSh7IGRhdGEsIHByaW1hcnlUeXBlLCB0eXBlcyB9KSB7XFxuICAgIGNvbnN0IGVuY29kZWRUeXBlcyA9IFt7IHR5cGU6IFwiYnl0ZXMzMlwiIH1dO1xcbiAgICBjb25zdCBlbmNvZGVkVmFsdWVzID0gW2hhc2hUeXBlKHsgcHJpbWFyeVR5cGUsIHR5cGVzIH0pXTtcXG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlc1twcmltYXJ5VHlwZV0pIHtcXG4gICAgICBjb25zdCBbdHlwZSwgdmFsdWVdID0gZW5jb2RlRmllbGQoe1xcbiAgICAgICAgdHlwZXMsXFxuICAgICAgICBuYW1lOiBmaWVsZC5uYW1lLFxcbiAgICAgICAgdHlwZTogZmllbGQudHlwZSxcXG4gICAgICAgIHZhbHVlOiBkYXRhW2ZpZWxkLm5hbWVdXFxuICAgICAgfSk7XFxuICAgICAgZW5jb2RlZFR5cGVzLnB1c2godHlwZSk7XFxuICAgICAgZW5jb2RlZFZhbHVlcy5wdXNoKHZhbHVlKTtcXG4gICAgfVxcbiAgICByZXR1cm4gZW5jb2RlQWJpUGFyYW1ldGVycyhlbmNvZGVkVHlwZXMsIGVuY29kZWRWYWx1ZXMpO1xcbiAgfVxcbiAgZnVuY3Rpb24gaGFzaFR5cGUoeyBwcmltYXJ5VHlwZSwgdHlwZXMgfSkge1xcbiAgICBjb25zdCBlbmNvZGVkSGFzaFR5cGUgPSB0b0hleChlbmNvZGVUeXBlKHsgcHJpbWFyeVR5cGUsIHR5cGVzIH0pKTtcXG4gICAgcmV0dXJuIGtlY2NhazI1NihlbmNvZGVkSGFzaFR5cGUpO1xcbiAgfVxcbiAgZnVuY3Rpb24gZW5jb2RlVHlwZSh7IHByaW1hcnlUeXBlLCB0eXBlcyB9KSB7XFxuICAgIGxldCByZXN1bHQgPSBcIlwiO1xcbiAgICBjb25zdCB1bnNvcnRlZERlcHMgPSBmaW5kVHlwZURlcGVuZGVuY2llcyh7IHByaW1hcnlUeXBlLCB0eXBlcyB9KTtcXG4gICAgdW5zb3J0ZWREZXBzLmRlbGV0ZShwcmltYXJ5VHlwZSk7XFxuICAgIGNvbnN0IGRlcHMgPSBbcHJpbWFyeVR5cGUsIC4uLkFycmF5LmZyb20odW5zb3J0ZWREZXBzKS5zb3J0KCldO1xcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgZGVwcykge1xcbiAgICAgIHJlc3VsdCArPSBgJHt0eXBlfSgke3R5cGVzW3R5cGVdLm1hcCgoeyBuYW1lLCB0eXBlOiB0IH0pID0+IGAke3R9ICR7bmFtZX1gKS5qb2luKFwiLFwiKX0pYDtcXG4gICAgfVxcbiAgICByZXR1cm4gcmVzdWx0O1xcbiAgfVxcbiAgZnVuY3Rpb24gZmluZFR5cGVEZXBlbmRlbmNpZXMoeyBwcmltYXJ5VHlwZTogcHJpbWFyeVR5cGVfLCB0eXBlcyB9LCByZXN1bHRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSkge1xcbiAgICBjb25zdCBtYXRjaCA9IHByaW1hcnlUeXBlXy5tYXRjaCgvXlxcXFx3Ki91KTtcXG4gICAgY29uc3QgcHJpbWFyeVR5cGUgPSBtYXRjaD8uWzBdO1xcbiAgICBpZiAocmVzdWx0cy5oYXMocHJpbWFyeVR5cGUpIHx8IHR5cGVzW3ByaW1hcnlUeXBlXSA9PT0gdm9pZCAwKSB7XFxuICAgICAgcmV0dXJuIHJlc3VsdHM7XFxuICAgIH1cXG4gICAgcmVzdWx0cy5hZGQocHJpbWFyeVR5cGUpO1xcbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGVzW3ByaW1hcnlUeXBlXSkge1xcbiAgICAgIGZpbmRUeXBlRGVwZW5kZW5jaWVzKHsgcHJpbWFyeVR5cGU6IGZpZWxkLnR5cGUsIHR5cGVzIH0sIHJlc3VsdHMpO1xcbiAgICB9XFxuICAgIHJldHVybiByZXN1bHRzO1xcbiAgfVxcbiAgZnVuY3Rpb24gZW5jb2RlRmllbGQoeyB0eXBlcywgbmFtZSwgdHlwZSwgdmFsdWUgfSkge1xcbiAgICBpZiAodHlwZXNbdHlwZV0gIT09IHZvaWQgMCkge1xcbiAgICAgIHJldHVybiBbXFxuICAgICAgICB7IHR5cGU6IFwiYnl0ZXMzMlwiIH0sXFxuICAgICAgICBrZWNjYWsyNTYoZW5jb2RlRGF0YSh7IGRhdGE6IHZhbHVlLCBwcmltYXJ5VHlwZTogdHlwZSwgdHlwZXMgfSkpXFxuICAgICAgXTtcXG4gICAgfVxcbiAgICBpZiAodHlwZSA9PT0gXCJieXRlc1wiKSB7XFxuICAgICAgY29uc3QgcHJlcGVuZCA9IHZhbHVlLmxlbmd0aCAlIDIgPyBcIjBcIiA6IFwiXCI7XFxuICAgICAgdmFsdWUgPSBgMHgke3ByZXBlbmQgKyB2YWx1ZS5zbGljZSgyKX1gO1xcbiAgICAgIHJldHVybiBbeyB0eXBlOiBcImJ5dGVzMzJcIiB9LCBrZWNjYWsyNTYodmFsdWUpXTtcXG4gICAgfVxcbiAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIilcXG4gICAgICByZXR1cm4gW3sgdHlwZTogXCJieXRlczMyXCIgfSwga2VjY2FrMjU2KHRvSGV4KHZhbHVlKSldO1xcbiAgICBpZiAodHlwZS5sYXN0SW5kZXhPZihcIl1cIikgPT09IHR5cGUubGVuZ3RoIC0gMSkge1xcbiAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0eXBlLnNsaWNlKDAsIHR5cGUubGFzdEluZGV4T2YoXCJbXCIpKTtcXG4gICAgICBjb25zdCB0eXBlVmFsdWVQYWlycyA9IHZhbHVlLm1hcCgoaXRlbSkgPT4gZW5jb2RlRmllbGQoe1xcbiAgICAgICAgbmFtZSxcXG4gICAgICAgIHR5cGU6IHBhcnNlZFR5cGUsXFxuICAgICAgICB0eXBlcyxcXG4gICAgICAgIHZhbHVlOiBpdGVtXFxuICAgICAgfSkpO1xcbiAgICAgIHJldHVybiBbXFxuICAgICAgICB7IHR5cGU6IFwiYnl0ZXMzMlwiIH0sXFxuICAgICAgICBrZWNjYWsyNTYoZW5jb2RlQWJpUGFyYW1ldGVycyh0eXBlVmFsdWVQYWlycy5tYXAoKFt0XSkgPT4gdCksIHR5cGVWYWx1ZVBhaXJzLm1hcCgoWywgdl0pID0+IHYpKSlcXG4gICAgICBdO1xcbiAgICB9XFxuICAgIHJldHVybiBbeyB0eXBlIH0sIHZhbHVlXTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL3R5cGVkRGF0YS5qc1xcbiAgaW5pdF9zdHJpbmdpZnkoKTtcXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZVR5cGVkRGF0YShwYXJhbWV0ZXJzKSB7XFxuICAgIGNvbnN0IHsgZG9tYWluOiBkb21haW5fLCBtZXNzYWdlOiBtZXNzYWdlXywgcHJpbWFyeVR5cGUsIHR5cGVzIH0gPSBwYXJhbWV0ZXJzO1xcbiAgICBjb25zdCBub3JtYWxpemVEYXRhID0gKHN0cnVjdCwgZGF0YV8pID0+IHtcXG4gICAgICBjb25zdCBkYXRhID0geyAuLi5kYXRhXyB9O1xcbiAgICAgIGZvciAoY29uc3QgcGFyYW0gb2Ygc3RydWN0KSB7XFxuICAgICAgICBjb25zdCB7IG5hbWUsIHR5cGUgfSA9IHBhcmFtO1xcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiYWRkcmVzc1wiKVxcbiAgICAgICAgICBkYXRhW25hbWVdID0gZGF0YVtuYW1lXS50b0xvd2VyQ2FzZSgpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gZGF0YTtcXG4gICAgfTtcXG4gICAgY29uc3QgZG9tYWluID0gKCgpID0+IHtcXG4gICAgICBpZiAoIXR5cGVzLkVJUDcxMkRvbWFpbilcXG4gICAgICAgIHJldHVybiB7fTtcXG4gICAgICBpZiAoIWRvbWFpbl8pXFxuICAgICAgICByZXR1cm4ge307XFxuICAgICAgcmV0dXJuIG5vcm1hbGl6ZURhdGEodHlwZXMuRUlQNzEyRG9tYWluLCBkb21haW5fKTtcXG4gICAgfSkoKTtcXG4gICAgY29uc3QgbWVzc2FnZSA9ICgoKSA9PiB7XFxuICAgICAgaWYgKHByaW1hcnlUeXBlID09PSBcIkVJUDcxMkRvbWFpblwiKVxcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcXG4gICAgICByZXR1cm4gbm9ybWFsaXplRGF0YSh0eXBlc1twcmltYXJ5VHlwZV0sIG1lc3NhZ2VfKTtcXG4gICAgfSkoKTtcXG4gICAgcmV0dXJuIHN0cmluZ2lmeSh7IGRvbWFpbiwgbWVzc2FnZSwgcHJpbWFyeVR5cGUsIHR5cGVzIH0pO1xcbiAgfVxcbiAgZnVuY3Rpb24gdmFsaWRhdGVUeXBlZERhdGEocGFyYW1ldGVycykge1xcbiAgICBjb25zdCB7IGRvbWFpbiwgbWVzc2FnZSwgcHJpbWFyeVR5cGUsIHR5cGVzIH0gPSBwYXJhbWV0ZXJzO1xcbiAgICBjb25zdCB2YWxpZGF0ZURhdGEgPSAoc3RydWN0LCBkYXRhKSA9PiB7XFxuICAgICAgZm9yIChjb25zdCBwYXJhbSBvZiBzdHJ1Y3QpIHtcXG4gICAgICAgIGNvbnN0IHsgbmFtZSwgdHlwZSB9ID0gcGFyYW07XFxuICAgICAgICBjb25zdCB2YWx1ZSA9IGRhdGFbbmFtZV07XFxuICAgICAgICBjb25zdCBpbnRlZ2VyTWF0Y2ggPSB0eXBlLm1hdGNoKGludGVnZXJSZWdleDIpO1xcbiAgICAgICAgaWYgKGludGVnZXJNYXRjaCAmJiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIikpIHtcXG4gICAgICAgICAgY29uc3QgW190eXBlLCBiYXNlMiwgc2l6ZV9dID0gaW50ZWdlck1hdGNoO1xcbiAgICAgICAgICBudW1iZXJUb0hleCh2YWx1ZSwge1xcbiAgICAgICAgICAgIHNpZ25lZDogYmFzZTIgPT09IFwiaW50XCIsXFxuICAgICAgICAgICAgc2l6ZTogTnVtYmVyLnBhcnNlSW50KHNpemVfKSAvIDhcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFpc0FkZHJlc3ModmFsdWUpKVxcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcih7IGFkZHJlc3M6IHZhbHVlIH0pO1xcbiAgICAgICAgY29uc3QgYnl0ZXNNYXRjaCA9IHR5cGUubWF0Y2goYnl0ZXNSZWdleDIpO1xcbiAgICAgICAgaWYgKGJ5dGVzTWF0Y2gpIHtcXG4gICAgICAgICAgY29uc3QgW190eXBlLCBzaXplX10gPSBieXRlc01hdGNoO1xcbiAgICAgICAgICBpZiAoc2l6ZV8gJiYgc2l6ZSh2YWx1ZSkgIT09IE51bWJlci5wYXJzZUludChzaXplXykpXFxuICAgICAgICAgICAgdGhyb3cgbmV3IEJ5dGVzU2l6ZU1pc21hdGNoRXJyb3Ioe1xcbiAgICAgICAgICAgICAgZXhwZWN0ZWRTaXplOiBOdW1iZXIucGFyc2VJbnQoc2l6ZV8pLFxcbiAgICAgICAgICAgICAgZ2l2ZW5TaXplOiBzaXplKHZhbHVlKVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgY29uc3Qgc3RydWN0MiA9IHR5cGVzW3R5cGVdO1xcbiAgICAgICAgaWYgKHN0cnVjdDIpIHtcXG4gICAgICAgICAgdmFsaWRhdGVSZWZlcmVuY2UodHlwZSk7XFxuICAgICAgICAgIHZhbGlkYXRlRGF0YShzdHJ1Y3QyLCB2YWx1ZSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9O1xcbiAgICBpZiAodHlwZXMuRUlQNzEyRG9tYWluICYmIGRvbWFpbikge1xcbiAgICAgIGlmICh0eXBlb2YgZG9tYWluICE9PSBcIm9iamVjdFwiKVxcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWREb21haW5FcnJvcih7IGRvbWFpbiB9KTtcXG4gICAgICB2YWxpZGF0ZURhdGEodHlwZXMuRUlQNzEyRG9tYWluLCBkb21haW4pO1xcbiAgICB9XFxuICAgIGlmIChwcmltYXJ5VHlwZSAhPT0gXCJFSVA3MTJEb21haW5cIikge1xcbiAgICAgIGlmICh0eXBlc1twcmltYXJ5VHlwZV0pXFxuICAgICAgICB2YWxpZGF0ZURhdGEodHlwZXNbcHJpbWFyeVR5cGVdLCBtZXNzYWdlKTtcXG4gICAgICBlbHNlXFxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFByaW1hcnlUeXBlRXJyb3IoeyBwcmltYXJ5VHlwZSwgdHlwZXMgfSk7XFxuICAgIH1cXG4gIH1cXG4gIGZ1bmN0aW9uIGdldFR5cGVzRm9yRUlQNzEyRG9tYWluKHsgZG9tYWluIH0pIHtcXG4gICAgcmV0dXJuIFtcXG4gICAgICB0eXBlb2YgZG9tYWluPy5uYW1lID09PSBcInN0cmluZ1wiICYmIHsgbmFtZTogXCJuYW1lXCIsIHR5cGU6IFwic3RyaW5nXCIgfSxcXG4gICAgICBkb21haW4/LnZlcnNpb24gJiYgeyBuYW1lOiBcInZlcnNpb25cIiwgdHlwZTogXCJzdHJpbmdcIiB9LFxcbiAgICAgICh0eXBlb2YgZG9tYWluPy5jaGFpbklkID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBkb21haW4/LmNoYWluSWQgPT09IFwiYmlnaW50XCIpICYmIHtcXG4gICAgICAgIG5hbWU6IFwiY2hhaW5JZFwiLFxcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcXG4gICAgICB9LFxcbiAgICAgIGRvbWFpbj8udmVyaWZ5aW5nQ29udHJhY3QgJiYge1xcbiAgICAgICAgbmFtZTogXCJ2ZXJpZnlpbmdDb250cmFjdFwiLFxcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcXG4gICAgICB9LFxcbiAgICAgIGRvbWFpbj8uc2FsdCAmJiB7IG5hbWU6IFwic2FsdFwiLCB0eXBlOiBcImJ5dGVzMzJcIiB9XFxuICAgIF0uZmlsdGVyKEJvb2xlYW4pO1xcbiAgfVxcbiAgZnVuY3Rpb24gdmFsaWRhdGVSZWZlcmVuY2UodHlwZSkge1xcbiAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIgfHwgdHlwZSA9PT0gXCJib29sXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlLnN0YXJ0c1dpdGgoXCJieXRlc1wiKSB8fCB0eXBlLnN0YXJ0c1dpdGgoXCJ1aW50XCIpIHx8IHR5cGUuc3RhcnRzV2l0aChcImludFwiKSlcXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFN0cnVjdFR5cGVFcnJvcih7IHR5cGUgfSk7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9pbmRleC5qc1xcbiAgaW5pdF9lbmNvZGVGdW5jdGlvbkRhdGEoKTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2F1dGhvcml6YXRpb24vc2VyaWFsaXplQXV0aG9yaXphdGlvbkxpc3QuanNcXG4gIGluaXRfdG9IZXgoKTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL3RyYW5zYWN0aW9uL3NlcmlhbGl6ZVRyYW5zYWN0aW9uLmpzXFxuICBpbml0X3RyYW5zYWN0aW9uKCk7XFxuICBpbml0X2NvbmNhdCgpO1xcbiAgaW5pdF90cmltKCk7XFxuICBpbml0X3RvSGV4KCk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy90cmFuc2FjdGlvbi9hc3NlcnRUcmFuc2FjdGlvbi5qc1xcbiAgaW5pdF9udW1iZXIoKTtcXG4gIGluaXRfYWRkcmVzcygpO1xcbiAgaW5pdF9iYXNlKCk7XFxuICBpbml0X2NoYWluKCk7XFxuICBpbml0X25vZGUoKTtcXG4gIGluaXRfaXNBZGRyZXNzKCk7XFxuICBpbml0X3NpemUoKTtcXG4gIGluaXRfc2xpY2UoKTtcXG4gIGluaXRfZnJvbUhleCgpO1xcbiAgZnVuY3Rpb24gYXNzZXJ0VHJhbnNhY3Rpb25FSVA3NzAyKHRyYW5zYWN0aW9uKSB7XFxuICAgIGNvbnN0IHsgYXV0aG9yaXphdGlvbkxpc3QgfSA9IHRyYW5zYWN0aW9uO1xcbiAgICBpZiAoYXV0aG9yaXphdGlvbkxpc3QpIHtcXG4gICAgICBmb3IgKGNvbnN0IGF1dGhvcml6YXRpb24gb2YgYXV0aG9yaXphdGlvbkxpc3QpIHtcXG4gICAgICAgIGNvbnN0IHsgY2hhaW5JZCB9ID0gYXV0aG9yaXphdGlvbjtcXG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhdXRob3JpemF0aW9uLmFkZHJlc3M7XFxuICAgICAgICBpZiAoIWlzQWRkcmVzcyhhZGRyZXNzKSlcXG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoeyBhZGRyZXNzIH0pO1xcbiAgICAgICAgaWYgKGNoYWluSWQgPCAwKVxcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZENoYWluSWRFcnJvcih7IGNoYWluSWQgfSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGFzc2VydFRyYW5zYWN0aW9uRUlQMTU1OSh0cmFuc2FjdGlvbik7XFxuICB9XFxuICBmdW5jdGlvbiBhc3NlcnRUcmFuc2FjdGlvbkVJUDQ4NDQodHJhbnNhY3Rpb24pIHtcXG4gICAgY29uc3QgeyBibG9iVmVyc2lvbmVkSGFzaGVzIH0gPSB0cmFuc2FjdGlvbjtcXG4gICAgaWYgKGJsb2JWZXJzaW9uZWRIYXNoZXMpIHtcXG4gICAgICBpZiAoYmxvYlZlcnNpb25lZEhhc2hlcy5sZW5ndGggPT09IDApXFxuICAgICAgICB0aHJvdyBuZXcgRW1wdHlCbG9iRXJyb3IoKTtcXG4gICAgICBmb3IgKGNvbnN0IGhhc2gyIG9mIGJsb2JWZXJzaW9uZWRIYXNoZXMpIHtcXG4gICAgICAgIGNvbnN0IHNpemVfID0gc2l6ZShoYXNoMik7XFxuICAgICAgICBjb25zdCB2ZXJzaW9uNCA9IGhleFRvTnVtYmVyKHNsaWNlKGhhc2gyLCAwLCAxKSk7XFxuICAgICAgICBpZiAoc2l6ZV8gIT09IDMyKVxcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFZlcnNpb25lZEhhc2hTaXplRXJyb3IoeyBoYXNoOiBoYXNoMiwgc2l6ZTogc2l6ZV8gfSk7XFxuICAgICAgICBpZiAodmVyc2lvbjQgIT09IHZlcnNpb25lZEhhc2hWZXJzaW9uS3pnKVxcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFZlcnNpb25lZEhhc2hWZXJzaW9uRXJyb3Ioe1xcbiAgICAgICAgICAgIGhhc2g6IGhhc2gyLFxcbiAgICAgICAgICAgIHZlcnNpb246IHZlcnNpb240XFxuICAgICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBhc3NlcnRUcmFuc2FjdGlvbkVJUDE1NTkodHJhbnNhY3Rpb24pO1xcbiAgfVxcbiAgZnVuY3Rpb24gYXNzZXJ0VHJhbnNhY3Rpb25FSVAxNTU5KHRyYW5zYWN0aW9uKSB7XFxuICAgIGNvbnN0IHsgY2hhaW5JZCwgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIG1heEZlZVBlckdhcywgdG8gfSA9IHRyYW5zYWN0aW9uO1xcbiAgICBpZiAoY2hhaW5JZCA8PSAwKVxcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQ2hhaW5JZEVycm9yKHsgY2hhaW5JZCB9KTtcXG4gICAgaWYgKHRvICYmICFpc0FkZHJlc3ModG8pKVxcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKHsgYWRkcmVzczogdG8gfSk7XFxuICAgIGlmIChtYXhGZWVQZXJHYXMgJiYgbWF4RmVlUGVyR2FzID4gbWF4VWludDI1NilcXG4gICAgICB0aHJvdyBuZXcgRmVlQ2FwVG9vSGlnaEVycm9yKHsgbWF4RmVlUGVyR2FzIH0pO1xcbiAgICBpZiAobWF4UHJpb3JpdHlGZWVQZXJHYXMgJiYgbWF4RmVlUGVyR2FzICYmIG1heFByaW9yaXR5RmVlUGVyR2FzID4gbWF4RmVlUGVyR2FzKVxcbiAgICAgIHRocm93IG5ldyBUaXBBYm92ZUZlZUNhcEVycm9yKHsgbWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhcyB9KTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGFzc2VydFRyYW5zYWN0aW9uRUlQMjkzMCh0cmFuc2FjdGlvbikge1xcbiAgICBjb25zdCB7IGNoYWluSWQsIG1heFByaW9yaXR5RmVlUGVyR2FzLCBnYXNQcmljZSwgbWF4RmVlUGVyR2FzLCB0byB9ID0gdHJhbnNhY3Rpb247XFxuICAgIGlmIChjaGFpbklkIDw9IDApXFxuICAgICAgdGhyb3cgbmV3IEludmFsaWRDaGFpbklkRXJyb3IoeyBjaGFpbklkIH0pO1xcbiAgICBpZiAodG8gJiYgIWlzQWRkcmVzcyh0bykpXFxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoeyBhZGRyZXNzOiB0byB9KTtcXG4gICAgaWYgKG1heFByaW9yaXR5RmVlUGVyR2FzIHx8IG1heEZlZVBlckdhcylcXG4gICAgICB0aHJvdyBuZXcgQmFzZUVycm9yMihcImBtYXhGZWVQZXJHYXNgL2BtYXhQcmlvcml0eUZlZVBlckdhc2AgaXMgbm90IGEgdmFsaWQgRUlQLTI5MzAgVHJhbnNhY3Rpb24gYXR0cmlidXRlLlwiKTtcXG4gICAgaWYgKGdhc1ByaWNlICYmIGdhc1ByaWNlID4gbWF4VWludDI1NilcXG4gICAgICB0aHJvdyBuZXcgRmVlQ2FwVG9vSGlnaEVycm9yKHsgbWF4RmVlUGVyR2FzOiBnYXNQcmljZSB9KTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGFzc2VydFRyYW5zYWN0aW9uTGVnYWN5KHRyYW5zYWN0aW9uKSB7XFxuICAgIGNvbnN0IHsgY2hhaW5JZCwgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIGdhc1ByaWNlLCBtYXhGZWVQZXJHYXMsIHRvIH0gPSB0cmFuc2FjdGlvbjtcXG4gICAgaWYgKHRvICYmICFpc0FkZHJlc3ModG8pKVxcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKHsgYWRkcmVzczogdG8gfSk7XFxuICAgIGlmICh0eXBlb2YgY2hhaW5JZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjaGFpbklkIDw9IDApXFxuICAgICAgdGhyb3cgbmV3IEludmFsaWRDaGFpbklkRXJyb3IoeyBjaGFpbklkIH0pO1xcbiAgICBpZiAobWF4UHJpb3JpdHlGZWVQZXJHYXMgfHwgbWF4RmVlUGVyR2FzKVxcbiAgICAgIHRocm93IG5ldyBCYXNlRXJyb3IyKFwiYG1heEZlZVBlckdhc2AvYG1heFByaW9yaXR5RmVlUGVyR2FzYCBpcyBub3QgYSB2YWxpZCBMZWdhY3kgVHJhbnNhY3Rpb24gYXR0cmlidXRlLlwiKTtcXG4gICAgaWYgKGdhc1ByaWNlICYmIGdhc1ByaWNlID4gbWF4VWludDI1NilcXG4gICAgICB0aHJvdyBuZXcgRmVlQ2FwVG9vSGlnaEVycm9yKHsgbWF4RmVlUGVyR2FzOiBnYXNQcmljZSB9KTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL3RyYW5zYWN0aW9uL3NlcmlhbGl6ZUFjY2Vzc0xpc3QuanNcXG4gIGluaXRfYWRkcmVzcygpO1xcbiAgaW5pdF90cmFuc2FjdGlvbigpO1xcbiAgaW5pdF9pc0FkZHJlc3MoKTtcXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZUFjY2Vzc0xpc3QoYWNjZXNzTGlzdCkge1xcbiAgICBpZiAoIWFjY2Vzc0xpc3QgfHwgYWNjZXNzTGlzdC5sZW5ndGggPT09IDApXFxuICAgICAgcmV0dXJuIFtdO1xcbiAgICBjb25zdCBzZXJpYWxpemVkQWNjZXNzTGlzdCA9IFtdO1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjY2Vzc0xpc3QubGVuZ3RoOyBpKyspIHtcXG4gICAgICBjb25zdCB7IGFkZHJlc3MsIHN0b3JhZ2VLZXlzIH0gPSBhY2Nlc3NMaXN0W2ldO1xcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RvcmFnZUtleXMubGVuZ3RoOyBqKyspIHtcXG4gICAgICAgIGlmIChzdG9yYWdlS2V5c1tqXS5sZW5ndGggLSAyICE9PSA2NCkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFN0b3JhZ2VLZXlTaXplRXJyb3IoeyBzdG9yYWdlS2V5OiBzdG9yYWdlS2V5c1tqXSB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgaWYgKCFpc0FkZHJlc3MoYWRkcmVzcywgeyBzdHJpY3Q6IGZhbHNlIH0pKSB7XFxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcih7IGFkZHJlc3MgfSk7XFxuICAgICAgfVxcbiAgICAgIHNlcmlhbGl6ZWRBY2Nlc3NMaXN0LnB1c2goW2FkZHJlc3MsIHN0b3JhZ2VLZXlzXSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRBY2Nlc3NMaXN0O1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvdHJhbnNhY3Rpb24vc2VyaWFsaXplVHJhbnNhY3Rpb24uanNcXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpIHtcXG4gICAgY29uc3QgdHlwZSA9IGdldFRyYW5zYWN0aW9uVHlwZSh0cmFuc2FjdGlvbik7XFxuICAgIGlmICh0eXBlID09PSBcImVpcDE1NTlcIilcXG4gICAgICByZXR1cm4gc2VyaWFsaXplVHJhbnNhY3Rpb25FSVAxNTU5KHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpO1xcbiAgICBpZiAodHlwZSA9PT0gXCJlaXAyOTMwXCIpXFxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZVRyYW5zYWN0aW9uRUlQMjkzMCh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKTtcXG4gICAgaWYgKHR5cGUgPT09IFwiZWlwNDg0NFwiKVxcbiAgICAgIHJldHVybiBzZXJpYWxpemVUcmFuc2FjdGlvbkVJUDQ4NDQodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSk7XFxuICAgIGlmICh0eXBlID09PSBcImVpcDc3MDJcIilcXG4gICAgICByZXR1cm4gc2VyaWFsaXplVHJhbnNhY3Rpb25FSVA3NzAyKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpO1xcbiAgICByZXR1cm4gc2VyaWFsaXplVHJhbnNhY3Rpb25MZWdhY3kodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSk7XFxuICB9XFxuICBmdW5jdGlvbiBzZXJpYWxpemVUcmFuc2FjdGlvbkVJUDc3MDIodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSkge1xcbiAgICBjb25zdCB7IGF1dGhvcml6YXRpb25MaXN0LCBjaGFpbklkLCBnYXMsIG5vbmNlLCB0bywgdmFsdWUsIG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIGFjY2Vzc0xpc3QsIGRhdGEgfSA9IHRyYW5zYWN0aW9uO1xcbiAgICBhc3NlcnRUcmFuc2FjdGlvbkVJUDc3MDIodHJhbnNhY3Rpb24pO1xcbiAgICBjb25zdCBzZXJpYWxpemVkQWNjZXNzTGlzdCA9IHNlcmlhbGl6ZUFjY2Vzc0xpc3QoYWNjZXNzTGlzdCk7XFxuICAgIGNvbnN0IHNlcmlhbGl6ZWRBdXRob3JpemF0aW9uTGlzdCA9IHNlcmlhbGl6ZUF1dGhvcml6YXRpb25MaXN0KGF1dGhvcml6YXRpb25MaXN0KTtcXG4gICAgcmV0dXJuIGNvbmNhdEhleChbXFxuICAgICAgXCIweDA0XCIsXFxuICAgICAgdG9SbHAoW1xcbiAgICAgICAgdG9IZXgoY2hhaW5JZCksXFxuICAgICAgICBub25jZSA/IHRvSGV4KG5vbmNlKSA6IFwiMHhcIixcXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzID8gdG9IZXgobWF4UHJpb3JpdHlGZWVQZXJHYXMpIDogXCIweFwiLFxcbiAgICAgICAgbWF4RmVlUGVyR2FzID8gdG9IZXgobWF4RmVlUGVyR2FzKSA6IFwiMHhcIixcXG4gICAgICAgIGdhcyA/IHRvSGV4KGdhcykgOiBcIjB4XCIsXFxuICAgICAgICB0byA/PyBcIjB4XCIsXFxuICAgICAgICB2YWx1ZSA/IHRvSGV4KHZhbHVlKSA6IFwiMHhcIixcXG4gICAgICAgIGRhdGEgPz8gXCIweFwiLFxcbiAgICAgICAgc2VyaWFsaXplZEFjY2Vzc0xpc3QsXFxuICAgICAgICBzZXJpYWxpemVkQXV0aG9yaXphdGlvbkxpc3QsXFxuICAgICAgICAuLi50b1lQYXJpdHlTaWduYXR1cmVBcnJheSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKVxcbiAgICAgIF0pXFxuICAgIF0pO1xcbiAgfVxcbiAgZnVuY3Rpb24gc2VyaWFsaXplVHJhbnNhY3Rpb25FSVA0ODQ0KHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpIHtcXG4gICAgY29uc3QgeyBjaGFpbklkLCBnYXMsIG5vbmNlLCB0bywgdmFsdWUsIG1heEZlZVBlckJsb2JHYXMsIG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIGFjY2Vzc0xpc3QsIGRhdGEgfSA9IHRyYW5zYWN0aW9uO1xcbiAgICBhc3NlcnRUcmFuc2FjdGlvbkVJUDQ4NDQodHJhbnNhY3Rpb24pO1xcbiAgICBsZXQgYmxvYlZlcnNpb25lZEhhc2hlcyA9IHRyYW5zYWN0aW9uLmJsb2JWZXJzaW9uZWRIYXNoZXM7XFxuICAgIGxldCBzaWRlY2FycyA9IHRyYW5zYWN0aW9uLnNpZGVjYXJzO1xcbiAgICBpZiAodHJhbnNhY3Rpb24uYmxvYnMgJiYgKHR5cGVvZiBibG9iVmVyc2lvbmVkSGFzaGVzID09PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBzaWRlY2FycyA9PT0gXCJ1bmRlZmluZWRcIikpIHtcXG4gICAgICBjb25zdCBibG9iczIgPSB0eXBlb2YgdHJhbnNhY3Rpb24uYmxvYnNbMF0gPT09IFwic3RyaW5nXCIgPyB0cmFuc2FjdGlvbi5ibG9icyA6IHRyYW5zYWN0aW9uLmJsb2JzLm1hcCgoeCkgPT4gYnl0ZXNUb0hleCh4KSk7XFxuICAgICAgY29uc3Qga3pnID0gdHJhbnNhY3Rpb24ua3pnO1xcbiAgICAgIGNvbnN0IGNvbW1pdG1lbnRzMiA9IGJsb2JzVG9Db21taXRtZW50cyh7XFxuICAgICAgICBibG9iczogYmxvYnMyLFxcbiAgICAgICAga3pnXFxuICAgICAgfSk7XFxuICAgICAgaWYgKHR5cGVvZiBibG9iVmVyc2lvbmVkSGFzaGVzID09PSBcInVuZGVmaW5lZFwiKVxcbiAgICAgICAgYmxvYlZlcnNpb25lZEhhc2hlcyA9IGNvbW1pdG1lbnRzVG9WZXJzaW9uZWRIYXNoZXMoe1xcbiAgICAgICAgICBjb21taXRtZW50czogY29tbWl0bWVudHMyXFxuICAgICAgICB9KTtcXG4gICAgICBpZiAodHlwZW9mIHNpZGVjYXJzID09PSBcInVuZGVmaW5lZFwiKSB7XFxuICAgICAgICBjb25zdCBwcm9vZnMyID0gYmxvYnNUb1Byb29mcyh7IGJsb2JzOiBibG9iczIsIGNvbW1pdG1lbnRzOiBjb21taXRtZW50czIsIGt6ZyB9KTtcXG4gICAgICAgIHNpZGVjYXJzID0gdG9CbG9iU2lkZWNhcnMoeyBibG9iczogYmxvYnMyLCBjb21taXRtZW50czogY29tbWl0bWVudHMyLCBwcm9vZnM6IHByb29mczIgfSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGNvbnN0IHNlcmlhbGl6ZWRBY2Nlc3NMaXN0ID0gc2VyaWFsaXplQWNjZXNzTGlzdChhY2Nlc3NMaXN0KTtcXG4gICAgY29uc3Qgc2VyaWFsaXplZFRyYW5zYWN0aW9uID0gW1xcbiAgICAgIHRvSGV4KGNoYWluSWQpLFxcbiAgICAgIG5vbmNlID8gdG9IZXgobm9uY2UpIDogXCIweFwiLFxcbiAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzID8gdG9IZXgobWF4UHJpb3JpdHlGZWVQZXJHYXMpIDogXCIweFwiLFxcbiAgICAgIG1heEZlZVBlckdhcyA/IHRvSGV4KG1heEZlZVBlckdhcykgOiBcIjB4XCIsXFxuICAgICAgZ2FzID8gdG9IZXgoZ2FzKSA6IFwiMHhcIixcXG4gICAgICB0byA/PyBcIjB4XCIsXFxuICAgICAgdmFsdWUgPyB0b0hleCh2YWx1ZSkgOiBcIjB4XCIsXFxuICAgICAgZGF0YSA/PyBcIjB4XCIsXFxuICAgICAgc2VyaWFsaXplZEFjY2Vzc0xpc3QsXFxuICAgICAgbWF4RmVlUGVyQmxvYkdhcyA/IHRvSGV4KG1heEZlZVBlckJsb2JHYXMpIDogXCIweFwiLFxcbiAgICAgIGJsb2JWZXJzaW9uZWRIYXNoZXMgPz8gW10sXFxuICAgICAgLi4udG9ZUGFyaXR5U2lnbmF0dXJlQXJyYXkodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSlcXG4gICAgXTtcXG4gICAgY29uc3QgYmxvYnMgPSBbXTtcXG4gICAgY29uc3QgY29tbWl0bWVudHMgPSBbXTtcXG4gICAgY29uc3QgcHJvb2ZzID0gW107XFxuICAgIGlmIChzaWRlY2FycylcXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZGVjYXJzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBjb25zdCB7IGJsb2IsIGNvbW1pdG1lbnQsIHByb29mIH0gPSBzaWRlY2Fyc1tpXTtcXG4gICAgICAgIGJsb2JzLnB1c2goYmxvYik7XFxuICAgICAgICBjb21taXRtZW50cy5wdXNoKGNvbW1pdG1lbnQpO1xcbiAgICAgICAgcHJvb2ZzLnB1c2gocHJvb2YpO1xcbiAgICAgIH1cXG4gICAgcmV0dXJuIGNvbmNhdEhleChbXFxuICAgICAgXCIweDAzXCIsXFxuICAgICAgc2lkZWNhcnMgPyAoXFxuICAgICAgICAvLyBJZiBzaWRlY2FycyBhcmUgZW5hYmxlZCwgZW52ZWxvcGUgdHVybnMgaW50byBhIFwid3JhcHBlclwiOlxcbiAgICAgICAgdG9SbHAoW3NlcmlhbGl6ZWRUcmFuc2FjdGlvbiwgYmxvYnMsIGNvbW1pdG1lbnRzLCBwcm9vZnNdKVxcbiAgICAgICkgOiAoXFxuICAgICAgICAvLyBJZiBzaWRlY2FycyBhcmUgZGlzYWJsZWQsIHN0YW5kYXJkIGVudmVsb3BlIGlzIHVzZWQ6XFxuICAgICAgICB0b1JscChzZXJpYWxpemVkVHJhbnNhY3Rpb24pXFxuICAgICAgKVxcbiAgICBdKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZVRyYW5zYWN0aW9uRUlQMTU1OSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKSB7XFxuICAgIGNvbnN0IHsgY2hhaW5JZCwgZ2FzLCBub25jZSwgdG8sIHZhbHVlLCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzLCBhY2Nlc3NMaXN0LCBkYXRhIH0gPSB0cmFuc2FjdGlvbjtcXG4gICAgYXNzZXJ0VHJhbnNhY3Rpb25FSVAxNTU5KHRyYW5zYWN0aW9uKTtcXG4gICAgY29uc3Qgc2VyaWFsaXplZEFjY2Vzc0xpc3QgPSBzZXJpYWxpemVBY2Nlc3NMaXN0KGFjY2Vzc0xpc3QpO1xcbiAgICBjb25zdCBzZXJpYWxpemVkVHJhbnNhY3Rpb24gPSBbXFxuICAgICAgdG9IZXgoY2hhaW5JZCksXFxuICAgICAgbm9uY2UgPyB0b0hleChub25jZSkgOiBcIjB4XCIsXFxuICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXMgPyB0b0hleChtYXhQcmlvcml0eUZlZVBlckdhcykgOiBcIjB4XCIsXFxuICAgICAgbWF4RmVlUGVyR2FzID8gdG9IZXgobWF4RmVlUGVyR2FzKSA6IFwiMHhcIixcXG4gICAgICBnYXMgPyB0b0hleChnYXMpIDogXCIweFwiLFxcbiAgICAgIHRvID8/IFwiMHhcIixcXG4gICAgICB2YWx1ZSA/IHRvSGV4KHZhbHVlKSA6IFwiMHhcIixcXG4gICAgICBkYXRhID8/IFwiMHhcIixcXG4gICAgICBzZXJpYWxpemVkQWNjZXNzTGlzdCxcXG4gICAgICAuLi50b1lQYXJpdHlTaWduYXR1cmVBcnJheSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKVxcbiAgICBdO1xcbiAgICByZXR1cm4gY29uY2F0SGV4KFtcXG4gICAgICBcIjB4MDJcIixcXG4gICAgICB0b1JscChzZXJpYWxpemVkVHJhbnNhY3Rpb24pXFxuICAgIF0pO1xcbiAgfVxcbiAgZnVuY3Rpb24gc2VyaWFsaXplVHJhbnNhY3Rpb25FSVAyOTMwKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpIHtcXG4gICAgY29uc3QgeyBjaGFpbklkLCBnYXMsIGRhdGEsIG5vbmNlLCB0bywgdmFsdWUsIGFjY2Vzc0xpc3QsIGdhc1ByaWNlIH0gPSB0cmFuc2FjdGlvbjtcXG4gICAgYXNzZXJ0VHJhbnNhY3Rpb25FSVAyOTMwKHRyYW5zYWN0aW9uKTtcXG4gICAgY29uc3Qgc2VyaWFsaXplZEFjY2Vzc0xpc3QgPSBzZXJpYWxpemVBY2Nlc3NMaXN0KGFjY2Vzc0xpc3QpO1xcbiAgICBjb25zdCBzZXJpYWxpemVkVHJhbnNhY3Rpb24gPSBbXFxuICAgICAgdG9IZXgoY2hhaW5JZCksXFxuICAgICAgbm9uY2UgPyB0b0hleChub25jZSkgOiBcIjB4XCIsXFxuICAgICAgZ2FzUHJpY2UgPyB0b0hleChnYXNQcmljZSkgOiBcIjB4XCIsXFxuICAgICAgZ2FzID8gdG9IZXgoZ2FzKSA6IFwiMHhcIixcXG4gICAgICB0byA/PyBcIjB4XCIsXFxuICAgICAgdmFsdWUgPyB0b0hleCh2YWx1ZSkgOiBcIjB4XCIsXFxuICAgICAgZGF0YSA/PyBcIjB4XCIsXFxuICAgICAgc2VyaWFsaXplZEFjY2Vzc0xpc3QsXFxuICAgICAgLi4udG9ZUGFyaXR5U2lnbmF0dXJlQXJyYXkodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSlcXG4gICAgXTtcXG4gICAgcmV0dXJuIGNvbmNhdEhleChbXFxuICAgICAgXCIweDAxXCIsXFxuICAgICAgdG9SbHAoc2VyaWFsaXplZFRyYW5zYWN0aW9uKVxcbiAgICBdKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZVRyYW5zYWN0aW9uTGVnYWN5KHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpIHtcXG4gICAgY29uc3QgeyBjaGFpbklkID0gMCwgZ2FzLCBkYXRhLCBub25jZSwgdG8sIHZhbHVlLCBnYXNQcmljZSB9ID0gdHJhbnNhY3Rpb247XFxuICAgIGFzc2VydFRyYW5zYWN0aW9uTGVnYWN5KHRyYW5zYWN0aW9uKTtcXG4gICAgbGV0IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbiA9IFtcXG4gICAgICBub25jZSA/IHRvSGV4KG5vbmNlKSA6IFwiMHhcIixcXG4gICAgICBnYXNQcmljZSA/IHRvSGV4KGdhc1ByaWNlKSA6IFwiMHhcIixcXG4gICAgICBnYXMgPyB0b0hleChnYXMpIDogXCIweFwiLFxcbiAgICAgIHRvID8/IFwiMHhcIixcXG4gICAgICB2YWx1ZSA/IHRvSGV4KHZhbHVlKSA6IFwiMHhcIixcXG4gICAgICBkYXRhID8/IFwiMHhcIlxcbiAgICBdO1xcbiAgICBpZiAoc2lnbmF0dXJlKSB7XFxuICAgICAgY29uc3QgdiA9ICgoKSA9PiB7XFxuICAgICAgICBpZiAoc2lnbmF0dXJlLnYgPj0gMzVuKSB7XFxuICAgICAgICAgIGNvbnN0IGluZmVycmVkQ2hhaW5JZCA9IChzaWduYXR1cmUudiAtIDM1bikgLyAybjtcXG4gICAgICAgICAgaWYgKGluZmVycmVkQ2hhaW5JZCA+IDApXFxuICAgICAgICAgICAgcmV0dXJuIHNpZ25hdHVyZS52O1xcbiAgICAgICAgICByZXR1cm4gMjduICsgKHNpZ25hdHVyZS52ID09PSAzNW4gPyAwbiA6IDFuKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChjaGFpbklkID4gMClcXG4gICAgICAgICAgcmV0dXJuIEJpZ0ludChjaGFpbklkICogMikgKyBCaWdJbnQoMzVuICsgc2lnbmF0dXJlLnYgLSAyN24pO1xcbiAgICAgICAgY29uc3QgdjIgPSAyN24gKyAoc2lnbmF0dXJlLnYgPT09IDI3biA/IDBuIDogMW4pO1xcbiAgICAgICAgaWYgKHNpZ25hdHVyZS52ICE9PSB2MilcXG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRMZWdhY3lWRXJyb3IoeyB2OiBzaWduYXR1cmUudiB9KTtcXG4gICAgICAgIHJldHVybiB2MjtcXG4gICAgICB9KSgpO1xcbiAgICAgIGNvbnN0IHIgPSB0cmltKHNpZ25hdHVyZS5yKTtcXG4gICAgICBjb25zdCBzID0gdHJpbShzaWduYXR1cmUucyk7XFxuICAgICAgc2VyaWFsaXplZFRyYW5zYWN0aW9uID0gW1xcbiAgICAgICAgLi4uc2VyaWFsaXplZFRyYW5zYWN0aW9uLFxcbiAgICAgICAgdG9IZXgodiksXFxuICAgICAgICByID09PSBcIjB4MDBcIiA/IFwiMHhcIiA6IHIsXFxuICAgICAgICBzID09PSBcIjB4MDBcIiA/IFwiMHhcIiA6IHNcXG4gICAgICBdO1xcbiAgICB9IGVsc2UgaWYgKGNoYWluSWQgPiAwKSB7XFxuICAgICAgc2VyaWFsaXplZFRyYW5zYWN0aW9uID0gW1xcbiAgICAgICAgLi4uc2VyaWFsaXplZFRyYW5zYWN0aW9uLFxcbiAgICAgICAgdG9IZXgoY2hhaW5JZCksXFxuICAgICAgICBcIjB4XCIsXFxuICAgICAgICBcIjB4XCJcXG4gICAgICBdO1xcbiAgICB9XFxuICAgIHJldHVybiB0b1JscChzZXJpYWxpemVkVHJhbnNhY3Rpb24pO1xcbiAgfVxcbiAgZnVuY3Rpb24gdG9ZUGFyaXR5U2lnbmF0dXJlQXJyYXkodHJhbnNhY3Rpb24sIHNpZ25hdHVyZV8pIHtcXG4gICAgY29uc3Qgc2lnbmF0dXJlID0gc2lnbmF0dXJlXyA/PyB0cmFuc2FjdGlvbjtcXG4gICAgY29uc3QgeyB2LCB5UGFyaXR5IH0gPSBzaWduYXR1cmU7XFxuICAgIGlmICh0eXBlb2Ygc2lnbmF0dXJlLnIgPT09IFwidW5kZWZpbmVkXCIpXFxuICAgICAgcmV0dXJuIFtdO1xcbiAgICBpZiAodHlwZW9mIHNpZ25hdHVyZS5zID09PSBcInVuZGVmaW5lZFwiKVxcbiAgICAgIHJldHVybiBbXTtcXG4gICAgaWYgKHR5cGVvZiB2ID09PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB5UGFyaXR5ID09PSBcInVuZGVmaW5lZFwiKVxcbiAgICAgIHJldHVybiBbXTtcXG4gICAgY29uc3QgciA9IHRyaW0oc2lnbmF0dXJlLnIpO1xcbiAgICBjb25zdCBzID0gdHJpbShzaWduYXR1cmUucyk7XFxuICAgIGNvbnN0IHlQYXJpdHlfID0gKCgpID0+IHtcXG4gICAgICBpZiAodHlwZW9mIHlQYXJpdHkgPT09IFwibnVtYmVyXCIpXFxuICAgICAgICByZXR1cm4geVBhcml0eSA/IHRvSGV4KDEpIDogXCIweFwiO1xcbiAgICAgIGlmICh2ID09PSAwbilcXG4gICAgICAgIHJldHVybiBcIjB4XCI7XFxuICAgICAgaWYgKHYgPT09IDFuKVxcbiAgICAgICAgcmV0dXJuIHRvSGV4KDEpO1xcbiAgICAgIHJldHVybiB2ID09PSAyN24gPyBcIjB4XCIgOiB0b0hleCgxKTtcXG4gICAgfSkoKTtcXG4gICAgcmV0dXJuIFt5UGFyaXR5XywgciA9PT0gXCIweDAwXCIgPyBcIjB4XCIgOiByLCBzID09PSBcIjB4MDBcIiA/IFwiMHhcIiA6IHNdO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvYXV0aG9yaXphdGlvbi9zZXJpYWxpemVBdXRob3JpemF0aW9uTGlzdC5qc1xcbiAgZnVuY3Rpb24gc2VyaWFsaXplQXV0aG9yaXphdGlvbkxpc3QoYXV0aG9yaXphdGlvbkxpc3QpIHtcXG4gICAgaWYgKCFhdXRob3JpemF0aW9uTGlzdCB8fCBhdXRob3JpemF0aW9uTGlzdC5sZW5ndGggPT09IDApXFxuICAgICAgcmV0dXJuIFtdO1xcbiAgICBjb25zdCBzZXJpYWxpemVkQXV0aG9yaXphdGlvbkxpc3QgPSBbXTtcXG4gICAgZm9yIChjb25zdCBhdXRob3JpemF0aW9uIG9mIGF1dGhvcml6YXRpb25MaXN0KSB7XFxuICAgICAgY29uc3QgeyBjaGFpbklkLCBub25jZSwgLi4uc2lnbmF0dXJlIH0gPSBhdXRob3JpemF0aW9uO1xcbiAgICAgIGNvbnN0IGNvbnRyYWN0QWRkcmVzcyA9IGF1dGhvcml6YXRpb24uYWRkcmVzcztcXG4gICAgICBzZXJpYWxpemVkQXV0aG9yaXphdGlvbkxpc3QucHVzaChbXFxuICAgICAgICBjaGFpbklkID8gdG9IZXgoY2hhaW5JZCkgOiBcIjB4XCIsXFxuICAgICAgICBjb250cmFjdEFkZHJlc3MsXFxuICAgICAgICBub25jZSA/IHRvSGV4KG5vbmNlKSA6IFwiMHhcIixcXG4gICAgICAgIC4uLnRvWVBhcml0eVNpZ25hdHVyZUFycmF5KHt9LCBzaWduYXR1cmUpXFxuICAgICAgXSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHNlcmlhbGl6ZWRBdXRob3JpemF0aW9uTGlzdDtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2Zvcm1hdHRlcnMvdHJhbnNhY3Rpb25SZWNlaXB0LmpzXFxuICBpbml0X2Zyb21IZXgoKTtcXG4gIGluaXRfZm9ybWF0dGVyKCk7XFxuICB2YXIgcmVjZWlwdFN0YXR1c2VzID0ge1xcbiAgICBcIjB4MFwiOiBcInJldmVydGVkXCIsXFxuICAgIFwiMHgxXCI6IFwic3VjY2Vzc1wiXFxuICB9O1xcbiAgZnVuY3Rpb24gZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0KHRyYW5zYWN0aW9uUmVjZWlwdCkge1xcbiAgICBjb25zdCByZWNlaXB0ID0ge1xcbiAgICAgIC4uLnRyYW5zYWN0aW9uUmVjZWlwdCxcXG4gICAgICBibG9ja051bWJlcjogdHJhbnNhY3Rpb25SZWNlaXB0LmJsb2NrTnVtYmVyID8gQmlnSW50KHRyYW5zYWN0aW9uUmVjZWlwdC5ibG9ja051bWJlcikgOiBudWxsLFxcbiAgICAgIGNvbnRyYWN0QWRkcmVzczogdHJhbnNhY3Rpb25SZWNlaXB0LmNvbnRyYWN0QWRkcmVzcyA/IHRyYW5zYWN0aW9uUmVjZWlwdC5jb250cmFjdEFkZHJlc3MgOiBudWxsLFxcbiAgICAgIGN1bXVsYXRpdmVHYXNVc2VkOiB0cmFuc2FjdGlvblJlY2VpcHQuY3VtdWxhdGl2ZUdhc1VzZWQgPyBCaWdJbnQodHJhbnNhY3Rpb25SZWNlaXB0LmN1bXVsYXRpdmVHYXNVc2VkKSA6IG51bGwsXFxuICAgICAgZWZmZWN0aXZlR2FzUHJpY2U6IHRyYW5zYWN0aW9uUmVjZWlwdC5lZmZlY3RpdmVHYXNQcmljZSA/IEJpZ0ludCh0cmFuc2FjdGlvblJlY2VpcHQuZWZmZWN0aXZlR2FzUHJpY2UpIDogbnVsbCxcXG4gICAgICBnYXNVc2VkOiB0cmFuc2FjdGlvblJlY2VpcHQuZ2FzVXNlZCA/IEJpZ0ludCh0cmFuc2FjdGlvblJlY2VpcHQuZ2FzVXNlZCkgOiBudWxsLFxcbiAgICAgIGxvZ3M6IHRyYW5zYWN0aW9uUmVjZWlwdC5sb2dzID8gdHJhbnNhY3Rpb25SZWNlaXB0LmxvZ3MubWFwKChsb2cpID0+IGZvcm1hdExvZyhsb2cpKSA6IG51bGwsXFxuICAgICAgdG86IHRyYW5zYWN0aW9uUmVjZWlwdC50byA/IHRyYW5zYWN0aW9uUmVjZWlwdC50byA6IG51bGwsXFxuICAgICAgdHJhbnNhY3Rpb25JbmRleDogdHJhbnNhY3Rpb25SZWNlaXB0LnRyYW5zYWN0aW9uSW5kZXggPyBoZXhUb051bWJlcih0cmFuc2FjdGlvblJlY2VpcHQudHJhbnNhY3Rpb25JbmRleCkgOiBudWxsLFxcbiAgICAgIHN0YXR1czogdHJhbnNhY3Rpb25SZWNlaXB0LnN0YXR1cyA/IHJlY2VpcHRTdGF0dXNlc1t0cmFuc2FjdGlvblJlY2VpcHQuc3RhdHVzXSA6IG51bGwsXFxuICAgICAgdHlwZTogdHJhbnNhY3Rpb25SZWNlaXB0LnR5cGUgPyB0cmFuc2FjdGlvblR5cGVbdHJhbnNhY3Rpb25SZWNlaXB0LnR5cGVdIHx8IHRyYW5zYWN0aW9uUmVjZWlwdC50eXBlIDogbnVsbFxcbiAgICB9O1xcbiAgICBpZiAodHJhbnNhY3Rpb25SZWNlaXB0LmJsb2JHYXNQcmljZSlcXG4gICAgICByZWNlaXB0LmJsb2JHYXNQcmljZSA9IEJpZ0ludCh0cmFuc2FjdGlvblJlY2VpcHQuYmxvYkdhc1ByaWNlKTtcXG4gICAgaWYgKHRyYW5zYWN0aW9uUmVjZWlwdC5ibG9iR2FzVXNlZClcXG4gICAgICByZWNlaXB0LmJsb2JHYXNVc2VkID0gQmlnSW50KHRyYW5zYWN0aW9uUmVjZWlwdC5ibG9iR2FzVXNlZCk7XFxuICAgIHJldHVybiByZWNlaXB0O1xcbiAgfVxcbiAgdmFyIGRlZmluZVRyYW5zYWN0aW9uUmVjZWlwdCA9IC8qIEBfX1BVUkVfXyAqLyBkZWZpbmVGb3JtYXR0ZXIoXCJ0cmFuc2FjdGlvblJlY2VpcHRcIiwgZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0KTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL2luZGV4LmpzXFxuICBpbml0X2Zyb21IZXgoKTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL3NpZ25hdHVyZS9oYXNoTWVzc2FnZS5qc1xcbiAgaW5pdF9rZWNjYWsyNTYoKTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2NvbnN0YW50cy9zdHJpbmdzLmpzXFxuICB2YXIgcHJlc2lnbk1lc3NhZ2VQcmVmaXggPSBcIlx1MDAxOUV0aGVyZXVtIFNpZ25lZCBNZXNzYWdlOlxcXFxuXCI7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9zaWduYXR1cmUvdG9QcmVmaXhlZE1lc3NhZ2UuanNcXG4gIGluaXRfY29uY2F0KCk7XFxuICBpbml0X3NpemUoKTtcXG4gIGluaXRfdG9IZXgoKTtcXG4gIGZ1bmN0aW9uIHRvUHJlZml4ZWRNZXNzYWdlKG1lc3NhZ2VfKSB7XFxuICAgIGNvbnN0IG1lc3NhZ2UgPSAoKCkgPT4ge1xcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZV8gPT09IFwic3RyaW5nXCIpXFxuICAgICAgICByZXR1cm4gc3RyaW5nVG9IZXgobWVzc2FnZV8pO1xcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZV8ucmF3ID09PSBcInN0cmluZ1wiKVxcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VfLnJhdztcXG4gICAgICByZXR1cm4gYnl0ZXNUb0hleChtZXNzYWdlXy5yYXcpO1xcbiAgICB9KSgpO1xcbiAgICBjb25zdCBwcmVmaXggPSBzdHJpbmdUb0hleChgJHtwcmVzaWduTWVzc2FnZVByZWZpeH0ke3NpemUobWVzc2FnZSl9YCk7XFxuICAgIHJldHVybiBjb25jYXQoW3ByZWZpeCwgbWVzc2FnZV0pO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvc2lnbmF0dXJlL2hhc2hNZXNzYWdlLmpzXFxuICBmdW5jdGlvbiBoYXNoTWVzc2FnZShtZXNzYWdlLCB0b18pIHtcXG4gICAgcmV0dXJuIGtlY2NhazI1Nih0b1ByZWZpeGVkTWVzc2FnZShtZXNzYWdlKSwgdG9fKTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2NvbnN0YW50cy9ieXRlcy5qc1xcbiAgdmFyIGVyYzY0OTJNYWdpY0J5dGVzID0gXCIweDY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTI2NDkyNjQ5MjY0OTJcIjtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL3NpZ25hdHVyZS9pc0VyYzY0OTJTaWduYXR1cmUuanNcXG4gIGluaXRfc2xpY2UoKTtcXG4gIGZ1bmN0aW9uIGlzRXJjNjQ5MlNpZ25hdHVyZShzaWduYXR1cmUpIHtcXG4gICAgcmV0dXJuIHNsaWNlSGV4KHNpZ25hdHVyZSwgLTMyKSA9PT0gZXJjNjQ5Mk1hZ2ljQnl0ZXM7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS91dGlscy9zaWduYXR1cmUvc2VyaWFsaXplRXJjNjQ5MlNpZ25hdHVyZS5qc1xcbiAgaW5pdF9lbmNvZGVBYmlQYXJhbWV0ZXJzKCk7XFxuICBpbml0X2NvbmNhdCgpO1xcbiAgaW5pdF90b0J5dGVzKCk7XFxuICBmdW5jdGlvbiBzZXJpYWxpemVFcmM2NDkyU2lnbmF0dXJlKHBhcmFtZXRlcnMpIHtcXG4gICAgY29uc3QgeyBhZGRyZXNzLCBkYXRhLCBzaWduYXR1cmUsIHRvID0gXCJoZXhcIiB9ID0gcGFyYW1ldGVycztcXG4gICAgY29uc3Qgc2lnbmF0dXJlXyA9IGNvbmNhdEhleChbXFxuICAgICAgZW5jb2RlQWJpUGFyYW1ldGVycyhbeyB0eXBlOiBcImFkZHJlc3NcIiB9LCB7IHR5cGU6IFwiYnl0ZXNcIiB9LCB7IHR5cGU6IFwiYnl0ZXNcIiB9XSwgW2FkZHJlc3MsIGRhdGEsIHNpZ25hdHVyZV0pLFxcbiAgICAgIGVyYzY0OTJNYWdpY0J5dGVzXFxuICAgIF0pO1xcbiAgICBpZiAodG8gPT09IFwiaGV4XCIpXFxuICAgICAgcmV0dXJuIHNpZ25hdHVyZV87XFxuICAgIHJldHVybiBoZXhUb0J5dGVzKHNpZ25hdHVyZV8pO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvZm9ybWF0dGVycy9wcm9vZi5qc1xcbiAgZnVuY3Rpb24gZm9ybWF0U3RvcmFnZVByb29mKHN0b3JhZ2VQcm9vZikge1xcbiAgICByZXR1cm4gc3RvcmFnZVByb29mLm1hcCgocHJvb2YpID0+ICh7XFxuICAgICAgLi4ucHJvb2YsXFxuICAgICAgdmFsdWU6IEJpZ0ludChwcm9vZi52YWx1ZSlcXG4gICAgfSkpO1xcbiAgfVxcbiAgZnVuY3Rpb24gZm9ybWF0UHJvb2YocHJvb2YpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICAuLi5wcm9vZixcXG4gICAgICBiYWxhbmNlOiBwcm9vZi5iYWxhbmNlID8gQmlnSW50KHByb29mLmJhbGFuY2UpIDogdm9pZCAwLFxcbiAgICAgIG5vbmNlOiBwcm9vZi5ub25jZSA/IGhleFRvTnVtYmVyKHByb29mLm5vbmNlKSA6IHZvaWQgMCxcXG4gICAgICBzdG9yYWdlUHJvb2Y6IHByb29mLnN0b3JhZ2VQcm9vZiA/IGZvcm1hdFN0b3JhZ2VQcm9vZihwcm9vZi5zdG9yYWdlUHJvb2YpIDogdm9pZCAwXFxuICAgIH07XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL3B1YmxpYy9nZXRQcm9vZi5qc1xcbiAgYXN5bmMgZnVuY3Rpb24gZ2V0UHJvb2YoY2xpZW50LCB7IGFkZHJlc3MsIGJsb2NrTnVtYmVyLCBibG9ja1RhZzogYmxvY2tUYWdfLCBzdG9yYWdlS2V5cyB9KSB7XFxuICAgIGNvbnN0IGJsb2NrVGFnID0gYmxvY2tUYWdfID8/IFwibGF0ZXN0XCI7XFxuICAgIGNvbnN0IGJsb2NrTnVtYmVySGV4ID0gYmxvY2tOdW1iZXIgIT09IHZvaWQgMCA/IG51bWJlclRvSGV4KGJsb2NrTnVtYmVyKSA6IHZvaWQgMDtcXG4gICAgY29uc3QgcHJvb2YgPSBhd2FpdCBjbGllbnQucmVxdWVzdCh7XFxuICAgICAgbWV0aG9kOiBcImV0aF9nZXRQcm9vZlwiLFxcbiAgICAgIHBhcmFtczogW2FkZHJlc3MsIHN0b3JhZ2VLZXlzLCBibG9ja051bWJlckhleCB8fCBibG9ja1RhZ11cXG4gICAgfSk7XFxuICAgIHJldHVybiBmb3JtYXRQcm9vZihwcm9vZik7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL3B1YmxpYy9nZXRTdG9yYWdlQXQuanNcXG4gIGluaXRfdG9IZXgoKTtcXG4gIGFzeW5jIGZ1bmN0aW9uIGdldFN0b3JhZ2VBdChjbGllbnQsIHsgYWRkcmVzcywgYmxvY2tOdW1iZXIsIGJsb2NrVGFnID0gXCJsYXRlc3RcIiwgc2xvdCB9KSB7XFxuICAgIGNvbnN0IGJsb2NrTnVtYmVySGV4ID0gYmxvY2tOdW1iZXIgIT09IHZvaWQgMCA/IG51bWJlclRvSGV4KGJsb2NrTnVtYmVyKSA6IHZvaWQgMDtcXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IGNsaWVudC5yZXF1ZXN0KHtcXG4gICAgICBtZXRob2Q6IFwiZXRoX2dldFN0b3JhZ2VBdFwiLFxcbiAgICAgIHBhcmFtczogW2FkZHJlc3MsIHNsb3QsIGJsb2NrTnVtYmVySGV4IHx8IGJsb2NrVGFnXVxcbiAgICB9KTtcXG4gICAgcmV0dXJuIGRhdGE7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL3B1YmxpYy9nZXRUcmFuc2FjdGlvbi5qc1xcbiAgaW5pdF90cmFuc2FjdGlvbigpO1xcbiAgaW5pdF90b0hleCgpO1xcbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb24oY2xpZW50LCB7IGJsb2NrSGFzaCwgYmxvY2tOdW1iZXIsIGJsb2NrVGFnOiBibG9ja1RhZ18sIGhhc2g6IGhhc2gyLCBpbmRleDogaW5kZXgyIH0pIHtcXG4gICAgY29uc3QgYmxvY2tUYWcgPSBibG9ja1RhZ18gfHwgXCJsYXRlc3RcIjtcXG4gICAgY29uc3QgYmxvY2tOdW1iZXJIZXggPSBibG9ja051bWJlciAhPT0gdm9pZCAwID8gbnVtYmVyVG9IZXgoYmxvY2tOdW1iZXIpIDogdm9pZCAwO1xcbiAgICBsZXQgdHJhbnNhY3Rpb24gPSBudWxsO1xcbiAgICBpZiAoaGFzaDIpIHtcXG4gICAgICB0cmFuc2FjdGlvbiA9IGF3YWl0IGNsaWVudC5yZXF1ZXN0KHtcXG4gICAgICAgIG1ldGhvZDogXCJldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2hcIixcXG4gICAgICAgIHBhcmFtczogW2hhc2gyXVxcbiAgICAgIH0sIHsgZGVkdXBlOiB0cnVlIH0pO1xcbiAgICB9IGVsc2UgaWYgKGJsb2NrSGFzaCkge1xcbiAgICAgIHRyYW5zYWN0aW9uID0gYXdhaXQgY2xpZW50LnJlcXVlc3Qoe1xcbiAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRUcmFuc2FjdGlvbkJ5QmxvY2tIYXNoQW5kSW5kZXhcIixcXG4gICAgICAgIHBhcmFtczogW2Jsb2NrSGFzaCwgbnVtYmVyVG9IZXgoaW5kZXgyKV1cXG4gICAgICB9LCB7IGRlZHVwZTogdHJ1ZSB9KTtcXG4gICAgfSBlbHNlIGlmIChibG9ja051bWJlckhleCB8fCBibG9ja1RhZykge1xcbiAgICAgIHRyYW5zYWN0aW9uID0gYXdhaXQgY2xpZW50LnJlcXVlc3Qoe1xcbiAgICAgICAgbWV0aG9kOiBcImV0aF9nZXRUcmFuc2FjdGlvbkJ5QmxvY2tOdW1iZXJBbmRJbmRleFwiLFxcbiAgICAgICAgcGFyYW1zOiBbYmxvY2tOdW1iZXJIZXggfHwgYmxvY2tUYWcsIG51bWJlclRvSGV4KGluZGV4MildXFxuICAgICAgfSwgeyBkZWR1cGU6IEJvb2xlYW4oYmxvY2tOdW1iZXJIZXgpIH0pO1xcbiAgICB9XFxuICAgIGlmICghdHJhbnNhY3Rpb24pXFxuICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uTm90Rm91bmRFcnJvcih7XFxuICAgICAgICBibG9ja0hhc2gsXFxuICAgICAgICBibG9ja051bWJlcixcXG4gICAgICAgIGJsb2NrVGFnLFxcbiAgICAgICAgaGFzaDogaGFzaDIsXFxuICAgICAgICBpbmRleDogaW5kZXgyXFxuICAgICAgfSk7XFxuICAgIGNvbnN0IGZvcm1hdCA9IGNsaWVudC5jaGFpbj8uZm9ybWF0dGVycz8udHJhbnNhY3Rpb24/LmZvcm1hdCB8fCBmb3JtYXRUcmFuc2FjdGlvbjtcXG4gICAgcmV0dXJuIGZvcm1hdCh0cmFuc2FjdGlvbik7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL3B1YmxpYy9nZXRUcmFuc2FjdGlvbkNvbmZpcm1hdGlvbnMuanNcXG4gIGFzeW5jIGZ1bmN0aW9uIGdldFRyYW5zYWN0aW9uQ29uZmlybWF0aW9ucyhjbGllbnQsIHsgaGFzaDogaGFzaDIsIHRyYW5zYWN0aW9uUmVjZWlwdCB9KSB7XFxuICAgIGNvbnN0IFtibG9ja051bWJlciwgdHJhbnNhY3Rpb25dID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xcbiAgICAgIGdldEFjdGlvbihjbGllbnQsIGdldEJsb2NrTnVtYmVyLCBcImdldEJsb2NrTnVtYmVyXCIpKHt9KSxcXG4gICAgICBoYXNoMiA/IGdldEFjdGlvbihjbGllbnQsIGdldFRyYW5zYWN0aW9uLCBcImdldFRyYW5zYWN0aW9uXCIpKHsgaGFzaDogaGFzaDIgfSkgOiB2b2lkIDBcXG4gICAgXSk7XFxuICAgIGNvbnN0IHRyYW5zYWN0aW9uQmxvY2tOdW1iZXIgPSB0cmFuc2FjdGlvblJlY2VpcHQ/LmJsb2NrTnVtYmVyIHx8IHRyYW5zYWN0aW9uPy5ibG9ja051bWJlcjtcXG4gICAgaWYgKCF0cmFuc2FjdGlvbkJsb2NrTnVtYmVyKVxcbiAgICAgIHJldHVybiAwbjtcXG4gICAgcmV0dXJuIGJsb2NrTnVtYmVyIC0gdHJhbnNhY3Rpb25CbG9ja051bWJlciArIDFuO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vYWN0aW9ucy9wdWJsaWMvZ2V0VHJhbnNhY3Rpb25SZWNlaXB0LmpzXFxuICBpbml0X3RyYW5zYWN0aW9uKCk7XFxuICBhc3luYyBmdW5jdGlvbiBnZXRUcmFuc2FjdGlvblJlY2VpcHQoY2xpZW50LCB7IGhhc2g6IGhhc2gyIH0pIHtcXG4gICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IGNsaWVudC5yZXF1ZXN0KHtcXG4gICAgICBtZXRob2Q6IFwiZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdFwiLFxcbiAgICAgIHBhcmFtczogW2hhc2gyXVxcbiAgICB9LCB7IGRlZHVwZTogdHJ1ZSB9KTtcXG4gICAgaWYgKCFyZWNlaXB0KVxcbiAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvblJlY2VpcHROb3RGb3VuZEVycm9yKHsgaGFzaDogaGFzaDIgfSk7XFxuICAgIGNvbnN0IGZvcm1hdCA9IGNsaWVudC5jaGFpbj8uZm9ybWF0dGVycz8udHJhbnNhY3Rpb25SZWNlaXB0Py5mb3JtYXQgfHwgZm9ybWF0VHJhbnNhY3Rpb25SZWNlaXB0O1xcbiAgICByZXR1cm4gZm9ybWF0KHJlY2VpcHQpO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vYWN0aW9ucy9wdWJsaWMvbXVsdGljYWxsLmpzXFxuICBpbml0X2FiaXMoKTtcXG4gIGluaXRfYWJpKCk7XFxuICBpbml0X2Jhc2UoKTtcXG4gIGluaXRfY29udHJhY3QoKTtcXG4gIGluaXRfZGVjb2RlRnVuY3Rpb25SZXN1bHQoKTtcXG4gIGluaXRfZW5jb2RlRnVuY3Rpb25EYXRhKCk7XFxuICBpbml0X2dldENoYWluQ29udHJhY3RBZGRyZXNzKCk7XFxuICBhc3luYyBmdW5jdGlvbiBtdWx0aWNhbGwoY2xpZW50LCBwYXJhbWV0ZXJzKSB7XFxuICAgIGNvbnN0IHsgYWxsb3dGYWlsdXJlID0gdHJ1ZSwgYmF0Y2hTaXplOiBiYXRjaFNpemVfLCBibG9ja051bWJlciwgYmxvY2tUYWcsIG11bHRpY2FsbEFkZHJlc3M6IG11bHRpY2FsbEFkZHJlc3NfLCBzdGF0ZU92ZXJyaWRlIH0gPSBwYXJhbWV0ZXJzO1xcbiAgICBjb25zdCBjb250cmFjdHMyID0gcGFyYW1ldGVycy5jb250cmFjdHM7XFxuICAgIGNvbnN0IGJhdGNoU2l6ZSA9IGJhdGNoU2l6ZV8gPz8gKHR5cGVvZiBjbGllbnQuYmF0Y2g/Lm11bHRpY2FsbCA9PT0gXCJvYmplY3RcIiAmJiBjbGllbnQuYmF0Y2gubXVsdGljYWxsLmJhdGNoU2l6ZSB8fCAxMDI0KTtcXG4gICAgbGV0IG11bHRpY2FsbEFkZHJlc3MgPSBtdWx0aWNhbGxBZGRyZXNzXztcXG4gICAgaWYgKCFtdWx0aWNhbGxBZGRyZXNzKSB7XFxuICAgICAgaWYgKCFjbGllbnQuY2hhaW4pXFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjbGllbnQgY2hhaW4gbm90IGNvbmZpZ3VyZWQuIG11bHRpY2FsbEFkZHJlc3MgaXMgcmVxdWlyZWQuXCIpO1xcbiAgICAgIG11bHRpY2FsbEFkZHJlc3MgPSBnZXRDaGFpbkNvbnRyYWN0QWRkcmVzcyh7XFxuICAgICAgICBibG9ja051bWJlcixcXG4gICAgICAgIGNoYWluOiBjbGllbnQuY2hhaW4sXFxuICAgICAgICBjb250cmFjdDogXCJtdWx0aWNhbGwzXCJcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICBjb25zdCBjaHVua2VkQ2FsbHMgPSBbW11dO1xcbiAgICBsZXQgY3VycmVudENodW5rID0gMDtcXG4gICAgbGV0IGN1cnJlbnRDaHVua1NpemUgPSAwO1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRyYWN0czIubGVuZ3RoOyBpKyspIHtcXG4gICAgICBjb25zdCB7IGFiaTogYWJpMiwgYWRkcmVzcywgYXJncywgZnVuY3Rpb25OYW1lIH0gPSBjb250cmFjdHMyW2ldO1xcbiAgICAgIHRyeSB7XFxuICAgICAgICBjb25zdCBjYWxsRGF0YSA9IGVuY29kZUZ1bmN0aW9uRGF0YSh7IGFiaTogYWJpMiwgYXJncywgZnVuY3Rpb25OYW1lIH0pO1xcbiAgICAgICAgY3VycmVudENodW5rU2l6ZSArPSAoY2FsbERhdGEubGVuZ3RoIC0gMikgLyAyO1xcbiAgICAgICAgaWYgKFxcbiAgICAgICAgICAvLyBDaGVjayBpZiBiYXRjaGluZyBpcyBlbmFibGVkLlxcbiAgICAgICAgICBiYXRjaFNpemUgPiAwICYmIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIGJhdGNoIGV4Y2VlZHMgdGhlIHNpemUgbGltaXQuXFxuICAgICAgICAgIGN1cnJlbnRDaHVua1NpemUgPiBiYXRjaFNpemUgJiYgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgY2h1bmsgaXMgbm90IGFscmVhZHkgZW1wdHkuXFxuICAgICAgICAgIGNodW5rZWRDYWxsc1tjdXJyZW50Q2h1bmtdLmxlbmd0aCA+IDBcXG4gICAgICAgICkge1xcbiAgICAgICAgICBjdXJyZW50Q2h1bmsrKztcXG4gICAgICAgICAgY3VycmVudENodW5rU2l6ZSA9IChjYWxsRGF0YS5sZW5ndGggLSAyKSAvIDI7XFxuICAgICAgICAgIGNodW5rZWRDYWxsc1tjdXJyZW50Q2h1bmtdID0gW107XFxuICAgICAgICB9XFxuICAgICAgICBjaHVua2VkQ2FsbHNbY3VycmVudENodW5rXSA9IFtcXG4gICAgICAgICAgLi4uY2h1bmtlZENhbGxzW2N1cnJlbnRDaHVua10sXFxuICAgICAgICAgIHtcXG4gICAgICAgICAgICBhbGxvd0ZhaWx1cmU6IHRydWUsXFxuICAgICAgICAgICAgY2FsbERhdGEsXFxuICAgICAgICAgICAgdGFyZ2V0OiBhZGRyZXNzXFxuICAgICAgICAgIH1cXG4gICAgICAgIF07XFxuICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICBjb25zdCBlcnJvciA9IGdldENvbnRyYWN0RXJyb3IoZXJyLCB7XFxuICAgICAgICAgIGFiaTogYWJpMixcXG4gICAgICAgICAgYWRkcmVzcyxcXG4gICAgICAgICAgYXJncyxcXG4gICAgICAgICAgZG9jc1BhdGg6IFwiL2RvY3MvY29udHJhY3QvbXVsdGljYWxsXCIsXFxuICAgICAgICAgIGZ1bmN0aW9uTmFtZVxcbiAgICAgICAgfSk7XFxuICAgICAgICBpZiAoIWFsbG93RmFpbHVyZSlcXG4gICAgICAgICAgdGhyb3cgZXJyb3I7XFxuICAgICAgICBjaHVua2VkQ2FsbHNbY3VycmVudENodW5rXSA9IFtcXG4gICAgICAgICAgLi4uY2h1bmtlZENhbGxzW2N1cnJlbnRDaHVua10sXFxuICAgICAgICAgIHtcXG4gICAgICAgICAgICBhbGxvd0ZhaWx1cmU6IHRydWUsXFxuICAgICAgICAgICAgY2FsbERhdGE6IFwiMHhcIixcXG4gICAgICAgICAgICB0YXJnZXQ6IGFkZHJlc3NcXG4gICAgICAgICAgfVxcbiAgICAgICAgXTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgY29uc3QgYWdncmVnYXRlM1Jlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoY2h1bmtlZENhbGxzLm1hcCgoY2FsbHMpID0+IGdldEFjdGlvbihjbGllbnQsIHJlYWRDb250cmFjdCwgXCJyZWFkQ29udHJhY3RcIikoe1xcbiAgICAgIGFiaTogbXVsdGljYWxsM0FiaSxcXG4gICAgICBhZGRyZXNzOiBtdWx0aWNhbGxBZGRyZXNzLFxcbiAgICAgIGFyZ3M6IFtjYWxsc10sXFxuICAgICAgYmxvY2tOdW1iZXIsXFxuICAgICAgYmxvY2tUYWcsXFxuICAgICAgZnVuY3Rpb25OYW1lOiBcImFnZ3JlZ2F0ZTNcIixcXG4gICAgICBzdGF0ZU92ZXJyaWRlXFxuICAgIH0pKSk7XFxuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZ2dyZWdhdGUzUmVzdWx0cy5sZW5ndGg7IGkrKykge1xcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGFnZ3JlZ2F0ZTNSZXN1bHRzW2ldO1xcbiAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcInJlamVjdGVkXCIpIHtcXG4gICAgICAgIGlmICghYWxsb3dGYWlsdXJlKVxcbiAgICAgICAgICB0aHJvdyByZXN1bHQucmVhc29uO1xcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaHVua2VkQ2FsbHNbaV0ubGVuZ3RoOyBqKyspIHtcXG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHtcXG4gICAgICAgICAgICBzdGF0dXM6IFwiZmFpbHVyZVwiLFxcbiAgICAgICAgICAgIGVycm9yOiByZXN1bHQucmVhc29uLFxcbiAgICAgICAgICAgIHJlc3VsdDogdm9pZCAwXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgY29udGludWU7XFxuICAgICAgfVxcbiAgICAgIGNvbnN0IGFnZ3JlZ2F0ZTNSZXN1bHQgPSByZXN1bHQudmFsdWU7XFxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBhZ2dyZWdhdGUzUmVzdWx0Lmxlbmd0aDsgaisrKSB7XFxuICAgICAgICBjb25zdCB7IHJldHVybkRhdGEsIHN1Y2Nlc3MgfSA9IGFnZ3JlZ2F0ZTNSZXN1bHRbal07XFxuICAgICAgICBjb25zdCB7IGNhbGxEYXRhIH0gPSBjaHVua2VkQ2FsbHNbaV1bal07XFxuICAgICAgICBjb25zdCB7IGFiaTogYWJpMiwgYWRkcmVzcywgZnVuY3Rpb25OYW1lLCBhcmdzIH0gPSBjb250cmFjdHMyW3Jlc3VsdHMubGVuZ3RoXTtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIGlmIChjYWxsRGF0YSA9PT0gXCIweFwiKVxcbiAgICAgICAgICAgIHRocm93IG5ldyBBYmlEZWNvZGluZ1plcm9EYXRhRXJyb3IoKTtcXG4gICAgICAgICAgaWYgKCFzdWNjZXNzKVxcbiAgICAgICAgICAgIHRocm93IG5ldyBSYXdDb250cmFjdEVycm9yKHsgZGF0YTogcmV0dXJuRGF0YSB9KTtcXG4gICAgICAgICAgY29uc3QgcmVzdWx0MiA9IGRlY29kZUZ1bmN0aW9uUmVzdWx0KHtcXG4gICAgICAgICAgICBhYmk6IGFiaTIsXFxuICAgICAgICAgICAgYXJncyxcXG4gICAgICAgICAgICBkYXRhOiByZXR1cm5EYXRhLFxcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgcmVzdWx0cy5wdXNoKGFsbG93RmFpbHVyZSA/IHsgcmVzdWx0OiByZXN1bHQyLCBzdGF0dXM6IFwic3VjY2Vzc1wiIH0gOiByZXN1bHQyKTtcXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgICAgICBjb25zdCBlcnJvciA9IGdldENvbnRyYWN0RXJyb3IoZXJyLCB7XFxuICAgICAgICAgICAgYWJpOiBhYmkyLFxcbiAgICAgICAgICAgIGFkZHJlc3MsXFxuICAgICAgICAgICAgYXJncyxcXG4gICAgICAgICAgICBkb2NzUGF0aDogXCIvZG9jcy9jb250cmFjdC9tdWx0aWNhbGxcIixcXG4gICAgICAgICAgICBmdW5jdGlvbk5hbWVcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIGlmICghYWxsb3dGYWlsdXJlKVxcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xcbiAgICAgICAgICByZXN1bHRzLnB1c2goeyBlcnJvciwgcmVzdWx0OiB2b2lkIDAsIHN0YXR1czogXCJmYWlsdXJlXCIgfSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGlmIChyZXN1bHRzLmxlbmd0aCAhPT0gY29udHJhY3RzMi5sZW5ndGgpXFxuICAgICAgdGhyb3cgbmV3IEJhc2VFcnJvcjIoXCJtdWx0aWNhbGwgcmVzdWx0cyBtaXNtYXRjaFwiKTtcXG4gICAgcmV0dXJuIHJlc3VsdHM7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS9veEAwLjYuOV90eXBlc2NyaXB0QDUuOC4zX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL294L19lc20vY29yZS92ZXJzaW9uLmpzXFxuICB2YXIgdmVyc2lvbjMgPSBcIjAuMS4xXCI7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS9veEAwLjYuOV90eXBlc2NyaXB0QDUuOC4zX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9lcnJvcnMuanNcXG4gIGZ1bmN0aW9uIGdldFZlcnNpb24oKSB7XFxuICAgIHJldHVybiB2ZXJzaW9uMztcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL294QDAuNi45X3R5cGVzY3JpcHRANS44LjNfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0Vycm9ycy5qc1xcbiAgdmFyIEJhc2VFcnJvcjMgPSBjbGFzcyBfQmFzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xcbiAgICBjb25zdHJ1Y3RvcihzaG9ydE1lc3NhZ2UsIG9wdGlvbnMgPSB7fSkge1xcbiAgICAgIGNvbnN0IGRldGFpbHMgPSAoKCkgPT4ge1xcbiAgICAgICAgaWYgKG9wdGlvbnMuY2F1c2UgaW5zdGFuY2VvZiBfQmFzZUVycm9yKSB7XFxuICAgICAgICAgIGlmIChvcHRpb25zLmNhdXNlLmRldGFpbHMpXFxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY2F1c2UuZGV0YWlscztcXG4gICAgICAgICAgaWYgKG9wdGlvbnMuY2F1c2Uuc2hvcnRNZXNzYWdlKVxcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmNhdXNlLnNob3J0TWVzc2FnZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChvcHRpb25zLmNhdXNlPy5tZXNzYWdlKVxcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jYXVzZS5tZXNzYWdlO1xcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGV0YWlscztcXG4gICAgICB9KSgpO1xcbiAgICAgIGNvbnN0IGRvY3NQYXRoOCA9ICgoKSA9PiB7XFxuICAgICAgICBpZiAob3B0aW9ucy5jYXVzZSBpbnN0YW5jZW9mIF9CYXNlRXJyb3IpXFxuICAgICAgICAgIHJldHVybiBvcHRpb25zLmNhdXNlLmRvY3NQYXRoIHx8IG9wdGlvbnMuZG9jc1BhdGg7XFxuICAgICAgICByZXR1cm4gb3B0aW9ucy5kb2NzUGF0aDtcXG4gICAgICB9KSgpO1xcbiAgICAgIGNvbnN0IGRvY3NCYXNlVXJsID0gXCJodHRwczovL294bGliLnNoXCI7XFxuICAgICAgY29uc3QgZG9jcyA9IGAke2RvY3NCYXNlVXJsfSR7ZG9jc1BhdGg4ID8/IFwiXCJ9YDtcXG4gICAgICBjb25zdCBtZXNzYWdlID0gW1xcbiAgICAgICAgc2hvcnRNZXNzYWdlIHx8IFwiQW4gZXJyb3Igb2NjdXJyZWQuXCIsXFxuICAgICAgICAuLi5vcHRpb25zLm1ldGFNZXNzYWdlcyA/IFtcIlwiLCAuLi5vcHRpb25zLm1ldGFNZXNzYWdlc10gOiBbXSxcXG4gICAgICAgIC4uLmRldGFpbHMgfHwgZG9jc1BhdGg4ID8gW1xcbiAgICAgICAgICBcIlwiLFxcbiAgICAgICAgICBkZXRhaWxzID8gYERldGFpbHM6ICR7ZGV0YWlsc31gIDogdm9pZCAwLFxcbiAgICAgICAgICBkb2NzUGF0aDggPyBgU2VlOiAke2RvY3N9YCA6IHZvaWQgMFxcbiAgICAgICAgXSA6IFtdXFxuICAgICAgXS5maWx0ZXIoKHgpID0+IHR5cGVvZiB4ID09PSBcInN0cmluZ1wiKS5qb2luKFwiXFxcXG5cIik7XFxuICAgICAgc3VwZXIobWVzc2FnZSwgb3B0aW9ucy5jYXVzZSA/IHsgY2F1c2U6IG9wdGlvbnMuY2F1c2UgfSA6IHZvaWQgMCk7XFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGV0YWlsc1wiLCB7XFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICB2YWx1ZTogdm9pZCAwXFxuICAgICAgfSk7XFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZG9jc1wiLCB7XFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICB2YWx1ZTogdm9pZCAwXFxuICAgICAgfSk7XFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZG9jc1BhdGhcIiwge1xcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgdmFsdWU6IHZvaWQgMFxcbiAgICAgIH0pO1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNob3J0TWVzc2FnZVwiLCB7XFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICB2YWx1ZTogdm9pZCAwXFxuICAgICAgfSk7XFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2F1c2VcIiwge1xcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgdmFsdWU6IHZvaWQgMFxcbiAgICAgIH0pO1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgdmFsdWU6IFwiQmFzZUVycm9yXCJcXG4gICAgICB9KTtcXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2ZXJzaW9uXCIsIHtcXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgIHZhbHVlOiBgb3hAJHtnZXRWZXJzaW9uKCl9YFxcbiAgICAgIH0pO1xcbiAgICAgIHRoaXMuY2F1c2UgPSBvcHRpb25zLmNhdXNlO1xcbiAgICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XFxuICAgICAgdGhpcy5kb2NzID0gZG9jcztcXG4gICAgICB0aGlzLmRvY3NQYXRoID0gZG9jc1BhdGg4O1xcbiAgICAgIHRoaXMuc2hvcnRNZXNzYWdlID0gc2hvcnRNZXNzYWdlO1xcbiAgICB9XFxuICAgIHdhbGsoZm4pIHtcXG4gICAgICByZXR1cm4gd2FsazIodGhpcywgZm4pO1xcbiAgICB9XFxuICB9O1xcbiAgZnVuY3Rpb24gd2FsazIoZXJyLCBmbikge1xcbiAgICBpZiAoZm4/LihlcnIpKVxcbiAgICAgIHJldHVybiBlcnI7XFxuICAgIGlmIChlcnIgJiYgdHlwZW9mIGVyciA9PT0gXCJvYmplY3RcIiAmJiBcImNhdXNlXCIgaW4gZXJyICYmIGVyci5jYXVzZSlcXG4gICAgICByZXR1cm4gd2FsazIoZXJyLmNhdXNlLCBmbik7XFxuICAgIHJldHVybiBmbiA/IG51bGwgOiBlcnI7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS9veEAwLjYuOV90eXBlc2NyaXB0QDUuOC4zX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9Kc29uLmpzXFxuICB2YXIgYmlnSW50U3VmZml4ID0gXCIjX19iaWdpbnRcIjtcXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeTIodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSkge1xcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIChrZXksIHZhbHVlMikgPT4ge1xcbiAgICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09IFwiZnVuY3Rpb25cIilcXG4gICAgICAgIHJldHVybiByZXBsYWNlcihrZXksIHZhbHVlMik7XFxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZTIgPT09IFwiYmlnaW50XCIpXFxuICAgICAgICByZXR1cm4gdmFsdWUyLnRvU3RyaW5nKCkgKyBiaWdJbnRTdWZmaXg7XFxuICAgICAgcmV0dXJuIHZhbHVlMjtcXG4gICAgfSwgc3BhY2UpO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vb3hAMC42LjlfdHlwZXNjcmlwdEA1LjguM196b2RAMy4yNC4zL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvYnl0ZXMuanNcXG4gIGZ1bmN0aW9uIGFzc2VydFNpemUyKGJ5dGVzLCBzaXplXykge1xcbiAgICBpZiAoc2l6ZTMoYnl0ZXMpID4gc2l6ZV8pXFxuICAgICAgdGhyb3cgbmV3IFNpemVPdmVyZmxvd0Vycm9yMih7XFxuICAgICAgICBnaXZlblNpemU6IHNpemUzKGJ5dGVzKSxcXG4gICAgICAgIG1heFNpemU6IHNpemVfXFxuICAgICAgfSk7XFxuICB9XFxuICB2YXIgY2hhckNvZGVNYXAyID0ge1xcbiAgICB6ZXJvOiA0OCxcXG4gICAgbmluZTogNTcsXFxuICAgIEE6IDY1LFxcbiAgICBGOiA3MCxcXG4gICAgYTogOTcsXFxuICAgIGY6IDEwMlxcbiAgfTtcXG4gIGZ1bmN0aW9uIGNoYXJDb2RlVG9CYXNlMTYyKGNoYXIpIHtcXG4gICAgaWYgKGNoYXIgPj0gY2hhckNvZGVNYXAyLnplcm8gJiYgY2hhciA8PSBjaGFyQ29kZU1hcDIubmluZSlcXG4gICAgICByZXR1cm4gY2hhciAtIGNoYXJDb2RlTWFwMi56ZXJvO1xcbiAgICBpZiAoY2hhciA+PSBjaGFyQ29kZU1hcDIuQSAmJiBjaGFyIDw9IGNoYXJDb2RlTWFwMi5GKVxcbiAgICAgIHJldHVybiBjaGFyIC0gKGNoYXJDb2RlTWFwMi5BIC0gMTApO1xcbiAgICBpZiAoY2hhciA+PSBjaGFyQ29kZU1hcDIuYSAmJiBjaGFyIDw9IGNoYXJDb2RlTWFwMi5mKVxcbiAgICAgIHJldHVybiBjaGFyIC0gKGNoYXJDb2RlTWFwMi5hIC0gMTApO1xcbiAgICByZXR1cm4gdm9pZCAwO1xcbiAgfVxcbiAgZnVuY3Rpb24gcGFkMihieXRlcywgb3B0aW9ucyA9IHt9KSB7XFxuICAgIGNvbnN0IHsgZGlyLCBzaXplOiBzaXplNSA9IDMyIH0gPSBvcHRpb25zO1xcbiAgICBpZiAoc2l6ZTUgPT09IDApXFxuICAgICAgcmV0dXJuIGJ5dGVzO1xcbiAgICBpZiAoYnl0ZXMubGVuZ3RoID4gc2l6ZTUpXFxuICAgICAgdGhyb3cgbmV3IFNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvcjIoe1xcbiAgICAgICAgc2l6ZTogYnl0ZXMubGVuZ3RoLFxcbiAgICAgICAgdGFyZ2V0U2l6ZTogc2l6ZTUsXFxuICAgICAgICB0eXBlOiBcIkJ5dGVzXCJcXG4gICAgICB9KTtcXG4gICAgY29uc3QgcGFkZGVkQnl0ZXMgPSBuZXcgVWludDhBcnJheShzaXplNSk7XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTU7IGkrKykge1xcbiAgICAgIGNvbnN0IHBhZEVuZCA9IGRpciA9PT0gXCJyaWdodFwiO1xcbiAgICAgIHBhZGRlZEJ5dGVzW3BhZEVuZCA/IGkgOiBzaXplNSAtIGkgLSAxXSA9IGJ5dGVzW3BhZEVuZCA/IGkgOiBieXRlcy5sZW5ndGggLSBpIC0gMV07XFxuICAgIH1cXG4gICAgcmV0dXJuIHBhZGRlZEJ5dGVzO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vb3hAMC42LjlfdHlwZXNjcmlwdEA1LjguM196b2RAMy4yNC4zL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvaW50ZXJuYWwvaGV4LmpzXFxuICBmdW5jdGlvbiBhc3NlcnRTaXplMyhoZXgsIHNpemVfKSB7XFxuICAgIGlmIChzaXplNChoZXgpID4gc2l6ZV8pXFxuICAgICAgdGhyb3cgbmV3IFNpemVPdmVyZmxvd0Vycm9yMyh7XFxuICAgICAgICBnaXZlblNpemU6IHNpemU0KGhleCksXFxuICAgICAgICBtYXhTaXplOiBzaXplX1xcbiAgICAgIH0pO1xcbiAgfVxcbiAgZnVuY3Rpb24gYXNzZXJ0U3RhcnRPZmZzZXQyKHZhbHVlLCBzdGFydCkge1xcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSBcIm51bWJlclwiICYmIHN0YXJ0ID4gMCAmJiBzdGFydCA+IHNpemU0KHZhbHVlKSAtIDEpXFxuICAgICAgdGhyb3cgbmV3IFNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcjMoe1xcbiAgICAgICAgb2Zmc2V0OiBzdGFydCxcXG4gICAgICAgIHBvc2l0aW9uOiBcInN0YXJ0XCIsXFxuICAgICAgICBzaXplOiBzaXplNCh2YWx1ZSlcXG4gICAgICB9KTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGFzc2VydEVuZE9mZnNldDIodmFsdWUsIHN0YXJ0LCBlbmQpIHtcXG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgZW5kID09PSBcIm51bWJlclwiICYmIHNpemU0KHZhbHVlKSAhPT0gZW5kIC0gc3RhcnQpIHtcXG4gICAgICB0aHJvdyBuZXcgU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yMyh7XFxuICAgICAgICBvZmZzZXQ6IGVuZCxcXG4gICAgICAgIHBvc2l0aW9uOiBcImVuZFwiLFxcbiAgICAgICAgc2l6ZTogc2l6ZTQodmFsdWUpXFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH1cXG4gIGZ1bmN0aW9uIHBhZDMoaGV4Xywgb3B0aW9ucyA9IHt9KSB7XFxuICAgIGNvbnN0IHsgZGlyLCBzaXplOiBzaXplNSA9IDMyIH0gPSBvcHRpb25zO1xcbiAgICBpZiAoc2l6ZTUgPT09IDApXFxuICAgICAgcmV0dXJuIGhleF87XFxuICAgIGNvbnN0IGhleCA9IGhleF8ucmVwbGFjZShcIjB4XCIsIFwiXCIpO1xcbiAgICBpZiAoaGV4Lmxlbmd0aCA+IHNpemU1ICogMilcXG4gICAgICB0aHJvdyBuZXcgU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yMyh7XFxuICAgICAgICBzaXplOiBNYXRoLmNlaWwoaGV4Lmxlbmd0aCAvIDIpLFxcbiAgICAgICAgdGFyZ2V0U2l6ZTogc2l6ZTUsXFxuICAgICAgICB0eXBlOiBcIkhleFwiXFxuICAgICAgfSk7XFxuICAgIHJldHVybiBgMHgke2hleFtkaXIgPT09IFwicmlnaHRcIiA/IFwicGFkRW5kXCIgOiBcInBhZFN0YXJ0XCJdKHNpemU1ICogMiwgXCIwXCIpfWA7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS9veEAwLjYuOV90eXBlc2NyaXB0QDUuOC4zX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9CeXRlcy5qc1xcbiAgdmFyIGVuY29kZXIzID0gLyogQF9fUFVSRV9fICovIG5ldyBUZXh0RW5jb2RlcigpO1xcbiAgZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxcbiAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIilcXG4gICAgICByZXR1cm4gZnJvbUhleDIodmFsdWUpO1xcbiAgICByZXR1cm4gZnJvbUFycmF5KHZhbHVlKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGZyb21BcnJheSh2YWx1ZSkge1xcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gdmFsdWUgOiBuZXcgVWludDhBcnJheSh2YWx1ZSk7XFxuICB9XFxuICBmdW5jdGlvbiBmcm9tSGV4Mih2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XFxuICAgIGNvbnN0IHsgc2l6ZTogc2l6ZTUgfSA9IG9wdGlvbnM7XFxuICAgIGxldCBoZXggPSB2YWx1ZTtcXG4gICAgaWYgKHNpemU1KSB7XFxuICAgICAgYXNzZXJ0U2l6ZTModmFsdWUsIHNpemU1KTtcXG4gICAgICBoZXggPSBwYWRSaWdodCh2YWx1ZSwgc2l6ZTUpO1xcbiAgICB9XFxuICAgIGxldCBoZXhTdHJpbmcgPSBoZXguc2xpY2UoMik7XFxuICAgIGlmIChoZXhTdHJpbmcubGVuZ3RoICUgMilcXG4gICAgICBoZXhTdHJpbmcgPSBgMCR7aGV4U3RyaW5nfWA7XFxuICAgIGNvbnN0IGxlbmd0aCA9IGhleFN0cmluZy5sZW5ndGggLyAyO1xcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XFxuICAgIGZvciAobGV0IGluZGV4MiA9IDAsIGogPSAwOyBpbmRleDIgPCBsZW5ndGg7IGluZGV4MisrKSB7XFxuICAgICAgY29uc3QgbmliYmxlTGVmdCA9IGNoYXJDb2RlVG9CYXNlMTYyKGhleFN0cmluZy5jaGFyQ29kZUF0KGorKykpO1xcbiAgICAgIGNvbnN0IG5pYmJsZVJpZ2h0ID0gY2hhckNvZGVUb0Jhc2UxNjIoaGV4U3RyaW5nLmNoYXJDb2RlQXQoaisrKSk7XFxuICAgICAgaWYgKG5pYmJsZUxlZnQgPT09IHZvaWQgMCB8fCBuaWJibGVSaWdodCA9PT0gdm9pZCAwKSB7XFxuICAgICAgICB0aHJvdyBuZXcgQmFzZUVycm9yMyhgSW52YWxpZCBieXRlIHNlcXVlbmNlIChcIiR7aGV4U3RyaW5nW2ogLSAyXX0ke2hleFN0cmluZ1tqIC0gMV19XCIgaW4gXCIke2hleFN0cmluZ31cIikuYCk7XFxuICAgICAgfVxcbiAgICAgIGJ5dGVzW2luZGV4Ml0gPSBuaWJibGVMZWZ0ICogMTYgKyBuaWJibGVSaWdodDtcXG4gICAgfVxcbiAgICByZXR1cm4gYnl0ZXM7XFxuICB9XFxuICBmdW5jdGlvbiBmcm9tU3RyaW5nKHZhbHVlLCBvcHRpb25zID0ge30pIHtcXG4gICAgY29uc3QgeyBzaXplOiBzaXplNSB9ID0gb3B0aW9ucztcXG4gICAgY29uc3QgYnl0ZXMgPSBlbmNvZGVyMy5lbmNvZGUodmFsdWUpO1xcbiAgICBpZiAodHlwZW9mIHNpemU1ID09PSBcIm51bWJlclwiKSB7XFxuICAgICAgYXNzZXJ0U2l6ZTIoYnl0ZXMsIHNpemU1KTtcXG4gICAgICByZXR1cm4gcGFkUmlnaHQyKGJ5dGVzLCBzaXplNSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIGJ5dGVzO1xcbiAgfVxcbiAgZnVuY3Rpb24gcGFkUmlnaHQyKHZhbHVlLCBzaXplNSkge1xcbiAgICByZXR1cm4gcGFkMih2YWx1ZSwgeyBkaXI6IFwicmlnaHRcIiwgc2l6ZTogc2l6ZTUgfSk7XFxuICB9XFxuICBmdW5jdGlvbiBzaXplMyh2YWx1ZSkge1xcbiAgICByZXR1cm4gdmFsdWUubGVuZ3RoO1xcbiAgfVxcbiAgdmFyIFNpemVPdmVyZmxvd0Vycm9yMiA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMyB7XFxuICAgIGNvbnN0cnVjdG9yKHsgZ2l2ZW5TaXplLCBtYXhTaXplIH0pIHtcXG4gICAgICBzdXBlcihgU2l6ZSBjYW5ub3QgZXhjZWVkIFxcXFxgJHttYXhTaXplfVxcXFxgIGJ5dGVzLiBHaXZlbiBzaXplOiBcXFxcYCR7Z2l2ZW5TaXplfVxcXFxgIGJ5dGVzLmApO1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgdmFsdWU6IFwiQnl0ZXMuU2l6ZU92ZXJmbG93RXJyb3JcIlxcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9O1xcbiAgdmFyIFNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvcjIgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjMge1xcbiAgICBjb25zdHJ1Y3Rvcih7IHNpemU6IHNpemU1LCB0YXJnZXRTaXplLCB0eXBlIH0pIHtcXG4gICAgICBzdXBlcihgJHt0eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpfSR7dHlwZS5zbGljZSgxKS50b0xvd2VyQ2FzZSgpfSBzaXplIChcXFxcYCR7c2l6ZTV9XFxcXGApIGV4Y2VlZHMgcGFkZGluZyBzaXplIChcXFxcYCR7dGFyZ2V0U2l6ZX1cXFxcYCkuYCk7XFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICB2YWx1ZTogXCJCeXRlcy5TaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3JcIlxcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9O1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vb3hAMC42LjlfdHlwZXNjcmlwdEA1LjguM196b2RAMy4yNC4zL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvSGV4LmpzXFxuICB2YXIgZW5jb2RlcjQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFRleHRFbmNvZGVyKCk7XFxuICB2YXIgaGV4ZXMzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoX3YsIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSk7XFxuICBmdW5jdGlvbiBhc3NlcnQodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xcbiAgICBjb25zdCB7IHN0cmljdCA9IGZhbHNlIH0gPSBvcHRpb25zO1xcbiAgICBpZiAoIXZhbHVlKVxcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkSGV4VHlwZUVycm9yKHZhbHVlKTtcXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIilcXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEhleFR5cGVFcnJvcih2YWx1ZSk7XFxuICAgIGlmIChzdHJpY3QpIHtcXG4gICAgICBpZiAoIS9eMHhbMC05YS1mQS1GXSokLy50ZXN0KHZhbHVlKSlcXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkSGV4VmFsdWVFcnJvcih2YWx1ZSk7XFxuICAgIH1cXG4gICAgaWYgKCF2YWx1ZS5zdGFydHNXaXRoKFwiMHhcIikpXFxuICAgICAgdGhyb3cgbmV3IEludmFsaWRIZXhWYWx1ZUVycm9yKHZhbHVlKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGNvbmNhdDIoLi4udmFsdWVzKSB7XFxuICAgIHJldHVybiBgMHgke3ZhbHVlcy5yZWR1Y2UoKGFjYywgeCkgPT4gYWNjICsgeC5yZXBsYWNlKFwiMHhcIiwgXCJcIiksIFwiXCIpfWA7XFxuICB9XFxuICBmdW5jdGlvbiBmcm9tQm9vbGVhbih2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XFxuICAgIGNvbnN0IGhleCA9IGAweCR7TnVtYmVyKHZhbHVlKX1gO1xcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuc2l6ZSA9PT0gXCJudW1iZXJcIikge1xcbiAgICAgIGFzc2VydFNpemUzKGhleCwgb3B0aW9ucy5zaXplKTtcXG4gICAgICByZXR1cm4gcGFkTGVmdChoZXgsIG9wdGlvbnMuc2l6ZSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIGhleDtcXG4gIH1cXG4gIGZ1bmN0aW9uIGZyb21CeXRlcyh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XFxuICAgIGxldCBzdHJpbmcgPSBcIlwiO1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKVxcbiAgICAgIHN0cmluZyArPSBoZXhlczNbdmFsdWVbaV1dO1xcbiAgICBjb25zdCBoZXggPSBgMHgke3N0cmluZ31gO1xcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuc2l6ZSA9PT0gXCJudW1iZXJcIikge1xcbiAgICAgIGFzc2VydFNpemUzKGhleCwgb3B0aW9ucy5zaXplKTtcXG4gICAgICByZXR1cm4gcGFkUmlnaHQoaGV4LCBvcHRpb25zLnNpemUpO1xcbiAgICB9XFxuICAgIHJldHVybiBoZXg7XFxuICB9XFxuICBmdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlLCBvcHRpb25zID0ge30pIHtcXG4gICAgY29uc3QgeyBzaWduZWQsIHNpemU6IHNpemU1IH0gPSBvcHRpb25zO1xcbiAgICBjb25zdCB2YWx1ZV8gPSBCaWdJbnQodmFsdWUpO1xcbiAgICBsZXQgbWF4VmFsdWU7XFxuICAgIGlmIChzaXplNSkge1xcbiAgICAgIGlmIChzaWduZWQpXFxuICAgICAgICBtYXhWYWx1ZSA9ICgxbiA8PCBCaWdJbnQoc2l6ZTUpICogOG4gLSAxbikgLSAxbjtcXG4gICAgICBlbHNlXFxuICAgICAgICBtYXhWYWx1ZSA9IDJuICoqIChCaWdJbnQoc2l6ZTUpICogOG4pIC0gMW47XFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XFxuICAgICAgbWF4VmFsdWUgPSBCaWdJbnQoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO1xcbiAgICB9XFxuICAgIGNvbnN0IG1pblZhbHVlID0gdHlwZW9mIG1heFZhbHVlID09PSBcImJpZ2ludFwiICYmIHNpZ25lZCA/IC1tYXhWYWx1ZSAtIDFuIDogMDtcXG4gICAgaWYgKG1heFZhbHVlICYmIHZhbHVlXyA+IG1heFZhbHVlIHx8IHZhbHVlXyA8IG1pblZhbHVlKSB7XFxuICAgICAgY29uc3Qgc3VmZml4ID0gdHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiID8gXCJuXCIgOiBcIlwiO1xcbiAgICAgIHRocm93IG5ldyBJbnRlZ2VyT3V0T2ZSYW5nZUVycm9yMih7XFxuICAgICAgICBtYXg6IG1heFZhbHVlID8gYCR7bWF4VmFsdWV9JHtzdWZmaXh9YCA6IHZvaWQgMCxcXG4gICAgICAgIG1pbjogYCR7bWluVmFsdWV9JHtzdWZmaXh9YCxcXG4gICAgICAgIHNpZ25lZCxcXG4gICAgICAgIHNpemU6IHNpemU1LFxcbiAgICAgICAgdmFsdWU6IGAke3ZhbHVlfSR7c3VmZml4fWBcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICBjb25zdCBzdHJpbmdWYWx1ZSA9IChzaWduZWQgJiYgdmFsdWVfIDwgMCA/ICgxbiA8PCBCaWdJbnQoc2l6ZTUgKiA4KSkgKyBCaWdJbnQodmFsdWVfKSA6IHZhbHVlXykudG9TdHJpbmcoMTYpO1xcbiAgICBjb25zdCBoZXggPSBgMHgke3N0cmluZ1ZhbHVlfWA7XFxuICAgIGlmIChzaXplNSlcXG4gICAgICByZXR1cm4gcGFkTGVmdChoZXgsIHNpemU1KTtcXG4gICAgcmV0dXJuIGhleDtcXG4gIH1cXG4gIGZ1bmN0aW9uIGZyb21TdHJpbmcyKHZhbHVlLCBvcHRpb25zID0ge30pIHtcXG4gICAgcmV0dXJuIGZyb21CeXRlcyhlbmNvZGVyNC5lbmNvZGUodmFsdWUpLCBvcHRpb25zKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIHBhZExlZnQodmFsdWUsIHNpemU1KSB7XFxuICAgIHJldHVybiBwYWQzKHZhbHVlLCB7IGRpcjogXCJsZWZ0XCIsIHNpemU6IHNpemU1IH0pO1xcbiAgfVxcbiAgZnVuY3Rpb24gcGFkUmlnaHQodmFsdWUsIHNpemU1KSB7XFxuICAgIHJldHVybiBwYWQzKHZhbHVlLCB7IGRpcjogXCJyaWdodFwiLCBzaXplOiBzaXplNSB9KTtcXG4gIH1cXG4gIGZ1bmN0aW9uIHNsaWNlMih2YWx1ZSwgc3RhcnQsIGVuZCwgb3B0aW9ucyA9IHt9KSB7XFxuICAgIGNvbnN0IHsgc3RyaWN0IH0gPSBvcHRpb25zO1xcbiAgICBhc3NlcnRTdGFydE9mZnNldDIodmFsdWUsIHN0YXJ0KTtcXG4gICAgY29uc3QgdmFsdWVfID0gYDB4JHt2YWx1ZS5yZXBsYWNlKFwiMHhcIiwgXCJcIikuc2xpY2UoKHN0YXJ0ID8/IDApICogMiwgKGVuZCA/PyB2YWx1ZS5sZW5ndGgpICogMil9YDtcXG4gICAgaWYgKHN0cmljdClcXG4gICAgICBhc3NlcnRFbmRPZmZzZXQyKHZhbHVlXywgc3RhcnQsIGVuZCk7XFxuICAgIHJldHVybiB2YWx1ZV87XFxuICB9XFxuICBmdW5jdGlvbiBzaXplNCh2YWx1ZSkge1xcbiAgICByZXR1cm4gTWF0aC5jZWlsKCh2YWx1ZS5sZW5ndGggLSAyKSAvIDIpO1xcbiAgfVxcbiAgZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xcbiAgICBjb25zdCB7IHN0cmljdCA9IGZhbHNlIH0gPSBvcHRpb25zO1xcbiAgICB0cnkge1xcbiAgICAgIGFzc2VydCh2YWx1ZSwgeyBzdHJpY3QgfSk7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH0gY2F0Y2gge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgfVxcbiAgdmFyIEludGVnZXJPdXRPZlJhbmdlRXJyb3IyID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IzIHtcXG4gICAgY29uc3RydWN0b3IoeyBtYXgsIG1pbiwgc2lnbmVkLCBzaXplOiBzaXplNSwgdmFsdWUgfSkge1xcbiAgICAgIHN1cGVyKGBOdW1iZXIgXFxcXGAke3ZhbHVlfVxcXFxgIGlzIG5vdCBpbiBzYWZlJHtzaXplNSA/IGAgJHtzaXplNSAqIDh9LWJpdGAgOiBcIlwifSR7c2lnbmVkID8gXCIgc2lnbmVkXCIgOiBcIiB1bnNpZ25lZFwifSBpbnRlZ2VyIHJhbmdlICR7bWF4ID8gYChcXFxcYCR7bWlufVxcXFxgIHRvIFxcXFxgJHttYXh9XFxcXGApYCA6IGAoYWJvdmUgXFxcXGAke21pbn1cXFxcYClgfWApO1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgdmFsdWU6IFwiSGV4LkludGVnZXJPdXRPZlJhbmdlRXJyb3JcIlxcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9O1xcbiAgdmFyIEludmFsaWRIZXhUeXBlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjMge1xcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xcbiAgICAgIHN1cGVyKGBWYWx1ZSBcXFxcYCR7dHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiID8gc3RyaW5naWZ5Mih2YWx1ZSkgOiB2YWx1ZX1cXFxcYCBvZiB0eXBlIFxcXFxgJHt0eXBlb2YgdmFsdWV9XFxcXGAgaXMgYW4gaW52YWxpZCBoZXggdHlwZS5gLCB7XFxuICAgICAgICBtZXRhTWVzc2FnZXM6IFtcXCdIZXggdHlwZXMgbXVzdCBiZSByZXByZXNlbnRlZCBhcyBgXCIweCR7c3RyaW5nfVwiYC5cXCddXFxuICAgICAgfSk7XFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICB2YWx1ZTogXCJIZXguSW52YWxpZEhleFR5cGVFcnJvclwiXFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH07XFxuICB2YXIgSW52YWxpZEhleFZhbHVlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjMge1xcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xcbiAgICAgIHN1cGVyKGBWYWx1ZSBcXFxcYCR7dmFsdWV9XFxcXGAgaXMgYW4gaW52YWxpZCBoZXggdmFsdWUuYCwge1xcbiAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXFxuICAgICAgICAgIFxcJ0hleCB2YWx1ZXMgbXVzdCBzdGFydCB3aXRoIGBcIjB4XCJgIGFuZCBjb250YWluIG9ubHkgaGV4YWRlY2ltYWwgY2hhcmFjdGVycyAoMC05LCBhLWYsIEEtRikuXFwnXFxuICAgICAgICBdXFxuICAgICAgfSk7XFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICB2YWx1ZTogXCJIZXguSW52YWxpZEhleFZhbHVlRXJyb3JcIlxcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9O1xcbiAgdmFyIFNpemVPdmVyZmxvd0Vycm9yMyA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMyB7XFxuICAgIGNvbnN0cnVjdG9yKHsgZ2l2ZW5TaXplLCBtYXhTaXplIH0pIHtcXG4gICAgICBzdXBlcihgU2l6ZSBjYW5ub3QgZXhjZWVkIFxcXFxgJHttYXhTaXplfVxcXFxgIGJ5dGVzLiBHaXZlbiBzaXplOiBcXFxcYCR7Z2l2ZW5TaXplfVxcXFxgIGJ5dGVzLmApO1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgdmFsdWU6IFwiSGV4LlNpemVPdmVyZmxvd0Vycm9yXCJcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfTtcXG4gIHZhciBTbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3IzID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IzIHtcXG4gICAgY29uc3RydWN0b3IoeyBvZmZzZXQsIHBvc2l0aW9uLCBzaXplOiBzaXplNSB9KSB7XFxuICAgICAgc3VwZXIoYFNsaWNlICR7cG9zaXRpb24gPT09IFwic3RhcnRcIiA/IFwic3RhcnRpbmdcIiA6IFwiZW5kaW5nXCJ9IGF0IG9mZnNldCBcXFxcYCR7b2Zmc2V0fVxcXFxgIGlzIG91dC1vZi1ib3VuZHMgKHNpemU6IFxcXFxgJHtzaXplNX1cXFxcYCkuYCk7XFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICB2YWx1ZTogXCJIZXguU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yXCJcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfTtcXG4gIHZhciBTaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3IzID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IzIHtcXG4gICAgY29uc3RydWN0b3IoeyBzaXplOiBzaXplNSwgdGFyZ2V0U2l6ZSwgdHlwZSB9KSB7XFxuICAgICAgc3VwZXIoYCR7dHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKX0ke3R5cGUuc2xpY2UoMSkudG9Mb3dlckNhc2UoKX0gc2l6ZSAoXFxcXGAke3NpemU1fVxcXFxgKSBleGNlZWRzIHBhZGRpbmcgc2l6ZSAoXFxcXGAke3RhcmdldFNpemV9XFxcXGApLmApO1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgdmFsdWU6IFwiSGV4LlNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvclwiXFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH07XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS9veEAwLjYuOV90eXBlc2NyaXB0QDUuOC4zX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9XaXRoZHJhd2FsLmpzXFxuICBmdW5jdGlvbiB0b1JwYyh3aXRoZHJhd2FsKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgYWRkcmVzczogd2l0aGRyYXdhbC5hZGRyZXNzLFxcbiAgICAgIGFtb3VudDogZnJvbU51bWJlcih3aXRoZHJhd2FsLmFtb3VudCksXFxuICAgICAgaW5kZXg6IGZyb21OdW1iZXIod2l0aGRyYXdhbC5pbmRleCksXFxuICAgICAgdmFsaWRhdG9ySW5kZXg6IGZyb21OdW1iZXIod2l0aGRyYXdhbC52YWxpZGF0b3JJbmRleClcXG4gICAgfTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL294QDAuNi45X3R5cGVzY3JpcHRANS44LjNfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0Jsb2NrT3ZlcnJpZGVzLmpzXFxuICBmdW5jdGlvbiB0b1JwYzIoYmxvY2tPdmVycmlkZXMpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICAuLi50eXBlb2YgYmxvY2tPdmVycmlkZXMuYmFzZUZlZVBlckdhcyA9PT0gXCJiaWdpbnRcIiAmJiB7XFxuICAgICAgICBiYXNlRmVlUGVyR2FzOiBmcm9tTnVtYmVyKGJsb2NrT3ZlcnJpZGVzLmJhc2VGZWVQZXJHYXMpXFxuICAgICAgfSxcXG4gICAgICAuLi50eXBlb2YgYmxvY2tPdmVycmlkZXMuYmxvYkJhc2VGZWUgPT09IFwiYmlnaW50XCIgJiYge1xcbiAgICAgICAgYmxvYkJhc2VGZWU6IGZyb21OdW1iZXIoYmxvY2tPdmVycmlkZXMuYmxvYkJhc2VGZWUpXFxuICAgICAgfSxcXG4gICAgICAuLi50eXBlb2YgYmxvY2tPdmVycmlkZXMuZmVlUmVjaXBpZW50ID09PSBcInN0cmluZ1wiICYmIHtcXG4gICAgICAgIGZlZVJlY2lwaWVudDogYmxvY2tPdmVycmlkZXMuZmVlUmVjaXBpZW50XFxuICAgICAgfSxcXG4gICAgICAuLi50eXBlb2YgYmxvY2tPdmVycmlkZXMuZ2FzTGltaXQgPT09IFwiYmlnaW50XCIgJiYge1xcbiAgICAgICAgZ2FzTGltaXQ6IGZyb21OdW1iZXIoYmxvY2tPdmVycmlkZXMuZ2FzTGltaXQpXFxuICAgICAgfSxcXG4gICAgICAuLi50eXBlb2YgYmxvY2tPdmVycmlkZXMubnVtYmVyID09PSBcImJpZ2ludFwiICYmIHtcXG4gICAgICAgIG51bWJlcjogZnJvbU51bWJlcihibG9ja092ZXJyaWRlcy5udW1iZXIpXFxuICAgICAgfSxcXG4gICAgICAuLi50eXBlb2YgYmxvY2tPdmVycmlkZXMucHJldlJhbmRhbyA9PT0gXCJiaWdpbnRcIiAmJiB7XFxuICAgICAgICBwcmV2UmFuZGFvOiBmcm9tTnVtYmVyKGJsb2NrT3ZlcnJpZGVzLnByZXZSYW5kYW8pXFxuICAgICAgfSxcXG4gICAgICAuLi50eXBlb2YgYmxvY2tPdmVycmlkZXMudGltZSA9PT0gXCJiaWdpbnRcIiAmJiB7XFxuICAgICAgICB0aW1lOiBmcm9tTnVtYmVyKGJsb2NrT3ZlcnJpZGVzLnRpbWUpXFxuICAgICAgfSxcXG4gICAgICAuLi5ibG9ja092ZXJyaWRlcy53aXRoZHJhd2FscyAmJiB7XFxuICAgICAgICB3aXRoZHJhd2FsczogYmxvY2tPdmVycmlkZXMud2l0aGRyYXdhbHMubWFwKHRvUnBjKVxcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjdGlvbnMvcHVibGljL3NpbXVsYXRlQmxvY2tzLmpzXFxuICBpbml0X3BhcnNlQWNjb3VudCgpO1xcbiAgaW5pdF9hYmkoKTtcXG4gIGluaXRfY29udHJhY3QoKTtcXG4gIGluaXRfbm9kZSgpO1xcbiAgaW5pdF9kZWNvZGVGdW5jdGlvblJlc3VsdCgpO1xcbiAgaW5pdF9lbmNvZGVGdW5jdGlvbkRhdGEoKTtcXG4gIGluaXRfdG9IZXgoKTtcXG4gIGluaXRfZ2V0Tm9kZUVycm9yKCk7XFxuICBpbml0X3RyYW5zYWN0aW9uUmVxdWVzdCgpO1xcbiAgaW5pdF9zdGF0ZU92ZXJyaWRlMigpO1xcbiAgaW5pdF9hc3NlcnRSZXF1ZXN0KCk7XFxuICBhc3luYyBmdW5jdGlvbiBzaW11bGF0ZUJsb2NrcyhjbGllbnQsIHBhcmFtZXRlcnMpIHtcXG4gICAgY29uc3QgeyBibG9ja051bWJlciwgYmxvY2tUYWcgPSBcImxhdGVzdFwiLCBibG9ja3MsIHJldHVybkZ1bGxUcmFuc2FjdGlvbnMsIHRyYWNlVHJhbnNmZXJzLCB2YWxpZGF0aW9uIH0gPSBwYXJhbWV0ZXJzO1xcbiAgICB0cnkge1xcbiAgICAgIGNvbnN0IGJsb2NrU3RhdGVDYWxscyA9IFtdO1xcbiAgICAgIGZvciAoY29uc3QgYmxvY2syIG9mIGJsb2Nrcykge1xcbiAgICAgICAgY29uc3QgYmxvY2tPdmVycmlkZXMgPSBibG9jazIuYmxvY2tPdmVycmlkZXMgPyB0b1JwYzIoYmxvY2syLmJsb2NrT3ZlcnJpZGVzKSA6IHZvaWQgMDtcXG4gICAgICAgIGNvbnN0IGNhbGxzID0gYmxvY2syLmNhbGxzLm1hcCgoY2FsbF8pID0+IHtcXG4gICAgICAgICAgY29uc3QgY2FsbDIgPSBjYWxsXztcXG4gICAgICAgICAgY29uc3QgYWNjb3VudCA9IGNhbGwyLmFjY291bnQgPyBwYXJzZUFjY291bnQoY2FsbDIuYWNjb3VudCkgOiB2b2lkIDA7XFxuICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XFxuICAgICAgICAgICAgLi4uY2FsbDIsXFxuICAgICAgICAgICAgZGF0YTogY2FsbDIuYWJpID8gZW5jb2RlRnVuY3Rpb25EYXRhKGNhbGwyKSA6IGNhbGwyLmRhdGEsXFxuICAgICAgICAgICAgZnJvbTogY2FsbDIuZnJvbSA/PyBhY2NvdW50Py5hZGRyZXNzXFxuICAgICAgICAgIH07XFxuICAgICAgICAgIGFzc2VydFJlcXVlc3QocmVxdWVzdCk7XFxuICAgICAgICAgIHJldHVybiBmb3JtYXRUcmFuc2FjdGlvblJlcXVlc3QocmVxdWVzdCk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIGNvbnN0IHN0YXRlT3ZlcnJpZGVzID0gYmxvY2syLnN0YXRlT3ZlcnJpZGVzID8gc2VyaWFsaXplU3RhdGVPdmVycmlkZShibG9jazIuc3RhdGVPdmVycmlkZXMpIDogdm9pZCAwO1xcbiAgICAgICAgYmxvY2tTdGF0ZUNhbGxzLnB1c2goe1xcbiAgICAgICAgICBibG9ja092ZXJyaWRlcyxcXG4gICAgICAgICAgY2FsbHMsXFxuICAgICAgICAgIHN0YXRlT3ZlcnJpZGVzXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgICAgY29uc3QgYmxvY2tOdW1iZXJIZXggPSBibG9ja051bWJlciA/IG51bWJlclRvSGV4KGJsb2NrTnVtYmVyKSA6IHZvaWQgMDtcXG4gICAgICBjb25zdCBibG9jayA9IGJsb2NrTnVtYmVySGV4IHx8IGJsb2NrVGFnO1xcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNsaWVudC5yZXF1ZXN0KHtcXG4gICAgICAgIG1ldGhvZDogXCJldGhfc2ltdWxhdGVWMVwiLFxcbiAgICAgICAgcGFyYW1zOiBbXFxuICAgICAgICAgIHsgYmxvY2tTdGF0ZUNhbGxzLCByZXR1cm5GdWxsVHJhbnNhY3Rpb25zLCB0cmFjZVRyYW5zZmVycywgdmFsaWRhdGlvbiB9LFxcbiAgICAgICAgICBibG9ja1xcbiAgICAgICAgXVxcbiAgICAgIH0pO1xcbiAgICAgIHJldHVybiByZXN1bHQubWFwKChibG9jazIsIGkpID0+ICh7XFxuICAgICAgICAuLi5mb3JtYXRCbG9jayhibG9jazIpLFxcbiAgICAgICAgY2FsbHM6IGJsb2NrMi5jYWxscy5tYXAoKGNhbGwyLCBqKSA9PiB7XFxuICAgICAgICAgIGNvbnN0IHsgYWJpOiBhYmkyLCBhcmdzLCBmdW5jdGlvbk5hbWUsIHRvIH0gPSBibG9ja3NbaV0uY2FsbHNbal07XFxuICAgICAgICAgIGNvbnN0IGRhdGEgPSBjYWxsMi5lcnJvcj8uZGF0YSA/PyBjYWxsMi5yZXR1cm5EYXRhO1xcbiAgICAgICAgICBjb25zdCBnYXNVc2VkID0gQmlnSW50KGNhbGwyLmdhc1VzZWQpO1xcbiAgICAgICAgICBjb25zdCBsb2dzID0gY2FsbDIubG9ncz8ubWFwKChsb2cpID0+IGZvcm1hdExvZyhsb2cpKTtcXG4gICAgICAgICAgY29uc3Qgc3RhdHVzID0gY2FsbDIuc3RhdHVzID09PSBcIjB4MVwiID8gXCJzdWNjZXNzXCIgOiBcImZhaWx1cmVcIjtcXG4gICAgICAgICAgY29uc3QgcmVzdWx0MiA9IGFiaTIgJiYgc3RhdHVzID09PSBcInN1Y2Nlc3NcIiAmJiBkYXRhICE9PSBcIjB4XCIgPyBkZWNvZGVGdW5jdGlvblJlc3VsdCh7XFxuICAgICAgICAgICAgYWJpOiBhYmkyLFxcbiAgICAgICAgICAgIGRhdGEsXFxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lXFxuICAgICAgICAgIH0pIDogbnVsbDtcXG4gICAgICAgICAgY29uc3QgZXJyb3IgPSAoKCkgPT4ge1xcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09IFwic3VjY2Vzc1wiKVxcbiAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcXG4gICAgICAgICAgICBsZXQgZXJyb3IyID0gdm9pZCAwO1xcbiAgICAgICAgICAgIGlmIChjYWxsMi5lcnJvcj8uZGF0YSA9PT0gXCIweFwiKVxcbiAgICAgICAgICAgICAgZXJyb3IyID0gbmV3IEFiaURlY29kaW5nWmVyb0RhdGFFcnJvcigpO1xcbiAgICAgICAgICAgIGVsc2UgaWYgKGNhbGwyLmVycm9yKVxcbiAgICAgICAgICAgICAgZXJyb3IyID0gbmV3IFJhd0NvbnRyYWN0RXJyb3IoY2FsbDIuZXJyb3IpO1xcbiAgICAgICAgICAgIGlmICghZXJyb3IyKVxcbiAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcXG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29udHJhY3RFcnJvcihlcnJvcjIsIHtcXG4gICAgICAgICAgICAgIGFiaTogYWJpMiA/PyBbXSxcXG4gICAgICAgICAgICAgIGFkZHJlc3M6IHRvLFxcbiAgICAgICAgICAgICAgYXJncyxcXG4gICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lID8/IFwiPHVua25vd24+XCJcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfSkoKTtcXG4gICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICBkYXRhLFxcbiAgICAgICAgICAgIGdhc1VzZWQsXFxuICAgICAgICAgICAgbG9ncyxcXG4gICAgICAgICAgICBzdGF0dXMsXFxuICAgICAgICAgICAgLi4uc3RhdHVzID09PSBcInN1Y2Nlc3NcIiA/IHtcXG4gICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0MlxcbiAgICAgICAgICAgIH0gOiB7XFxuICAgICAgICAgICAgICBlcnJvclxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfTtcXG4gICAgICAgIH0pXFxuICAgICAgfSkpO1xcbiAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgY29uc3QgY2F1c2UgPSBlO1xcbiAgICAgIGNvbnN0IGVycm9yID0gZ2V0Tm9kZUVycm9yKGNhdXNlLCB7fSk7XFxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVW5rbm93bk5vZGVFcnJvcilcXG4gICAgICAgIHRocm93IGNhdXNlO1xcbiAgICAgIHRocm93IGVycm9yO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS9veEAwLjYuOV90eXBlc2NyaXB0QDUuOC4zX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BYmlJdGVtLmpzXFxuICBpbml0X2V4cG9ydHMoKTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStoYXNoZXNAMS43LjIvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanNcXG4gIGZ1bmN0aW9uIGFudW1iZXIyKG4pIHtcXG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwb3NpdGl2ZSBpbnRlZ2VyIGV4cGVjdGVkLCBnb3QgXCIgKyBuKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGlzQnl0ZXMzKGEpIHtcXG4gICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IEFycmF5QnVmZmVyLmlzVmlldyhhKSAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiVWludDhBcnJheVwiO1xcbiAgfVxcbiAgZnVuY3Rpb24gYWJ5dGVzMyhiLCAuLi5sZW5ndGhzKSB7XFxuICAgIGlmICghaXNCeXRlczMoYikpXFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVWludDhBcnJheSBleHBlY3RlZFwiKTtcXG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVWludDhBcnJheSBleHBlY3RlZCBvZiBsZW5ndGggXCIgKyBsZW5ndGhzICsgXCIsIGdvdCBsZW5ndGg9XCIgKyBiLmxlbmd0aCk7XFxuICB9XFxuICBmdW5jdGlvbiBhZXhpc3RzMihpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcXG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZFwiKTtcXG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZFwiKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGFvdXRwdXQyKG91dCwgaW5zdGFuY2UpIHtcXG4gICAgYWJ5dGVzMyhvdXQpO1xcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XFxuICAgIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgXCIgKyBtaW4pO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS9Abm9ibGUraGFzaGVzQDEuNy4yL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qc1xcbiAgZnVuY3Rpb24gdTMyMihhcnIpIHtcXG4gICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcXG4gIH1cXG4gIHZhciBpc0xFMiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsyODc0NTQwMjBdKS5idWZmZXIpWzBdID09PSA2OCkoKTtcXG4gIGZ1bmN0aW9uIGJ5dGVTd2FwMih3b3JkKSB7XFxuICAgIHJldHVybiB3b3JkIDw8IDI0ICYgNDI3ODE5MDA4MCB8IHdvcmQgPDwgOCAmIDE2NzExNjgwIHwgd29yZCA+Pj4gOCAmIDY1MjgwIHwgd29yZCA+Pj4gMjQgJiAyNTU7XFxuICB9XFxuICBmdW5jdGlvbiBieXRlU3dhcDMyMihhcnIpIHtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcXG4gICAgICBhcnJbaV0gPSBieXRlU3dhcDIoYXJyW2ldKTtcXG4gICAgfVxcbiAgfVxcbiAgdmFyIGhhc0hleEJ1aWx0aW4gPSAoXFxuICAgIC8vIEB0cy1pZ25vcmVcXG4gICAgdHlwZW9mIFVpbnQ4QXJyYXkuZnJvbShbXSkudG9IZXggPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgVWludDhBcnJheS5mcm9tSGV4ID09PSBcImZ1bmN0aW9uXCJcXG4gICk7XFxuICBmdW5jdGlvbiB1dGY4VG9CeXRlczMoc3RyKSB7XFxuICAgIGlmICh0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiKVxcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290IFwiICsgdHlwZW9mIHN0cik7XFxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7XFxuICB9XFxuICBmdW5jdGlvbiB0b0J5dGVzMyhkYXRhKSB7XFxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIilcXG4gICAgICBkYXRhID0gdXRmOFRvQnl0ZXMzKGRhdGEpO1xcbiAgICBhYnl0ZXMzKGRhdGEpO1xcbiAgICByZXR1cm4gZGF0YTtcXG4gIH1cXG4gIHZhciBIYXNoMiA9IGNsYXNzIHtcXG4gICAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXFxuICAgIGNsb25lKCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcXG4gICAgfVxcbiAgfTtcXG4gIGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcjIoaGFzaENvbnMpIHtcXG4gICAgY29uc3QgaGFzaEMgPSAobXNnKSA9PiBoYXNoQ29ucygpLnVwZGF0ZSh0b0J5dGVzMyhtc2cpKS5kaWdlc3QoKTtcXG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoKTtcXG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcXG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XFxuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zKCk7XFxuICAgIHJldHVybiBoYXNoQztcXG4gIH1cXG4gIGZ1bmN0aW9uIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzMihoYXNoQ29ucykge1xcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzMyhtc2cpKS5kaWdlc3QoKTtcXG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcXG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xcbiAgICByZXR1cm4gaGFzaEM7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS9Abm9ibGUraGFzaGVzQDEuNy4yL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fdTY0LmpzXFxuICB2YXIgVTMyX01BU0s2NDIgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIgKiogMzIgLSAxKTtcXG4gIHZhciBfMzJuMiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMzIpO1xcbiAgZnVuY3Rpb24gZnJvbUJpZzIobiwgbGUgPSBmYWxzZSkge1xcbiAgICBpZiAobGUpXFxuICAgICAgcmV0dXJuIHsgaDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0MiksIGw6IE51bWJlcihuID4+IF8zMm4yICYgVTMyX01BU0s2NDIpIH07XFxuICAgIHJldHVybiB7IGg6IE51bWJlcihuID4+IF8zMm4yICYgVTMyX01BU0s2NDIpIHwgMCwgbDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0MikgfCAwIH07XFxuICB9XFxuICBmdW5jdGlvbiBzcGxpdDIobHN0LCBsZSA9IGZhbHNlKSB7XFxuICAgIGxldCBBaCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcXG4gICAgbGV0IEFsID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKykge1xcbiAgICAgIGNvbnN0IHsgaCwgbCB9ID0gZnJvbUJpZzIobHN0W2ldLCBsZSk7XFxuICAgICAgW0FoW2ldLCBBbFtpXV0gPSBbaCwgbF07XFxuICAgIH1cXG4gICAgcmV0dXJuIFtBaCwgQWxdO1xcbiAgfVxcbiAgdmFyIHJvdGxTSDIgPSAoaCwgbCwgcykgPT4gaCA8PCBzIHwgbCA+Pj4gMzIgLSBzO1xcbiAgdmFyIHJvdGxTTDIgPSAoaCwgbCwgcykgPT4gbCA8PCBzIHwgaCA+Pj4gMzIgLSBzO1xcbiAgdmFyIHJvdGxCSDIgPSAoaCwgbCwgcykgPT4gbCA8PCBzIC0gMzIgfCBoID4+PiA2NCAtIHM7XFxuICB2YXIgcm90bEJMMiA9IChoLCBsLCBzKSA9PiBoIDw8IHMgLSAzMiB8IGwgPj4+IDY0IC0gcztcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStoYXNoZXNAMS43LjIvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTMuanNcXG4gIHZhciBTSEEzX1BJMiA9IFtdO1xcbiAgdmFyIFNIQTNfUk9UTDIgPSBbXTtcXG4gIHZhciBfU0hBM19JT1RBMiA9IFtdO1xcbiAgdmFyIF8wbjcgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDApO1xcbiAgdmFyIF8xbjcgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDEpO1xcbiAgdmFyIF8ybjYgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIpO1xcbiAgdmFyIF83bjIgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDcpO1xcbiAgdmFyIF8yNTZuMiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMjU2KTtcXG4gIHZhciBfMHg3MW4yID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgxMTMpO1xcbiAgZm9yIChsZXQgcm91bmQgPSAwLCBSID0gXzFuNywgeCA9IDEsIHkgPSAwOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XFxuICAgIFt4LCB5XSA9IFt5LCAoMiAqIHggKyAzICogeSkgJSA1XTtcXG4gICAgU0hBM19QSTIucHVzaCgyICogKDUgKiB5ICsgeCkpO1xcbiAgICBTSEEzX1JPVEwyLnB1c2goKHJvdW5kICsgMSkgKiAocm91bmQgKyAyKSAvIDIgJSA2NCk7XFxuICAgIGxldCB0ID0gXzBuNztcXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCA3OyBqKyspIHtcXG4gICAgICBSID0gKFIgPDwgXzFuNyBeIChSID4+IF83bjIpICogXzB4NzFuMikgJSBfMjU2bjI7XFxuICAgICAgaWYgKFIgJiBfMm42KVxcbiAgICAgICAgdCBePSBfMW43IDw8IChfMW43IDw8IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoaikpIC0gXzFuNztcXG4gICAgfVxcbiAgICBfU0hBM19JT1RBMi5wdXNoKHQpO1xcbiAgfVxcbiAgdmFyIFtTSEEzX0lPVEFfSDIsIFNIQTNfSU9UQV9MMl0gPSAvKiBAX19QVVJFX18gKi8gc3BsaXQyKF9TSEEzX0lPVEEyLCB0cnVlKTtcXG4gIHZhciByb3RsSDIgPSAoaCwgbCwgcykgPT4gcyA+IDMyID8gcm90bEJIMihoLCBsLCBzKSA6IHJvdGxTSDIoaCwgbCwgcyk7XFxuICB2YXIgcm90bEwyID0gKGgsIGwsIHMpID0+IHMgPiAzMiA/IHJvdGxCTDIoaCwgbCwgcykgOiByb3RsU0wyKGgsIGwsIHMpO1xcbiAgZnVuY3Rpb24ga2VjY2FrUDIocywgcm91bmRzID0gMjQpIHtcXG4gICAgY29uc3QgQiA9IG5ldyBVaW50MzJBcnJheSg1ICogMik7XFxuICAgIGZvciAobGV0IHJvdW5kID0gMjQgLSByb3VuZHM7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcXG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXFxuICAgICAgICBCW3hdID0gc1t4XSBeIHNbeCArIDEwXSBeIHNbeCArIDIwXSBeIHNbeCArIDMwXSBeIHNbeCArIDQwXTtcXG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4ICs9IDIpIHtcXG4gICAgICAgIGNvbnN0IGlkeDEgPSAoeCArIDgpICUgMTA7XFxuICAgICAgICBjb25zdCBpZHgwID0gKHggKyAyKSAlIDEwO1xcbiAgICAgICAgY29uc3QgQjAgPSBCW2lkeDBdO1xcbiAgICAgICAgY29uc3QgQjEgPSBCW2lkeDAgKyAxXTtcXG4gICAgICAgIGNvbnN0IFRoID0gcm90bEgyKEIwLCBCMSwgMSkgXiBCW2lkeDFdO1xcbiAgICAgICAgY29uc3QgVGwgPSByb3RsTDIoQjAsIEIxLCAxKSBeIEJbaWR4MSArIDFdO1xcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1MDsgeSArPSAxMCkge1xcbiAgICAgICAgICBzW3ggKyB5XSBePSBUaDtcXG4gICAgICAgICAgc1t4ICsgeSArIDFdIF49IFRsO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBsZXQgY3VySCA9IHNbMl07XFxuICAgICAgbGV0IGN1ckwgPSBzWzNdO1xcbiAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgMjQ7IHQrKykge1xcbiAgICAgICAgY29uc3Qgc2hpZnQgPSBTSEEzX1JPVEwyW3RdO1xcbiAgICAgICAgY29uc3QgVGggPSByb3RsSDIoY3VySCwgY3VyTCwgc2hpZnQpO1xcbiAgICAgICAgY29uc3QgVGwgPSByb3RsTDIoY3VySCwgY3VyTCwgc2hpZnQpO1xcbiAgICAgICAgY29uc3QgUEkgPSBTSEEzX1BJMlt0XTtcXG4gICAgICAgIGN1ckggPSBzW1BJXTtcXG4gICAgICAgIGN1ckwgPSBzW1BJICsgMV07XFxuICAgICAgICBzW1BJXSA9IFRoO1xcbiAgICAgICAgc1tQSSArIDFdID0gVGw7XFxuICAgICAgfVxcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcXG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcXG4gICAgICAgICAgQlt4XSA9IHNbeSArIHhdO1xcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxcbiAgICAgICAgICBzW3kgKyB4XSBePSB+QlsoeCArIDIpICUgMTBdICYgQlsoeCArIDQpICUgMTBdO1xcbiAgICAgIH1cXG4gICAgICBzWzBdIF49IFNIQTNfSU9UQV9IMltyb3VuZF07XFxuICAgICAgc1sxXSBePSBTSEEzX0lPVEFfTDJbcm91bmRdO1xcbiAgICB9XFxuICAgIEIuZmlsbCgwKTtcXG4gIH1cXG4gIHZhciBLZWNjYWsyID0gY2xhc3MgX0tlY2NhayBleHRlbmRzIEhhc2gyIHtcXG4gICAgLy8gTk9URTogd2UgYWNjZXB0IGFyZ3VtZW50cyBpbiBieXRlcyBpbnN0ZWFkIG9mIGJpdHMgaGVyZS5cXG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YgPSBmYWxzZSwgcm91bmRzID0gMjQpIHtcXG4gICAgICBzdXBlcigpO1xcbiAgICAgIHRoaXMucG9zID0gMDtcXG4gICAgICB0aGlzLnBvc091dCA9IDA7XFxuICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xcbiAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XFxuICAgICAgdGhpcy5lbmFibGVYT0YgPSBmYWxzZTtcXG4gICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XFxuICAgICAgdGhpcy5zdWZmaXggPSBzdWZmaXg7XFxuICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XFxuICAgICAgdGhpcy5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XFxuICAgICAgdGhpcy5yb3VuZHMgPSByb3VuZHM7XFxuICAgICAgYW51bWJlcjIob3V0cHV0TGVuKTtcXG4gICAgICBpZiAoMCA+PSB0aGlzLmJsb2NrTGVuIHx8IHRoaXMuYmxvY2tMZW4gPj0gMjAwKVxcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2hhMyBzdXBwb3J0cyBvbmx5IGtlY2Nhay1mMTYwMCBmdW5jdGlvblwiKTtcXG4gICAgICB0aGlzLnN0YXRlID0gbmV3IFVpbnQ4QXJyYXkoMjAwKTtcXG4gICAgICB0aGlzLnN0YXRlMzIgPSB1MzIyKHRoaXMuc3RhdGUpO1xcbiAgICB9XFxuICAgIGtlY2NhaygpIHtcXG4gICAgICBpZiAoIWlzTEUyKVxcbiAgICAgICAgYnl0ZVN3YXAzMjIodGhpcy5zdGF0ZTMyKTtcXG4gICAgICBrZWNjYWtQMih0aGlzLnN0YXRlMzIsIHRoaXMucm91bmRzKTtcXG4gICAgICBpZiAoIWlzTEUyKVxcbiAgICAgICAgYnl0ZVN3YXAzMjIodGhpcy5zdGF0ZTMyKTtcXG4gICAgICB0aGlzLnBvc091dCA9IDA7XFxuICAgICAgdGhpcy5wb3MgPSAwO1xcbiAgICB9XFxuICAgIHVwZGF0ZShkYXRhKSB7XFxuICAgICAgYWV4aXN0czIodGhpcyk7XFxuICAgICAgY29uc3QgeyBibG9ja0xlbiwgc3RhdGUgfSA9IHRoaXM7XFxuICAgICAgZGF0YSA9IHRvQnl0ZXMzKGRhdGEpO1xcbiAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xcbiAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjsgKSB7XFxuICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFrZTsgaSsrKVxcbiAgICAgICAgICBzdGF0ZVt0aGlzLnBvcysrXSBePSBkYXRhW3BvcysrXTtcXG4gICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pXFxuICAgICAgICAgIHRoaXMua2VjY2FrKCk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB0aGlzO1xcbiAgICB9XFxuICAgIGZpbmlzaCgpIHtcXG4gICAgICBpZiAodGhpcy5maW5pc2hlZClcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcXG4gICAgICBjb25zdCB7IHN0YXRlLCBzdWZmaXgsIHBvcywgYmxvY2tMZW4gfSA9IHRoaXM7XFxuICAgICAgc3RhdGVbcG9zXSBePSBzdWZmaXg7XFxuICAgICAgaWYgKChzdWZmaXggJiAxMjgpICE9PSAwICYmIHBvcyA9PT0gYmxvY2tMZW4gLSAxKVxcbiAgICAgICAgdGhpcy5rZWNjYWsoKTtcXG4gICAgICBzdGF0ZVtibG9ja0xlbiAtIDFdIF49IDEyODtcXG4gICAgICB0aGlzLmtlY2NhaygpO1xcbiAgICB9XFxuICAgIHdyaXRlSW50byhvdXQpIHtcXG4gICAgICBhZXhpc3RzMih0aGlzLCBmYWxzZSk7XFxuICAgICAgYWJ5dGVzMyhvdXQpO1xcbiAgICAgIHRoaXMuZmluaXNoKCk7XFxuICAgICAgY29uc3QgYnVmZmVyT3V0ID0gdGhpcy5zdGF0ZTtcXG4gICAgICBjb25zdCB7IGJsb2NrTGVuIH0gPSB0aGlzO1xcbiAgICAgIGZvciAobGV0IHBvcyA9IDAsIGxlbiA9IG91dC5sZW5ndGg7IHBvcyA8IGxlbjsgKSB7XFxuICAgICAgICBpZiAodGhpcy5wb3NPdXQgPj0gYmxvY2tMZW4pXFxuICAgICAgICAgIHRoaXMua2VjY2FrKCk7XFxuICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvc091dCwgbGVuIC0gcG9zKTtcXG4gICAgICAgIG91dC5zZXQoYnVmZmVyT3V0LnN1YmFycmF5KHRoaXMucG9zT3V0LCB0aGlzLnBvc091dCArIHRha2UpLCBwb3MpO1xcbiAgICAgICAgdGhpcy5wb3NPdXQgKz0gdGFrZTtcXG4gICAgICAgIHBvcyArPSB0YWtlO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gb3V0O1xcbiAgICB9XFxuICAgIHhvZkludG8ob3V0KSB7XFxuICAgICAgaWYgKCF0aGlzLmVuYWJsZVhPRilcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlhPRiBpcyBub3QgcG9zc2libGUgZm9yIHRoaXMgaW5zdGFuY2VcIik7XFxuICAgICAgcmV0dXJuIHRoaXMud3JpdGVJbnRvKG91dCk7XFxuICAgIH1cXG4gICAgeG9mKGJ5dGVzKSB7XFxuICAgICAgYW51bWJlcjIoYnl0ZXMpO1xcbiAgICAgIHJldHVybiB0aGlzLnhvZkludG8obmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKTtcXG4gICAgfVxcbiAgICBkaWdlc3RJbnRvKG91dCkge1xcbiAgICAgIGFvdXRwdXQyKG91dCwgdGhpcyk7XFxuICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaWdlc3QoKSB3YXMgYWxyZWFkeSBjYWxsZWRcIik7XFxuICAgICAgdGhpcy53cml0ZUludG8ob3V0KTtcXG4gICAgICB0aGlzLmRlc3Ryb3koKTtcXG4gICAgICByZXR1cm4gb3V0O1xcbiAgICB9XFxuICAgIGRpZ2VzdCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5kaWdlc3RJbnRvKG5ldyBVaW50OEFycmF5KHRoaXMub3V0cHV0TGVuKSk7XFxuICAgIH1cXG4gICAgZGVzdHJveSgpIHtcXG4gICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XFxuICAgICAgdGhpcy5zdGF0ZS5maWxsKDApO1xcbiAgICB9XFxuICAgIF9jbG9uZUludG8odG8pIHtcXG4gICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgcm91bmRzLCBlbmFibGVYT0YgfSA9IHRoaXM7XFxuICAgICAgdG8gfHwgKHRvID0gbmV3IF9LZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YsIHJvdW5kcykpO1xcbiAgICAgIHRvLnN0YXRlMzIuc2V0KHRoaXMuc3RhdGUzMik7XFxuICAgICAgdG8ucG9zID0gdGhpcy5wb3M7XFxuICAgICAgdG8ucG9zT3V0ID0gdGhpcy5wb3NPdXQ7XFxuICAgICAgdG8uZmluaXNoZWQgPSB0aGlzLmZpbmlzaGVkO1xcbiAgICAgIHRvLnJvdW5kcyA9IHJvdW5kcztcXG4gICAgICB0by5zdWZmaXggPSBzdWZmaXg7XFxuICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xcbiAgICAgIHRvLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcXG4gICAgICB0by5kZXN0cm95ZWQgPSB0aGlzLmRlc3Ryb3llZDtcXG4gICAgICByZXR1cm4gdG87XFxuICAgIH1cXG4gIH07XFxuICB2YXIgZ2VuMiA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+IHdyYXBDb25zdHJ1Y3RvcjIoKCkgPT4gbmV3IEtlY2NhazIoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuKSk7XFxuICB2YXIgc2hhM18yMjQyID0gLyogQF9fUFVSRV9fICovIGdlbjIoNiwgMTQ0LCAyMjQgLyA4KTtcXG4gIHZhciBzaGEzXzI1NjIgPSAvKiBAX19QVVJFX18gKi8gZ2VuMig2LCAxMzYsIDI1NiAvIDgpO1xcbiAgdmFyIHNoYTNfMzg0MiA9IC8qIEBfX1BVUkVfXyAqLyBnZW4yKDYsIDEwNCwgMzg0IC8gOCk7XFxuICB2YXIgc2hhM181MTIyID0gLyogQF9fUFVSRV9fICovIGdlbjIoNiwgNzIsIDUxMiAvIDgpO1xcbiAgdmFyIGtlY2Nha18yMjQyID0gLyogQF9fUFVSRV9fICovIGdlbjIoMSwgMTQ0LCAyMjQgLyA4KTtcXG4gIHZhciBrZWNjYWtfMjU2MiA9IC8qIEBfX1BVUkVfXyAqLyBnZW4yKDEsIDEzNiwgMjU2IC8gOCk7XFxuICB2YXIga2VjY2FrXzM4NDIgPSAvKiBAX19QVVJFX18gKi8gZ2VuMigxLCAxMDQsIDM4NCAvIDgpO1xcbiAgdmFyIGtlY2Nha181MTIyID0gLyogQF9fUFVSRV9fICovIGdlbjIoMSwgNzIsIDUxMiAvIDgpO1xcbiAgdmFyIGdlblNoYWtlMiA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+IHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzMigob3B0cyA9IHt9KSA9PiBuZXcgS2VjY2FrMihibG9ja0xlbiwgc3VmZml4LCBvcHRzLmRrTGVuID09PSB2b2lkIDAgPyBvdXRwdXRMZW4gOiBvcHRzLmRrTGVuLCB0cnVlKSk7XFxuICB2YXIgc2hha2UxMjgyID0gLyogQF9fUFVSRV9fICovIGdlblNoYWtlMigzMSwgMTY4LCAxMjggLyA4KTtcXG4gIHZhciBzaGFrZTI1NjIgPSAvKiBAX19QVVJFX18gKi8gZ2VuU2hha2UyKDMxLCAxMzYsIDI1NiAvIDgpO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vb3hAMC42LjlfdHlwZXNjcmlwdEA1LjguM196b2RAMy4yNC4zL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvSGFzaC5qc1xcbiAgZnVuY3Rpb24ga2VjY2FrMjU2Mih2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XFxuICAgIGNvbnN0IHsgYXMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyBcIkhleFwiIDogXCJCeXRlc1wiIH0gPSBvcHRpb25zO1xcbiAgICBjb25zdCBieXRlcyA9IGtlY2Nha18yNTYyKGZyb20odmFsdWUpKTtcXG4gICAgaWYgKGFzID09PSBcIkJ5dGVzXCIpXFxuICAgICAgcmV0dXJuIGJ5dGVzO1xcbiAgICByZXR1cm4gZnJvbUJ5dGVzKGJ5dGVzKTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL294QDAuNi45X3R5cGVzY3JpcHRANS44LjNfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2xydS5qc1xcbiAgdmFyIExydU1hcDIgPSBjbGFzcyBleHRlbmRzIE1hcCB7XFxuICAgIGNvbnN0cnVjdG9yKHNpemU1KSB7XFxuICAgICAgc3VwZXIoKTtcXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhTaXplXCIsIHtcXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgIHZhbHVlOiB2b2lkIDBcXG4gICAgICB9KTtcXG4gICAgICB0aGlzLm1heFNpemUgPSBzaXplNTtcXG4gICAgfVxcbiAgICBnZXQoa2V5KSB7XFxuICAgICAgY29uc3QgdmFsdWUgPSBzdXBlci5nZXQoa2V5KTtcXG4gICAgICBpZiAoc3VwZXIuaGFzKGtleSkgJiYgdmFsdWUgIT09IHZvaWQgMCkge1xcbiAgICAgICAgdGhpcy5kZWxldGUoa2V5KTtcXG4gICAgICAgIHN1cGVyLnNldChrZXksIHZhbHVlKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICB9XFxuICAgIHNldChrZXksIHZhbHVlKSB7XFxuICAgICAgc3VwZXIuc2V0KGtleSwgdmFsdWUpO1xcbiAgICAgIGlmICh0aGlzLm1heFNpemUgJiYgdGhpcy5zaXplID4gdGhpcy5tYXhTaXplKSB7XFxuICAgICAgICBjb25zdCBmaXJzdEtleSA9IHRoaXMua2V5cygpLm5leHQoKS52YWx1ZTtcXG4gICAgICAgIGlmIChmaXJzdEtleSlcXG4gICAgICAgICAgdGhpcy5kZWxldGUoZmlyc3RLZXkpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gdGhpcztcXG4gICAgfVxcbiAgfTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL294QDAuNi45X3R5cGVzY3JpcHRANS44LjNfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0NhY2hlcy5qc1xcbiAgdmFyIGNhY2hlcyA9IHtcXG4gICAgY2hlY2tzdW06IC8qIEBfX1BVUkVfXyAqLyBuZXcgTHJ1TWFwMig4MTkyKVxcbiAgfTtcXG4gIHZhciBjaGVja3N1bSA9IGNhY2hlcy5jaGVja3N1bTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL294QDAuNi45X3R5cGVzY3JpcHRANS44LjNfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FkZHJlc3MuanNcXG4gIHZhciBhZGRyZXNzUmVnZXgyID0gL14weFthLWZBLUYwLTldezQwfSQvO1xcbiAgZnVuY3Rpb24gYXNzZXJ0Mih2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XFxuICAgIGNvbnN0IHsgc3RyaWN0ID0gdHJ1ZSB9ID0gb3B0aW9ucztcXG4gICAgaWYgKCFhZGRyZXNzUmVnZXgyLnRlc3QodmFsdWUpKVxcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yMih7XFxuICAgICAgICBhZGRyZXNzOiB2YWx1ZSxcXG4gICAgICAgIGNhdXNlOiBuZXcgSW52YWxpZElucHV0RXJyb3IoKVxcbiAgICAgIH0pO1xcbiAgICBpZiAoc3RyaWN0KSB7XFxuICAgICAgaWYgKHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IHZhbHVlKVxcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIGlmIChjaGVja3N1bTIodmFsdWUpICE9PSB2YWx1ZSlcXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yMih7XFxuICAgICAgICAgIGFkZHJlc3M6IHZhbHVlLFxcbiAgICAgICAgICBjYXVzZTogbmV3IEludmFsaWRDaGVja3N1bUVycm9yKClcXG4gICAgICAgIH0pO1xcbiAgICB9XFxuICB9XFxuICBmdW5jdGlvbiBjaGVja3N1bTIoYWRkcmVzcykge1xcbiAgICBpZiAoY2hlY2tzdW0uaGFzKGFkZHJlc3MpKVxcbiAgICAgIHJldHVybiBjaGVja3N1bS5nZXQoYWRkcmVzcyk7XFxuICAgIGFzc2VydDIoYWRkcmVzcywgeyBzdHJpY3Q6IGZhbHNlIH0pO1xcbiAgICBjb25zdCBoZXhBZGRyZXNzID0gYWRkcmVzcy5zdWJzdHJpbmcoMikudG9Mb3dlckNhc2UoKTtcXG4gICAgY29uc3QgaGFzaDIgPSBrZWNjYWsyNTYyKGZyb21TdHJpbmcoaGV4QWRkcmVzcyksIHsgYXM6IFwiQnl0ZXNcIiB9KTtcXG4gICAgY29uc3QgY2hhcmFjdGVycyA9IGhleEFkZHJlc3Muc3BsaXQoXCJcIik7XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDA7IGkgKz0gMikge1xcbiAgICAgIGlmIChoYXNoMltpID4+IDFdID4+IDQgPj0gOCAmJiBjaGFyYWN0ZXJzW2ldKSB7XFxuICAgICAgICBjaGFyYWN0ZXJzW2ldID0gY2hhcmFjdGVyc1tpXS50b1VwcGVyQ2FzZSgpO1xcbiAgICAgIH1cXG4gICAgICBpZiAoKGhhc2gyW2kgPj4gMV0gJiAxNSkgPj0gOCAmJiBjaGFyYWN0ZXJzW2kgKyAxXSkge1xcbiAgICAgICAgY2hhcmFjdGVyc1tpICsgMV0gPSBjaGFyYWN0ZXJzW2kgKyAxXS50b1VwcGVyQ2FzZSgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBjb25zdCByZXN1bHQgPSBgMHgke2NoYXJhY3RlcnMuam9pbihcIlwiKX1gO1xcbiAgICBjaGVja3N1bS5zZXQoYWRkcmVzcywgcmVzdWx0KTtcXG4gICAgcmV0dXJuIHJlc3VsdDtcXG4gIH1cXG4gIGZ1bmN0aW9uIHZhbGlkYXRlMihhZGRyZXNzLCBvcHRpb25zID0ge30pIHtcXG4gICAgY29uc3QgeyBzdHJpY3QgPSB0cnVlIH0gPSBvcHRpb25zID8/IHt9O1xcbiAgICB0cnkge1xcbiAgICAgIGFzc2VydDIoYWRkcmVzcywgeyBzdHJpY3QgfSk7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH0gY2F0Y2gge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgfVxcbiAgdmFyIEludmFsaWRBZGRyZXNzRXJyb3IyID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IzIHtcXG4gICAgY29uc3RydWN0b3IoeyBhZGRyZXNzLCBjYXVzZSB9KSB7XFxuICAgICAgc3VwZXIoYEFkZHJlc3MgXCIke2FkZHJlc3N9XCIgaXMgaW52YWxpZC5gLCB7XFxuICAgICAgICBjYXVzZVxcbiAgICAgIH0pO1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgdmFsdWU6IFwiQWRkcmVzcy5JbnZhbGlkQWRkcmVzc0Vycm9yXCJcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfTtcXG4gIHZhciBJbnZhbGlkSW5wdXRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMyB7XFxuICAgIGNvbnN0cnVjdG9yKCkge1xcbiAgICAgIHN1cGVyKFwiQWRkcmVzcyBpcyBub3QgYSAyMCBieXRlICg0MCBoZXhhZGVjaW1hbCBjaGFyYWN0ZXIpIHZhbHVlLlwiKTtcXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgIHZhbHVlOiBcIkFkZHJlc3MuSW52YWxpZElucHV0RXJyb3JcIlxcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9O1xcbiAgdmFyIEludmFsaWRDaGVja3N1bUVycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IzIHtcXG4gICAgY29uc3RydWN0b3IoKSB7XFxuICAgICAgc3VwZXIoXCJBZGRyZXNzIGRvZXMgbm90IG1hdGNoIGl0cyBjaGVja3N1bSBjb3VudGVycGFydC5cIik7XFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICB2YWx1ZTogXCJBZGRyZXNzLkludmFsaWRDaGVja3N1bUVycm9yXCJcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL294QDAuNi45X3R5cGVzY3JpcHRANS44LjNfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2FiaUl0ZW0uanNcXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVNpZ25hdHVyZTIoc2lnbmF0dXJlKSB7XFxuICAgIGxldCBhY3RpdmUgPSB0cnVlO1xcbiAgICBsZXQgY3VycmVudCA9IFwiXCI7XFxuICAgIGxldCBsZXZlbCA9IDA7XFxuICAgIGxldCByZXN1bHQgPSBcIlwiO1xcbiAgICBsZXQgdmFsaWQgPSBmYWxzZTtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWduYXR1cmUubGVuZ3RoOyBpKyspIHtcXG4gICAgICBjb25zdCBjaGFyID0gc2lnbmF0dXJlW2ldO1xcbiAgICAgIGlmIChbXCIoXCIsIFwiKVwiLCBcIixcIl0uaW5jbHVkZXMoY2hhcikpXFxuICAgICAgICBhY3RpdmUgPSB0cnVlO1xcbiAgICAgIGlmIChjaGFyID09PSBcIihcIilcXG4gICAgICAgIGxldmVsKys7XFxuICAgICAgaWYgKGNoYXIgPT09IFwiKVwiKVxcbiAgICAgICAgbGV2ZWwtLTtcXG4gICAgICBpZiAoIWFjdGl2ZSlcXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICAgIGlmIChsZXZlbCA9PT0gMCkge1xcbiAgICAgICAgaWYgKGNoYXIgPT09IFwiIFwiICYmIFtcImV2ZW50XCIsIFwiZnVuY3Rpb25cIiwgXCJlcnJvclwiLCBcIlwiXS5pbmNsdWRlcyhyZXN1bHQpKVxcbiAgICAgICAgICByZXN1bHQgPSBcIlwiO1xcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgIHJlc3VsdCArPSBjaGFyO1xcbiAgICAgICAgICBpZiAoY2hhciA9PT0gXCIpXCIpIHtcXG4gICAgICAgICAgICB2YWxpZCA9IHRydWU7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICAgIH1cXG4gICAgICBpZiAoY2hhciA9PT0gXCIgXCIpIHtcXG4gICAgICAgIGlmIChzaWduYXR1cmVbaSAtIDFdICE9PSBcIixcIiAmJiBjdXJyZW50ICE9PSBcIixcIiAmJiBjdXJyZW50ICE9PSBcIiwoXCIpIHtcXG4gICAgICAgICAgY3VycmVudCA9IFwiXCI7XFxuICAgICAgICAgIGFjdGl2ZSA9IGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgICAgY29udGludWU7XFxuICAgICAgfVxcbiAgICAgIHJlc3VsdCArPSBjaGFyO1xcbiAgICAgIGN1cnJlbnQgKz0gY2hhcjtcXG4gICAgfVxcbiAgICBpZiAoIXZhbGlkKVxcbiAgICAgIHRocm93IG5ldyBCYXNlRXJyb3IzKFwiVW5hYmxlIHRvIG5vcm1hbGl6ZSBzaWduYXR1cmUuXCIpO1xcbiAgICByZXR1cm4gcmVzdWx0O1xcbiAgfVxcbiAgZnVuY3Rpb24gaXNBcmdPZlR5cGUyKGFyZywgYWJpUGFyYW1ldGVyKSB7XFxuICAgIGNvbnN0IGFyZ1R5cGUgPSB0eXBlb2YgYXJnO1xcbiAgICBjb25zdCBhYmlQYXJhbWV0ZXJUeXBlID0gYWJpUGFyYW1ldGVyLnR5cGU7XFxuICAgIHN3aXRjaCAoYWJpUGFyYW1ldGVyVHlwZSkge1xcbiAgICAgIGNhc2UgXCJhZGRyZXNzXCI6XFxuICAgICAgICByZXR1cm4gdmFsaWRhdGUyKGFyZywgeyBzdHJpY3Q6IGZhbHNlIH0pO1xcbiAgICAgIGNhc2UgXCJib29sXCI6XFxuICAgICAgICByZXR1cm4gYXJnVHlwZSA9PT0gXCJib29sZWFuXCI7XFxuICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XFxuICAgICAgICByZXR1cm4gYXJnVHlwZSA9PT0gXCJzdHJpbmdcIjtcXG4gICAgICBjYXNlIFwic3RyaW5nXCI6XFxuICAgICAgICByZXR1cm4gYXJnVHlwZSA9PT0gXCJzdHJpbmdcIjtcXG4gICAgICBkZWZhdWx0OiB7XFxuICAgICAgICBpZiAoYWJpUGFyYW1ldGVyVHlwZSA9PT0gXCJ0dXBsZVwiICYmIFwiY29tcG9uZW50c1wiIGluIGFiaVBhcmFtZXRlcilcXG4gICAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoYWJpUGFyYW1ldGVyLmNvbXBvbmVudHMpLmV2ZXJ5KChjb21wb25lbnQsIGluZGV4MikgPT4ge1xcbiAgICAgICAgICAgIHJldHVybiBpc0FyZ09mVHlwZTIoT2JqZWN0LnZhbHVlcyhhcmcpW2luZGV4Ml0sIGNvbXBvbmVudCk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgaWYgKC9edT9pbnQoOHwxNnwyNHwzMnw0MHw0OHw1Nnw2NHw3Mnw4MHw4OHw5NnwxMDR8MTEyfDEyMHwxMjh8MTM2fDE0NHwxNTJ8MTYwfDE2OHwxNzZ8MTg0fDE5MnwyMDB8MjA4fDIxNnwyMjR8MjMyfDI0MHwyNDh8MjU2KT8kLy50ZXN0KGFiaVBhcmFtZXRlclR5cGUpKVxcbiAgICAgICAgICByZXR1cm4gYXJnVHlwZSA9PT0gXCJudW1iZXJcIiB8fCBhcmdUeXBlID09PSBcImJpZ2ludFwiO1xcbiAgICAgICAgaWYgKC9eYnl0ZXMoWzEtOV18MVswLTldfDJbMC05XXwzWzAtMl0pPyQvLnRlc3QoYWJpUGFyYW1ldGVyVHlwZSkpXFxuICAgICAgICAgIHJldHVybiBhcmdUeXBlID09PSBcInN0cmluZ1wiIHx8IGFyZyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XFxuICAgICAgICBpZiAoL1thLXpdK1sxLTldezAsM30oXFxcXFtbMC05XXswLH1cXFxcXSkrJC8udGVzdChhYmlQYXJhbWV0ZXJUeXBlKSkge1xcbiAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpICYmIGFyZy5ldmVyeSgoeCkgPT4gaXNBcmdPZlR5cGUyKHgsIHtcXG4gICAgICAgICAgICAuLi5hYmlQYXJhbWV0ZXIsXFxuICAgICAgICAgICAgLy8gUG9wIG9mZiBgW11gIG9yIGBbTV1gIGZyb20gZW5kIG9mIHR5cGVcXG4gICAgICAgICAgICB0eXBlOiBhYmlQYXJhbWV0ZXJUeXBlLnJlcGxhY2UoLyhcXFxcW1swLTldezAsfVxcXFxdKSQvLCBcIlwiKVxcbiAgICAgICAgICB9KSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuICBmdW5jdGlvbiBnZXRBbWJpZ3VvdXNUeXBlczIoc291cmNlUGFyYW1ldGVycywgdGFyZ2V0UGFyYW1ldGVycywgYXJncykge1xcbiAgICBmb3IgKGNvbnN0IHBhcmFtZXRlckluZGV4IGluIHNvdXJjZVBhcmFtZXRlcnMpIHtcXG4gICAgICBjb25zdCBzb3VyY2VQYXJhbWV0ZXIgPSBzb3VyY2VQYXJhbWV0ZXJzW3BhcmFtZXRlckluZGV4XTtcXG4gICAgICBjb25zdCB0YXJnZXRQYXJhbWV0ZXIgPSB0YXJnZXRQYXJhbWV0ZXJzW3BhcmFtZXRlckluZGV4XTtcXG4gICAgICBpZiAoc291cmNlUGFyYW1ldGVyLnR5cGUgPT09IFwidHVwbGVcIiAmJiB0YXJnZXRQYXJhbWV0ZXIudHlwZSA9PT0gXCJ0dXBsZVwiICYmIFwiY29tcG9uZW50c1wiIGluIHNvdXJjZVBhcmFtZXRlciAmJiBcImNvbXBvbmVudHNcIiBpbiB0YXJnZXRQYXJhbWV0ZXIpXFxuICAgICAgICByZXR1cm4gZ2V0QW1iaWd1b3VzVHlwZXMyKHNvdXJjZVBhcmFtZXRlci5jb21wb25lbnRzLCB0YXJnZXRQYXJhbWV0ZXIuY29tcG9uZW50cywgYXJnc1twYXJhbWV0ZXJJbmRleF0pO1xcbiAgICAgIGNvbnN0IHR5cGVzID0gW3NvdXJjZVBhcmFtZXRlci50eXBlLCB0YXJnZXRQYXJhbWV0ZXIudHlwZV07XFxuICAgICAgY29uc3QgYW1iaWd1b3VzID0gKCgpID0+IHtcXG4gICAgICAgIGlmICh0eXBlcy5pbmNsdWRlcyhcImFkZHJlc3NcIikgJiYgdHlwZXMuaW5jbHVkZXMoXCJieXRlczIwXCIpKVxcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIGlmICh0eXBlcy5pbmNsdWRlcyhcImFkZHJlc3NcIikgJiYgdHlwZXMuaW5jbHVkZXMoXCJzdHJpbmdcIikpXFxuICAgICAgICAgIHJldHVybiB2YWxpZGF0ZTIoYXJnc1twYXJhbWV0ZXJJbmRleF0sIHtcXG4gICAgICAgICAgICBzdHJpY3Q6IGZhbHNlXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgaWYgKHR5cGVzLmluY2x1ZGVzKFwiYWRkcmVzc1wiKSAmJiB0eXBlcy5pbmNsdWRlcyhcImJ5dGVzXCIpKVxcbiAgICAgICAgICByZXR1cm4gdmFsaWRhdGUyKGFyZ3NbcGFyYW1ldGVySW5kZXhdLCB7XFxuICAgICAgICAgICAgc3RyaWN0OiBmYWxzZVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9KSgpO1xcbiAgICAgIGlmIChhbWJpZ3VvdXMpXFxuICAgICAgICByZXR1cm4gdHlwZXM7XFxuICAgIH1cXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vb3hAMC42LjlfdHlwZXNjcmlwdEA1LjguM196b2RAMy4yNC4zL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQWJpSXRlbS5qc1xcbiAgZnVuY3Rpb24gZnJvbTIoYWJpSXRlbSwgb3B0aW9ucyA9IHt9KSB7XFxuICAgIGNvbnN0IHsgcHJlcGFyZSA9IHRydWUgfSA9IG9wdGlvbnM7XFxuICAgIGNvbnN0IGl0ZW0gPSAoKCkgPT4ge1xcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFiaUl0ZW0pKVxcbiAgICAgICAgcmV0dXJuIHBhcnNlQWJpSXRlbShhYmlJdGVtKTtcXG4gICAgICBpZiAodHlwZW9mIGFiaUl0ZW0gPT09IFwic3RyaW5nXCIpXFxuICAgICAgICByZXR1cm4gcGFyc2VBYmlJdGVtKGFiaUl0ZW0pO1xcbiAgICAgIHJldHVybiBhYmlJdGVtO1xcbiAgICB9KSgpO1xcbiAgICByZXR1cm4ge1xcbiAgICAgIC4uLml0ZW0sXFxuICAgICAgLi4ucHJlcGFyZSA/IHsgaGFzaDogZ2V0U2lnbmF0dXJlSGFzaChpdGVtKSB9IDoge31cXG4gICAgfTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGZyb21BYmkoYWJpMiwgbmFtZSwgb3B0aW9ucykge1xcbiAgICBjb25zdCB7IGFyZ3MgPSBbXSwgcHJlcGFyZSA9IHRydWUgfSA9IG9wdGlvbnMgPz8ge307XFxuICAgIGNvbnN0IGlzU2VsZWN0b3IgPSB2YWxpZGF0ZShuYW1lLCB7IHN0cmljdDogZmFsc2UgfSk7XFxuICAgIGNvbnN0IGFiaUl0ZW1zID0gYWJpMi5maWx0ZXIoKGFiaUl0ZW0yKSA9PiB7XFxuICAgICAgaWYgKGlzU2VsZWN0b3IpIHtcXG4gICAgICAgIGlmIChhYmlJdGVtMi50eXBlID09PSBcImZ1bmN0aW9uXCIgfHwgYWJpSXRlbTIudHlwZSA9PT0gXCJlcnJvclwiKVxcbiAgICAgICAgICByZXR1cm4gZ2V0U2VsZWN0b3IoYWJpSXRlbTIpID09PSBzbGljZTIobmFtZSwgMCwgNCk7XFxuICAgICAgICBpZiAoYWJpSXRlbTIudHlwZSA9PT0gXCJldmVudFwiKVxcbiAgICAgICAgICByZXR1cm4gZ2V0U2lnbmF0dXJlSGFzaChhYmlJdGVtMikgPT09IG5hbWU7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBcIm5hbWVcIiBpbiBhYmlJdGVtMiAmJiBhYmlJdGVtMi5uYW1lID09PSBuYW1lO1xcbiAgICB9KTtcXG4gICAgaWYgKGFiaUl0ZW1zLmxlbmd0aCA9PT0gMClcXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRFcnJvcih7IG5hbWUgfSk7XFxuICAgIGlmIChhYmlJdGVtcy5sZW5ndGggPT09IDEpXFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIC4uLmFiaUl0ZW1zWzBdLFxcbiAgICAgICAgLi4ucHJlcGFyZSA/IHsgaGFzaDogZ2V0U2lnbmF0dXJlSGFzaChhYmlJdGVtc1swXSkgfSA6IHt9XFxuICAgICAgfTtcXG4gICAgbGV0IG1hdGNoZWRBYmlJdGVtID0gdm9pZCAwO1xcbiAgICBmb3IgKGNvbnN0IGFiaUl0ZW0yIG9mIGFiaUl0ZW1zKSB7XFxuICAgICAgaWYgKCEoXCJpbnB1dHNcIiBpbiBhYmlJdGVtMikpXFxuICAgICAgICBjb250aW51ZTtcXG4gICAgICBpZiAoIWFyZ3MgfHwgYXJncy5sZW5ndGggPT09IDApIHtcXG4gICAgICAgIGlmICghYWJpSXRlbTIuaW5wdXRzIHx8IGFiaUl0ZW0yLmlucHV0cy5sZW5ndGggPT09IDApXFxuICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgLi4uYWJpSXRlbTIsXFxuICAgICAgICAgICAgLi4ucHJlcGFyZSA/IHsgaGFzaDogZ2V0U2lnbmF0dXJlSGFzaChhYmlJdGVtMikgfSA6IHt9XFxuICAgICAgICAgIH07XFxuICAgICAgICBjb250aW51ZTtcXG4gICAgICB9XFxuICAgICAgaWYgKCFhYmlJdGVtMi5pbnB1dHMpXFxuICAgICAgICBjb250aW51ZTtcXG4gICAgICBpZiAoYWJpSXRlbTIuaW5wdXRzLmxlbmd0aCA9PT0gMClcXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICAgIGlmIChhYmlJdGVtMi5pbnB1dHMubGVuZ3RoICE9PSBhcmdzLmxlbmd0aClcXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICAgIGNvbnN0IG1hdGNoZWQgPSBhcmdzLmV2ZXJ5KChhcmcsIGluZGV4MikgPT4ge1xcbiAgICAgICAgY29uc3QgYWJpUGFyYW1ldGVyID0gXCJpbnB1dHNcIiBpbiBhYmlJdGVtMiAmJiBhYmlJdGVtMi5pbnB1dHNbaW5kZXgyXTtcXG4gICAgICAgIGlmICghYWJpUGFyYW1ldGVyKVxcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICByZXR1cm4gaXNBcmdPZlR5cGUyKGFyZywgYWJpUGFyYW1ldGVyKTtcXG4gICAgICB9KTtcXG4gICAgICBpZiAobWF0Y2hlZCkge1xcbiAgICAgICAgaWYgKG1hdGNoZWRBYmlJdGVtICYmIFwiaW5wdXRzXCIgaW4gbWF0Y2hlZEFiaUl0ZW0gJiYgbWF0Y2hlZEFiaUl0ZW0uaW5wdXRzKSB7XFxuICAgICAgICAgIGNvbnN0IGFtYmlndW91c1R5cGVzID0gZ2V0QW1iaWd1b3VzVHlwZXMyKGFiaUl0ZW0yLmlucHV0cywgbWF0Y2hlZEFiaUl0ZW0uaW5wdXRzLCBhcmdzKTtcXG4gICAgICAgICAgaWYgKGFtYmlndW91c1R5cGVzKVxcbiAgICAgICAgICAgIHRocm93IG5ldyBBbWJpZ3VpdHlFcnJvcih7XFxuICAgICAgICAgICAgICBhYmlJdGVtOiBhYmlJdGVtMixcXG4gICAgICAgICAgICAgIHR5cGU6IGFtYmlndW91c1R5cGVzWzBdXFxuICAgICAgICAgICAgfSwge1xcbiAgICAgICAgICAgICAgYWJpSXRlbTogbWF0Y2hlZEFiaUl0ZW0sXFxuICAgICAgICAgICAgICB0eXBlOiBhbWJpZ3VvdXNUeXBlc1sxXVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgbWF0Y2hlZEFiaUl0ZW0gPSBhYmlJdGVtMjtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgY29uc3QgYWJpSXRlbSA9ICgoKSA9PiB7XFxuICAgICAgaWYgKG1hdGNoZWRBYmlJdGVtKVxcbiAgICAgICAgcmV0dXJuIG1hdGNoZWRBYmlJdGVtO1xcbiAgICAgIGNvbnN0IFthYmlJdGVtMiwgLi4ub3ZlcmxvYWRzXSA9IGFiaUl0ZW1zO1xcbiAgICAgIHJldHVybiB7IC4uLmFiaUl0ZW0yLCBvdmVybG9hZHMgfTtcXG4gICAgfSkoKTtcXG4gICAgaWYgKCFhYmlJdGVtKVxcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKHsgbmFtZSB9KTtcXG4gICAgcmV0dXJuIHtcXG4gICAgICAuLi5hYmlJdGVtLFxcbiAgICAgIC4uLnByZXBhcmUgPyB7IGhhc2g6IGdldFNpZ25hdHVyZUhhc2goYWJpSXRlbSkgfSA6IHt9XFxuICAgIH07XFxuICB9XFxuICBmdW5jdGlvbiBnZXRTZWxlY3RvcihhYmlJdGVtKSB7XFxuICAgIHJldHVybiBzbGljZTIoZ2V0U2lnbmF0dXJlSGFzaChhYmlJdGVtKSwgMCwgNCk7XFxuICB9XFxuICBmdW5jdGlvbiBnZXRTaWduYXR1cmUoYWJpSXRlbSkge1xcbiAgICBjb25zdCBzaWduYXR1cmUgPSAoKCkgPT4ge1xcbiAgICAgIGlmICh0eXBlb2YgYWJpSXRlbSA9PT0gXCJzdHJpbmdcIilcXG4gICAgICAgIHJldHVybiBhYmlJdGVtO1xcbiAgICAgIHJldHVybiBmb3JtYXRBYmlJdGVtKGFiaUl0ZW0pO1xcbiAgICB9KSgpO1xcbiAgICByZXR1cm4gbm9ybWFsaXplU2lnbmF0dXJlMihzaWduYXR1cmUpO1xcbiAgfVxcbiAgZnVuY3Rpb24gZ2V0U2lnbmF0dXJlSGFzaChhYmlJdGVtKSB7XFxuICAgIGlmICh0eXBlb2YgYWJpSXRlbSAhPT0gXCJzdHJpbmdcIiAmJiBcImhhc2hcIiBpbiBhYmlJdGVtICYmIGFiaUl0ZW0uaGFzaClcXG4gICAgICByZXR1cm4gYWJpSXRlbS5oYXNoO1xcbiAgICByZXR1cm4ga2VjY2FrMjU2Mihmcm9tU3RyaW5nMihnZXRTaWduYXR1cmUoYWJpSXRlbSkpKTtcXG4gIH1cXG4gIHZhciBBbWJpZ3VpdHlFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMyB7XFxuICAgIGNvbnN0cnVjdG9yKHgsIHkpIHtcXG4gICAgICBzdXBlcihcIkZvdW5kIGFtYmlndW91cyB0eXBlcyBpbiBvdmVybG9hZGVkIEFCSSBJdGVtcy5cIiwge1xcbiAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXFxuICAgICAgICAgIC8vIFRPRE86IGFiaXR5cGUgdG8gYWRkIHN1cHBvcnQgZm9yIHNpZ25hdHVyZS1mb3JtYXR0ZWQgQUJJIGl0ZW1zLlxcbiAgICAgICAgICBgXFxcXGAke3gudHlwZX1cXFxcYCBpbiBcXFxcYCR7bm9ybWFsaXplU2lnbmF0dXJlMihmb3JtYXRBYmlJdGVtKHguYWJpSXRlbSkpfVxcXFxgLCBhbmRgLFxcbiAgICAgICAgICBgXFxcXGAke3kudHlwZX1cXFxcYCBpbiBcXFxcYCR7bm9ybWFsaXplU2lnbmF0dXJlMihmb3JtYXRBYmlJdGVtKHkuYWJpSXRlbSkpfVxcXFxgYCxcXG4gICAgICAgICAgXCJcIixcXG4gICAgICAgICAgXCJUaGVzZSB0eXBlcyBlbmNvZGUgZGlmZmVyZW50bHkgYW5kIGNhbm5vdCBiZSBkaXN0aW5ndWlzaGVkIGF0IHJ1bnRpbWUuXCIsXFxuICAgICAgICAgIFwiUmVtb3ZlIG9uZSBvZiB0aGUgYW1iaWd1b3VzIGl0ZW1zIGluIHRoZSBBQkkuXCJcXG4gICAgICAgIF1cXG4gICAgICB9KTtcXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgIHZhbHVlOiBcIkFiaUl0ZW0uQW1iaWd1aXR5RXJyb3JcIlxcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9O1xcbiAgdmFyIE5vdEZvdW5kRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjMge1xcbiAgICBjb25zdHJ1Y3Rvcih7IG5hbWUsIGRhdGEsIHR5cGUgPSBcIml0ZW1cIiB9KSB7XFxuICAgICAgY29uc3Qgc2VsZWN0b3IgPSAoKCkgPT4ge1xcbiAgICAgICAgaWYgKG5hbWUpXFxuICAgICAgICAgIHJldHVybiBgIHdpdGggbmFtZSBcIiR7bmFtZX1cImA7XFxuICAgICAgICBpZiAoZGF0YSlcXG4gICAgICAgICAgcmV0dXJuIGAgd2l0aCBkYXRhIFwiJHtkYXRhfVwiYDtcXG4gICAgICAgIHJldHVybiBcIlwiO1xcbiAgICAgIH0pKCk7XFxuICAgICAgc3VwZXIoYEFCSSAke3R5cGV9JHtzZWxlY3Rvcn0gbm90IGZvdW5kLmApO1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgdmFsdWU6IFwiQWJpSXRlbS5Ob3RGb3VuZEVycm9yXCJcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL294QDAuNi45X3R5cGVzY3JpcHRANS44LjNfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1NvbGlkaXR5LmpzXFxuICB2YXIgYXJyYXlSZWdleCA9IC9eKC4qKVxcXFxbKFswLTldKilcXFxcXSQvO1xcbiAgdmFyIGJ5dGVzUmVnZXgzID0gL15ieXRlcyhbMS05XXwxWzAtOV18MlswLTldfDNbMC0yXSk/JC87XFxuICB2YXIgaW50ZWdlclJlZ2V4MyA9IC9eKHU/aW50KSg4fDE2fDI0fDMyfDQwfDQ4fDU2fDY0fDcyfDgwfDg4fDk2fDEwNHwxMTJ8MTIwfDEyOHwxMzZ8MTQ0fDE1MnwxNjB8MTY4fDE3NnwxODR8MTkyfDIwMHwyMDh8MjE2fDIyNHwyMzJ8MjQwfDI0OHwyNTYpPyQvO1xcbiAgdmFyIG1heEludDgyID0gMm4gKiogKDhuIC0gMW4pIC0gMW47XFxuICB2YXIgbWF4SW50MTYyID0gMm4gKiogKDE2biAtIDFuKSAtIDFuO1xcbiAgdmFyIG1heEludDI0MiA9IDJuICoqICgyNG4gLSAxbikgLSAxbjtcXG4gIHZhciBtYXhJbnQzMjIgPSAybiAqKiAoMzJuIC0gMW4pIC0gMW47XFxuICB2YXIgbWF4SW50NDAyID0gMm4gKiogKDQwbiAtIDFuKSAtIDFuO1xcbiAgdmFyIG1heEludDQ4MiA9IDJuICoqICg0OG4gLSAxbikgLSAxbjtcXG4gIHZhciBtYXhJbnQ1NjIgPSAybiAqKiAoNTZuIC0gMW4pIC0gMW47XFxuICB2YXIgbWF4SW50NjQyID0gMm4gKiogKDY0biAtIDFuKSAtIDFuO1xcbiAgdmFyIG1heEludDcyMiA9IDJuICoqICg3Mm4gLSAxbikgLSAxbjtcXG4gIHZhciBtYXhJbnQ4MDIgPSAybiAqKiAoODBuIC0gMW4pIC0gMW47XFxuICB2YXIgbWF4SW50ODgyID0gMm4gKiogKDg4biAtIDFuKSAtIDFuO1xcbiAgdmFyIG1heEludDk2MiA9IDJuICoqICg5Nm4gLSAxbikgLSAxbjtcXG4gIHZhciBtYXhJbnQxMDQyID0gMm4gKiogKDEwNG4gLSAxbikgLSAxbjtcXG4gIHZhciBtYXhJbnQxMTIyID0gMm4gKiogKDExMm4gLSAxbikgLSAxbjtcXG4gIHZhciBtYXhJbnQxMjAyID0gMm4gKiogKDEyMG4gLSAxbikgLSAxbjtcXG4gIHZhciBtYXhJbnQxMjgyID0gMm4gKiogKDEyOG4gLSAxbikgLSAxbjtcXG4gIHZhciBtYXhJbnQxMzYyID0gMm4gKiogKDEzNm4gLSAxbikgLSAxbjtcXG4gIHZhciBtYXhJbnQxNDQyID0gMm4gKiogKDE0NG4gLSAxbikgLSAxbjtcXG4gIHZhciBtYXhJbnQxNTIyID0gMm4gKiogKDE1Mm4gLSAxbikgLSAxbjtcXG4gIHZhciBtYXhJbnQxNjAyID0gMm4gKiogKDE2MG4gLSAxbikgLSAxbjtcXG4gIHZhciBtYXhJbnQxNjgyID0gMm4gKiogKDE2OG4gLSAxbikgLSAxbjtcXG4gIHZhciBtYXhJbnQxNzYyID0gMm4gKiogKDE3Nm4gLSAxbikgLSAxbjtcXG4gIHZhciBtYXhJbnQxODQyID0gMm4gKiogKDE4NG4gLSAxbikgLSAxbjtcXG4gIHZhciBtYXhJbnQxOTIyID0gMm4gKiogKDE5Mm4gLSAxbikgLSAxbjtcXG4gIHZhciBtYXhJbnQyMDAyID0gMm4gKiogKDIwMG4gLSAxbikgLSAxbjtcXG4gIHZhciBtYXhJbnQyMDgyID0gMm4gKiogKDIwOG4gLSAxbikgLSAxbjtcXG4gIHZhciBtYXhJbnQyMTYyID0gMm4gKiogKDIxNm4gLSAxbikgLSAxbjtcXG4gIHZhciBtYXhJbnQyMjQyID0gMm4gKiogKDIyNG4gLSAxbikgLSAxbjtcXG4gIHZhciBtYXhJbnQyMzIyID0gMm4gKiogKDIzMm4gLSAxbikgLSAxbjtcXG4gIHZhciBtYXhJbnQyNDAyID0gMm4gKiogKDI0MG4gLSAxbikgLSAxbjtcXG4gIHZhciBtYXhJbnQyNDgyID0gMm4gKiogKDI0OG4gLSAxbikgLSAxbjtcXG4gIHZhciBtYXhJbnQyNTYyID0gMm4gKiogKDI1Nm4gLSAxbikgLSAxbjtcXG4gIHZhciBtaW5JbnQ4MiA9IC0oMm4gKiogKDhuIC0gMW4pKTtcXG4gIHZhciBtaW5JbnQxNjIgPSAtKDJuICoqICgxNm4gLSAxbikpO1xcbiAgdmFyIG1pbkludDI0MiA9IC0oMm4gKiogKDI0biAtIDFuKSk7XFxuICB2YXIgbWluSW50MzIyID0gLSgybiAqKiAoMzJuIC0gMW4pKTtcXG4gIHZhciBtaW5JbnQ0MDIgPSAtKDJuICoqICg0MG4gLSAxbikpO1xcbiAgdmFyIG1pbkludDQ4MiA9IC0oMm4gKiogKDQ4biAtIDFuKSk7XFxuICB2YXIgbWluSW50NTYyID0gLSgybiAqKiAoNTZuIC0gMW4pKTtcXG4gIHZhciBtaW5JbnQ2NDIgPSAtKDJuICoqICg2NG4gLSAxbikpO1xcbiAgdmFyIG1pbkludDcyMiA9IC0oMm4gKiogKDcybiAtIDFuKSk7XFxuICB2YXIgbWluSW50ODAyID0gLSgybiAqKiAoODBuIC0gMW4pKTtcXG4gIHZhciBtaW5JbnQ4ODIgPSAtKDJuICoqICg4OG4gLSAxbikpO1xcbiAgdmFyIG1pbkludDk2MiA9IC0oMm4gKiogKDk2biAtIDFuKSk7XFxuICB2YXIgbWluSW50MTA0MiA9IC0oMm4gKiogKDEwNG4gLSAxbikpO1xcbiAgdmFyIG1pbkludDExMjIgPSAtKDJuICoqICgxMTJuIC0gMW4pKTtcXG4gIHZhciBtaW5JbnQxMjAyID0gLSgybiAqKiAoMTIwbiAtIDFuKSk7XFxuICB2YXIgbWluSW50MTI4MiA9IC0oMm4gKiogKDEyOG4gLSAxbikpO1xcbiAgdmFyIG1pbkludDEzNjIgPSAtKDJuICoqICgxMzZuIC0gMW4pKTtcXG4gIHZhciBtaW5JbnQxNDQyID0gLSgybiAqKiAoMTQ0biAtIDFuKSk7XFxuICB2YXIgbWluSW50MTUyMiA9IC0oMm4gKiogKDE1Mm4gLSAxbikpO1xcbiAgdmFyIG1pbkludDE2MDIgPSAtKDJuICoqICgxNjBuIC0gMW4pKTtcXG4gIHZhciBtaW5JbnQxNjgyID0gLSgybiAqKiAoMTY4biAtIDFuKSk7XFxuICB2YXIgbWluSW50MTc2MiA9IC0oMm4gKiogKDE3Nm4gLSAxbikpO1xcbiAgdmFyIG1pbkludDE4NDIgPSAtKDJuICoqICgxODRuIC0gMW4pKTtcXG4gIHZhciBtaW5JbnQxOTIyID0gLSgybiAqKiAoMTkybiAtIDFuKSk7XFxuICB2YXIgbWluSW50MjAwMiA9IC0oMm4gKiogKDIwMG4gLSAxbikpO1xcbiAgdmFyIG1pbkludDIwODIgPSAtKDJuICoqICgyMDhuIC0gMW4pKTtcXG4gIHZhciBtaW5JbnQyMTYyID0gLSgybiAqKiAoMjE2biAtIDFuKSk7XFxuICB2YXIgbWluSW50MjI0MiA9IC0oMm4gKiogKDIyNG4gLSAxbikpO1xcbiAgdmFyIG1pbkludDIzMjIgPSAtKDJuICoqICgyMzJuIC0gMW4pKTtcXG4gIHZhciBtaW5JbnQyNDAyID0gLSgybiAqKiAoMjQwbiAtIDFuKSk7XFxuICB2YXIgbWluSW50MjQ4MiA9IC0oMm4gKiogKDI0OG4gLSAxbikpO1xcbiAgdmFyIG1pbkludDI1NjIgPSAtKDJuICoqICgyNTZuIC0gMW4pKTtcXG4gIHZhciBtYXhVaW50ODIgPSAybiAqKiA4biAtIDFuO1xcbiAgdmFyIG1heFVpbnQxNjIgPSAybiAqKiAxNm4gLSAxbjtcXG4gIHZhciBtYXhVaW50MjQyID0gMm4gKiogMjRuIC0gMW47XFxuICB2YXIgbWF4VWludDMyMiA9IDJuICoqIDMybiAtIDFuO1xcbiAgdmFyIG1heFVpbnQ0MDIgPSAybiAqKiA0MG4gLSAxbjtcXG4gIHZhciBtYXhVaW50NDgyID0gMm4gKiogNDhuIC0gMW47XFxuICB2YXIgbWF4VWludDU2MiA9IDJuICoqIDU2biAtIDFuO1xcbiAgdmFyIG1heFVpbnQ2NDIgPSAybiAqKiA2NG4gLSAxbjtcXG4gIHZhciBtYXhVaW50NzIyID0gMm4gKiogNzJuIC0gMW47XFxuICB2YXIgbWF4VWludDgwMiA9IDJuICoqIDgwbiAtIDFuO1xcbiAgdmFyIG1heFVpbnQ4ODIgPSAybiAqKiA4OG4gLSAxbjtcXG4gIHZhciBtYXhVaW50OTYyID0gMm4gKiogOTZuIC0gMW47XFxuICB2YXIgbWF4VWludDEwNDIgPSAybiAqKiAxMDRuIC0gMW47XFxuICB2YXIgbWF4VWludDExMjIgPSAybiAqKiAxMTJuIC0gMW47XFxuICB2YXIgbWF4VWludDEyMDIgPSAybiAqKiAxMjBuIC0gMW47XFxuICB2YXIgbWF4VWludDEyODIgPSAybiAqKiAxMjhuIC0gMW47XFxuICB2YXIgbWF4VWludDEzNjIgPSAybiAqKiAxMzZuIC0gMW47XFxuICB2YXIgbWF4VWludDE0NDIgPSAybiAqKiAxNDRuIC0gMW47XFxuICB2YXIgbWF4VWludDE1MjIgPSAybiAqKiAxNTJuIC0gMW47XFxuICB2YXIgbWF4VWludDE2MDIgPSAybiAqKiAxNjBuIC0gMW47XFxuICB2YXIgbWF4VWludDE2ODIgPSAybiAqKiAxNjhuIC0gMW47XFxuICB2YXIgbWF4VWludDE3NjIgPSAybiAqKiAxNzZuIC0gMW47XFxuICB2YXIgbWF4VWludDE4NDIgPSAybiAqKiAxODRuIC0gMW47XFxuICB2YXIgbWF4VWludDE5MjIgPSAybiAqKiAxOTJuIC0gMW47XFxuICB2YXIgbWF4VWludDIwMDIgPSAybiAqKiAyMDBuIC0gMW47XFxuICB2YXIgbWF4VWludDIwODIgPSAybiAqKiAyMDhuIC0gMW47XFxuICB2YXIgbWF4VWludDIxNjIgPSAybiAqKiAyMTZuIC0gMW47XFxuICB2YXIgbWF4VWludDIyNDIgPSAybiAqKiAyMjRuIC0gMW47XFxuICB2YXIgbWF4VWludDIzMjIgPSAybiAqKiAyMzJuIC0gMW47XFxuICB2YXIgbWF4VWludDI0MDIgPSAybiAqKiAyNDBuIC0gMW47XFxuICB2YXIgbWF4VWludDI0ODIgPSAybiAqKiAyNDhuIC0gMW47XFxuICB2YXIgbWF4VWludDI1NjIgPSAybiAqKiAyNTZuIC0gMW47XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS9veEAwLjYuOV90eXBlc2NyaXB0QDUuOC4zX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9hYmlQYXJhbWV0ZXJzLmpzXFxuICBmdW5jdGlvbiBwcmVwYXJlUGFyYW1ldGVycyh7IGNoZWNrc3VtQWRkcmVzczogY2hlY2tzdW1BZGRyZXNzMiwgcGFyYW1ldGVycywgdmFsdWVzIH0pIHtcXG4gICAgY29uc3QgcHJlcGFyZWRQYXJhbWV0ZXJzID0gW107XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1ldGVycy5sZW5ndGg7IGkrKykge1xcbiAgICAgIHByZXBhcmVkUGFyYW1ldGVycy5wdXNoKHByZXBhcmVQYXJhbWV0ZXIoe1xcbiAgICAgICAgY2hlY2tzdW1BZGRyZXNzOiBjaGVja3N1bUFkZHJlc3MyLFxcbiAgICAgICAgcGFyYW1ldGVyOiBwYXJhbWV0ZXJzW2ldLFxcbiAgICAgICAgdmFsdWU6IHZhbHVlc1tpXVxcbiAgICAgIH0pKTtcXG4gICAgfVxcbiAgICByZXR1cm4gcHJlcGFyZWRQYXJhbWV0ZXJzO1xcbiAgfVxcbiAgZnVuY3Rpb24gcHJlcGFyZVBhcmFtZXRlcih7IGNoZWNrc3VtQWRkcmVzczogY2hlY2tzdW1BZGRyZXNzMiA9IGZhbHNlLCBwYXJhbWV0ZXI6IHBhcmFtZXRlcl8sIHZhbHVlIH0pIHtcXG4gICAgY29uc3QgcGFyYW1ldGVyID0gcGFyYW1ldGVyXztcXG4gICAgY29uc3QgYXJyYXlDb21wb25lbnRzID0gZ2V0QXJyYXlDb21wb25lbnRzMihwYXJhbWV0ZXIudHlwZSk7XFxuICAgIGlmIChhcnJheUNvbXBvbmVudHMpIHtcXG4gICAgICBjb25zdCBbbGVuZ3RoLCB0eXBlXSA9IGFycmF5Q29tcG9uZW50cztcXG4gICAgICByZXR1cm4gZW5jb2RlQXJyYXkyKHZhbHVlLCB7XFxuICAgICAgICBjaGVja3N1bUFkZHJlc3M6IGNoZWNrc3VtQWRkcmVzczIsXFxuICAgICAgICBsZW5ndGgsXFxuICAgICAgICBwYXJhbWV0ZXI6IHtcXG4gICAgICAgICAgLi4ucGFyYW1ldGVyLFxcbiAgICAgICAgICB0eXBlXFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgaWYgKHBhcmFtZXRlci50eXBlID09PSBcInR1cGxlXCIpIHtcXG4gICAgICByZXR1cm4gZW5jb2RlVHVwbGUyKHZhbHVlLCB7XFxuICAgICAgICBjaGVja3N1bUFkZHJlc3M6IGNoZWNrc3VtQWRkcmVzczIsXFxuICAgICAgICBwYXJhbWV0ZXJcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICBpZiAocGFyYW1ldGVyLnR5cGUgPT09IFwiYWRkcmVzc1wiKSB7XFxuICAgICAgcmV0dXJuIGVuY29kZUFkZHJlc3MyKHZhbHVlLCB7XFxuICAgICAgICBjaGVja3N1bTogY2hlY2tzdW1BZGRyZXNzMlxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIGlmIChwYXJhbWV0ZXIudHlwZSA9PT0gXCJib29sXCIpIHtcXG4gICAgICByZXR1cm4gZW5jb2RlQm9vbGVhbih2YWx1ZSk7XFxuICAgIH1cXG4gICAgaWYgKHBhcmFtZXRlci50eXBlLnN0YXJ0c1dpdGgoXCJ1aW50XCIpIHx8IHBhcmFtZXRlci50eXBlLnN0YXJ0c1dpdGgoXCJpbnRcIikpIHtcXG4gICAgICBjb25zdCBzaWduZWQgPSBwYXJhbWV0ZXIudHlwZS5zdGFydHNXaXRoKFwiaW50XCIpO1xcbiAgICAgIGNvbnN0IFssICwgc2l6ZTUgPSBcIjI1NlwiXSA9IGludGVnZXJSZWdleDMuZXhlYyhwYXJhbWV0ZXIudHlwZSkgPz8gW107XFxuICAgICAgcmV0dXJuIGVuY29kZU51bWJlcjIodmFsdWUsIHtcXG4gICAgICAgIHNpZ25lZCxcXG4gICAgICAgIHNpemU6IE51bWJlcihzaXplNSlcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICBpZiAocGFyYW1ldGVyLnR5cGUuc3RhcnRzV2l0aChcImJ5dGVzXCIpKSB7XFxuICAgICAgcmV0dXJuIGVuY29kZUJ5dGVzMih2YWx1ZSwgeyB0eXBlOiBwYXJhbWV0ZXIudHlwZSB9KTtcXG4gICAgfVxcbiAgICBpZiAocGFyYW1ldGVyLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcXG4gICAgICByZXR1cm4gZW5jb2RlU3RyaW5nMih2YWx1ZSk7XFxuICAgIH1cXG4gICAgdGhyb3cgbmV3IEludmFsaWRUeXBlRXJyb3IocGFyYW1ldGVyLnR5cGUpO1xcbiAgfVxcbiAgZnVuY3Rpb24gZW5jb2RlKHByZXBhcmVkUGFyYW1ldGVycykge1xcbiAgICBsZXQgc3RhdGljU2l6ZSA9IDA7XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlcGFyZWRQYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgY29uc3QgeyBkeW5hbWljLCBlbmNvZGVkIH0gPSBwcmVwYXJlZFBhcmFtZXRlcnNbaV07XFxuICAgICAgaWYgKGR5bmFtaWMpXFxuICAgICAgICBzdGF0aWNTaXplICs9IDMyO1xcbiAgICAgIGVsc2VcXG4gICAgICAgIHN0YXRpY1NpemUgKz0gc2l6ZTQoZW5jb2RlZCk7XFxuICAgIH1cXG4gICAgY29uc3Qgc3RhdGljUGFyYW1ldGVycyA9IFtdO1xcbiAgICBjb25zdCBkeW5hbWljUGFyYW1ldGVycyA9IFtdO1xcbiAgICBsZXQgZHluYW1pY1NpemUgPSAwO1xcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXBhcmVkUGFyYW1ldGVycy5sZW5ndGg7IGkrKykge1xcbiAgICAgIGNvbnN0IHsgZHluYW1pYywgZW5jb2RlZCB9ID0gcHJlcGFyZWRQYXJhbWV0ZXJzW2ldO1xcbiAgICAgIGlmIChkeW5hbWljKSB7XFxuICAgICAgICBzdGF0aWNQYXJhbWV0ZXJzLnB1c2goZnJvbU51bWJlcihzdGF0aWNTaXplICsgZHluYW1pY1NpemUsIHsgc2l6ZTogMzIgfSkpO1xcbiAgICAgICAgZHluYW1pY1BhcmFtZXRlcnMucHVzaChlbmNvZGVkKTtcXG4gICAgICAgIGR5bmFtaWNTaXplICs9IHNpemU0KGVuY29kZWQpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzdGF0aWNQYXJhbWV0ZXJzLnB1c2goZW5jb2RlZCk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBjb25jYXQyKC4uLnN0YXRpY1BhcmFtZXRlcnMsIC4uLmR5bmFtaWNQYXJhbWV0ZXJzKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGVuY29kZUFkZHJlc3MyKHZhbHVlLCBvcHRpb25zKSB7XFxuICAgIGNvbnN0IHsgY2hlY2tzdW06IGNoZWNrc3VtMyA9IGZhbHNlIH0gPSBvcHRpb25zO1xcbiAgICBhc3NlcnQyKHZhbHVlLCB7IHN0cmljdDogY2hlY2tzdW0zIH0pO1xcbiAgICByZXR1cm4ge1xcbiAgICAgIGR5bmFtaWM6IGZhbHNlLFxcbiAgICAgIGVuY29kZWQ6IHBhZExlZnQodmFsdWUudG9Mb3dlckNhc2UoKSlcXG4gICAgfTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGVuY29kZUFycmF5Mih2YWx1ZSwgb3B0aW9ucykge1xcbiAgICBjb25zdCB7IGNoZWNrc3VtQWRkcmVzczogY2hlY2tzdW1BZGRyZXNzMiwgbGVuZ3RoLCBwYXJhbWV0ZXIgfSA9IG9wdGlvbnM7XFxuICAgIGNvbnN0IGR5bmFtaWMgPSBsZW5ndGggPT09IG51bGw7XFxuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpXFxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcnJheUVycm9yMih2YWx1ZSk7XFxuICAgIGlmICghZHluYW1pYyAmJiB2YWx1ZS5sZW5ndGggIT09IGxlbmd0aClcXG4gICAgICB0aHJvdyBuZXcgQXJyYXlMZW5ndGhNaXNtYXRjaEVycm9yKHtcXG4gICAgICAgIGV4cGVjdGVkTGVuZ3RoOiBsZW5ndGgsXFxuICAgICAgICBnaXZlbkxlbmd0aDogdmFsdWUubGVuZ3RoLFxcbiAgICAgICAgdHlwZTogYCR7cGFyYW1ldGVyLnR5cGV9WyR7bGVuZ3RofV1gXFxuICAgICAgfSk7XFxuICAgIGxldCBkeW5hbWljQ2hpbGQgPSBmYWxzZTtcXG4gICAgY29uc3QgcHJlcGFyZWRQYXJhbWV0ZXJzID0gW107XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcXG4gICAgICBjb25zdCBwcmVwYXJlZFBhcmFtID0gcHJlcGFyZVBhcmFtZXRlcih7XFxuICAgICAgICBjaGVja3N1bUFkZHJlc3M6IGNoZWNrc3VtQWRkcmVzczIsXFxuICAgICAgICBwYXJhbWV0ZXIsXFxuICAgICAgICB2YWx1ZTogdmFsdWVbaV1cXG4gICAgICB9KTtcXG4gICAgICBpZiAocHJlcGFyZWRQYXJhbS5keW5hbWljKVxcbiAgICAgICAgZHluYW1pY0NoaWxkID0gdHJ1ZTtcXG4gICAgICBwcmVwYXJlZFBhcmFtZXRlcnMucHVzaChwcmVwYXJlZFBhcmFtKTtcXG4gICAgfVxcbiAgICBpZiAoZHluYW1pYyB8fCBkeW5hbWljQ2hpbGQpIHtcXG4gICAgICBjb25zdCBkYXRhID0gZW5jb2RlKHByZXBhcmVkUGFyYW1ldGVycyk7XFxuICAgICAgaWYgKGR5bmFtaWMpIHtcXG4gICAgICAgIGNvbnN0IGxlbmd0aDIgPSBmcm9tTnVtYmVyKHByZXBhcmVkUGFyYW1ldGVycy5sZW5ndGgsIHsgc2l6ZTogMzIgfSk7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICBkeW5hbWljOiB0cnVlLFxcbiAgICAgICAgICBlbmNvZGVkOiBwcmVwYXJlZFBhcmFtZXRlcnMubGVuZ3RoID4gMCA/IGNvbmNhdDIobGVuZ3RoMiwgZGF0YSkgOiBsZW5ndGgyXFxuICAgICAgICB9O1xcbiAgICAgIH1cXG4gICAgICBpZiAoZHluYW1pY0NoaWxkKVxcbiAgICAgICAgcmV0dXJuIHsgZHluYW1pYzogdHJ1ZSwgZW5jb2RlZDogZGF0YSB9O1xcbiAgICB9XFxuICAgIHJldHVybiB7XFxuICAgICAgZHluYW1pYzogZmFsc2UsXFxuICAgICAgZW5jb2RlZDogY29uY2F0MiguLi5wcmVwYXJlZFBhcmFtZXRlcnMubWFwKCh7IGVuY29kZWQgfSkgPT4gZW5jb2RlZCkpXFxuICAgIH07XFxuICB9XFxuICBmdW5jdGlvbiBlbmNvZGVCeXRlczIodmFsdWUsIHsgdHlwZSB9KSB7XFxuICAgIGNvbnN0IFssIHBhcmFtZXRlcnNpemVdID0gdHlwZS5zcGxpdChcImJ5dGVzXCIpO1xcbiAgICBjb25zdCBieXRlc1NpemUgPSBzaXplNCh2YWx1ZSk7XFxuICAgIGlmICghcGFyYW1ldGVyc2l6ZSkge1xcbiAgICAgIGxldCB2YWx1ZV8gPSB2YWx1ZTtcXG4gICAgICBpZiAoYnl0ZXNTaXplICUgMzIgIT09IDApXFxuICAgICAgICB2YWx1ZV8gPSBwYWRSaWdodCh2YWx1ZV8sIE1hdGguY2VpbCgodmFsdWUubGVuZ3RoIC0gMikgLyAyIC8gMzIpICogMzIpO1xcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBkeW5hbWljOiB0cnVlLFxcbiAgICAgICAgZW5jb2RlZDogY29uY2F0MihwYWRMZWZ0KGZyb21OdW1iZXIoYnl0ZXNTaXplLCB7IHNpemU6IDMyIH0pKSwgdmFsdWVfKVxcbiAgICAgIH07XFxuICAgIH1cXG4gICAgaWYgKGJ5dGVzU2l6ZSAhPT0gTnVtYmVyLnBhcnNlSW50KHBhcmFtZXRlcnNpemUpKVxcbiAgICAgIHRocm93IG5ldyBCeXRlc1NpemVNaXNtYXRjaEVycm9yMih7XFxuICAgICAgICBleHBlY3RlZFNpemU6IE51bWJlci5wYXJzZUludChwYXJhbWV0ZXJzaXplKSxcXG4gICAgICAgIHZhbHVlXFxuICAgICAgfSk7XFxuICAgIHJldHVybiB7IGR5bmFtaWM6IGZhbHNlLCBlbmNvZGVkOiBwYWRSaWdodCh2YWx1ZSkgfTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGVuY29kZUJvb2xlYW4odmFsdWUpIHtcXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJib29sZWFuXCIpXFxuICAgICAgdGhyb3cgbmV3IEJhc2VFcnJvcjMoYEludmFsaWQgYm9vbGVhbiB2YWx1ZTogXCIke3ZhbHVlfVwiICh0eXBlOiAke3R5cGVvZiB2YWx1ZX0pLiBFeHBlY3RlZDogXFxcXGB0cnVlXFxcXGAgb3IgXFxcXGBmYWxzZVxcXFxgLmApO1xcbiAgICByZXR1cm4geyBkeW5hbWljOiBmYWxzZSwgZW5jb2RlZDogcGFkTGVmdChmcm9tQm9vbGVhbih2YWx1ZSkpIH07XFxuICB9XFxuICBmdW5jdGlvbiBlbmNvZGVOdW1iZXIyKHZhbHVlLCB7IHNpZ25lZCwgc2l6ZTogc2l6ZTUgfSkge1xcbiAgICBpZiAodHlwZW9mIHNpemU1ID09PSBcIm51bWJlclwiKSB7XFxuICAgICAgY29uc3QgbWF4ID0gMm4gKiogKEJpZ0ludChzaXplNSkgLSAoc2lnbmVkID8gMW4gOiAwbikpIC0gMW47XFxuICAgICAgY29uc3QgbWluID0gc2lnbmVkID8gLW1heCAtIDFuIDogMG47XFxuICAgICAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKVxcbiAgICAgICAgdGhyb3cgbmV3IEludGVnZXJPdXRPZlJhbmdlRXJyb3IyKHtcXG4gICAgICAgICAgbWF4OiBtYXgudG9TdHJpbmcoKSxcXG4gICAgICAgICAgbWluOiBtaW4udG9TdHJpbmcoKSxcXG4gICAgICAgICAgc2lnbmVkLFxcbiAgICAgICAgICBzaXplOiBzaXplNSAvIDgsXFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZS50b1N0cmluZygpXFxuICAgICAgICB9KTtcXG4gICAgfVxcbiAgICByZXR1cm4ge1xcbiAgICAgIGR5bmFtaWM6IGZhbHNlLFxcbiAgICAgIGVuY29kZWQ6IGZyb21OdW1iZXIodmFsdWUsIHtcXG4gICAgICAgIHNpemU6IDMyLFxcbiAgICAgICAgc2lnbmVkXFxuICAgICAgfSlcXG4gICAgfTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGVuY29kZVN0cmluZzIodmFsdWUpIHtcXG4gICAgY29uc3QgaGV4VmFsdWUgPSBmcm9tU3RyaW5nMih2YWx1ZSk7XFxuICAgIGNvbnN0IHBhcnRzTGVuZ3RoID0gTWF0aC5jZWlsKHNpemU0KGhleFZhbHVlKSAvIDMyKTtcXG4gICAgY29uc3QgcGFydHMgPSBbXTtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0c0xlbmd0aDsgaSsrKSB7XFxuICAgICAgcGFydHMucHVzaChwYWRSaWdodChzbGljZTIoaGV4VmFsdWUsIGkgKiAzMiwgKGkgKyAxKSAqIDMyKSkpO1xcbiAgICB9XFxuICAgIHJldHVybiB7XFxuICAgICAgZHluYW1pYzogdHJ1ZSxcXG4gICAgICBlbmNvZGVkOiBjb25jYXQyKHBhZFJpZ2h0KGZyb21OdW1iZXIoc2l6ZTQoaGV4VmFsdWUpLCB7IHNpemU6IDMyIH0pKSwgLi4ucGFydHMpXFxuICAgIH07XFxuICB9XFxuICBmdW5jdGlvbiBlbmNvZGVUdXBsZTIodmFsdWUsIG9wdGlvbnMpIHtcXG4gICAgY29uc3QgeyBjaGVja3N1bUFkZHJlc3M6IGNoZWNrc3VtQWRkcmVzczIsIHBhcmFtZXRlciB9ID0gb3B0aW9ucztcXG4gICAgbGV0IGR5bmFtaWMgPSBmYWxzZTtcXG4gICAgY29uc3QgcHJlcGFyZWRQYXJhbWV0ZXJzID0gW107XFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1ldGVyLmNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcXG4gICAgICBjb25zdCBwYXJhbV8gPSBwYXJhbWV0ZXIuY29tcG9uZW50c1tpXTtcXG4gICAgICBjb25zdCBpbmRleDIgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IGkgOiBwYXJhbV8ubmFtZTtcXG4gICAgICBjb25zdCBwcmVwYXJlZFBhcmFtID0gcHJlcGFyZVBhcmFtZXRlcih7XFxuICAgICAgICBjaGVja3N1bUFkZHJlc3M6IGNoZWNrc3VtQWRkcmVzczIsXFxuICAgICAgICBwYXJhbWV0ZXI6IHBhcmFtXyxcXG4gICAgICAgIHZhbHVlOiB2YWx1ZVtpbmRleDJdXFxuICAgICAgfSk7XFxuICAgICAgcHJlcGFyZWRQYXJhbWV0ZXJzLnB1c2gocHJlcGFyZWRQYXJhbSk7XFxuICAgICAgaWYgKHByZXBhcmVkUGFyYW0uZHluYW1pYylcXG4gICAgICAgIGR5bmFtaWMgPSB0cnVlO1xcbiAgICB9XFxuICAgIHJldHVybiB7XFxuICAgICAgZHluYW1pYyxcXG4gICAgICBlbmNvZGVkOiBkeW5hbWljID8gZW5jb2RlKHByZXBhcmVkUGFyYW1ldGVycykgOiBjb25jYXQyKC4uLnByZXBhcmVkUGFyYW1ldGVycy5tYXAoKHsgZW5jb2RlZCB9KSA9PiBlbmNvZGVkKSlcXG4gICAgfTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGdldEFycmF5Q29tcG9uZW50czIodHlwZSkge1xcbiAgICBjb25zdCBtYXRjaGVzID0gdHlwZS5tYXRjaCgvXiguKilcXFxcWyhcXFxcZCspP1xcXFxdJC8pO1xcbiAgICByZXR1cm4gbWF0Y2hlcyA/IChcXG4gICAgICAvLyBSZXR1cm4gYG51bGxgIGlmIHRoZSBhcnJheSBpcyBkeW5hbWljLlxcbiAgICAgIFttYXRjaGVzWzJdID8gTnVtYmVyKG1hdGNoZXNbMl0pIDogbnVsbCwgbWF0Y2hlc1sxXV1cXG4gICAgKSA6IHZvaWQgMDtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL294QDAuNi45X3R5cGVzY3JpcHRANS44LjNfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FiaVBhcmFtZXRlcnMuanNcXG4gIGZ1bmN0aW9uIGVuY29kZTIocGFyYW1ldGVycywgdmFsdWVzLCBvcHRpb25zKSB7XFxuICAgIGNvbnN0IHsgY2hlY2tzdW1BZGRyZXNzOiBjaGVja3N1bUFkZHJlc3MyID0gZmFsc2UgfSA9IG9wdGlvbnMgPz8ge307XFxuICAgIGlmIChwYXJhbWV0ZXJzLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aClcXG4gICAgICB0aHJvdyBuZXcgTGVuZ3RoTWlzbWF0Y2hFcnJvcih7XFxuICAgICAgICBleHBlY3RlZExlbmd0aDogcGFyYW1ldGVycy5sZW5ndGgsXFxuICAgICAgICBnaXZlbkxlbmd0aDogdmFsdWVzLmxlbmd0aFxcbiAgICAgIH0pO1xcbiAgICBjb25zdCBwcmVwYXJlZFBhcmFtZXRlcnMgPSBwcmVwYXJlUGFyYW1ldGVycyh7XFxuICAgICAgY2hlY2tzdW1BZGRyZXNzOiBjaGVja3N1bUFkZHJlc3MyLFxcbiAgICAgIHBhcmFtZXRlcnMsXFxuICAgICAgdmFsdWVzXFxuICAgIH0pO1xcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlKHByZXBhcmVkUGFyYW1ldGVycyk7XFxuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMClcXG4gICAgICByZXR1cm4gXCIweFwiO1xcbiAgICByZXR1cm4gZGF0YTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGVuY29kZVBhY2tlZCh0eXBlcywgdmFsdWVzKSB7XFxuICAgIGlmICh0eXBlcy5sZW5ndGggIT09IHZhbHVlcy5sZW5ndGgpXFxuICAgICAgdGhyb3cgbmV3IExlbmd0aE1pc21hdGNoRXJyb3Ioe1xcbiAgICAgICAgZXhwZWN0ZWRMZW5ndGg6IHR5cGVzLmxlbmd0aCxcXG4gICAgICAgIGdpdmVuTGVuZ3RoOiB2YWx1ZXMubGVuZ3RoXFxuICAgICAgfSk7XFxuICAgIGNvbnN0IGRhdGEgPSBbXTtcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgIGNvbnN0IHR5cGUgPSB0eXBlc1tpXTtcXG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcXG4gICAgICBkYXRhLnB1c2goZW5jb2RlUGFja2VkLmVuY29kZSh0eXBlLCB2YWx1ZSkpO1xcbiAgICB9XFxuICAgIHJldHVybiBjb25jYXQyKC4uLmRhdGEpO1xcbiAgfVxcbiAgKGZ1bmN0aW9uKGVuY29kZVBhY2tlZDIpIHtcXG4gICAgZnVuY3Rpb24gZW5jb2RlNCh0eXBlLCB2YWx1ZSwgaXNBcnJheSA9IGZhbHNlKSB7XFxuICAgICAgaWYgKHR5cGUgPT09IFwiYWRkcmVzc1wiKSB7XFxuICAgICAgICBjb25zdCBhZGRyZXNzID0gdmFsdWU7XFxuICAgICAgICBhc3NlcnQyKGFkZHJlc3MpO1xcbiAgICAgICAgcmV0dXJuIHBhZExlZnQoYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBpc0FycmF5ID8gMzIgOiAwKTtcXG4gICAgICB9XFxuICAgICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpXFxuICAgICAgICByZXR1cm4gZnJvbVN0cmluZzIodmFsdWUpO1xcbiAgICAgIGlmICh0eXBlID09PSBcImJ5dGVzXCIpXFxuICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgaWYgKHR5cGUgPT09IFwiYm9vbFwiKVxcbiAgICAgICAgcmV0dXJuIHBhZExlZnQoZnJvbUJvb2xlYW4odmFsdWUpLCBpc0FycmF5ID8gMzIgOiAxKTtcXG4gICAgICBjb25zdCBpbnRNYXRjaCA9IHR5cGUubWF0Y2goaW50ZWdlclJlZ2V4Myk7XFxuICAgICAgaWYgKGludE1hdGNoKSB7XFxuICAgICAgICBjb25zdCBbX3R5cGUsIGJhc2VUeXBlLCBiaXRzID0gXCIyNTZcIl0gPSBpbnRNYXRjaDtcXG4gICAgICAgIGNvbnN0IHNpemU1ID0gTnVtYmVyLnBhcnNlSW50KGJpdHMpIC8gODtcXG4gICAgICAgIHJldHVybiBmcm9tTnVtYmVyKHZhbHVlLCB7XFxuICAgICAgICAgIHNpemU6IGlzQXJyYXkgPyAzMiA6IHNpemU1LFxcbiAgICAgICAgICBzaWduZWQ6IGJhc2VUeXBlID09PSBcImludFwiXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgICAgY29uc3QgYnl0ZXNNYXRjaCA9IHR5cGUubWF0Y2goYnl0ZXNSZWdleDMpO1xcbiAgICAgIGlmIChieXRlc01hdGNoKSB7XFxuICAgICAgICBjb25zdCBbX3R5cGUsIHNpemU1XSA9IGJ5dGVzTWF0Y2g7XFxuICAgICAgICBpZiAoTnVtYmVyLnBhcnNlSW50KHNpemU1KSAhPT0gKHZhbHVlLmxlbmd0aCAtIDIpIC8gMilcXG4gICAgICAgICAgdGhyb3cgbmV3IEJ5dGVzU2l6ZU1pc21hdGNoRXJyb3IyKHtcXG4gICAgICAgICAgICBleHBlY3RlZFNpemU6IE51bWJlci5wYXJzZUludChzaXplNSksXFxuICAgICAgICAgICAgdmFsdWVcXG4gICAgICAgICAgfSk7XFxuICAgICAgICByZXR1cm4gcGFkUmlnaHQodmFsdWUsIGlzQXJyYXkgPyAzMiA6IDApO1xcbiAgICAgIH1cXG4gICAgICBjb25zdCBhcnJheU1hdGNoID0gdHlwZS5tYXRjaChhcnJheVJlZ2V4KTtcXG4gICAgICBpZiAoYXJyYXlNYXRjaCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xcbiAgICAgICAgY29uc3QgW190eXBlLCBjaGlsZFR5cGVdID0gYXJyYXlNYXRjaDtcXG4gICAgICAgIGNvbnN0IGRhdGEgPSBbXTtcXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgZGF0YS5wdXNoKGVuY29kZTQoY2hpbGRUeXBlLCB2YWx1ZVtpXSwgdHJ1ZSkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKVxcbiAgICAgICAgICByZXR1cm4gXCIweFwiO1xcbiAgICAgICAgcmV0dXJuIGNvbmNhdDIoLi4uZGF0YSk7XFxuICAgICAgfVxcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHlwZUVycm9yKHR5cGUpO1xcbiAgICB9XFxuICAgIGVuY29kZVBhY2tlZDIuZW5jb2RlID0gZW5jb2RlNDtcXG4gIH0pKGVuY29kZVBhY2tlZCB8fCAoZW5jb2RlUGFja2VkID0ge30pKTtcXG4gIHZhciBBcnJheUxlbmd0aE1pc21hdGNoRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjMge1xcbiAgICBjb25zdHJ1Y3Rvcih7IGV4cGVjdGVkTGVuZ3RoLCBnaXZlbkxlbmd0aCwgdHlwZSB9KSB7XFxuICAgICAgc3VwZXIoYEFycmF5IGxlbmd0aCBtaXNtYXRjaCBmb3IgdHlwZSBcXFxcYCR7dHlwZX1cXFxcYC4gRXhwZWN0ZWQ6IFxcXFxgJHtleHBlY3RlZExlbmd0aH1cXFxcYC4gR2l2ZW46IFxcXFxgJHtnaXZlbkxlbmd0aH1cXFxcYC5gKTtcXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgIHZhbHVlOiBcIkFiaVBhcmFtZXRlcnMuQXJyYXlMZW5ndGhNaXNtYXRjaEVycm9yXCJcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfTtcXG4gIHZhciBCeXRlc1NpemVNaXNtYXRjaEVycm9yMiA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMyB7XFxuICAgIGNvbnN0cnVjdG9yKHsgZXhwZWN0ZWRTaXplLCB2YWx1ZSB9KSB7XFxuICAgICAgc3VwZXIoYFNpemUgb2YgYnl0ZXMgXCIke3ZhbHVlfVwiIChieXRlcyR7c2l6ZTQodmFsdWUpfSkgZG9lcyBub3QgbWF0Y2ggZXhwZWN0ZWQgc2l6ZSAoYnl0ZXMke2V4cGVjdGVkU2l6ZX0pLmApO1xcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgdmFsdWU6IFwiQWJpUGFyYW1ldGVycy5CeXRlc1NpemVNaXNtYXRjaEVycm9yXCJcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfTtcXG4gIHZhciBMZW5ndGhNaXNtYXRjaEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlRXJyb3IzIHtcXG4gICAgY29uc3RydWN0b3IoeyBleHBlY3RlZExlbmd0aCwgZ2l2ZW5MZW5ndGggfSkge1xcbiAgICAgIHN1cGVyKFtcXG4gICAgICAgIFwiQUJJIGVuY29kaW5nIHBhcmFtZXRlcnMvdmFsdWVzIGxlbmd0aCBtaXNtYXRjaC5cIixcXG4gICAgICAgIGBFeHBlY3RlZCBsZW5ndGggKHBhcmFtZXRlcnMpOiAke2V4cGVjdGVkTGVuZ3RofWAsXFxuICAgICAgICBgR2l2ZW4gbGVuZ3RoICh2YWx1ZXMpOiAke2dpdmVuTGVuZ3RofWBcXG4gICAgICBdLmpvaW4oXCJcXFxcblwiKSk7XFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICB2YWx1ZTogXCJBYmlQYXJhbWV0ZXJzLkxlbmd0aE1pc21hdGNoRXJyb3JcIlxcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9O1xcbiAgdmFyIEludmFsaWRBcnJheUVycm9yMiA9IGNsYXNzIGV4dGVuZHMgQmFzZUVycm9yMyB7XFxuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XFxuICAgICAgc3VwZXIoYFZhbHVlIFxcXFxgJHt2YWx1ZX1cXFxcYCBpcyBub3QgYSB2YWxpZCBhcnJheS5gKTtcXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcXG4gICAgICAgIHZhbHVlOiBcIkFiaVBhcmFtZXRlcnMuSW52YWxpZEFycmF5RXJyb3JcIlxcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9O1xcbiAgdmFyIEludmFsaWRUeXBlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJhc2VFcnJvcjMge1xcbiAgICBjb25zdHJ1Y3Rvcih0eXBlKSB7XFxuICAgICAgc3VwZXIoYFR5cGUgXFxcXGAke3R5cGV9XFxcXGAgaXMgbm90IGEgdmFsaWQgQUJJIFR5cGUuYCk7XFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgICB2YWx1ZTogXCJBYmlQYXJhbWV0ZXJzLkludmFsaWRUeXBlRXJyb3JcIlxcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9O1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vb3hAMC42LjlfdHlwZXNjcmlwdEA1LjguM196b2RAMy4yNC4zL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQWJpQ29uc3RydWN0b3IuanNcXG4gIGZ1bmN0aW9uIGVuY29kZTMoYWJpQ29uc3RydWN0b3IsIG9wdGlvbnMpIHtcXG4gICAgY29uc3QgeyBieXRlY29kZSwgYXJncyB9ID0gb3B0aW9ucztcXG4gICAgcmV0dXJuIGNvbmNhdDIoYnl0ZWNvZGUsIGFiaUNvbnN0cnVjdG9yLmlucHV0cz8ubGVuZ3RoICYmIGFyZ3M/Lmxlbmd0aCA/IGVuY29kZTIoYWJpQ29uc3RydWN0b3IuaW5wdXRzLCBhcmdzKSA6IFwiMHhcIik7XFxuICB9XFxuICBmdW5jdGlvbiBmcm9tMyhhYmlDb25zdHJ1Y3Rvcikge1xcbiAgICByZXR1cm4gZnJvbTIoYWJpQ29uc3RydWN0b3IpO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vb3hAMC42LjlfdHlwZXNjcmlwdEA1LjguM196b2RAMy4yNC4zL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQWJpRnVuY3Rpb24uanNcXG4gIGZ1bmN0aW9uIGVuY29kZURhdGEyKGFiaUZ1bmN0aW9uLCAuLi5hcmdzKSB7XFxuICAgIGNvbnN0IHsgb3ZlcmxvYWRzIH0gPSBhYmlGdW5jdGlvbjtcXG4gICAgY29uc3QgaXRlbSA9IG92ZXJsb2FkcyA/IGZyb21BYmkyKFthYmlGdW5jdGlvbiwgLi4ub3ZlcmxvYWRzXSwgYWJpRnVuY3Rpb24ubmFtZSwge1xcbiAgICAgIGFyZ3M6IGFyZ3NbMF1cXG4gICAgfSkgOiBhYmlGdW5jdGlvbjtcXG4gICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3RvcjIoaXRlbSk7XFxuICAgIGNvbnN0IGRhdGEgPSBhcmdzLmxlbmd0aCA+IDAgPyBlbmNvZGUyKGl0ZW0uaW5wdXRzLCBhcmdzWzBdKSA6IHZvaWQgMDtcXG4gICAgcmV0dXJuIGRhdGEgPyBjb25jYXQyKHNlbGVjdG9yLCBkYXRhKSA6IHNlbGVjdG9yO1xcbiAgfVxcbiAgZnVuY3Rpb24gZnJvbTQoYWJpRnVuY3Rpb24sIG9wdGlvbnMgPSB7fSkge1xcbiAgICByZXR1cm4gZnJvbTIoYWJpRnVuY3Rpb24sIG9wdGlvbnMpO1xcbiAgfVxcbiAgZnVuY3Rpb24gZnJvbUFiaTIoYWJpMiwgbmFtZSwgb3B0aW9ucykge1xcbiAgICBjb25zdCBpdGVtID0gZnJvbUFiaShhYmkyLCBuYW1lLCBvcHRpb25zKTtcXG4gICAgaWYgKGl0ZW0udHlwZSAhPT0gXCJmdW5jdGlvblwiKVxcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKHsgbmFtZSwgdHlwZTogXCJmdW5jdGlvblwiIH0pO1xcbiAgICByZXR1cm4gaXRlbTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGdldFNlbGVjdG9yMihhYmlJdGVtKSB7XFxuICAgIHJldHVybiBnZXRTZWxlY3RvcihhYmlJdGVtKTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjdGlvbnMvcHVibGljL3NpbXVsYXRlQ2FsbHMuanNcXG4gIGluaXRfcGFyc2VBY2NvdW50KCk7XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9jb25zdGFudHMvYWRkcmVzcy5qc1xcbiAgdmFyIGV0aEFkZHJlc3MgPSBcIjB4ZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZVwiO1xcbiAgdmFyIHplcm9BZGRyZXNzID0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjdGlvbnMvcHVibGljL3NpbXVsYXRlQ2FsbHMuanNcXG4gIGluaXRfY29udHJhY3RzKCk7XFxuICBpbml0X2Jhc2UoKTtcXG4gIGluaXRfZW5jb2RlRnVuY3Rpb25EYXRhKCk7XFxuICB2YXIgZ2V0QmFsYW5jZUNvZGUgPSBcIjB4NjA4MDYwNDA1MjM0ODAxNTYwMGU1NzVmODBmZDViNTA2MTAxNmQ4MDYxMDAxYzVmMzk1ZmYzZmU2MDgwNjA0MDUyMzQ4MDE1NjEwMDBmNTc1ZjgwZmQ1YjUwNjAwNDM2MTA2MTAwMjk1NzVmMzU2MGUwMWM4MDYzZjhiMmNiNGYxNDYxMDAyZDU3NWI1ZjgwZmQ1YjYxMDA0NzYwMDQ4MDM2MDM4MTAxOTA2MTAwNDI5MTkwNjEwMGRiNTY1YjYxMDA1ZDU2NWI2MDQwNTE2MTAwNTQ5MTkwNjEwMTFlNTY1YjYwNDA1MTgwOTEwMzkwZjM1YjVmODE3M2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmYxNjMxOTA1MDkxOTA1MDU2NWI1ZjgwZmQ1YjVmNzNmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmODIxNjkwNTA5MTkwNTA1NjViNWY2MTAwYWE4MjYxMDA4MTU2NWI5MDUwOTE5MDUwNTY1YjYxMDBiYTgxNjEwMGEwNTY1YjgxMTQ2MTAwYzQ1NzVmODBmZDViNTA1NjViNWY4MTM1OTA1MDYxMDBkNTgxNjEwMGIxNTY1YjkyOTE1MDUwNTY1YjVmNjAyMDgyODQwMzEyMTU2MTAwZjA1NzYxMDBlZjYxMDA3ZDU2NWI1YjVmNjEwMGZkODQ4Mjg1MDE2MTAwYzc1NjViOTE1MDUwOTI5MTUwNTA1NjViNWY4MTkwNTA5MTkwNTA1NjViNjEwMTE4ODE2MTAxMDY1NjViODI1MjUwNTA1NjViNWY2MDIwODIwMTkwNTA2MTAxMzE1ZjgzMDE4NDYxMDEwZjU2NWI5MjkxNTA1MDU2ZmVhMjY0Njk3MDY2NzM1ODIyMTIyMDNiOWZlOTI5ZmU5OTVjN2NmOTg4N2YwYmRiYThhMzZkZDc4ZThiNzNmMTQ5YjE3ZDJkOWFkN2NkMDlkMmRjNjI2NDczNmY2YzYzNDMwMDA4MWEwMDMzXCI7XFxuICBhc3luYyBmdW5jdGlvbiBzaW11bGF0ZUNhbGxzKGNsaWVudCwgcGFyYW1ldGVycykge1xcbiAgICBjb25zdCB7IGJsb2NrTnVtYmVyLCBibG9ja1RhZywgY2FsbHMsIHN0YXRlT3ZlcnJpZGVzLCB0cmFjZUFzc2V0Q2hhbmdlcywgdHJhY2VUcmFuc2ZlcnMsIHZhbGlkYXRpb24gfSA9IHBhcmFtZXRlcnM7XFxuICAgIGNvbnN0IGFjY291bnQgPSBwYXJhbWV0ZXJzLmFjY291bnQgPyBwYXJzZUFjY291bnQocGFyYW1ldGVycy5hY2NvdW50KSA6IHZvaWQgMDtcXG4gICAgaWYgKHRyYWNlQXNzZXRDaGFuZ2VzICYmICFhY2NvdW50KVxcbiAgICAgIHRocm93IG5ldyBCYXNlRXJyb3IyKFwiYGFjY291bnRgIGlzIHJlcXVpcmVkIHdoZW4gYHRyYWNlQXNzZXRDaGFuZ2VzYCBpcyB0cnVlXCIpO1xcbiAgICBjb25zdCBnZXRCYWxhbmNlRGF0YSA9IGFjY291bnQgPyBlbmNvZGUzKGZyb20zKFwiY29uc3RydWN0b3IoYnl0ZXMsIGJ5dGVzKVwiKSwge1xcbiAgICAgIGJ5dGVjb2RlOiBkZXBsb3lsZXNzQ2FsbFZpYUJ5dGVjb2RlQnl0ZWNvZGUsXFxuICAgICAgYXJnczogW1xcbiAgICAgICAgZ2V0QmFsYW5jZUNvZGUsXFxuICAgICAgICBlbmNvZGVEYXRhMihmcm9tNChcImZ1bmN0aW9uIGdldEJhbGFuY2UoYWRkcmVzcylcIiksIFthY2NvdW50LmFkZHJlc3NdKVxcbiAgICAgIF1cXG4gICAgfSkgOiB2b2lkIDA7XFxuICAgIGNvbnN0IGFzc2V0QWRkcmVzc2VzID0gdHJhY2VBc3NldENoYW5nZXMgPyBhd2FpdCBQcm9taXNlLmFsbChwYXJhbWV0ZXJzLmNhbGxzLm1hcChhc3luYyAoY2FsbDIpID0+IHtcXG4gICAgICBpZiAoIWNhbGwyLmRhdGEgJiYgIWNhbGwyLmFiaSlcXG4gICAgICAgIHJldHVybjtcXG4gICAgICBjb25zdCB7IGFjY2Vzc0xpc3QgfSA9IGF3YWl0IGNyZWF0ZUFjY2Vzc0xpc3QoY2xpZW50LCB7XFxuICAgICAgICBhY2NvdW50OiBhY2NvdW50LmFkZHJlc3MsXFxuICAgICAgICAuLi5jYWxsMixcXG4gICAgICAgIGRhdGE6IGNhbGwyLmFiaSA/IGVuY29kZUZ1bmN0aW9uRGF0YShjYWxsMikgOiBjYWxsMi5kYXRhXFxuICAgICAgfSk7XFxuICAgICAgcmV0dXJuIGFjY2Vzc0xpc3QubWFwKCh7IGFkZHJlc3MsIHN0b3JhZ2VLZXlzIH0pID0+IHN0b3JhZ2VLZXlzLmxlbmd0aCA+IDAgPyBhZGRyZXNzIDogbnVsbCk7XFxuICAgIH0pKS50aGVuKCh4KSA9PiB4LmZsYXQoKS5maWx0ZXIoQm9vbGVhbikpIDogW107XFxuICAgIGNvbnN0IHJlc3VsdHNTdGF0ZU92ZXJyaWRlcyA9IHN0YXRlT3ZlcnJpZGVzPy5tYXAoKG92ZXJyaWRlKSA9PiB7XFxuICAgICAgaWYgKG92ZXJyaWRlLmFkZHJlc3MgPT09IGFjY291bnQ/LmFkZHJlc3MpXFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAuLi5vdmVycmlkZSxcXG4gICAgICAgICAgbm9uY2U6IDBcXG4gICAgICAgIH07XFxuICAgICAgcmV0dXJuIG92ZXJyaWRlO1xcbiAgICB9KTtcXG4gICAgY29uc3QgYmxvY2tzID0gYXdhaXQgc2ltdWxhdGVCbG9ja3MoY2xpZW50LCB7XFxuICAgICAgYmxvY2tOdW1iZXIsXFxuICAgICAgYmxvY2tUYWcsXFxuICAgICAgYmxvY2tzOiBbXFxuICAgICAgICAuLi50cmFjZUFzc2V0Q2hhbmdlcyA/IFtcXG4gICAgICAgICAgLy8gRVRIIHByZSBiYWxhbmNlc1xcbiAgICAgICAgICB7XFxuICAgICAgICAgICAgY2FsbHM6IFt7IGRhdGE6IGdldEJhbGFuY2VEYXRhIH1dLFxcbiAgICAgICAgICAgIHN0YXRlT3ZlcnJpZGVzXFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIC8vIEFzc2V0IHByZSBiYWxhbmNlc1xcbiAgICAgICAgICB7XFxuICAgICAgICAgICAgY2FsbHM6IGFzc2V0QWRkcmVzc2VzLm1hcCgoYWRkcmVzcywgaSkgPT4gKHtcXG4gICAgICAgICAgICAgIGFiaTogW1xcbiAgICAgICAgICAgICAgICBmcm9tNChcImZ1bmN0aW9uIGJhbGFuY2VPZihhZGRyZXNzKSByZXR1cm5zICh1aW50MjU2KVwiKVxcbiAgICAgICAgICAgICAgXSxcXG4gICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogXCJiYWxhbmNlT2ZcIixcXG4gICAgICAgICAgICAgIGFyZ3M6IFthY2NvdW50LmFkZHJlc3NdLFxcbiAgICAgICAgICAgICAgdG86IGFkZHJlc3MsXFxuICAgICAgICAgICAgICBmcm9tOiB6ZXJvQWRkcmVzcyxcXG4gICAgICAgICAgICAgIG5vbmNlOiBpXFxuICAgICAgICAgICAgfSkpLFxcbiAgICAgICAgICAgIHN0YXRlT3ZlcnJpZGVzOiBbXFxuICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHplcm9BZGRyZXNzLFxcbiAgICAgICAgICAgICAgICBub25jZTogMFxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIF1cXG4gICAgICAgICAgfVxcbiAgICAgICAgXSA6IFtdLFxcbiAgICAgICAge1xcbiAgICAgICAgICBjYWxsczogWy4uLmNhbGxzLCB7fV0ubWFwKChjYWxsMiwgaW5kZXgyKSA9PiAoe1xcbiAgICAgICAgICAgIC4uLmNhbGwyLFxcbiAgICAgICAgICAgIGZyb206IGFjY291bnQ/LmFkZHJlc3MsXFxuICAgICAgICAgICAgbm9uY2U6IGluZGV4MlxcbiAgICAgICAgICB9KSksXFxuICAgICAgICAgIHN0YXRlT3ZlcnJpZGVzOiByZXN1bHRzU3RhdGVPdmVycmlkZXNcXG4gICAgICAgIH0sXFxuICAgICAgICAuLi50cmFjZUFzc2V0Q2hhbmdlcyA/IFtcXG4gICAgICAgICAgLy8gRVRIIHBvc3QgYmFsYW5jZXNcXG4gICAgICAgICAge1xcbiAgICAgICAgICAgIGNhbGxzOiBbeyBkYXRhOiBnZXRCYWxhbmNlRGF0YSB9XVxcbiAgICAgICAgICB9LFxcbiAgICAgICAgICAvLyBBc3NldCBwb3N0IGJhbGFuY2VzXFxuICAgICAgICAgIHtcXG4gICAgICAgICAgICBjYWxsczogYXNzZXRBZGRyZXNzZXMubWFwKChhZGRyZXNzLCBpKSA9PiAoe1xcbiAgICAgICAgICAgICAgYWJpOiBbXFxuICAgICAgICAgICAgICAgIGZyb200KFwiZnVuY3Rpb24gYmFsYW5jZU9mKGFkZHJlc3MpIHJldHVybnMgKHVpbnQyNTYpXCIpXFxuICAgICAgICAgICAgICBdLFxcbiAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBcImJhbGFuY2VPZlwiLFxcbiAgICAgICAgICAgICAgYXJnczogW2FjY291bnQuYWRkcmVzc10sXFxuICAgICAgICAgICAgICB0bzogYWRkcmVzcyxcXG4gICAgICAgICAgICAgIGZyb206IHplcm9BZGRyZXNzLFxcbiAgICAgICAgICAgICAgbm9uY2U6IGlcXG4gICAgICAgICAgICB9KSksXFxuICAgICAgICAgICAgc3RhdGVPdmVycmlkZXM6IFtcXG4gICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgYWRkcmVzczogemVyb0FkZHJlc3MsXFxuICAgICAgICAgICAgICAgIG5vbmNlOiAwXFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgXVxcbiAgICAgICAgICB9LFxcbiAgICAgICAgICAvLyBEZWNpbWFsc1xcbiAgICAgICAgICB7XFxuICAgICAgICAgICAgY2FsbHM6IGFzc2V0QWRkcmVzc2VzLm1hcCgoYWRkcmVzcywgaSkgPT4gKHtcXG4gICAgICAgICAgICAgIHRvOiBhZGRyZXNzLFxcbiAgICAgICAgICAgICAgYWJpOiBbXFxuICAgICAgICAgICAgICAgIGZyb200KFwiZnVuY3Rpb24gZGVjaW1hbHMoKSByZXR1cm5zICh1aW50MjU2KVwiKVxcbiAgICAgICAgICAgICAgXSxcXG4gICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogXCJkZWNpbWFsc1wiLFxcbiAgICAgICAgICAgICAgZnJvbTogemVyb0FkZHJlc3MsXFxuICAgICAgICAgICAgICBub25jZTogaVxcbiAgICAgICAgICAgIH0pKSxcXG4gICAgICAgICAgICBzdGF0ZU92ZXJyaWRlczogW1xcbiAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiB6ZXJvQWRkcmVzcyxcXG4gICAgICAgICAgICAgICAgbm9uY2U6IDBcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBdXFxuICAgICAgICAgIH0sXFxuICAgICAgICAgIC8vIFRva2VuIFVSSVxcbiAgICAgICAgICB7XFxuICAgICAgICAgICAgY2FsbHM6IGFzc2V0QWRkcmVzc2VzLm1hcCgoYWRkcmVzcywgaSkgPT4gKHtcXG4gICAgICAgICAgICAgIHRvOiBhZGRyZXNzLFxcbiAgICAgICAgICAgICAgYWJpOiBbXFxuICAgICAgICAgICAgICAgIGZyb200KFwiZnVuY3Rpb24gdG9rZW5VUkkodWludDI1NikgcmV0dXJucyAoc3RyaW5nKVwiKVxcbiAgICAgICAgICAgICAgXSxcXG4gICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogXCJ0b2tlblVSSVwiLFxcbiAgICAgICAgICAgICAgYXJnczogWzBuXSxcXG4gICAgICAgICAgICAgIGZyb206IHplcm9BZGRyZXNzLFxcbiAgICAgICAgICAgICAgbm9uY2U6IGlcXG4gICAgICAgICAgICB9KSksXFxuICAgICAgICAgICAgc3RhdGVPdmVycmlkZXM6IFtcXG4gICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgYWRkcmVzczogemVyb0FkZHJlc3MsXFxuICAgICAgICAgICAgICAgIG5vbmNlOiAwXFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgXVxcbiAgICAgICAgICB9LFxcbiAgICAgICAgICAvLyBTeW1ib2xzXFxuICAgICAgICAgIHtcXG4gICAgICAgICAgICBjYWxsczogYXNzZXRBZGRyZXNzZXMubWFwKChhZGRyZXNzLCBpKSA9PiAoe1xcbiAgICAgICAgICAgICAgdG86IGFkZHJlc3MsXFxuICAgICAgICAgICAgICBhYmk6IFtmcm9tNChcImZ1bmN0aW9uIHN5bWJvbCgpIHJldHVybnMgKHN0cmluZylcIildLFxcbiAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBcInN5bWJvbFwiLFxcbiAgICAgICAgICAgICAgZnJvbTogemVyb0FkZHJlc3MsXFxuICAgICAgICAgICAgICBub25jZTogaVxcbiAgICAgICAgICAgIH0pKSxcXG4gICAgICAgICAgICBzdGF0ZU92ZXJyaWRlczogW1xcbiAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiB6ZXJvQWRkcmVzcyxcXG4gICAgICAgICAgICAgICAgbm9uY2U6IDBcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBdXFxuICAgICAgICAgIH1cXG4gICAgICAgIF0gOiBbXVxcbiAgICAgIF0sXFxuICAgICAgdHJhY2VUcmFuc2ZlcnMsXFxuICAgICAgdmFsaWRhdGlvblxcbiAgICB9KTtcXG4gICAgY29uc3QgYmxvY2tfcmVzdWx0cyA9IHRyYWNlQXNzZXRDaGFuZ2VzID8gYmxvY2tzWzJdIDogYmxvY2tzWzBdO1xcbiAgICBjb25zdCBbYmxvY2tfZXRoUHJlLCBibG9ja19hc3NldHNQcmUsICwgYmxvY2tfZXRoUG9zdCwgYmxvY2tfYXNzZXRzUG9zdCwgYmxvY2tfZGVjaW1hbHMsIGJsb2NrX3Rva2VuVVJJLCBibG9ja19zeW1ib2xzXSA9IHRyYWNlQXNzZXRDaGFuZ2VzID8gYmxvY2tzIDogW107XFxuICAgIGNvbnN0IHsgY2FsbHM6IGJsb2NrX2NhbGxzLCAuLi5ibG9jayB9ID0gYmxvY2tfcmVzdWx0cztcXG4gICAgY29uc3QgcmVzdWx0cyA9IGJsb2NrX2NhbGxzLnNsaWNlKDAsIC0xKSA/PyBbXTtcXG4gICAgY29uc3QgZXRoUHJlID0gYmxvY2tfZXRoUHJlPy5jYWxscyA/PyBbXTtcXG4gICAgY29uc3QgYXNzZXRzUHJlID0gYmxvY2tfYXNzZXRzUHJlPy5jYWxscyA/PyBbXTtcXG4gICAgY29uc3QgYmFsYW5jZXNQcmUgPSBbLi4uZXRoUHJlLCAuLi5hc3NldHNQcmVdLm1hcCgoY2FsbDIpID0+IGNhbGwyLnN0YXR1cyA9PT0gXCJzdWNjZXNzXCIgPyBoZXhUb0JpZ0ludChjYWxsMi5kYXRhKSA6IG51bGwpO1xcbiAgICBjb25zdCBldGhQb3N0ID0gYmxvY2tfZXRoUG9zdD8uY2FsbHMgPz8gW107XFxuICAgIGNvbnN0IGFzc2V0c1Bvc3QgPSBibG9ja19hc3NldHNQb3N0Py5jYWxscyA/PyBbXTtcXG4gICAgY29uc3QgYmFsYW5jZXNQb3N0ID0gWy4uLmV0aFBvc3QsIC4uLmFzc2V0c1Bvc3RdLm1hcCgoY2FsbDIpID0+IGNhbGwyLnN0YXR1cyA9PT0gXCJzdWNjZXNzXCIgPyBoZXhUb0JpZ0ludChjYWxsMi5kYXRhKSA6IG51bGwpO1xcbiAgICBjb25zdCBkZWNpbWFscyA9IChibG9ja19kZWNpbWFscz8uY2FsbHMgPz8gW10pLm1hcCgoeCkgPT4geC5zdGF0dXMgPT09IFwic3VjY2Vzc1wiID8geC5yZXN1bHQgOiBudWxsKTtcXG4gICAgY29uc3Qgc3ltYm9scyA9IChibG9ja19zeW1ib2xzPy5jYWxscyA/PyBbXSkubWFwKCh4KSA9PiB4LnN0YXR1cyA9PT0gXCJzdWNjZXNzXCIgPyB4LnJlc3VsdCA6IG51bGwpO1xcbiAgICBjb25zdCB0b2tlblVSSSA9IChibG9ja190b2tlblVSST8uY2FsbHMgPz8gW10pLm1hcCgoeCkgPT4geC5zdGF0dXMgPT09IFwic3VjY2Vzc1wiID8geC5yZXN1bHQgOiBudWxsKTtcXG4gICAgY29uc3QgY2hhbmdlcyA9IFtdO1xcbiAgICBmb3IgKGNvbnN0IFtpLCBiYWxhbmNlUG9zdF0gb2YgYmFsYW5jZXNQb3N0LmVudHJpZXMoKSkge1xcbiAgICAgIGNvbnN0IGJhbGFuY2VQcmUgPSBiYWxhbmNlc1ByZVtpXTtcXG4gICAgICBpZiAodHlwZW9mIGJhbGFuY2VQb3N0ICE9PSBcImJpZ2ludFwiKVxcbiAgICAgICAgY29udGludWU7XFxuICAgICAgaWYgKHR5cGVvZiBiYWxhbmNlUHJlICE9PSBcImJpZ2ludFwiKVxcbiAgICAgICAgY29udGludWU7XFxuICAgICAgY29uc3QgZGVjaW1hbHNfID0gZGVjaW1hbHNbaSAtIDFdO1xcbiAgICAgIGNvbnN0IHN5bWJvbF8gPSBzeW1ib2xzW2kgLSAxXTtcXG4gICAgICBjb25zdCB0b2tlblVSSV8gPSB0b2tlblVSSVtpIC0gMV07XFxuICAgICAgY29uc3QgdG9rZW4gPSAoKCkgPT4ge1xcbiAgICAgICAgaWYgKGkgPT09IDApXFxuICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgYWRkcmVzczogZXRoQWRkcmVzcyxcXG4gICAgICAgICAgICBkZWNpbWFsczogMTgsXFxuICAgICAgICAgICAgc3ltYm9sOiBcIkVUSFwiXFxuICAgICAgICAgIH07XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICBhZGRyZXNzOiBhc3NldEFkZHJlc3Nlc1tpIC0gMV0sXFxuICAgICAgICAgIGRlY2ltYWxzOiB0b2tlblVSSV8gfHwgZGVjaW1hbHNfID8gTnVtYmVyKGRlY2ltYWxzXyA/PyAxKSA6IHZvaWQgMCxcXG4gICAgICAgICAgc3ltYm9sOiBzeW1ib2xfID8/IHZvaWQgMFxcbiAgICAgICAgfTtcXG4gICAgICB9KSgpO1xcbiAgICAgIGlmIChjaGFuZ2VzLnNvbWUoKGNoYW5nZSkgPT4gY2hhbmdlLnRva2VuLmFkZHJlc3MgPT09IHRva2VuLmFkZHJlc3MpKVxcbiAgICAgICAgY29udGludWU7XFxuICAgICAgY2hhbmdlcy5wdXNoKHtcXG4gICAgICAgIHRva2VuLFxcbiAgICAgICAgdmFsdWU6IHtcXG4gICAgICAgICAgcHJlOiBiYWxhbmNlUHJlLFxcbiAgICAgICAgICBwb3N0OiBiYWxhbmNlUG9zdCxcXG4gICAgICAgICAgZGlmZjogYmFsYW5jZVBvc3QgLSBiYWxhbmNlUHJlXFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHtcXG4gICAgICBhc3NldENoYW5nZXM6IGNoYW5nZXMsXFxuICAgICAgYmxvY2ssXFxuICAgICAgcmVzdWx0c1xcbiAgICB9O1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vYWN0aW9ucy9wdWJsaWMvdmVyaWZ5SGFzaC5qc1xcbiAgaW5pdF9hYmlzKCk7XFxuICBpbml0X2NvbnRyYWN0cygpO1xcbiAgaW5pdF9jb250cmFjdCgpO1xcbiAgaW5pdF9lbmNvZGVEZXBsb3lEYXRhKCk7XFxuICBpbml0X2dldEFkZHJlc3MoKTtcXG4gIGluaXRfaXNBZGRyZXNzRXF1YWwoKTtcXG4gIGluaXRfaXNIZXgoKTtcXG4gIGluaXRfdG9IZXgoKTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL3NpZ25hdHVyZS9zZXJpYWxpemVTaWduYXR1cmUuanNcXG4gIGluaXRfc2VjcDI1NmsxKCk7XFxuICBpbml0X2Zyb21IZXgoKTtcXG4gIGluaXRfdG9CeXRlcygpO1xcbiAgZnVuY3Rpb24gc2VyaWFsaXplU2lnbmF0dXJlKHsgciwgcywgdG8gPSBcImhleFwiLCB2LCB5UGFyaXR5IH0pIHtcXG4gICAgY29uc3QgeVBhcml0eV8gPSAoKCkgPT4ge1xcbiAgICAgIGlmICh5UGFyaXR5ID09PSAwIHx8IHlQYXJpdHkgPT09IDEpXFxuICAgICAgICByZXR1cm4geVBhcml0eTtcXG4gICAgICBpZiAodiAmJiAodiA9PT0gMjduIHx8IHYgPT09IDI4biB8fCB2ID49IDM1bikpXFxuICAgICAgICByZXR1cm4gdiAlIDJuID09PSAwbiA/IDEgOiAwO1xcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYHZgIG9yIGB5UGFyaXR5YCB2YWx1ZVwiKTtcXG4gICAgfSkoKTtcXG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYDB4JHtuZXcgc2VjcDI1NmsxLlNpZ25hdHVyZShoZXhUb0JpZ0ludChyKSwgaGV4VG9CaWdJbnQocykpLnRvQ29tcGFjdEhleCgpfSR7eVBhcml0eV8gPT09IDAgPyBcIjFiXCIgOiBcIjFjXCJ9YDtcXG4gICAgaWYgKHRvID09PSBcImhleFwiKVxcbiAgICAgIHJldHVybiBzaWduYXR1cmU7XFxuICAgIHJldHVybiBoZXhUb0J5dGVzKHNpZ25hdHVyZSk7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL3B1YmxpYy92ZXJpZnlIYXNoLmpzXFxuICBpbml0X2NhbGwoKTtcXG4gIGFzeW5jIGZ1bmN0aW9uIHZlcmlmeUhhc2goY2xpZW50LCBwYXJhbWV0ZXJzKSB7XFxuICAgIGNvbnN0IHsgYWRkcmVzcywgZmFjdG9yeSwgZmFjdG9yeURhdGEsIGhhc2g6IGhhc2gyLCBzaWduYXR1cmUsIHVuaXZlcnNhbFNpZ25hdHVyZVZlcmlmaWVyQWRkcmVzcyA9IGNsaWVudC5jaGFpbj8uY29udHJhY3RzPy51bml2ZXJzYWxTaWduYXR1cmVWZXJpZmllcj8uYWRkcmVzcywgLi4ucmVzdCB9ID0gcGFyYW1ldGVycztcXG4gICAgY29uc3Qgc2lnbmF0dXJlSGV4ID0gKCgpID0+IHtcXG4gICAgICBpZiAoaXNIZXgoc2lnbmF0dXJlKSlcXG4gICAgICAgIHJldHVybiBzaWduYXR1cmU7XFxuICAgICAgaWYgKHR5cGVvZiBzaWduYXR1cmUgPT09IFwib2JqZWN0XCIgJiYgXCJyXCIgaW4gc2lnbmF0dXJlICYmIFwic1wiIGluIHNpZ25hdHVyZSlcXG4gICAgICAgIHJldHVybiBzZXJpYWxpemVTaWduYXR1cmUoc2lnbmF0dXJlKTtcXG4gICAgICByZXR1cm4gYnl0ZXNUb0hleChzaWduYXR1cmUpO1xcbiAgICB9KSgpO1xcbiAgICBjb25zdCB3cmFwcGVkU2lnbmF0dXJlID0gYXdhaXQgKGFzeW5jICgpID0+IHtcXG4gICAgICBpZiAoIWZhY3RvcnkgJiYgIWZhY3RvcnlEYXRhKVxcbiAgICAgICAgcmV0dXJuIHNpZ25hdHVyZUhleDtcXG4gICAgICBpZiAoaXNFcmM2NDkyU2lnbmF0dXJlKHNpZ25hdHVyZUhleCkpXFxuICAgICAgICByZXR1cm4gc2lnbmF0dXJlSGV4O1xcbiAgICAgIHJldHVybiBzZXJpYWxpemVFcmM2NDkyU2lnbmF0dXJlKHtcXG4gICAgICAgIGFkZHJlc3M6IGZhY3RvcnksXFxuICAgICAgICBkYXRhOiBmYWN0b3J5RGF0YSxcXG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlSGV4XFxuICAgICAgfSk7XFxuICAgIH0pKCk7XFxuICAgIHRyeSB7XFxuICAgICAgY29uc3QgYXJncyA9IHVuaXZlcnNhbFNpZ25hdHVyZVZlcmlmaWVyQWRkcmVzcyA/IHtcXG4gICAgICAgIHRvOiB1bml2ZXJzYWxTaWduYXR1cmVWZXJpZmllckFkZHJlc3MsXFxuICAgICAgICBkYXRhOiBlbmNvZGVGdW5jdGlvbkRhdGEoe1xcbiAgICAgICAgICBhYmk6IHVuaXZlcnNhbFNpZ25hdHVyZVZhbGlkYXRvckFiaSxcXG4gICAgICAgICAgZnVuY3Rpb25OYW1lOiBcImlzVmFsaWRTaWdcIixcXG4gICAgICAgICAgYXJnczogW2FkZHJlc3MsIGhhc2gyLCB3cmFwcGVkU2lnbmF0dXJlXVxcbiAgICAgICAgfSksXFxuICAgICAgICAuLi5yZXN0XFxuICAgICAgfSA6IHtcXG4gICAgICAgIGRhdGE6IGVuY29kZURlcGxveURhdGEoe1xcbiAgICAgICAgICBhYmk6IHVuaXZlcnNhbFNpZ25hdHVyZVZhbGlkYXRvckFiaSxcXG4gICAgICAgICAgYXJnczogW2FkZHJlc3MsIGhhc2gyLCB3cmFwcGVkU2lnbmF0dXJlXSxcXG4gICAgICAgICAgYnl0ZWNvZGU6IHVuaXZlcnNhbFNpZ25hdHVyZVZhbGlkYXRvckJ5dGVDb2RlXFxuICAgICAgICB9KSxcXG4gICAgICAgIC4uLnJlc3RcXG4gICAgICB9O1xcbiAgICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgZ2V0QWN0aW9uKGNsaWVudCwgY2FsbCwgXCJjYWxsXCIpKGFyZ3MpO1xcbiAgICAgIHJldHVybiBoZXhUb0Jvb2woZGF0YSA/PyBcIjB4MFwiKTtcXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcXG4gICAgICB0cnkge1xcbiAgICAgICAgY29uc3QgdmVyaWZpZWQgPSBpc0FkZHJlc3NFcXVhbChnZXRBZGRyZXNzKGFkZHJlc3MpLCBhd2FpdCByZWNvdmVyQWRkcmVzcyh7IGhhc2g6IGhhc2gyLCBzaWduYXR1cmUgfSkpO1xcbiAgICAgICAgaWYgKHZlcmlmaWVkKVxcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICB9IGNhdGNoIHtcXG4gICAgICB9XFxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQ2FsbEV4ZWN1dGlvbkVycm9yKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcbiAgICAgIHRocm93IGVycm9yO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL3B1YmxpYy92ZXJpZnlNZXNzYWdlLmpzXFxuICBhc3luYyBmdW5jdGlvbiB2ZXJpZnlNZXNzYWdlKGNsaWVudCwgeyBhZGRyZXNzLCBtZXNzYWdlLCBmYWN0b3J5LCBmYWN0b3J5RGF0YSwgc2lnbmF0dXJlLCAuLi5jYWxsUmVxdWVzdCB9KSB7XFxuICAgIGNvbnN0IGhhc2gyID0gaGFzaE1lc3NhZ2UobWVzc2FnZSk7XFxuICAgIHJldHVybiB2ZXJpZnlIYXNoKGNsaWVudCwge1xcbiAgICAgIGFkZHJlc3MsXFxuICAgICAgZmFjdG9yeSxcXG4gICAgICBmYWN0b3J5RGF0YSxcXG4gICAgICBoYXNoOiBoYXNoMixcXG4gICAgICBzaWduYXR1cmUsXFxuICAgICAgLi4uY2FsbFJlcXVlc3RcXG4gICAgfSk7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL3B1YmxpYy92ZXJpZnlUeXBlZERhdGEuanNcXG4gIGFzeW5jIGZ1bmN0aW9uIHZlcmlmeVR5cGVkRGF0YShjbGllbnQsIHBhcmFtZXRlcnMpIHtcXG4gICAgY29uc3QgeyBhZGRyZXNzLCBmYWN0b3J5LCBmYWN0b3J5RGF0YSwgc2lnbmF0dXJlLCBtZXNzYWdlLCBwcmltYXJ5VHlwZSwgdHlwZXMsIGRvbWFpbiwgLi4uY2FsbFJlcXVlc3QgfSA9IHBhcmFtZXRlcnM7XFxuICAgIGNvbnN0IGhhc2gyID0gaGFzaFR5cGVkRGF0YSh7IG1lc3NhZ2UsIHByaW1hcnlUeXBlLCB0eXBlcywgZG9tYWluIH0pO1xcbiAgICByZXR1cm4gdmVyaWZ5SGFzaChjbGllbnQsIHtcXG4gICAgICBhZGRyZXNzLFxcbiAgICAgIGZhY3RvcnksXFxuICAgICAgZmFjdG9yeURhdGEsXFxuICAgICAgaGFzaDogaGFzaDIsXFxuICAgICAgc2lnbmF0dXJlLFxcbiAgICAgIC4uLmNhbGxSZXF1ZXN0XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vYWN0aW9ucy9wdWJsaWMvd2FpdEZvclRyYW5zYWN0aW9uUmVjZWlwdC5qc1xcbiAgaW5pdF90cmFuc2FjdGlvbigpO1xcbiAgaW5pdF93aXRoUmVzb2x2ZXJzKCk7XFxuICBpbml0X3N0cmluZ2lmeSgpO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vYWN0aW9ucy9wdWJsaWMvd2F0Y2hCbG9ja051bWJlci5qc1xcbiAgaW5pdF9mcm9tSGV4KCk7XFxuICBpbml0X3N0cmluZ2lmeSgpO1xcbiAgZnVuY3Rpb24gd2F0Y2hCbG9ja051bWJlcihjbGllbnQsIHsgZW1pdE9uQmVnaW4gPSBmYWxzZSwgZW1pdE1pc3NlZCA9IGZhbHNlLCBvbkJsb2NrTnVtYmVyLCBvbkVycm9yLCBwb2xsOiBwb2xsXywgcG9sbGluZ0ludGVydmFsID0gY2xpZW50LnBvbGxpbmdJbnRlcnZhbCB9KSB7XFxuICAgIGNvbnN0IGVuYWJsZVBvbGxpbmcgPSAoKCkgPT4ge1xcbiAgICAgIGlmICh0eXBlb2YgcG9sbF8gIT09IFwidW5kZWZpbmVkXCIpXFxuICAgICAgICByZXR1cm4gcG9sbF87XFxuICAgICAgaWYgKGNsaWVudC50cmFuc3BvcnQudHlwZSA9PT0gXCJ3ZWJTb2NrZXRcIilcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICBpZiAoY2xpZW50LnRyYW5zcG9ydC50eXBlID09PSBcImZhbGxiYWNrXCIgJiYgY2xpZW50LnRyYW5zcG9ydC50cmFuc3BvcnRzWzBdLmNvbmZpZy50eXBlID09PSBcIndlYlNvY2tldFwiKVxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9KSgpO1xcbiAgICBsZXQgcHJldkJsb2NrTnVtYmVyO1xcbiAgICBjb25zdCBwb2xsQmxvY2tOdW1iZXIgPSAoKSA9PiB7XFxuICAgICAgY29uc3Qgb2JzZXJ2ZXJJZCA9IHN0cmluZ2lmeShbXFxuICAgICAgICBcIndhdGNoQmxvY2tOdW1iZXJcIixcXG4gICAgICAgIGNsaWVudC51aWQsXFxuICAgICAgICBlbWl0T25CZWdpbixcXG4gICAgICAgIGVtaXRNaXNzZWQsXFxuICAgICAgICBwb2xsaW5nSW50ZXJ2YWxcXG4gICAgICBdKTtcXG4gICAgICByZXR1cm4gb2JzZXJ2ZShvYnNlcnZlcklkLCB7IG9uQmxvY2tOdW1iZXIsIG9uRXJyb3IgfSwgKGVtaXQpID0+IHBvbGwoYXN5bmMgKCkgPT4ge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSBhd2FpdCBnZXRBY3Rpb24oY2xpZW50LCBnZXRCbG9ja051bWJlciwgXCJnZXRCbG9ja051bWJlclwiKSh7IGNhY2hlVGltZTogMCB9KTtcXG4gICAgICAgICAgaWYgKHByZXZCbG9ja051bWJlcikge1xcbiAgICAgICAgICAgIGlmIChibG9ja051bWJlciA9PT0gcHJldkJsb2NrTnVtYmVyKVxcbiAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIGlmIChibG9ja051bWJlciAtIHByZXZCbG9ja051bWJlciA+IDEgJiYgZW1pdE1pc3NlZCkge1xcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHByZXZCbG9ja051bWJlciArIDFuOyBpIDwgYmxvY2tOdW1iZXI7IGkrKykge1xcbiAgICAgICAgICAgICAgICBlbWl0Lm9uQmxvY2tOdW1iZXIoaSwgcHJldkJsb2NrTnVtYmVyKTtcXG4gICAgICAgICAgICAgICAgcHJldkJsb2NrTnVtYmVyID0gaTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKCFwcmV2QmxvY2tOdW1iZXIgfHwgYmxvY2tOdW1iZXIgPiBwcmV2QmxvY2tOdW1iZXIpIHtcXG4gICAgICAgICAgICBlbWl0Lm9uQmxvY2tOdW1iZXIoYmxvY2tOdW1iZXIsIHByZXZCbG9ja051bWJlcik7XFxuICAgICAgICAgICAgcHJldkJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgICAgICBlbWl0Lm9uRXJyb3I/LihlcnIpO1xcbiAgICAgICAgfVxcbiAgICAgIH0sIHtcXG4gICAgICAgIGVtaXRPbkJlZ2luLFxcbiAgICAgICAgaW50ZXJ2YWw6IHBvbGxpbmdJbnRlcnZhbFxcbiAgICAgIH0pKTtcXG4gICAgfTtcXG4gICAgY29uc3Qgc3Vic2NyaWJlQmxvY2tOdW1iZXIgPSAoKSA9PiB7XFxuICAgICAgY29uc3Qgb2JzZXJ2ZXJJZCA9IHN0cmluZ2lmeShbXFxuICAgICAgICBcIndhdGNoQmxvY2tOdW1iZXJcIixcXG4gICAgICAgIGNsaWVudC51aWQsXFxuICAgICAgICBlbWl0T25CZWdpbixcXG4gICAgICAgIGVtaXRNaXNzZWRcXG4gICAgICBdKTtcXG4gICAgICByZXR1cm4gb2JzZXJ2ZShvYnNlcnZlcklkLCB7IG9uQmxvY2tOdW1iZXIsIG9uRXJyb3IgfSwgKGVtaXQpID0+IHtcXG4gICAgICAgIGxldCBhY3RpdmUgPSB0cnVlO1xcbiAgICAgICAgbGV0IHVuc3Vic2NyaWJlID0gKCkgPT4gYWN0aXZlID0gZmFsc2U7XFxuICAgICAgICAoYXN5bmMgKCkgPT4ge1xcbiAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zcG9ydCA9ICgoKSA9PiB7XFxuICAgICAgICAgICAgICBpZiAoY2xpZW50LnRyYW5zcG9ydC50eXBlID09PSBcImZhbGxiYWNrXCIpIHtcXG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNwb3J0MiA9IGNsaWVudC50cmFuc3BvcnQudHJhbnNwb3J0cy5maW5kKCh0cmFuc3BvcnQzKSA9PiB0cmFuc3BvcnQzLmNvbmZpZy50eXBlID09PSBcIndlYlNvY2tldFwiKTtcXG4gICAgICAgICAgICAgICAgaWYgKCF0cmFuc3BvcnQyKVxcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjbGllbnQudHJhbnNwb3J0O1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNwb3J0Mi52YWx1ZTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIHJldHVybiBjbGllbnQudHJhbnNwb3J0O1xcbiAgICAgICAgICAgIH0pKCk7XFxuICAgICAgICAgICAgY29uc3QgeyB1bnN1YnNjcmliZTogdW5zdWJzY3JpYmVfIH0gPSBhd2FpdCB0cmFuc3BvcnQuc3Vic2NyaWJlKHtcXG4gICAgICAgICAgICAgIHBhcmFtczogW1wibmV3SGVhZHNcIl0sXFxuICAgICAgICAgICAgICBvbkRhdGEoZGF0YSkge1xcbiAgICAgICAgICAgICAgICBpZiAoIWFjdGl2ZSlcXG4gICAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gaGV4VG9CaWdJbnQoZGF0YS5yZXN1bHQ/Lm51bWJlcik7XFxuICAgICAgICAgICAgICAgIGVtaXQub25CbG9ja051bWJlcihibG9ja051bWJlciwgcHJldkJsb2NrTnVtYmVyKTtcXG4gICAgICAgICAgICAgICAgcHJldkJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XFxuICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgb25FcnJvcihlcnJvcikge1xcbiAgICAgICAgICAgICAgICBlbWl0Lm9uRXJyb3I/LihlcnJvcik7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgdW5zdWJzY3JpYmUgPSB1bnN1YnNjcmliZV87XFxuICAgICAgICAgICAgaWYgKCFhY3RpdmUpXFxuICAgICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAgICAgICBvbkVycm9yPy4oZXJyKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSkoKTtcXG4gICAgICAgIHJldHVybiAoKSA9PiB1bnN1YnNjcmliZSgpO1xcbiAgICAgIH0pO1xcbiAgICB9O1xcbiAgICByZXR1cm4gZW5hYmxlUG9sbGluZyA/IHBvbGxCbG9ja051bWJlcigpIDogc3Vic2NyaWJlQmxvY2tOdW1iZXIoKTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjdGlvbnMvcHVibGljL3dhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHQuanNcXG4gIGFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHQoY2xpZW50LCB7XFxuICAgIGNvbmZpcm1hdGlvbnMgPSAxLFxcbiAgICBoYXNoOiBoYXNoMixcXG4gICAgb25SZXBsYWNlZCxcXG4gICAgcG9sbGluZ0ludGVydmFsID0gY2xpZW50LnBvbGxpbmdJbnRlcnZhbCxcXG4gICAgcmV0cnlDb3VudCA9IDYsXFxuICAgIHJldHJ5RGVsYXkgPSAoeyBjb3VudCB9KSA9PiB+figxIDw8IGNvdW50KSAqIDIwMCxcXG4gICAgLy8gZXhwb25lbnRpYWwgYmFja29mZlxcbiAgICB0aW1lb3V0ID0gMThlNFxcbiAgfSkge1xcbiAgICBjb25zdCBvYnNlcnZlcklkID0gc3RyaW5naWZ5KFtcIndhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHRcIiwgY2xpZW50LnVpZCwgaGFzaDJdKTtcXG4gICAgbGV0IHRyYW5zYWN0aW9uO1xcbiAgICBsZXQgcmVwbGFjZWRUcmFuc2FjdGlvbjtcXG4gICAgbGV0IHJlY2VpcHQ7XFxuICAgIGxldCByZXRyeWluZyA9IGZhbHNlO1xcbiAgICBjb25zdCB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9ID0gd2l0aFJlc29sdmVycygpO1xcbiAgICBjb25zdCB0aW1lciA9IHRpbWVvdXQgPyBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgV2FpdEZvclRyYW5zYWN0aW9uUmVjZWlwdFRpbWVvdXRFcnJvcih7IGhhc2g6IGhhc2gyIH0pKSwgdGltZW91dCkgOiB2b2lkIDA7XFxuICAgIGNvbnN0IF91bm9ic2VydmUgPSBvYnNlcnZlKG9ic2VydmVySWQsIHsgb25SZXBsYWNlZCwgcmVzb2x2ZSwgcmVqZWN0IH0sIChlbWl0KSA9PiB7XFxuICAgICAgY29uc3QgX3Vud2F0Y2ggPSBnZXRBY3Rpb24oY2xpZW50LCB3YXRjaEJsb2NrTnVtYmVyLCBcIndhdGNoQmxvY2tOdW1iZXJcIikoe1xcbiAgICAgICAgZW1pdE1pc3NlZDogdHJ1ZSxcXG4gICAgICAgIGVtaXRPbkJlZ2luOiB0cnVlLFxcbiAgICAgICAgcG9sbDogdHJ1ZSxcXG4gICAgICAgIHBvbGxpbmdJbnRlcnZhbCxcXG4gICAgICAgIGFzeW5jIG9uQmxvY2tOdW1iZXIoYmxvY2tOdW1iZXJfKSB7XFxuICAgICAgICAgIGNvbnN0IGRvbmUgPSAoZm4pID0+IHtcXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xcbiAgICAgICAgICAgIF91bndhdGNoKCk7XFxuICAgICAgICAgICAgZm4oKTtcXG4gICAgICAgICAgICBfdW5vYnNlcnZlKCk7XFxuICAgICAgICAgIH07XFxuICAgICAgICAgIGxldCBibG9ja051bWJlciA9IGJsb2NrTnVtYmVyXztcXG4gICAgICAgICAgaWYgKHJldHJ5aW5nKVxcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBpZiAocmVjZWlwdCkge1xcbiAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvbnMgPiAxICYmICghcmVjZWlwdC5ibG9ja051bWJlciB8fCBibG9ja051bWJlciAtIHJlY2VpcHQuYmxvY2tOdW1iZXIgKyAxbiA8IGNvbmZpcm1hdGlvbnMpKVxcbiAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgICBkb25lKCgpID0+IGVtaXQucmVzb2x2ZShyZWNlaXB0KSk7XFxuICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmICghdHJhbnNhY3Rpb24pIHtcXG4gICAgICAgICAgICAgIHJldHJ5aW5nID0gdHJ1ZTtcXG4gICAgICAgICAgICAgIGF3YWl0IHdpdGhSZXRyeShhc3luYyAoKSA9PiB7XFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gYXdhaXQgZ2V0QWN0aW9uKGNsaWVudCwgZ2V0VHJhbnNhY3Rpb24sIFwiZ2V0VHJhbnNhY3Rpb25cIikoeyBoYXNoOiBoYXNoMiB9KTtcXG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmJsb2NrTnVtYmVyKVxcbiAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gdHJhbnNhY3Rpb24uYmxvY2tOdW1iZXI7XFxuICAgICAgICAgICAgICB9LCB7XFxuICAgICAgICAgICAgICAgIGRlbGF5OiByZXRyeURlbGF5LFxcbiAgICAgICAgICAgICAgICByZXRyeUNvdW50XFxuICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgIHJldHJ5aW5nID0gZmFsc2U7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJlY2VpcHQgPSBhd2FpdCBnZXRBY3Rpb24oY2xpZW50LCBnZXRUcmFuc2FjdGlvblJlY2VpcHQsIFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCIpKHsgaGFzaDogaGFzaDIgfSk7XFxuICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvbnMgPiAxICYmICghcmVjZWlwdC5ibG9ja051bWJlciB8fCBibG9ja051bWJlciAtIHJlY2VpcHQuYmxvY2tOdW1iZXIgKyAxbiA8IGNvbmZpcm1hdGlvbnMpKVxcbiAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIGRvbmUoKCkgPT4gZW1pdC5yZXNvbHZlKHJlY2VpcHQpKTtcXG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uTm90Rm91bmRFcnJvciB8fCBlcnIgaW5zdGFuY2VvZiBUcmFuc2FjdGlvblJlY2VpcHROb3RGb3VuZEVycm9yKSB7XFxuICAgICAgICAgICAgICBpZiAoIXRyYW5zYWN0aW9uKSB7XFxuICAgICAgICAgICAgICAgIHJldHJ5aW5nID0gZmFsc2U7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgIHJlcGxhY2VkVHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcXG4gICAgICAgICAgICAgICAgcmV0cnlpbmcgPSB0cnVlO1xcbiAgICAgICAgICAgICAgICBjb25zdCBibG9jayA9IGF3YWl0IHdpdGhSZXRyeSgoKSA9PiBnZXRBY3Rpb24oY2xpZW50LCBnZXRCbG9jaywgXCJnZXRCbG9ja1wiKSh7XFxuICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIsXFxuICAgICAgICAgICAgICAgICAgaW5jbHVkZVRyYW5zYWN0aW9uczogdHJ1ZVxcbiAgICAgICAgICAgICAgICB9KSwge1xcbiAgICAgICAgICAgICAgICAgIGRlbGF5OiByZXRyeURlbGF5LFxcbiAgICAgICAgICAgICAgICAgIHJldHJ5Q291bnQsXFxuICAgICAgICAgICAgICAgICAgc2hvdWxkUmV0cnk6ICh7IGVycm9yIH0pID0+IGVycm9yIGluc3RhbmNlb2YgQmxvY2tOb3RGb3VuZEVycm9yXFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICByZXRyeWluZyA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlbWVudFRyYW5zYWN0aW9uID0gYmxvY2sudHJhbnNhY3Rpb25zLmZpbmQoKHsgZnJvbTogZnJvbTUsIG5vbmNlIH0pID0+IGZyb201ID09PSByZXBsYWNlZFRyYW5zYWN0aW9uLmZyb20gJiYgbm9uY2UgPT09IHJlcGxhY2VkVHJhbnNhY3Rpb24ubm9uY2UpO1xcbiAgICAgICAgICAgICAgICBpZiAoIXJlcGxhY2VtZW50VHJhbnNhY3Rpb24pXFxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgICAgICByZWNlaXB0ID0gYXdhaXQgZ2V0QWN0aW9uKGNsaWVudCwgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0LCBcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiKSh7XFxuICAgICAgICAgICAgICAgICAgaGFzaDogcmVwbGFjZW1lbnRUcmFuc2FjdGlvbi5oYXNoXFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9ucyA+IDEgJiYgKCFyZWNlaXB0LmJsb2NrTnVtYmVyIHx8IGJsb2NrTnVtYmVyIC0gcmVjZWlwdC5ibG9ja051bWJlciArIDFuIDwgY29uZmlybWF0aW9ucykpXFxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgICAgICBsZXQgcmVhc29uID0gXCJyZXBsYWNlZFwiO1xcbiAgICAgICAgICAgICAgICBpZiAocmVwbGFjZW1lbnRUcmFuc2FjdGlvbi50byA9PT0gcmVwbGFjZWRUcmFuc2FjdGlvbi50byAmJiByZXBsYWNlbWVudFRyYW5zYWN0aW9uLnZhbHVlID09PSByZXBsYWNlZFRyYW5zYWN0aW9uLnZhbHVlICYmIHJlcGxhY2VtZW50VHJhbnNhY3Rpb24uaW5wdXQgPT09IHJlcGxhY2VkVHJhbnNhY3Rpb24uaW5wdXQpIHtcXG4gICAgICAgICAgICAgICAgICByZWFzb24gPSBcInJlcHJpY2VkXCI7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVwbGFjZW1lbnRUcmFuc2FjdGlvbi5mcm9tID09PSByZXBsYWNlbWVudFRyYW5zYWN0aW9uLnRvICYmIHJlcGxhY2VtZW50VHJhbnNhY3Rpb24udmFsdWUgPT09IDBuKSB7XFxuICAgICAgICAgICAgICAgICAgcmVhc29uID0gXCJjYW5jZWxsZWRcIjtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBkb25lKCgpID0+IHtcXG4gICAgICAgICAgICAgICAgICBlbWl0Lm9uUmVwbGFjZWQ/Lih7XFxuICAgICAgICAgICAgICAgICAgICByZWFzb24sXFxuICAgICAgICAgICAgICAgICAgICByZXBsYWNlZFRyYW5zYWN0aW9uLFxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHJlcGxhY2VtZW50VHJhbnNhY3Rpb24sXFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvblJlY2VpcHQ6IHJlY2VpcHRcXG4gICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgICBlbWl0LnJlc29sdmUocmVjZWlwdCk7XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyXykge1xcbiAgICAgICAgICAgICAgICBkb25lKCgpID0+IGVtaXQucmVqZWN0KGVycl8pKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgZG9uZSgoKSA9PiBlbWl0LnJlamVjdChlcnIpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfSk7XFxuICAgIHJldHVybiBwcm9taXNlO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vYWN0aW9ucy9wdWJsaWMvd2F0Y2hCbG9ja3MuanNcXG4gIGluaXRfc3RyaW5naWZ5KCk7XFxuICBmdW5jdGlvbiB3YXRjaEJsb2NrcyhjbGllbnQsIHsgYmxvY2tUYWcgPSBcImxhdGVzdFwiLCBlbWl0TWlzc2VkID0gZmFsc2UsIGVtaXRPbkJlZ2luID0gZmFsc2UsIG9uQmxvY2ssIG9uRXJyb3IsIGluY2x1ZGVUcmFuc2FjdGlvbnM6IGluY2x1ZGVUcmFuc2FjdGlvbnNfLCBwb2xsOiBwb2xsXywgcG9sbGluZ0ludGVydmFsID0gY2xpZW50LnBvbGxpbmdJbnRlcnZhbCB9KSB7XFxuICAgIGNvbnN0IGVuYWJsZVBvbGxpbmcgPSAoKCkgPT4ge1xcbiAgICAgIGlmICh0eXBlb2YgcG9sbF8gIT09IFwidW5kZWZpbmVkXCIpXFxuICAgICAgICByZXR1cm4gcG9sbF87XFxuICAgICAgaWYgKGNsaWVudC50cmFuc3BvcnQudHlwZSA9PT0gXCJ3ZWJTb2NrZXRcIilcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICBpZiAoY2xpZW50LnRyYW5zcG9ydC50eXBlID09PSBcImZhbGxiYWNrXCIgJiYgY2xpZW50LnRyYW5zcG9ydC50cmFuc3BvcnRzWzBdLmNvbmZpZy50eXBlID09PSBcIndlYlNvY2tldFwiKVxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9KSgpO1xcbiAgICBjb25zdCBpbmNsdWRlVHJhbnNhY3Rpb25zID0gaW5jbHVkZVRyYW5zYWN0aW9uc18gPz8gZmFsc2U7XFxuICAgIGxldCBwcmV2QmxvY2s7XFxuICAgIGNvbnN0IHBvbGxCbG9ja3MgPSAoKSA9PiB7XFxuICAgICAgY29uc3Qgb2JzZXJ2ZXJJZCA9IHN0cmluZ2lmeShbXFxuICAgICAgICBcIndhdGNoQmxvY2tzXCIsXFxuICAgICAgICBjbGllbnQudWlkLFxcbiAgICAgICAgYmxvY2tUYWcsXFxuICAgICAgICBlbWl0TWlzc2VkLFxcbiAgICAgICAgZW1pdE9uQmVnaW4sXFxuICAgICAgICBpbmNsdWRlVHJhbnNhY3Rpb25zLFxcbiAgICAgICAgcG9sbGluZ0ludGVydmFsXFxuICAgICAgXSk7XFxuICAgICAgcmV0dXJuIG9ic2VydmUob2JzZXJ2ZXJJZCwgeyBvbkJsb2NrLCBvbkVycm9yIH0sIChlbWl0KSA9PiBwb2xsKGFzeW5jICgpID0+IHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgZ2V0QWN0aW9uKGNsaWVudCwgZ2V0QmxvY2ssIFwiZ2V0QmxvY2tcIikoe1xcbiAgICAgICAgICAgIGJsb2NrVGFnLFxcbiAgICAgICAgICAgIGluY2x1ZGVUcmFuc2FjdGlvbnNcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIGlmIChibG9jay5udW1iZXIgJiYgcHJldkJsb2NrPy5udW1iZXIpIHtcXG4gICAgICAgICAgICBpZiAoYmxvY2subnVtYmVyID09PSBwcmV2QmxvY2subnVtYmVyKVxcbiAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIGlmIChibG9jay5udW1iZXIgLSBwcmV2QmxvY2subnVtYmVyID4gMSAmJiBlbWl0TWlzc2VkKSB7XFxuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gcHJldkJsb2NrPy5udW1iZXIgKyAxbjsgaSA8IGJsb2NrLm51bWJlcjsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrMiA9IGF3YWl0IGdldEFjdGlvbihjbGllbnQsIGdldEJsb2NrLCBcImdldEJsb2NrXCIpKHtcXG4gICAgICAgICAgICAgICAgICBibG9ja051bWJlcjogaSxcXG4gICAgICAgICAgICAgICAgICBpbmNsdWRlVHJhbnNhY3Rpb25zXFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICBlbWl0Lm9uQmxvY2soYmxvY2syLCBwcmV2QmxvY2spO1xcbiAgICAgICAgICAgICAgICBwcmV2QmxvY2sgPSBibG9jazI7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmIChcXG4gICAgICAgICAgICAvLyBJZiBubyBwcmV2aW91cyBibG9jayBleGlzdHMsIGVtaXQuXFxuICAgICAgICAgICAgIXByZXZCbG9jaz8ubnVtYmVyIHx8IC8vIElmIHRoZSBibG9jayB0YWcgaXMgXCJwZW5kaW5nXCIgd2l0aCBubyBibG9jayBudW1iZXIsIGVtaXQuXFxuICAgICAgICAgICAgYmxvY2tUYWcgPT09IFwicGVuZGluZ1wiICYmICFibG9jaz8ubnVtYmVyIHx8IC8vIElmIHRoZSBuZXh0IGJsb2NrIG51bWJlciBpcyBncmVhdGVyIHRoYW4gdGhlIHByZXZpb3VzIGJsb2NrIG51bWJlciwgZW1pdC5cXG4gICAgICAgICAgICAvLyBXZSBkb25cXCd0IHdhbnQgdG8gZW1pdCBibG9ja3MgaW4gdGhlIHBhc3QuXFxuICAgICAgICAgICAgYmxvY2subnVtYmVyICYmIGJsb2NrLm51bWJlciA+IHByZXZCbG9jay5udW1iZXJcXG4gICAgICAgICAgKSB7XFxuICAgICAgICAgICAgZW1pdC5vbkJsb2NrKGJsb2NrLCBwcmV2QmxvY2spO1xcbiAgICAgICAgICAgIHByZXZCbG9jayA9IGJsb2NrO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAgICAgZW1pdC5vbkVycm9yPy4oZXJyKTtcXG4gICAgICAgIH1cXG4gICAgICB9LCB7XFxuICAgICAgICBlbWl0T25CZWdpbixcXG4gICAgICAgIGludGVydmFsOiBwb2xsaW5nSW50ZXJ2YWxcXG4gICAgICB9KSk7XFxuICAgIH07XFxuICAgIGNvbnN0IHN1YnNjcmliZUJsb2NrcyA9ICgpID0+IHtcXG4gICAgICBsZXQgYWN0aXZlID0gdHJ1ZTtcXG4gICAgICBsZXQgZW1pdEZldGNoZWQgPSB0cnVlO1xcbiAgICAgIGxldCB1bnN1YnNjcmliZSA9ICgpID0+IGFjdGl2ZSA9IGZhbHNlO1xcbiAgICAgIChhc3luYyAoKSA9PiB7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICBpZiAoZW1pdE9uQmVnaW4pIHtcXG4gICAgICAgICAgICBnZXRBY3Rpb24oY2xpZW50LCBnZXRCbG9jaywgXCJnZXRCbG9ja1wiKSh7XFxuICAgICAgICAgICAgICBibG9ja1RhZyxcXG4gICAgICAgICAgICAgIGluY2x1ZGVUcmFuc2FjdGlvbnNcXG4gICAgICAgICAgICB9KS50aGVuKChibG9jaykgPT4ge1xcbiAgICAgICAgICAgICAgaWYgKCFhY3RpdmUpXFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICAgIGlmICghZW1pdEZldGNoZWQpXFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICAgIG9uQmxvY2soYmxvY2ssIHZvaWQgMCk7XFxuICAgICAgICAgICAgICBlbWl0RmV0Y2hlZCA9IGZhbHNlO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGNvbnN0IHRyYW5zcG9ydCA9ICgoKSA9PiB7XFxuICAgICAgICAgICAgaWYgKGNsaWVudC50cmFuc3BvcnQudHlwZSA9PT0gXCJmYWxsYmFja1wiKSB7XFxuICAgICAgICAgICAgICBjb25zdCB0cmFuc3BvcnQyID0gY2xpZW50LnRyYW5zcG9ydC50cmFuc3BvcnRzLmZpbmQoKHRyYW5zcG9ydDMpID0+IHRyYW5zcG9ydDMuY29uZmlnLnR5cGUgPT09IFwid2ViU29ja2V0XCIpO1xcbiAgICAgICAgICAgICAgaWYgKCF0cmFuc3BvcnQyKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50LnRyYW5zcG9ydDtcXG4gICAgICAgICAgICAgIHJldHVybiB0cmFuc3BvcnQyLnZhbHVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gY2xpZW50LnRyYW5zcG9ydDtcXG4gICAgICAgICAgfSkoKTtcXG4gICAgICAgICAgY29uc3QgeyB1bnN1YnNjcmliZTogdW5zdWJzY3JpYmVfIH0gPSBhd2FpdCB0cmFuc3BvcnQuc3Vic2NyaWJlKHtcXG4gICAgICAgICAgICBwYXJhbXM6IFtcIm5ld0hlYWRzXCJdLFxcbiAgICAgICAgICAgIGFzeW5jIG9uRGF0YShkYXRhKSB7XFxuICAgICAgICAgICAgICBpZiAoIWFjdGl2ZSlcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCBnZXRBY3Rpb24oY2xpZW50LCBnZXRCbG9jaywgXCJnZXRCbG9ja1wiKSh7XFxuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBkYXRhLmJsb2NrTnVtYmVyLFxcbiAgICAgICAgICAgICAgICBpbmNsdWRlVHJhbnNhY3Rpb25zXFxuICAgICAgICAgICAgICB9KS5jYXRjaCgoKSA9PiB7XFxuICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgIGlmICghYWN0aXZlKVxcbiAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgICBvbkJsb2NrKGJsb2NrLCBwcmV2QmxvY2spO1xcbiAgICAgICAgICAgICAgZW1pdEZldGNoZWQgPSBmYWxzZTtcXG4gICAgICAgICAgICAgIHByZXZCbG9jayA9IGJsb2NrO1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgb25FcnJvcihlcnJvcikge1xcbiAgICAgICAgICAgICAgb25FcnJvcj8uKGVycm9yKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICB1bnN1YnNjcmliZSA9IHVuc3Vic2NyaWJlXztcXG4gICAgICAgICAgaWYgKCFhY3RpdmUpXFxuICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgICAgICBvbkVycm9yPy4oZXJyKTtcXG4gICAgICAgIH1cXG4gICAgICB9KSgpO1xcbiAgICAgIHJldHVybiAoKSA9PiB1bnN1YnNjcmliZSgpO1xcbiAgICB9O1xcbiAgICByZXR1cm4gZW5hYmxlUG9sbGluZyA/IHBvbGxCbG9ja3MoKSA6IHN1YnNjcmliZUJsb2NrcygpO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vYWN0aW9ucy9wdWJsaWMvd2F0Y2hFdmVudC5qc1xcbiAgaW5pdF9zdHJpbmdpZnkoKTtcXG4gIGluaXRfYWJpKCk7XFxuICBpbml0X3JwYygpO1xcbiAgZnVuY3Rpb24gd2F0Y2hFdmVudChjbGllbnQsIHsgYWRkcmVzcywgYXJncywgYmF0Y2ggPSB0cnVlLCBldmVudCwgZXZlbnRzLCBmcm9tQmxvY2ssIG9uRXJyb3IsIG9uTG9ncywgcG9sbDogcG9sbF8sIHBvbGxpbmdJbnRlcnZhbCA9IGNsaWVudC5wb2xsaW5nSW50ZXJ2YWwsIHN0cmljdDogc3RyaWN0XyB9KSB7XFxuICAgIGNvbnN0IGVuYWJsZVBvbGxpbmcgPSAoKCkgPT4ge1xcbiAgICAgIGlmICh0eXBlb2YgcG9sbF8gIT09IFwidW5kZWZpbmVkXCIpXFxuICAgICAgICByZXR1cm4gcG9sbF87XFxuICAgICAgaWYgKHR5cGVvZiBmcm9tQmxvY2sgPT09IFwiYmlnaW50XCIpXFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICBpZiAoY2xpZW50LnRyYW5zcG9ydC50eXBlID09PSBcIndlYlNvY2tldFwiKVxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIGlmIChjbGllbnQudHJhbnNwb3J0LnR5cGUgPT09IFwiZmFsbGJhY2tcIiAmJiBjbGllbnQudHJhbnNwb3J0LnRyYW5zcG9ydHNbMF0uY29uZmlnLnR5cGUgPT09IFwid2ViU29ja2V0XCIpXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH0pKCk7XFxuICAgIGNvbnN0IHN0cmljdCA9IHN0cmljdF8gPz8gZmFsc2U7XFxuICAgIGNvbnN0IHBvbGxFdmVudCA9ICgpID0+IHtcXG4gICAgICBjb25zdCBvYnNlcnZlcklkID0gc3RyaW5naWZ5KFtcXG4gICAgICAgIFwid2F0Y2hFdmVudFwiLFxcbiAgICAgICAgYWRkcmVzcyxcXG4gICAgICAgIGFyZ3MsXFxuICAgICAgICBiYXRjaCxcXG4gICAgICAgIGNsaWVudC51aWQsXFxuICAgICAgICBldmVudCxcXG4gICAgICAgIHBvbGxpbmdJbnRlcnZhbCxcXG4gICAgICAgIGZyb21CbG9ja1xcbiAgICAgIF0pO1xcbiAgICAgIHJldHVybiBvYnNlcnZlKG9ic2VydmVySWQsIHsgb25Mb2dzLCBvbkVycm9yIH0sIChlbWl0KSA9PiB7XFxuICAgICAgICBsZXQgcHJldmlvdXNCbG9ja051bWJlcjtcXG4gICAgICAgIGlmIChmcm9tQmxvY2sgIT09IHZvaWQgMClcXG4gICAgICAgICAgcHJldmlvdXNCbG9ja051bWJlciA9IGZyb21CbG9jayAtIDFuO1xcbiAgICAgICAgbGV0IGZpbHRlcjtcXG4gICAgICAgIGxldCBpbml0aWFsaXplZCA9IGZhbHNlO1xcbiAgICAgICAgY29uc3QgdW53YXRjaCA9IHBvbGwoYXN5bmMgKCkgPT4ge1xcbiAgICAgICAgICBpZiAoIWluaXRpYWxpemVkKSB7XFxuICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgIGZpbHRlciA9IGF3YWl0IGdldEFjdGlvbihjbGllbnQsIGNyZWF0ZUV2ZW50RmlsdGVyLCBcImNyZWF0ZUV2ZW50RmlsdGVyXCIpKHtcXG4gICAgICAgICAgICAgICAgYWRkcmVzcyxcXG4gICAgICAgICAgICAgICAgYXJncyxcXG4gICAgICAgICAgICAgICAgZXZlbnQsXFxuICAgICAgICAgICAgICAgIGV2ZW50cyxcXG4gICAgICAgICAgICAgICAgc3RyaWN0LFxcbiAgICAgICAgICAgICAgICBmcm9tQmxvY2tcXG4gICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH0gY2F0Y2gge1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbml0aWFsaXplZCA9IHRydWU7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgbGV0IGxvZ3M7XFxuICAgICAgICAgICAgaWYgKGZpbHRlcikge1xcbiAgICAgICAgICAgICAgbG9ncyA9IGF3YWl0IGdldEFjdGlvbihjbGllbnQsIGdldEZpbHRlckNoYW5nZXMsIFwiZ2V0RmlsdGVyQ2hhbmdlc1wiKSh7IGZpbHRlciB9KTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSBhd2FpdCBnZXRBY3Rpb24oY2xpZW50LCBnZXRCbG9ja051bWJlciwgXCJnZXRCbG9ja051bWJlclwiKSh7fSk7XFxuICAgICAgICAgICAgICBpZiAocHJldmlvdXNCbG9ja051bWJlciAmJiBwcmV2aW91c0Jsb2NrTnVtYmVyICE9PSBibG9ja051bWJlcikge1xcbiAgICAgICAgICAgICAgICBsb2dzID0gYXdhaXQgZ2V0QWN0aW9uKGNsaWVudCwgZ2V0TG9ncywgXCJnZXRMb2dzXCIpKHtcXG4gICAgICAgICAgICAgICAgICBhZGRyZXNzLFxcbiAgICAgICAgICAgICAgICAgIGFyZ3MsXFxuICAgICAgICAgICAgICAgICAgZXZlbnQsXFxuICAgICAgICAgICAgICAgICAgZXZlbnRzLFxcbiAgICAgICAgICAgICAgICAgIGZyb21CbG9jazogcHJldmlvdXNCbG9ja051bWJlciArIDFuLFxcbiAgICAgICAgICAgICAgICAgIHRvQmxvY2s6IGJsb2NrTnVtYmVyXFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgbG9ncyA9IFtdO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgcHJldmlvdXNCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAobG9ncy5sZW5ndGggPT09IDApXFxuICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgaWYgKGJhdGNoKVxcbiAgICAgICAgICAgICAgZW1pdC5vbkxvZ3MobG9ncyk7XFxuICAgICAgICAgICAgZWxzZVxcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBsb2cgb2YgbG9ncylcXG4gICAgICAgICAgICAgICAgZW1pdC5vbkxvZ3MoW2xvZ10pO1xcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAgICAgICBpZiAoZmlsdGVyICYmIGVyciBpbnN0YW5jZW9mIEludmFsaWRJbnB1dFJwY0Vycm9yKVxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcXG4gICAgICAgICAgICBlbWl0Lm9uRXJyb3I/LihlcnIpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9LCB7XFxuICAgICAgICAgIGVtaXRPbkJlZ2luOiB0cnVlLFxcbiAgICAgICAgICBpbnRlcnZhbDogcG9sbGluZ0ludGVydmFsXFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiBhc3luYyAoKSA9PiB7XFxuICAgICAgICAgIGlmIChmaWx0ZXIpXFxuICAgICAgICAgICAgYXdhaXQgZ2V0QWN0aW9uKGNsaWVudCwgdW5pbnN0YWxsRmlsdGVyLCBcInVuaW5zdGFsbEZpbHRlclwiKSh7IGZpbHRlciB9KTtcXG4gICAgICAgICAgdW53YXRjaCgpO1xcbiAgICAgICAgfTtcXG4gICAgICB9KTtcXG4gICAgfTtcXG4gICAgY29uc3Qgc3Vic2NyaWJlRXZlbnQgPSAoKSA9PiB7XFxuICAgICAgbGV0IGFjdGl2ZSA9IHRydWU7XFxuICAgICAgbGV0IHVuc3Vic2NyaWJlID0gKCkgPT4gYWN0aXZlID0gZmFsc2U7XFxuICAgICAgKGFzeW5jICgpID0+IHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIGNvbnN0IHRyYW5zcG9ydCA9ICgoKSA9PiB7XFxuICAgICAgICAgICAgaWYgKGNsaWVudC50cmFuc3BvcnQudHlwZSA9PT0gXCJmYWxsYmFja1wiKSB7XFxuICAgICAgICAgICAgICBjb25zdCB0cmFuc3BvcnQyID0gY2xpZW50LnRyYW5zcG9ydC50cmFuc3BvcnRzLmZpbmQoKHRyYW5zcG9ydDMpID0+IHRyYW5zcG9ydDMuY29uZmlnLnR5cGUgPT09IFwid2ViU29ja2V0XCIpO1xcbiAgICAgICAgICAgICAgaWYgKCF0cmFuc3BvcnQyKVxcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50LnRyYW5zcG9ydDtcXG4gICAgICAgICAgICAgIHJldHVybiB0cmFuc3BvcnQyLnZhbHVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gY2xpZW50LnRyYW5zcG9ydDtcXG4gICAgICAgICAgfSkoKTtcXG4gICAgICAgICAgY29uc3QgZXZlbnRzXyA9IGV2ZW50cyA/PyAoZXZlbnQgPyBbZXZlbnRdIDogdm9pZCAwKTtcXG4gICAgICAgICAgbGV0IHRvcGljcyA9IFtdO1xcbiAgICAgICAgICBpZiAoZXZlbnRzXykge1xcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWQgPSBldmVudHNfLmZsYXRNYXAoKGV2ZW50MikgPT4gZW5jb2RlRXZlbnRUb3BpY3Moe1xcbiAgICAgICAgICAgICAgYWJpOiBbZXZlbnQyXSxcXG4gICAgICAgICAgICAgIGV2ZW50TmFtZTogZXZlbnQyLm5hbWUsXFxuICAgICAgICAgICAgICBhcmdzXFxuICAgICAgICAgICAgfSkpO1xcbiAgICAgICAgICAgIHRvcGljcyA9IFtlbmNvZGVkXTtcXG4gICAgICAgICAgICBpZiAoZXZlbnQpXFxuICAgICAgICAgICAgICB0b3BpY3MgPSB0b3BpY3NbMF07XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgY29uc3QgeyB1bnN1YnNjcmliZTogdW5zdWJzY3JpYmVfIH0gPSBhd2FpdCB0cmFuc3BvcnQuc3Vic2NyaWJlKHtcXG4gICAgICAgICAgICBwYXJhbXM6IFtcImxvZ3NcIiwgeyBhZGRyZXNzLCB0b3BpY3MgfV0sXFxuICAgICAgICAgICAgb25EYXRhKGRhdGEpIHtcXG4gICAgICAgICAgICAgIGlmICghYWN0aXZlKVxcbiAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgICBjb25zdCBsb2cgPSBkYXRhLnJlc3VsdDtcXG4gICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXZlbnROYW1lLCBhcmdzOiBhcmdzMiB9ID0gZGVjb2RlRXZlbnRMb2coe1xcbiAgICAgICAgICAgICAgICAgIGFiaTogZXZlbnRzXyA/PyBbXSxcXG4gICAgICAgICAgICAgICAgICBkYXRhOiBsb2cuZGF0YSxcXG4gICAgICAgICAgICAgICAgICB0b3BpY3M6IGxvZy50b3BpY3MsXFxuICAgICAgICAgICAgICAgICAgc3RyaWN0XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICBjb25zdCBmb3JtYXR0ZWQgPSBmb3JtYXRMb2cobG9nLCB7IGFyZ3M6IGFyZ3MyLCBldmVudE5hbWUgfSk7XFxuICAgICAgICAgICAgICAgIG9uTG9ncyhbZm9ybWF0dGVkXSk7XFxuICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50TmFtZTtcXG4gICAgICAgICAgICAgICAgbGV0IGlzVW5uYW1lZDtcXG4gICAgICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIERlY29kZUxvZ0RhdGFNaXNtYXRjaCB8fCBlcnIgaW5zdGFuY2VvZiBEZWNvZGVMb2dUb3BpY3NNaXNtYXRjaCkge1xcbiAgICAgICAgICAgICAgICAgIGlmIChzdHJpY3RfKVxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZSA9IGVyci5hYmlJdGVtLm5hbWU7XFxuICAgICAgICAgICAgICAgICAgaXNVbm5hbWVkID0gZXJyLmFiaUl0ZW0uaW5wdXRzPy5zb21lKCh4KSA9PiAhKFwibmFtZVwiIGluIHggJiYgeC5uYW1lKSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkID0gZm9ybWF0TG9nKGxvZywge1xcbiAgICAgICAgICAgICAgICAgIGFyZ3M6IGlzVW5uYW1lZCA/IFtdIDoge30sXFxuICAgICAgICAgICAgICAgICAgZXZlbnROYW1lXFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICBvbkxvZ3MoW2Zvcm1hdHRlZF0pO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgb25FcnJvcihlcnJvcikge1xcbiAgICAgICAgICAgICAgb25FcnJvcj8uKGVycm9yKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICB1bnN1YnNjcmliZSA9IHVuc3Vic2NyaWJlXztcXG4gICAgICAgICAgaWYgKCFhY3RpdmUpXFxuICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgICAgICBvbkVycm9yPy4oZXJyKTtcXG4gICAgICAgIH1cXG4gICAgICB9KSgpO1xcbiAgICAgIHJldHVybiAoKSA9PiB1bnN1YnNjcmliZSgpO1xcbiAgICB9O1xcbiAgICByZXR1cm4gZW5hYmxlUG9sbGluZyA/IHBvbGxFdmVudCgpIDogc3Vic2NyaWJlRXZlbnQoKTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjdGlvbnMvcHVibGljL3dhdGNoUGVuZGluZ1RyYW5zYWN0aW9ucy5qc1xcbiAgaW5pdF9zdHJpbmdpZnkoKTtcXG4gIGZ1bmN0aW9uIHdhdGNoUGVuZGluZ1RyYW5zYWN0aW9ucyhjbGllbnQsIHsgYmF0Y2ggPSB0cnVlLCBvbkVycm9yLCBvblRyYW5zYWN0aW9ucywgcG9sbDogcG9sbF8sIHBvbGxpbmdJbnRlcnZhbCA9IGNsaWVudC5wb2xsaW5nSW50ZXJ2YWwgfSkge1xcbiAgICBjb25zdCBlbmFibGVQb2xsaW5nID0gdHlwZW9mIHBvbGxfICE9PSBcInVuZGVmaW5lZFwiID8gcG9sbF8gOiBjbGllbnQudHJhbnNwb3J0LnR5cGUgIT09IFwid2ViU29ja2V0XCI7XFxuICAgIGNvbnN0IHBvbGxQZW5kaW5nVHJhbnNhY3Rpb25zID0gKCkgPT4ge1xcbiAgICAgIGNvbnN0IG9ic2VydmVySWQgPSBzdHJpbmdpZnkoW1xcbiAgICAgICAgXCJ3YXRjaFBlbmRpbmdUcmFuc2FjdGlvbnNcIixcXG4gICAgICAgIGNsaWVudC51aWQsXFxuICAgICAgICBiYXRjaCxcXG4gICAgICAgIHBvbGxpbmdJbnRlcnZhbFxcbiAgICAgIF0pO1xcbiAgICAgIHJldHVybiBvYnNlcnZlKG9ic2VydmVySWQsIHsgb25UcmFuc2FjdGlvbnMsIG9uRXJyb3IgfSwgKGVtaXQpID0+IHtcXG4gICAgICAgIGxldCBmaWx0ZXI7XFxuICAgICAgICBjb25zdCB1bndhdGNoID0gcG9sbChhc3luYyAoKSA9PiB7XFxuICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgaWYgKCFmaWx0ZXIpIHtcXG4gICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgIGZpbHRlciA9IGF3YWl0IGdldEFjdGlvbihjbGllbnQsIGNyZWF0ZVBlbmRpbmdUcmFuc2FjdGlvbkZpbHRlciwgXCJjcmVhdGVQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXJcIikoe30pO1xcbiAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAgICAgICAgICAgdW53YXRjaCgpO1xcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGNvbnN0IGhhc2hlcyA9IGF3YWl0IGdldEFjdGlvbihjbGllbnQsIGdldEZpbHRlckNoYW5nZXMsIFwiZ2V0RmlsdGVyQ2hhbmdlc1wiKSh7IGZpbHRlciB9KTtcXG4gICAgICAgICAgICBpZiAoaGFzaGVzLmxlbmd0aCA9PT0gMClcXG4gICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICBpZiAoYmF0Y2gpXFxuICAgICAgICAgICAgICBlbWl0Lm9uVHJhbnNhY3Rpb25zKGhhc2hlcyk7XFxuICAgICAgICAgICAgZWxzZVxcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBoYXNoMiBvZiBoYXNoZXMpXFxuICAgICAgICAgICAgICAgIGVtaXQub25UcmFuc2FjdGlvbnMoW2hhc2gyXSk7XFxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgICAgICAgIGVtaXQub25FcnJvcj8uKGVycik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIHtcXG4gICAgICAgICAgZW1pdE9uQmVnaW46IHRydWUsXFxuICAgICAgICAgIGludGVydmFsOiBwb2xsaW5nSW50ZXJ2YWxcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIGFzeW5jICgpID0+IHtcXG4gICAgICAgICAgaWYgKGZpbHRlcilcXG4gICAgICAgICAgICBhd2FpdCBnZXRBY3Rpb24oY2xpZW50LCB1bmluc3RhbGxGaWx0ZXIsIFwidW5pbnN0YWxsRmlsdGVyXCIpKHsgZmlsdGVyIH0pO1xcbiAgICAgICAgICB1bndhdGNoKCk7XFxuICAgICAgICB9O1xcbiAgICAgIH0pO1xcbiAgICB9O1xcbiAgICBjb25zdCBzdWJzY3JpYmVQZW5kaW5nVHJhbnNhY3Rpb25zID0gKCkgPT4ge1xcbiAgICAgIGxldCBhY3RpdmUgPSB0cnVlO1xcbiAgICAgIGxldCB1bnN1YnNjcmliZSA9ICgpID0+IGFjdGl2ZSA9IGZhbHNlO1xcbiAgICAgIChhc3luYyAoKSA9PiB7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICBjb25zdCB7IHVuc3Vic2NyaWJlOiB1bnN1YnNjcmliZV8gfSA9IGF3YWl0IGNsaWVudC50cmFuc3BvcnQuc3Vic2NyaWJlKHtcXG4gICAgICAgICAgICBwYXJhbXM6IFtcIm5ld1BlbmRpbmdUcmFuc2FjdGlvbnNcIl0sXFxuICAgICAgICAgICAgb25EYXRhKGRhdGEpIHtcXG4gICAgICAgICAgICAgIGlmICghYWN0aXZlKVxcbiAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGRhdGEucmVzdWx0O1xcbiAgICAgICAgICAgICAgb25UcmFuc2FjdGlvbnMoW3RyYW5zYWN0aW9uXSk7XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBvbkVycm9yKGVycm9yKSB7XFxuICAgICAgICAgICAgICBvbkVycm9yPy4oZXJyb3IpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIHVuc3Vic2NyaWJlID0gdW5zdWJzY3JpYmVfO1xcbiAgICAgICAgICBpZiAoIWFjdGl2ZSlcXG4gICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICAgIG9uRXJyb3I/LihlcnIpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pKCk7XFxuICAgICAgcmV0dXJuICgpID0+IHVuc3Vic2NyaWJlKCk7XFxuICAgIH07XFxuICAgIHJldHVybiBlbmFibGVQb2xsaW5nID8gcG9sbFBlbmRpbmdUcmFuc2FjdGlvbnMoKSA6IHN1YnNjcmliZVBlbmRpbmdUcmFuc2FjdGlvbnMoKTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL3V0aWxzL3Npd2UvcGFyc2VTaXdlTWVzc2FnZS5qc1xcbiAgZnVuY3Rpb24gcGFyc2VTaXdlTWVzc2FnZShtZXNzYWdlKSB7XFxuICAgIGNvbnN0IHsgc2NoZW1lLCBzdGF0ZW1lbnQsIC4uLnByZWZpeCB9ID0gbWVzc2FnZS5tYXRjaChwcmVmaXhSZWdleCk/Lmdyb3VwcyA/PyB7fTtcXG4gICAgY29uc3QgeyBjaGFpbklkLCBleHBpcmF0aW9uVGltZSwgaXNzdWVkQXQsIG5vdEJlZm9yZSwgcmVxdWVzdElkLCAuLi5zdWZmaXggfSA9IG1lc3NhZ2UubWF0Y2goc3VmZml4UmVnZXgpPy5ncm91cHMgPz8ge307XFxuICAgIGNvbnN0IHJlc291cmNlcyA9IG1lc3NhZ2Uuc3BsaXQoXCJSZXNvdXJjZXM6XCIpWzFdPy5zcGxpdChcIlxcXFxuLSBcIikuc2xpY2UoMSk7XFxuICAgIHJldHVybiB7XFxuICAgICAgLi4ucHJlZml4LFxcbiAgICAgIC4uLnN1ZmZpeCxcXG4gICAgICAuLi5jaGFpbklkID8geyBjaGFpbklkOiBOdW1iZXIoY2hhaW5JZCkgfSA6IHt9LFxcbiAgICAgIC4uLmV4cGlyYXRpb25UaW1lID8geyBleHBpcmF0aW9uVGltZTogbmV3IERhdGUoZXhwaXJhdGlvblRpbWUpIH0gOiB7fSxcXG4gICAgICAuLi5pc3N1ZWRBdCA/IHsgaXNzdWVkQXQ6IG5ldyBEYXRlKGlzc3VlZEF0KSB9IDoge30sXFxuICAgICAgLi4ubm90QmVmb3JlID8geyBub3RCZWZvcmU6IG5ldyBEYXRlKG5vdEJlZm9yZSkgfSA6IHt9LFxcbiAgICAgIC4uLnJlcXVlc3RJZCA/IHsgcmVxdWVzdElkIH0gOiB7fSxcXG4gICAgICAuLi5yZXNvdXJjZXMgPyB7IHJlc291cmNlcyB9IDoge30sXFxuICAgICAgLi4uc2NoZW1lID8geyBzY2hlbWUgfSA6IHt9LFxcbiAgICAgIC4uLnN0YXRlbWVudCA/IHsgc3RhdGVtZW50IH0gOiB7fVxcbiAgICB9O1xcbiAgfVxcbiAgdmFyIHByZWZpeFJlZ2V4ID0gL14oPzooPzxzY2hlbWU+W2EtekEtWl1bYS16QS1aMC05Ky0uXSopOlxcXFwvXFxcXC8pPyg/PGRvbWFpbj5bYS16QS1aMC05Ky0uXSooPzo6WzAtOV17MSw1fSk/KSAoPzp3YW50cyB5b3UgdG8gc2lnbiBpbiB3aXRoIHlvdXIgRXRoZXJldW0gYWNjb3VudDpcXFxcbikoPzxhZGRyZXNzPjB4W2EtZkEtRjAtOV17NDB9KVxcXFxuXFxcXG4oPzooPzxzdGF0ZW1lbnQ+LiopXFxcXG5cXFxcbik/LztcXG4gIHZhciBzdWZmaXhSZWdleCA9IC8oPzpVUkk6ICg/PHVyaT4uKykpXFxcXG4oPzpWZXJzaW9uOiAoPzx2ZXJzaW9uPi4rKSlcXFxcbig/OkNoYWluIElEOiAoPzxjaGFpbklkPlxcXFxkKykpXFxcXG4oPzpOb25jZTogKD88bm9uY2U+W2EtekEtWjAtOV0rKSlcXFxcbig/Oklzc3VlZCBBdDogKD88aXNzdWVkQXQ+LispKSg/OlxcXFxuRXhwaXJhdGlvbiBUaW1lOiAoPzxleHBpcmF0aW9uVGltZT4uKykpPyg/OlxcXFxuTm90IEJlZm9yZTogKD88bm90QmVmb3JlPi4rKSk/KD86XFxcXG5SZXF1ZXN0IElEOiAoPzxyZXF1ZXN0SWQ+LispKT8vO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vdXRpbHMvc2l3ZS92YWxpZGF0ZVNpd2VNZXNzYWdlLmpzXFxuICBpbml0X2lzQWRkcmVzc0VxdWFsKCk7XFxuICBmdW5jdGlvbiB2YWxpZGF0ZVNpd2VNZXNzYWdlKHBhcmFtZXRlcnMpIHtcXG4gICAgY29uc3QgeyBhZGRyZXNzLCBkb21haW4sIG1lc3NhZ2UsIG5vbmNlLCBzY2hlbWUsIHRpbWUgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSB9ID0gcGFyYW1ldGVycztcXG4gICAgaWYgKGRvbWFpbiAmJiBtZXNzYWdlLmRvbWFpbiAhPT0gZG9tYWluKVxcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgaWYgKG5vbmNlICYmIG1lc3NhZ2Uubm9uY2UgIT09IG5vbmNlKVxcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgaWYgKHNjaGVtZSAmJiBtZXNzYWdlLnNjaGVtZSAhPT0gc2NoZW1lKVxcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgaWYgKG1lc3NhZ2UuZXhwaXJhdGlvblRpbWUgJiYgdGltZSA+PSBtZXNzYWdlLmV4cGlyYXRpb25UaW1lKVxcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgaWYgKG1lc3NhZ2Uubm90QmVmb3JlICYmIHRpbWUgPCBtZXNzYWdlLm5vdEJlZm9yZSlcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIHRyeSB7XFxuICAgICAgaWYgKCFtZXNzYWdlLmFkZHJlc3MpXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgaWYgKGFkZHJlc3MgJiYgIWlzQWRkcmVzc0VxdWFsKG1lc3NhZ2UuYWRkcmVzcywgYWRkcmVzcykpXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH0gY2F0Y2gge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICByZXR1cm4gdHJ1ZTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjdGlvbnMvc2l3ZS92ZXJpZnlTaXdlTWVzc2FnZS5qc1xcbiAgYXN5bmMgZnVuY3Rpb24gdmVyaWZ5U2l3ZU1lc3NhZ2UoY2xpZW50LCBwYXJhbWV0ZXJzKSB7XFxuICAgIGNvbnN0IHsgYWRkcmVzcywgZG9tYWluLCBtZXNzYWdlLCBub25jZSwgc2NoZW1lLCBzaWduYXR1cmUsIHRpbWUgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSwgLi4uY2FsbFJlcXVlc3QgfSA9IHBhcmFtZXRlcnM7XFxuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlU2l3ZU1lc3NhZ2UobWVzc2FnZSk7XFxuICAgIGlmICghcGFyc2VkLmFkZHJlc3MpXFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICBjb25zdCBpc1ZhbGlkMiA9IHZhbGlkYXRlU2l3ZU1lc3NhZ2Uoe1xcbiAgICAgIGFkZHJlc3MsXFxuICAgICAgZG9tYWluLFxcbiAgICAgIG1lc3NhZ2U6IHBhcnNlZCxcXG4gICAgICBub25jZSxcXG4gICAgICBzY2hlbWUsXFxuICAgICAgdGltZVxcbiAgICB9KTtcXG4gICAgaWYgKCFpc1ZhbGlkMilcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIGNvbnN0IGhhc2gyID0gaGFzaE1lc3NhZ2UobWVzc2FnZSk7XFxuICAgIHJldHVybiB2ZXJpZnlIYXNoKGNsaWVudCwge1xcbiAgICAgIGFkZHJlc3M6IHBhcnNlZC5hZGRyZXNzLFxcbiAgICAgIGhhc2g6IGhhc2gyLFxcbiAgICAgIHNpZ25hdHVyZSxcXG4gICAgICAuLi5jYWxsUmVxdWVzdFxcbiAgICB9KTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2NsaWVudHMvZGVjb3JhdG9ycy9wdWJsaWMuanNcXG4gIGZ1bmN0aW9uIHB1YmxpY0FjdGlvbnMoY2xpZW50KSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgY2FsbDogKGFyZ3MpID0+IGNhbGwoY2xpZW50LCBhcmdzKSxcXG4gICAgICBjcmVhdGVBY2Nlc3NMaXN0OiAoYXJncykgPT4gY3JlYXRlQWNjZXNzTGlzdChjbGllbnQsIGFyZ3MpLFxcbiAgICAgIGNyZWF0ZUJsb2NrRmlsdGVyOiAoKSA9PiBjcmVhdGVCbG9ja0ZpbHRlcihjbGllbnQpLFxcbiAgICAgIGNyZWF0ZUNvbnRyYWN0RXZlbnRGaWx0ZXI6IChhcmdzKSA9PiBjcmVhdGVDb250cmFjdEV2ZW50RmlsdGVyKGNsaWVudCwgYXJncyksXFxuICAgICAgY3JlYXRlRXZlbnRGaWx0ZXI6IChhcmdzKSA9PiBjcmVhdGVFdmVudEZpbHRlcihjbGllbnQsIGFyZ3MpLFxcbiAgICAgIGNyZWF0ZVBlbmRpbmdUcmFuc2FjdGlvbkZpbHRlcjogKCkgPT4gY3JlYXRlUGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyKGNsaWVudCksXFxuICAgICAgZXN0aW1hdGVDb250cmFjdEdhczogKGFyZ3MpID0+IGVzdGltYXRlQ29udHJhY3RHYXMoY2xpZW50LCBhcmdzKSxcXG4gICAgICBlc3RpbWF0ZUdhczogKGFyZ3MpID0+IGVzdGltYXRlR2FzKGNsaWVudCwgYXJncyksXFxuICAgICAgZ2V0QmFsYW5jZTogKGFyZ3MpID0+IGdldEJhbGFuY2UoY2xpZW50LCBhcmdzKSxcXG4gICAgICBnZXRCbG9iQmFzZUZlZTogKCkgPT4gZ2V0QmxvYkJhc2VGZWUoY2xpZW50KSxcXG4gICAgICBnZXRCbG9jazogKGFyZ3MpID0+IGdldEJsb2NrKGNsaWVudCwgYXJncyksXFxuICAgICAgZ2V0QmxvY2tOdW1iZXI6IChhcmdzKSA9PiBnZXRCbG9ja051bWJlcihjbGllbnQsIGFyZ3MpLFxcbiAgICAgIGdldEJsb2NrVHJhbnNhY3Rpb25Db3VudDogKGFyZ3MpID0+IGdldEJsb2NrVHJhbnNhY3Rpb25Db3VudChjbGllbnQsIGFyZ3MpLFxcbiAgICAgIGdldEJ5dGVjb2RlOiAoYXJncykgPT4gZ2V0Q29kZShjbGllbnQsIGFyZ3MpLFxcbiAgICAgIGdldENoYWluSWQ6ICgpID0+IGdldENoYWluSWQoY2xpZW50KSxcXG4gICAgICBnZXRDb2RlOiAoYXJncykgPT4gZ2V0Q29kZShjbGllbnQsIGFyZ3MpLFxcbiAgICAgIGdldENvbnRyYWN0RXZlbnRzOiAoYXJncykgPT4gZ2V0Q29udHJhY3RFdmVudHMoY2xpZW50LCBhcmdzKSxcXG4gICAgICBnZXRFaXA3MTJEb21haW46IChhcmdzKSA9PiBnZXRFaXA3MTJEb21haW4oY2xpZW50LCBhcmdzKSxcXG4gICAgICBnZXRFbnNBZGRyZXNzOiAoYXJncykgPT4gZ2V0RW5zQWRkcmVzcyhjbGllbnQsIGFyZ3MpLFxcbiAgICAgIGdldEVuc0F2YXRhcjogKGFyZ3MpID0+IGdldEVuc0F2YXRhcihjbGllbnQsIGFyZ3MpLFxcbiAgICAgIGdldEVuc05hbWU6IChhcmdzKSA9PiBnZXRFbnNOYW1lKGNsaWVudCwgYXJncyksXFxuICAgICAgZ2V0RW5zUmVzb2x2ZXI6IChhcmdzKSA9PiBnZXRFbnNSZXNvbHZlcihjbGllbnQsIGFyZ3MpLFxcbiAgICAgIGdldEVuc1RleHQ6IChhcmdzKSA9PiBnZXRFbnNUZXh0KGNsaWVudCwgYXJncyksXFxuICAgICAgZ2V0RmVlSGlzdG9yeTogKGFyZ3MpID0+IGdldEZlZUhpc3RvcnkoY2xpZW50LCBhcmdzKSxcXG4gICAgICBlc3RpbWF0ZUZlZXNQZXJHYXM6IChhcmdzKSA9PiBlc3RpbWF0ZUZlZXNQZXJHYXMoY2xpZW50LCBhcmdzKSxcXG4gICAgICBnZXRGaWx0ZXJDaGFuZ2VzOiAoYXJncykgPT4gZ2V0RmlsdGVyQ2hhbmdlcyhjbGllbnQsIGFyZ3MpLFxcbiAgICAgIGdldEZpbHRlckxvZ3M6IChhcmdzKSA9PiBnZXRGaWx0ZXJMb2dzKGNsaWVudCwgYXJncyksXFxuICAgICAgZ2V0R2FzUHJpY2U6ICgpID0+IGdldEdhc1ByaWNlKGNsaWVudCksXFxuICAgICAgZ2V0TG9nczogKGFyZ3MpID0+IGdldExvZ3MoY2xpZW50LCBhcmdzKSxcXG4gICAgICBnZXRQcm9vZjogKGFyZ3MpID0+IGdldFByb29mKGNsaWVudCwgYXJncyksXFxuICAgICAgZXN0aW1hdGVNYXhQcmlvcml0eUZlZVBlckdhczogKGFyZ3MpID0+IGVzdGltYXRlTWF4UHJpb3JpdHlGZWVQZXJHYXMoY2xpZW50LCBhcmdzKSxcXG4gICAgICBnZXRTdG9yYWdlQXQ6IChhcmdzKSA9PiBnZXRTdG9yYWdlQXQoY2xpZW50LCBhcmdzKSxcXG4gICAgICBnZXRUcmFuc2FjdGlvbjogKGFyZ3MpID0+IGdldFRyYW5zYWN0aW9uKGNsaWVudCwgYXJncyksXFxuICAgICAgZ2V0VHJhbnNhY3Rpb25Db25maXJtYXRpb25zOiAoYXJncykgPT4gZ2V0VHJhbnNhY3Rpb25Db25maXJtYXRpb25zKGNsaWVudCwgYXJncyksXFxuICAgICAgZ2V0VHJhbnNhY3Rpb25Db3VudDogKGFyZ3MpID0+IGdldFRyYW5zYWN0aW9uQ291bnQoY2xpZW50LCBhcmdzKSxcXG4gICAgICBnZXRUcmFuc2FjdGlvblJlY2VpcHQ6IChhcmdzKSA9PiBnZXRUcmFuc2FjdGlvblJlY2VpcHQoY2xpZW50LCBhcmdzKSxcXG4gICAgICBtdWx0aWNhbGw6IChhcmdzKSA9PiBtdWx0aWNhbGwoY2xpZW50LCBhcmdzKSxcXG4gICAgICBwcmVwYXJlVHJhbnNhY3Rpb25SZXF1ZXN0OiAoYXJncykgPT4gcHJlcGFyZVRyYW5zYWN0aW9uUmVxdWVzdChjbGllbnQsIGFyZ3MpLFxcbiAgICAgIHJlYWRDb250cmFjdDogKGFyZ3MpID0+IHJlYWRDb250cmFjdChjbGllbnQsIGFyZ3MpLFxcbiAgICAgIHNlbmRSYXdUcmFuc2FjdGlvbjogKGFyZ3MpID0+IHNlbmRSYXdUcmFuc2FjdGlvbihjbGllbnQsIGFyZ3MpLFxcbiAgICAgIHNpbXVsYXRlOiAoYXJncykgPT4gc2ltdWxhdGVCbG9ja3MoY2xpZW50LCBhcmdzKSxcXG4gICAgICBzaW11bGF0ZUJsb2NrczogKGFyZ3MpID0+IHNpbXVsYXRlQmxvY2tzKGNsaWVudCwgYXJncyksXFxuICAgICAgc2ltdWxhdGVDYWxsczogKGFyZ3MpID0+IHNpbXVsYXRlQ2FsbHMoY2xpZW50LCBhcmdzKSxcXG4gICAgICBzaW11bGF0ZUNvbnRyYWN0OiAoYXJncykgPT4gc2ltdWxhdGVDb250cmFjdChjbGllbnQsIGFyZ3MpLFxcbiAgICAgIHZlcmlmeU1lc3NhZ2U6IChhcmdzKSA9PiB2ZXJpZnlNZXNzYWdlKGNsaWVudCwgYXJncyksXFxuICAgICAgdmVyaWZ5U2l3ZU1lc3NhZ2U6IChhcmdzKSA9PiB2ZXJpZnlTaXdlTWVzc2FnZShjbGllbnQsIGFyZ3MpLFxcbiAgICAgIHZlcmlmeVR5cGVkRGF0YTogKGFyZ3MpID0+IHZlcmlmeVR5cGVkRGF0YShjbGllbnQsIGFyZ3MpLFxcbiAgICAgIHVuaW5zdGFsbEZpbHRlcjogKGFyZ3MpID0+IHVuaW5zdGFsbEZpbHRlcihjbGllbnQsIGFyZ3MpLFxcbiAgICAgIHdhaXRGb3JUcmFuc2FjdGlvblJlY2VpcHQ6IChhcmdzKSA9PiB3YWl0Rm9yVHJhbnNhY3Rpb25SZWNlaXB0KGNsaWVudCwgYXJncyksXFxuICAgICAgd2F0Y2hCbG9ja3M6IChhcmdzKSA9PiB3YXRjaEJsb2NrcyhjbGllbnQsIGFyZ3MpLFxcbiAgICAgIHdhdGNoQmxvY2tOdW1iZXI6IChhcmdzKSA9PiB3YXRjaEJsb2NrTnVtYmVyKGNsaWVudCwgYXJncyksXFxuICAgICAgd2F0Y2hDb250cmFjdEV2ZW50OiAoYXJncykgPT4gd2F0Y2hDb250cmFjdEV2ZW50KGNsaWVudCwgYXJncyksXFxuICAgICAgd2F0Y2hFdmVudDogKGFyZ3MpID0+IHdhdGNoRXZlbnQoY2xpZW50LCBhcmdzKSxcXG4gICAgICB3YXRjaFBlbmRpbmdUcmFuc2FjdGlvbnM6IChhcmdzKSA9PiB3YXRjaFBlbmRpbmdUcmFuc2FjdGlvbnMoY2xpZW50LCBhcmdzKVxcbiAgICB9O1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vY2xpZW50cy9jcmVhdGVQdWJsaWNDbGllbnQuanNcXG4gIGZ1bmN0aW9uIGNyZWF0ZVB1YmxpY0NsaWVudChwYXJhbWV0ZXJzKSB7XFxuICAgIGNvbnN0IHsga2V5ID0gXCJwdWJsaWNcIiwgbmFtZSA9IFwiUHVibGljIENsaWVudFwiIH0gPSBwYXJhbWV0ZXJzO1xcbiAgICBjb25zdCBjbGllbnQgPSBjcmVhdGVDbGllbnQoe1xcbiAgICAgIC4uLnBhcmFtZXRlcnMsXFxuICAgICAga2V5LFxcbiAgICAgIG5hbWUsXFxuICAgICAgdHlwZTogXCJwdWJsaWNDbGllbnRcIlxcbiAgICB9KTtcXG4gICAgcmV0dXJuIGNsaWVudC5leHRlbmQocHVibGljQWN0aW9ucyk7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL3dhbGxldC9hZGRDaGFpbi5qc1xcbiAgaW5pdF90b0hleCgpO1xcbiAgYXN5bmMgZnVuY3Rpb24gYWRkQ2hhaW4oY2xpZW50LCB7IGNoYWluIH0pIHtcXG4gICAgY29uc3QgeyBpZCwgbmFtZSwgbmF0aXZlQ3VycmVuY3ksIHJwY1VybHMsIGJsb2NrRXhwbG9yZXJzIH0gPSBjaGFpbjtcXG4gICAgYXdhaXQgY2xpZW50LnJlcXVlc3Qoe1xcbiAgICAgIG1ldGhvZDogXCJ3YWxsZXRfYWRkRXRoZXJldW1DaGFpblwiLFxcbiAgICAgIHBhcmFtczogW1xcbiAgICAgICAge1xcbiAgICAgICAgICBjaGFpbklkOiBudW1iZXJUb0hleChpZCksXFxuICAgICAgICAgIGNoYWluTmFtZTogbmFtZSxcXG4gICAgICAgICAgbmF0aXZlQ3VycmVuY3ksXFxuICAgICAgICAgIHJwY1VybHM6IHJwY1VybHMuZGVmYXVsdC5odHRwLFxcbiAgICAgICAgICBibG9ja0V4cGxvcmVyVXJsczogYmxvY2tFeHBsb3JlcnMgPyBPYmplY3QudmFsdWVzKGJsb2NrRXhwbG9yZXJzKS5tYXAoKHsgdXJsIH0pID0+IHVybCkgOiB2b2lkIDBcXG4gICAgICAgIH1cXG4gICAgICBdXFxuICAgIH0sIHsgZGVkdXBlOiB0cnVlLCByZXRyeUNvdW50OiAwIH0pO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vYWN0aW9ucy93YWxsZXQvZGVwbG95Q29udHJhY3QuanNcXG4gIGluaXRfZW5jb2RlRGVwbG95RGF0YSgpO1xcbiAgZnVuY3Rpb24gZGVwbG95Q29udHJhY3Qod2FsbGV0Q2xpZW50LCBwYXJhbWV0ZXJzKSB7XFxuICAgIGNvbnN0IHsgYWJpOiBhYmkyLCBhcmdzLCBieXRlY29kZSwgLi4ucmVxdWVzdCB9ID0gcGFyYW1ldGVycztcXG4gICAgY29uc3QgY2FsbGRhdGEgPSBlbmNvZGVEZXBsb3lEYXRhKHsgYWJpOiBhYmkyLCBhcmdzLCBieXRlY29kZSB9KTtcXG4gICAgcmV0dXJuIHNlbmRUcmFuc2FjdGlvbih3YWxsZXRDbGllbnQsIHtcXG4gICAgICAuLi5yZXF1ZXN0LFxcbiAgICAgIC4uLnJlcXVlc3QuYXV0aG9yaXphdGlvbkxpc3QgPyB7IHRvOiBudWxsIH0gOiB7fSxcXG4gICAgICBkYXRhOiBjYWxsZGF0YVxcbiAgICB9KTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjdGlvbnMvd2FsbGV0L2dldEFkZHJlc3Nlcy5qc1xcbiAgaW5pdF9nZXRBZGRyZXNzKCk7XFxuICBhc3luYyBmdW5jdGlvbiBnZXRBZGRyZXNzZXMoY2xpZW50KSB7XFxuICAgIGlmIChjbGllbnQuYWNjb3VudD8udHlwZSA9PT0gXCJsb2NhbFwiKVxcbiAgICAgIHJldHVybiBbY2xpZW50LmFjY291bnQuYWRkcmVzc107XFxuICAgIGNvbnN0IGFkZHJlc3NlcyA9IGF3YWl0IGNsaWVudC5yZXF1ZXN0KHsgbWV0aG9kOiBcImV0aF9hY2NvdW50c1wiIH0sIHsgZGVkdXBlOiB0cnVlIH0pO1xcbiAgICByZXR1cm4gYWRkcmVzc2VzLm1hcCgoYWRkcmVzcykgPT4gY2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpKTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjdGlvbnMvd2FsbGV0L2dldFBlcm1pc3Npb25zLmpzXFxuICBhc3luYyBmdW5jdGlvbiBnZXRQZXJtaXNzaW9ucyhjbGllbnQpIHtcXG4gICAgY29uc3QgcGVybWlzc2lvbnMgPSBhd2FpdCBjbGllbnQucmVxdWVzdCh7IG1ldGhvZDogXCJ3YWxsZXRfZ2V0UGVybWlzc2lvbnNcIiB9LCB7IGRlZHVwZTogdHJ1ZSB9KTtcXG4gICAgcmV0dXJuIHBlcm1pc3Npb25zO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vYWN0aW9ucy93YWxsZXQvcHJlcGFyZUF1dGhvcml6YXRpb24uanNcXG4gIGluaXRfcGFyc2VBY2NvdW50KCk7XFxuICBpbml0X2lzQWRkcmVzc0VxdWFsKCk7XFxuICBhc3luYyBmdW5jdGlvbiBwcmVwYXJlQXV0aG9yaXphdGlvbihjbGllbnQsIHBhcmFtZXRlcnMpIHtcXG4gICAgY29uc3QgeyBhY2NvdW50OiBhY2NvdW50XyA9IGNsaWVudC5hY2NvdW50LCBjaGFpbklkLCBub25jZSB9ID0gcGFyYW1ldGVycztcXG4gICAgaWYgKCFhY2NvdW50XylcXG4gICAgICB0aHJvdyBuZXcgQWNjb3VudE5vdEZvdW5kRXJyb3Ioe1xcbiAgICAgICAgZG9jc1BhdGg6IFwiL2RvY3MvZWlwNzcwMi9wcmVwYXJlQXV0aG9yaXphdGlvblwiXFxuICAgICAgfSk7XFxuICAgIGNvbnN0IGFjY291bnQgPSBwYXJzZUFjY291bnQoYWNjb3VudF8pO1xcbiAgICBjb25zdCBleGVjdXRvciA9ICgoKSA9PiB7XFxuICAgICAgaWYgKCFwYXJhbWV0ZXJzLmV4ZWN1dG9yKVxcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcXG4gICAgICBpZiAocGFyYW1ldGVycy5leGVjdXRvciA9PT0gXCJzZWxmXCIpXFxuICAgICAgICByZXR1cm4gcGFyYW1ldGVycy5leGVjdXRvcjtcXG4gICAgICByZXR1cm4gcGFyc2VBY2NvdW50KHBhcmFtZXRlcnMuZXhlY3V0b3IpO1xcbiAgICB9KSgpO1xcbiAgICBjb25zdCBhdXRob3JpemF0aW9uID0ge1xcbiAgICAgIGFkZHJlc3M6IHBhcmFtZXRlcnMuY29udHJhY3RBZGRyZXNzID8/IHBhcmFtZXRlcnMuYWRkcmVzcyxcXG4gICAgICBjaGFpbklkLFxcbiAgICAgIG5vbmNlXFxuICAgIH07XFxuICAgIGlmICh0eXBlb2YgYXV0aG9yaXphdGlvbi5jaGFpbklkID09PSBcInVuZGVmaW5lZFwiKVxcbiAgICAgIGF1dGhvcml6YXRpb24uY2hhaW5JZCA9IGNsaWVudC5jaGFpbj8uaWQgPz8gYXdhaXQgZ2V0QWN0aW9uKGNsaWVudCwgZ2V0Q2hhaW5JZCwgXCJnZXRDaGFpbklkXCIpKHt9KTtcXG4gICAgaWYgKHR5cGVvZiBhdXRob3JpemF0aW9uLm5vbmNlID09PSBcInVuZGVmaW5lZFwiKSB7XFxuICAgICAgYXV0aG9yaXphdGlvbi5ub25jZSA9IGF3YWl0IGdldEFjdGlvbihjbGllbnQsIGdldFRyYW5zYWN0aW9uQ291bnQsIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiKSh7XFxuICAgICAgICBhZGRyZXNzOiBhY2NvdW50LmFkZHJlc3MsXFxuICAgICAgICBibG9ja1RhZzogXCJwZW5kaW5nXCJcXG4gICAgICB9KTtcXG4gICAgICBpZiAoZXhlY3V0b3IgPT09IFwic2VsZlwiIHx8IGV4ZWN1dG9yPy5hZGRyZXNzICYmIGlzQWRkcmVzc0VxdWFsKGV4ZWN1dG9yLmFkZHJlc3MsIGFjY291bnQuYWRkcmVzcykpXFxuICAgICAgICBhdXRob3JpemF0aW9uLm5vbmNlICs9IDE7XFxuICAgIH1cXG4gICAgcmV0dXJuIGF1dGhvcml6YXRpb247XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL3dhbGxldC9yZXF1ZXN0QWRkcmVzc2VzLmpzXFxuICBpbml0X2dldEFkZHJlc3MoKTtcXG4gIGFzeW5jIGZ1bmN0aW9uIHJlcXVlc3RBZGRyZXNzZXMoY2xpZW50KSB7XFxuICAgIGNvbnN0IGFkZHJlc3NlcyA9IGF3YWl0IGNsaWVudC5yZXF1ZXN0KHsgbWV0aG9kOiBcImV0aF9yZXF1ZXN0QWNjb3VudHNcIiB9LCB7IGRlZHVwZTogdHJ1ZSwgcmV0cnlDb3VudDogMCB9KTtcXG4gICAgcmV0dXJuIGFkZHJlc3Nlcy5tYXAoKGFkZHJlc3MpID0+IGdldEFkZHJlc3MoYWRkcmVzcykpO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vYWN0aW9ucy93YWxsZXQvcmVxdWVzdFBlcm1pc3Npb25zLmpzXFxuICBhc3luYyBmdW5jdGlvbiByZXF1ZXN0UGVybWlzc2lvbnMoY2xpZW50LCBwZXJtaXNzaW9ucykge1xcbiAgICByZXR1cm4gY2xpZW50LnJlcXVlc3Qoe1xcbiAgICAgIG1ldGhvZDogXCJ3YWxsZXRfcmVxdWVzdFBlcm1pc3Npb25zXCIsXFxuICAgICAgcGFyYW1zOiBbcGVybWlzc2lvbnNdXFxuICAgIH0sIHsgcmV0cnlDb3VudDogMCB9KTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjdGlvbnMvd2FsbGV0L3NpZ25BdXRob3JpemF0aW9uLmpzXFxuICBpbml0X3BhcnNlQWNjb3VudCgpO1xcbiAgYXN5bmMgZnVuY3Rpb24gc2lnbkF1dGhvcml6YXRpb24oY2xpZW50LCBwYXJhbWV0ZXJzKSB7XFxuICAgIGNvbnN0IHsgYWNjb3VudDogYWNjb3VudF8gPSBjbGllbnQuYWNjb3VudCB9ID0gcGFyYW1ldGVycztcXG4gICAgaWYgKCFhY2NvdW50XylcXG4gICAgICB0aHJvdyBuZXcgQWNjb3VudE5vdEZvdW5kRXJyb3Ioe1xcbiAgICAgICAgZG9jc1BhdGg6IFwiL2RvY3MvZWlwNzcwMi9zaWduQXV0aG9yaXphdGlvblwiXFxuICAgICAgfSk7XFxuICAgIGNvbnN0IGFjY291bnQgPSBwYXJzZUFjY291bnQoYWNjb3VudF8pO1xcbiAgICBpZiAoIWFjY291bnQuc2lnbkF1dGhvcml6YXRpb24pXFxuICAgICAgdGhyb3cgbmV3IEFjY291bnRUeXBlTm90U3VwcG9ydGVkRXJyb3Ioe1xcbiAgICAgICAgZG9jc1BhdGg6IFwiL2RvY3MvZWlwNzcwMi9zaWduQXV0aG9yaXphdGlvblwiLFxcbiAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXFxuICAgICAgICAgIFwiVGhlIGBzaWduQXV0aG9yaXphdGlvbmAgQWN0aW9uIGRvZXMgbm90IHN1cHBvcnQgSlNPTi1SUEMgQWNjb3VudHMuXCJcXG4gICAgICAgIF0sXFxuICAgICAgICB0eXBlOiBhY2NvdW50LnR5cGVcXG4gICAgICB9KTtcXG4gICAgY29uc3QgYXV0aG9yaXphdGlvbiA9IGF3YWl0IHByZXBhcmVBdXRob3JpemF0aW9uKGNsaWVudCwgcGFyYW1ldGVycyk7XFxuICAgIHJldHVybiBhY2NvdW50LnNpZ25BdXRob3JpemF0aW9uKGF1dGhvcml6YXRpb24pO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vYWN0aW9ucy93YWxsZXQvc2lnbk1lc3NhZ2UuanNcXG4gIGluaXRfcGFyc2VBY2NvdW50KCk7XFxuICBpbml0X3RvSGV4KCk7XFxuICBhc3luYyBmdW5jdGlvbiBzaWduTWVzc2FnZShjbGllbnQsIHsgYWNjb3VudDogYWNjb3VudF8gPSBjbGllbnQuYWNjb3VudCwgbWVzc2FnZSB9KSB7XFxuICAgIGlmICghYWNjb3VudF8pXFxuICAgICAgdGhyb3cgbmV3IEFjY291bnROb3RGb3VuZEVycm9yKHtcXG4gICAgICAgIGRvY3NQYXRoOiBcIi9kb2NzL2FjdGlvbnMvd2FsbGV0L3NpZ25NZXNzYWdlXCJcXG4gICAgICB9KTtcXG4gICAgY29uc3QgYWNjb3VudCA9IHBhcnNlQWNjb3VudChhY2NvdW50Xyk7XFxuICAgIGlmIChhY2NvdW50LnNpZ25NZXNzYWdlKVxcbiAgICAgIHJldHVybiBhY2NvdW50LnNpZ25NZXNzYWdlKHsgbWVzc2FnZSB9KTtcXG4gICAgY29uc3QgbWVzc2FnZV8gPSAoKCkgPT4ge1xcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIilcXG4gICAgICAgIHJldHVybiBzdHJpbmdUb0hleChtZXNzYWdlKTtcXG4gICAgICBpZiAobWVzc2FnZS5yYXcgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxcbiAgICAgICAgcmV0dXJuIHRvSGV4KG1lc3NhZ2UucmF3KTtcXG4gICAgICByZXR1cm4gbWVzc2FnZS5yYXc7XFxuICAgIH0pKCk7XFxuICAgIHJldHVybiBjbGllbnQucmVxdWVzdCh7XFxuICAgICAgbWV0aG9kOiBcInBlcnNvbmFsX3NpZ25cIixcXG4gICAgICBwYXJhbXM6IFttZXNzYWdlXywgYWNjb3VudC5hZGRyZXNzXVxcbiAgICB9LCB7IHJldHJ5Q291bnQ6IDAgfSk7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL3dhbGxldC9zaWduVHJhbnNhY3Rpb24uanNcXG4gIGluaXRfcGFyc2VBY2NvdW50KCk7XFxuICBpbml0X3RvSGV4KCk7XFxuICBpbml0X3RyYW5zYWN0aW9uUmVxdWVzdCgpO1xcbiAgaW5pdF9hc3NlcnRSZXF1ZXN0KCk7XFxuICBhc3luYyBmdW5jdGlvbiBzaWduVHJhbnNhY3Rpb24oY2xpZW50LCBwYXJhbWV0ZXJzKSB7XFxuICAgIGNvbnN0IHsgYWNjb3VudDogYWNjb3VudF8gPSBjbGllbnQuYWNjb3VudCwgY2hhaW4gPSBjbGllbnQuY2hhaW4sIC4uLnRyYW5zYWN0aW9uIH0gPSBwYXJhbWV0ZXJzO1xcbiAgICBpZiAoIWFjY291bnRfKVxcbiAgICAgIHRocm93IG5ldyBBY2NvdW50Tm90Rm91bmRFcnJvcih7XFxuICAgICAgICBkb2NzUGF0aDogXCIvZG9jcy9hY3Rpb25zL3dhbGxldC9zaWduVHJhbnNhY3Rpb25cIlxcbiAgICAgIH0pO1xcbiAgICBjb25zdCBhY2NvdW50ID0gcGFyc2VBY2NvdW50KGFjY291bnRfKTtcXG4gICAgYXNzZXJ0UmVxdWVzdCh7XFxuICAgICAgYWNjb3VudCxcXG4gICAgICAuLi5wYXJhbWV0ZXJzXFxuICAgIH0pO1xcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgZ2V0QWN0aW9uKGNsaWVudCwgZ2V0Q2hhaW5JZCwgXCJnZXRDaGFpbklkXCIpKHt9KTtcXG4gICAgaWYgKGNoYWluICE9PSBudWxsKVxcbiAgICAgIGFzc2VydEN1cnJlbnRDaGFpbih7XFxuICAgICAgICBjdXJyZW50Q2hhaW5JZDogY2hhaW5JZCxcXG4gICAgICAgIGNoYWluXFxuICAgICAgfSk7XFxuICAgIGNvbnN0IGZvcm1hdHRlcnMyID0gY2hhaW4/LmZvcm1hdHRlcnMgfHwgY2xpZW50LmNoYWluPy5mb3JtYXR0ZXJzO1xcbiAgICBjb25zdCBmb3JtYXQgPSBmb3JtYXR0ZXJzMj8udHJhbnNhY3Rpb25SZXF1ZXN0Py5mb3JtYXQgfHwgZm9ybWF0VHJhbnNhY3Rpb25SZXF1ZXN0O1xcbiAgICBpZiAoYWNjb3VudC5zaWduVHJhbnNhY3Rpb24pXFxuICAgICAgcmV0dXJuIGFjY291bnQuc2lnblRyYW5zYWN0aW9uKHtcXG4gICAgICAgIC4uLnRyYW5zYWN0aW9uLFxcbiAgICAgICAgY2hhaW5JZFxcbiAgICAgIH0sIHsgc2VyaWFsaXplcjogY2xpZW50LmNoYWluPy5zZXJpYWxpemVycz8udHJhbnNhY3Rpb24gfSk7XFxuICAgIHJldHVybiBhd2FpdCBjbGllbnQucmVxdWVzdCh7XFxuICAgICAgbWV0aG9kOiBcImV0aF9zaWduVHJhbnNhY3Rpb25cIixcXG4gICAgICBwYXJhbXM6IFtcXG4gICAgICAgIHtcXG4gICAgICAgICAgLi4uZm9ybWF0KHRyYW5zYWN0aW9uKSxcXG4gICAgICAgICAgY2hhaW5JZDogbnVtYmVyVG9IZXgoY2hhaW5JZCksXFxuICAgICAgICAgIGZyb206IGFjY291bnQuYWRkcmVzc1xcbiAgICAgICAgfVxcbiAgICAgIF1cXG4gICAgfSwgeyByZXRyeUNvdW50OiAwIH0pO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vYWN0aW9ucy93YWxsZXQvc2lnblR5cGVkRGF0YS5qc1xcbiAgaW5pdF9wYXJzZUFjY291bnQoKTtcXG4gIGFzeW5jIGZ1bmN0aW9uIHNpZ25UeXBlZERhdGEoY2xpZW50LCBwYXJhbWV0ZXJzKSB7XFxuICAgIGNvbnN0IHsgYWNjb3VudDogYWNjb3VudF8gPSBjbGllbnQuYWNjb3VudCwgZG9tYWluLCBtZXNzYWdlLCBwcmltYXJ5VHlwZSB9ID0gcGFyYW1ldGVycztcXG4gICAgaWYgKCFhY2NvdW50XylcXG4gICAgICB0aHJvdyBuZXcgQWNjb3VudE5vdEZvdW5kRXJyb3Ioe1xcbiAgICAgICAgZG9jc1BhdGg6IFwiL2RvY3MvYWN0aW9ucy93YWxsZXQvc2lnblR5cGVkRGF0YVwiXFxuICAgICAgfSk7XFxuICAgIGNvbnN0IGFjY291bnQgPSBwYXJzZUFjY291bnQoYWNjb3VudF8pO1xcbiAgICBjb25zdCB0eXBlcyA9IHtcXG4gICAgICBFSVA3MTJEb21haW46IGdldFR5cGVzRm9yRUlQNzEyRG9tYWluKHsgZG9tYWluIH0pLFxcbiAgICAgIC4uLnBhcmFtZXRlcnMudHlwZXNcXG4gICAgfTtcXG4gICAgdmFsaWRhdGVUeXBlZERhdGEoeyBkb21haW4sIG1lc3NhZ2UsIHByaW1hcnlUeXBlLCB0eXBlcyB9KTtcXG4gICAgaWYgKGFjY291bnQuc2lnblR5cGVkRGF0YSlcXG4gICAgICByZXR1cm4gYWNjb3VudC5zaWduVHlwZWREYXRhKHsgZG9tYWluLCBtZXNzYWdlLCBwcmltYXJ5VHlwZSwgdHlwZXMgfSk7XFxuICAgIGNvbnN0IHR5cGVkRGF0YSA9IHNlcmlhbGl6ZVR5cGVkRGF0YSh7IGRvbWFpbiwgbWVzc2FnZSwgcHJpbWFyeVR5cGUsIHR5cGVzIH0pO1xcbiAgICByZXR1cm4gY2xpZW50LnJlcXVlc3Qoe1xcbiAgICAgIG1ldGhvZDogXCJldGhfc2lnblR5cGVkRGF0YV92NFwiLFxcbiAgICAgIHBhcmFtczogW2FjY291bnQuYWRkcmVzcywgdHlwZWREYXRhXVxcbiAgICB9LCB7IHJldHJ5Q291bnQ6IDAgfSk7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9hY3Rpb25zL3dhbGxldC9zd2l0Y2hDaGFpbi5qc1xcbiAgaW5pdF90b0hleCgpO1xcbiAgYXN5bmMgZnVuY3Rpb24gc3dpdGNoQ2hhaW4oY2xpZW50LCB7IGlkIH0pIHtcXG4gICAgYXdhaXQgY2xpZW50LnJlcXVlc3Qoe1xcbiAgICAgIG1ldGhvZDogXCJ3YWxsZXRfc3dpdGNoRXRoZXJldW1DaGFpblwiLFxcbiAgICAgIHBhcmFtczogW1xcbiAgICAgICAge1xcbiAgICAgICAgICBjaGFpbklkOiBudW1iZXJUb0hleChpZClcXG4gICAgICAgIH1cXG4gICAgICBdXFxuICAgIH0sIHsgcmV0cnlDb3VudDogMCB9KTtcXG4gIH1cXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL2FjdGlvbnMvd2FsbGV0L3dhdGNoQXNzZXQuanNcXG4gIGFzeW5jIGZ1bmN0aW9uIHdhdGNoQXNzZXQoY2xpZW50LCBwYXJhbXMpIHtcXG4gICAgY29uc3QgYWRkZWQgPSBhd2FpdCBjbGllbnQucmVxdWVzdCh7XFxuICAgICAgbWV0aG9kOiBcIndhbGxldF93YXRjaEFzc2V0XCIsXFxuICAgICAgcGFyYW1zXFxuICAgIH0sIHsgcmV0cnlDb3VudDogMCB9KTtcXG4gICAgcmV0dXJuIGFkZGVkO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vY2xpZW50cy9kZWNvcmF0b3JzL3dhbGxldC5qc1xcbiAgZnVuY3Rpb24gd2FsbGV0QWN0aW9ucyhjbGllbnQpIHtcXG4gICAgcmV0dXJuIHtcXG4gICAgICBhZGRDaGFpbjogKGFyZ3MpID0+IGFkZENoYWluKGNsaWVudCwgYXJncyksXFxuICAgICAgZGVwbG95Q29udHJhY3Q6IChhcmdzKSA9PiBkZXBsb3lDb250cmFjdChjbGllbnQsIGFyZ3MpLFxcbiAgICAgIGdldEFkZHJlc3NlczogKCkgPT4gZ2V0QWRkcmVzc2VzKGNsaWVudCksXFxuICAgICAgZ2V0Q2hhaW5JZDogKCkgPT4gZ2V0Q2hhaW5JZChjbGllbnQpLFxcbiAgICAgIGdldFBlcm1pc3Npb25zOiAoKSA9PiBnZXRQZXJtaXNzaW9ucyhjbGllbnQpLFxcbiAgICAgIHByZXBhcmVBdXRob3JpemF0aW9uOiAoYXJncykgPT4gcHJlcGFyZUF1dGhvcml6YXRpb24oY2xpZW50LCBhcmdzKSxcXG4gICAgICBwcmVwYXJlVHJhbnNhY3Rpb25SZXF1ZXN0OiAoYXJncykgPT4gcHJlcGFyZVRyYW5zYWN0aW9uUmVxdWVzdChjbGllbnQsIGFyZ3MpLFxcbiAgICAgIHJlcXVlc3RBZGRyZXNzZXM6ICgpID0+IHJlcXVlc3RBZGRyZXNzZXMoY2xpZW50KSxcXG4gICAgICByZXF1ZXN0UGVybWlzc2lvbnM6IChhcmdzKSA9PiByZXF1ZXN0UGVybWlzc2lvbnMoY2xpZW50LCBhcmdzKSxcXG4gICAgICBzZW5kUmF3VHJhbnNhY3Rpb246IChhcmdzKSA9PiBzZW5kUmF3VHJhbnNhY3Rpb24oY2xpZW50LCBhcmdzKSxcXG4gICAgICBzZW5kVHJhbnNhY3Rpb246IChhcmdzKSA9PiBzZW5kVHJhbnNhY3Rpb24oY2xpZW50LCBhcmdzKSxcXG4gICAgICBzaWduQXV0aG9yaXphdGlvbjogKGFyZ3MpID0+IHNpZ25BdXRob3JpemF0aW9uKGNsaWVudCwgYXJncyksXFxuICAgICAgc2lnbk1lc3NhZ2U6IChhcmdzKSA9PiBzaWduTWVzc2FnZShjbGllbnQsIGFyZ3MpLFxcbiAgICAgIHNpZ25UcmFuc2FjdGlvbjogKGFyZ3MpID0+IHNpZ25UcmFuc2FjdGlvbihjbGllbnQsIGFyZ3MpLFxcbiAgICAgIHNpZ25UeXBlZERhdGE6IChhcmdzKSA9PiBzaWduVHlwZWREYXRhKGNsaWVudCwgYXJncyksXFxuICAgICAgc3dpdGNoQ2hhaW46IChhcmdzKSA9PiBzd2l0Y2hDaGFpbihjbGllbnQsIGFyZ3MpLFxcbiAgICAgIHdhdGNoQXNzZXQ6IChhcmdzKSA9PiB3YXRjaEFzc2V0KGNsaWVudCwgYXJncyksXFxuICAgICAgd3JpdGVDb250cmFjdDogKGFyZ3MpID0+IHdyaXRlQ29udHJhY3QoY2xpZW50LCBhcmdzKVxcbiAgICB9O1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vY2xpZW50cy9jcmVhdGVXYWxsZXRDbGllbnQuanNcXG4gIGZ1bmN0aW9uIGNyZWF0ZVdhbGxldENsaWVudChwYXJhbWV0ZXJzKSB7XFxuICAgIGNvbnN0IHsga2V5ID0gXCJ3YWxsZXRcIiwgbmFtZSA9IFwiV2FsbGV0IENsaWVudFwiLCB0cmFuc3BvcnQgfSA9IHBhcmFtZXRlcnM7XFxuICAgIGNvbnN0IGNsaWVudCA9IGNyZWF0ZUNsaWVudCh7XFxuICAgICAgLi4ucGFyYW1ldGVycyxcXG4gICAgICBrZXksXFxuICAgICAgbmFtZSxcXG4gICAgICB0cmFuc3BvcnQsXFxuICAgICAgdHlwZTogXCJ3YWxsZXRDbGllbnRcIlxcbiAgICB9KTtcXG4gICAgcmV0dXJuIGNsaWVudC5leHRlbmQod2FsbGV0QWN0aW9ucyk7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9pbmRleC5qc1xcbiAgaW5pdF90b0hleCgpO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vb3Atc3RhY2svY29udHJhY3RzLmpzXFxuICB2YXIgY29udHJhY3RzID0ge1xcbiAgICBnYXNQcmljZU9yYWNsZTogeyBhZGRyZXNzOiBcIjB4NDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwRlwiIH0sXFxuICAgIGwxQmxvY2s6IHsgYWRkcmVzczogXCIweDQyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTVcIiB9LFxcbiAgICBsMkNyb3NzRG9tYWluTWVzc2VuZ2VyOiB7XFxuICAgICAgYWRkcmVzczogXCIweDQyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDdcIlxcbiAgICB9LFxcbiAgICBsMkVyYzcyMUJyaWRnZTogeyBhZGRyZXNzOiBcIjB4NDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxNFwiIH0sXFxuICAgIGwyU3RhbmRhcmRCcmlkZ2U6IHsgYWRkcmVzczogXCIweDQyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTBcIiB9LFxcbiAgICBsMlRvTDFNZXNzYWdlUGFzc2VyOiB7XFxuICAgICAgYWRkcmVzczogXCIweDQyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTZcIlxcbiAgICB9XFxuICB9O1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vb3Atc3RhY2svZm9ybWF0dGVycy5qc1xcbiAgaW5pdF9mcm9tSGV4KCk7XFxuICB2YXIgZm9ybWF0dGVycyA9IHtcXG4gICAgYmxvY2s6IC8qIEBfX1BVUkVfXyAqLyBkZWZpbmVCbG9jayh7XFxuICAgICAgZm9ybWF0KGFyZ3MpIHtcXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9ucyA9IGFyZ3MudHJhbnNhY3Rpb25zPy5tYXAoKHRyYW5zYWN0aW9uKSA9PiB7XFxuICAgICAgICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb24gPT09IFwic3RyaW5nXCIpXFxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xcbiAgICAgICAgICBjb25zdCBmb3JtYXR0ZWQgPSBmb3JtYXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XFxuICAgICAgICAgIGlmIChmb3JtYXR0ZWQudHlwZUhleCA9PT0gXCIweDdlXCIpIHtcXG4gICAgICAgICAgICBmb3JtYXR0ZWQuaXNTeXN0ZW1UeCA9IHRyYW5zYWN0aW9uLmlzU3lzdGVtVHg7XFxuICAgICAgICAgICAgZm9ybWF0dGVkLm1pbnQgPSB0cmFuc2FjdGlvbi5taW50ID8gaGV4VG9CaWdJbnQodHJhbnNhY3Rpb24ubWludCkgOiB2b2lkIDA7XFxuICAgICAgICAgICAgZm9ybWF0dGVkLnNvdXJjZUhhc2ggPSB0cmFuc2FjdGlvbi5zb3VyY2VIYXNoO1xcbiAgICAgICAgICAgIGZvcm1hdHRlZC50eXBlID0gXCJkZXBvc2l0XCI7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgcmV0dXJuIGZvcm1hdHRlZDtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgdHJhbnNhY3Rpb25zLFxcbiAgICAgICAgICBzdGF0ZVJvb3Q6IGFyZ3Muc3RhdGVSb290XFxuICAgICAgICB9O1xcbiAgICAgIH1cXG4gICAgfSksXFxuICAgIHRyYW5zYWN0aW9uOiAvKiBAX19QVVJFX18gKi8gZGVmaW5lVHJhbnNhY3Rpb24oe1xcbiAgICAgIGZvcm1hdChhcmdzKSB7XFxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHt9O1xcbiAgICAgICAgaWYgKGFyZ3MudHlwZSA9PT0gXCIweDdlXCIpIHtcXG4gICAgICAgICAgdHJhbnNhY3Rpb24uaXNTeXN0ZW1UeCA9IGFyZ3MuaXNTeXN0ZW1UeDtcXG4gICAgICAgICAgdHJhbnNhY3Rpb24ubWludCA9IGFyZ3MubWludCA/IGhleFRvQmlnSW50KGFyZ3MubWludCkgOiB2b2lkIDA7XFxuICAgICAgICAgIHRyYW5zYWN0aW9uLnNvdXJjZUhhc2ggPSBhcmdzLnNvdXJjZUhhc2g7XFxuICAgICAgICAgIHRyYW5zYWN0aW9uLnR5cGUgPSBcImRlcG9zaXRcIjtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB0cmFuc2FjdGlvbjtcXG4gICAgICB9XFxuICAgIH0pLFxcbiAgICB0cmFuc2FjdGlvblJlY2VpcHQ6IC8qIEBfX1BVUkVfXyAqLyBkZWZpbmVUcmFuc2FjdGlvblJlY2VpcHQoe1xcbiAgICAgIGZvcm1hdChhcmdzKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICBsMUdhc1ByaWNlOiBhcmdzLmwxR2FzUHJpY2UgPyBoZXhUb0JpZ0ludChhcmdzLmwxR2FzUHJpY2UpIDogbnVsbCxcXG4gICAgICAgICAgbDFHYXNVc2VkOiBhcmdzLmwxR2FzVXNlZCA/IGhleFRvQmlnSW50KGFyZ3MubDFHYXNVc2VkKSA6IG51bGwsXFxuICAgICAgICAgIGwxRmVlOiBhcmdzLmwxRmVlID8gaGV4VG9CaWdJbnQoYXJncy5sMUZlZSkgOiBudWxsLFxcbiAgICAgICAgICBsMUZlZVNjYWxhcjogYXJncy5sMUZlZVNjYWxhciA/IE51bWJlcihhcmdzLmwxRmVlU2NhbGFyKSA6IG51bGxcXG4gICAgICAgIH07XFxuICAgICAgfVxcbiAgICB9KVxcbiAgfTtcXG5cXG4gIC8vIC4uLy4uLy4uL2V4YW1wbGVzL3R5cGVzY3JpcHQvbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMi4yNy4yX2J1ZmZlcnV0aWxANC4wLjlfdHlwZXNjcmlwdEA1LjguM191dGYtOC12YWxpZGF0ZUA1LjAuMTBfem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvdmllbS9fZXNtL29wLXN0YWNrL3NlcmlhbGl6ZXJzLmpzXFxuICBpbml0X2FkZHJlc3MoKTtcXG4gIGluaXRfaXNBZGRyZXNzKCk7XFxuICBpbml0X2NvbmNhdCgpO1xcbiAgaW5pdF90b0hleCgpO1xcbiAgZnVuY3Rpb24gc2VyaWFsaXplVHJhbnNhY3Rpb24yKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpIHtcXG4gICAgaWYgKGlzRGVwb3NpdCh0cmFuc2FjdGlvbikpXFxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZVRyYW5zYWN0aW9uRGVwb3NpdCh0cmFuc2FjdGlvbik7XFxuICAgIHJldHVybiBzZXJpYWxpemVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKTtcXG4gIH1cXG4gIHZhciBzZXJpYWxpemVycyA9IHtcXG4gICAgdHJhbnNhY3Rpb246IHNlcmlhbGl6ZVRyYW5zYWN0aW9uMlxcbiAgfTtcXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZVRyYW5zYWN0aW9uRGVwb3NpdCh0cmFuc2FjdGlvbikge1xcbiAgICBhc3NlcnRUcmFuc2FjdGlvbkRlcG9zaXQodHJhbnNhY3Rpb24pO1xcbiAgICBjb25zdCB7IHNvdXJjZUhhc2gsIGRhdGEsIGZyb206IGZyb201LCBnYXMsIGlzU3lzdGVtVHgsIG1pbnQsIHRvLCB2YWx1ZSB9ID0gdHJhbnNhY3Rpb247XFxuICAgIGNvbnN0IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbiA9IFtcXG4gICAgICBzb3VyY2VIYXNoLFxcbiAgICAgIGZyb201LFxcbiAgICAgIHRvID8/IFwiMHhcIixcXG4gICAgICBtaW50ID8gdG9IZXgobWludCkgOiBcIjB4XCIsXFxuICAgICAgdmFsdWUgPyB0b0hleCh2YWx1ZSkgOiBcIjB4XCIsXFxuICAgICAgZ2FzID8gdG9IZXgoZ2FzKSA6IFwiMHhcIixcXG4gICAgICBpc1N5c3RlbVR4ID8gXCIweDFcIiA6IFwiMHhcIixcXG4gICAgICBkYXRhID8/IFwiMHhcIlxcbiAgICBdO1xcbiAgICByZXR1cm4gY29uY2F0SGV4KFtcXG4gICAgICBcIjB4N2VcIixcXG4gICAgICB0b1JscChzZXJpYWxpemVkVHJhbnNhY3Rpb24pXFxuICAgIF0pO1xcbiAgfVxcbiAgZnVuY3Rpb24gaXNEZXBvc2l0KHRyYW5zYWN0aW9uKSB7XFxuICAgIGlmICh0cmFuc2FjdGlvbi50eXBlID09PSBcImRlcG9zaXRcIilcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbi5zb3VyY2VIYXNoICE9PSBcInVuZGVmaW5lZFwiKVxcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuICBmdW5jdGlvbiBhc3NlcnRUcmFuc2FjdGlvbkRlcG9zaXQodHJhbnNhY3Rpb24pIHtcXG4gICAgY29uc3QgeyBmcm9tOiBmcm9tNSwgdG8gfSA9IHRyYW5zYWN0aW9uO1xcbiAgICBpZiAoZnJvbTUgJiYgIWlzQWRkcmVzcyhmcm9tNSkpXFxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoeyBhZGRyZXNzOiBmcm9tNSB9KTtcXG4gICAgaWYgKHRvICYmICFpc0FkZHJlc3ModG8pKVxcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKHsgYWRkcmVzczogdG8gfSk7XFxuICB9XFxuXFxuICAvLyAuLi8uLi8uLi9leGFtcGxlcy90eXBlc2NyaXB0L25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDIuMjcuMl9idWZmZXJ1dGlsQDQuMC45X3R5cGVzY3JpcHRANS44LjNfdXRmLTgtdmFsaWRhdGVANS4wLjEwX3pvZEAzLjI0LjMvbm9kZV9tb2R1bGVzL3ZpZW0vX2VzbS9vcC1zdGFjay9jaGFpbkNvbmZpZy5qc1xcbiAgdmFyIGNoYWluQ29uZmlnID0ge1xcbiAgICBjb250cmFjdHMsXFxuICAgIGZvcm1hdHRlcnMsXFxuICAgIHNlcmlhbGl6ZXJzXFxuICB9O1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vY2hhaW5zL2RlZmluaXRpb25zL2Jhc2UuanNcXG4gIHZhciBzb3VyY2VJZCA9IDE7XFxuICB2YXIgYmFzZSA9IC8qIEBfX1BVUkVfXyAqLyBkZWZpbmVDaGFpbih7XFxuICAgIC4uLmNoYWluQ29uZmlnLFxcbiAgICBpZDogODQ1MyxcXG4gICAgbmFtZTogXCJCYXNlXCIsXFxuICAgIG5hdGl2ZUN1cnJlbmN5OiB7IG5hbWU6IFwiRXRoZXJcIiwgc3ltYm9sOiBcIkVUSFwiLCBkZWNpbWFsczogMTggfSxcXG4gICAgcnBjVXJsczoge1xcbiAgICAgIGRlZmF1bHQ6IHtcXG4gICAgICAgIGh0dHA6IFtcImh0dHBzOi8vbWFpbm5ldC5iYXNlLm9yZ1wiXVxcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgYmxvY2tFeHBsb3JlcnM6IHtcXG4gICAgICBkZWZhdWx0OiB7XFxuICAgICAgICBuYW1lOiBcIkJhc2VzY2FuXCIsXFxuICAgICAgICB1cmw6IFwiaHR0cHM6Ly9iYXNlc2Nhbi5vcmdcIixcXG4gICAgICAgIGFwaVVybDogXCJodHRwczovL2FwaS5iYXNlc2Nhbi5vcmcvYXBpXCJcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIGNvbnRyYWN0czoge1xcbiAgICAgIC4uLmNoYWluQ29uZmlnLmNvbnRyYWN0cyxcXG4gICAgICBkaXNwdXRlR2FtZUZhY3Rvcnk6IHtcXG4gICAgICAgIFtzb3VyY2VJZF06IHtcXG4gICAgICAgICAgYWRkcmVzczogXCIweDQzZWRCODhDNEI4MGZERDJBZEZGMjQxMkE3QmViRjlkRjQyY0I0MGVcIlxcbiAgICAgICAgfVxcbiAgICAgIH0sXFxuICAgICAgbDJPdXRwdXRPcmFjbGU6IHtcXG4gICAgICAgIFtzb3VyY2VJZF06IHtcXG4gICAgICAgICAgYWRkcmVzczogXCIweDU2MzE1YjkwYzQwNzMwOTI1ZWM1NDg1Y2YwMDRkODM1MDU4NTE4QTBcIlxcbiAgICAgICAgfVxcbiAgICAgIH0sXFxuICAgICAgbXVsdGljYWxsMzoge1xcbiAgICAgICAgYWRkcmVzczogXCIweGNhMTFiZGUwNTk3N2IzNjMxMTY3MDI4ODYyYmUyYTE3Mzk3NmNhMTFcIixcXG4gICAgICAgIGJsb2NrQ3JlYXRlZDogNTAyMlxcbiAgICAgIH0sXFxuICAgICAgcG9ydGFsOiB7XFxuICAgICAgICBbc291cmNlSWRdOiB7XFxuICAgICAgICAgIGFkZHJlc3M6IFwiMHg0OTA0ODA0NEQ1N2UxQzkyQTc3Zjc5OTg4ZDIxRmE4ZkFGNzRFOTdlXCIsXFxuICAgICAgICAgIGJsb2NrQ3JlYXRlZDogMTc0ODIxNDNcXG4gICAgICAgIH1cXG4gICAgICB9LFxcbiAgICAgIGwxU3RhbmRhcmRCcmlkZ2U6IHtcXG4gICAgICAgIFtzb3VyY2VJZF06IHtcXG4gICAgICAgICAgYWRkcmVzczogXCIweDMxNTRDZjE2Y2NkYjRDNmQ5MjI2Mjk2NjQxNzRiOTA0ZDgwRjJDMzVcIixcXG4gICAgICAgICAgYmxvY2tDcmVhdGVkOiAxNzQ4MjE0M1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgc291cmNlSWRcXG4gIH0pO1xcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vdmllbUAyLjI3LjJfYnVmZmVydXRpbEA0LjAuOV90eXBlc2NyaXB0QDUuOC4zX3V0Zi04LXZhbGlkYXRlQDUuMC4xMF96b2RAMy4yNC4zL25vZGVfbW9kdWxlcy92aWVtL19lc20vY2hhaW5zL2RlZmluaXRpb25zL2Jhc2VTZXBvbGlhLmpzXFxuICB2YXIgc291cmNlSWQyID0gMTExNTUxMTE7XFxuICB2YXIgYmFzZVNlcG9saWEgPSAvKiBAX19QVVJFX18gKi8gZGVmaW5lQ2hhaW4oe1xcbiAgICAuLi5jaGFpbkNvbmZpZyxcXG4gICAgaWQ6IDg0NTMyLFxcbiAgICBuZXR3b3JrOiBcImJhc2Utc2Vwb2xpYVwiLFxcbiAgICBuYW1lOiBcIkJhc2UgU2Vwb2xpYVwiLFxcbiAgICBuYXRpdmVDdXJyZW5jeTogeyBuYW1lOiBcIlNlcG9saWEgRXRoZXJcIiwgc3ltYm9sOiBcIkVUSFwiLCBkZWNpbWFsczogMTggfSxcXG4gICAgcnBjVXJsczoge1xcbiAgICAgIGRlZmF1bHQ6IHtcXG4gICAgICAgIGh0dHA6IFtcImh0dHBzOi8vc2Vwb2xpYS5iYXNlLm9yZ1wiXVxcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgYmxvY2tFeHBsb3JlcnM6IHtcXG4gICAgICBkZWZhdWx0OiB7XFxuICAgICAgICBuYW1lOiBcIkJhc2VzY2FuXCIsXFxuICAgICAgICB1cmw6IFwiaHR0cHM6Ly9zZXBvbGlhLmJhc2VzY2FuLm9yZ1wiLFxcbiAgICAgICAgYXBpVXJsOiBcImh0dHBzOi8vYXBpLXNlcG9saWEuYmFzZXNjYW4ub3JnL2FwaVwiXFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBjb250cmFjdHM6IHtcXG4gICAgICAuLi5jaGFpbkNvbmZpZy5jb250cmFjdHMsXFxuICAgICAgZGlzcHV0ZUdhbWVGYWN0b3J5OiB7XFxuICAgICAgICBbc291cmNlSWQyXToge1xcbiAgICAgICAgICBhZGRyZXNzOiBcIjB4ZDZFNmRCZjRGN0VBMGFjNDEyZkQ4YjY1RUQyOTdlNjRCQjdhMDZFMVwiXFxuICAgICAgICB9XFxuICAgICAgfSxcXG4gICAgICBsMk91dHB1dE9yYWNsZToge1xcbiAgICAgICAgW3NvdXJjZUlkMl06IHtcXG4gICAgICAgICAgYWRkcmVzczogXCIweDg0NDU3Y2E5RDAxNjNGYkM0YmJmZTREZmJiMjBiYTQ2ZTQ4REYyNTRcIlxcbiAgICAgICAgfVxcbiAgICAgIH0sXFxuICAgICAgcG9ydGFsOiB7XFxuICAgICAgICBbc291cmNlSWQyXToge1xcbiAgICAgICAgICBhZGRyZXNzOiBcIjB4NDlmNTNlNDE0NTJjNzQ1ODllODVjYTE2Nzc0MjZiYTQyNjQ1OWU4NVwiLFxcbiAgICAgICAgICBibG9ja0NyZWF0ZWQ6IDQ0NDY2NzdcXG4gICAgICAgIH1cXG4gICAgICB9LFxcbiAgICAgIGwxU3RhbmRhcmRCcmlkZ2U6IHtcXG4gICAgICAgIFtzb3VyY2VJZDJdOiB7XFxuICAgICAgICAgIGFkZHJlc3M6IFwiMHhmZDBCZjcxRjYwNjYwRTJmNjA4ZWQ1NmUxNjU5QzQ1MGVCMTEzMTIwXCIsXFxuICAgICAgICAgIGJsb2NrQ3JlYXRlZDogNDQ0NjY3N1xcbiAgICAgICAgfVxcbiAgICAgIH0sXFxuICAgICAgbXVsdGljYWxsMzoge1xcbiAgICAgICAgYWRkcmVzczogXCIweGNhMTFiZGUwNTk3N2IzNjMxMTY3MDI4ODYyYmUyYTE3Mzk3NmNhMTFcIixcXG4gICAgICAgIGJsb2NrQ3JlYXRlZDogMTA1OTY0N1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgdGVzdG5ldDogdHJ1ZSxcXG4gICAgc291cmNlSWQ6IHNvdXJjZUlkMlxcbiAgfSk7XFxuXFxuICAvLyBzcmMvdHlwZXMvc2hhcmVkL2V2bS9jb25maWcudHNcXG4gIHZhciBjb25maWcgPSB7XFxuICAgIFwiODQ1MzJcIjoge1xcbiAgICAgIHVzZGNBZGRyZXNzOiBcIjB4MDM2Q2JENTM4NDJjNTQyNjYzNGU3OTI5NTQxZUMyMzE4ZjNkQ0Y3ZVwiLFxcbiAgICAgIHVzZGNOYW1lOiBcIlVTRENcIlxcbiAgICB9LFxcbiAgICBcIjg0NTNcIjoge1xcbiAgICAgIHVzZGNBZGRyZXNzOiBcIjB4ODMzNTg5ZkNENmVEYjZFMDhmNGM3QzMyRDRmNzFiNTRiZEEwMjkxM1wiLFxcbiAgICAgIHVzZGNOYW1lOiBcIlVTRENcIlxcbiAgICB9LFxcbiAgICBcIjQzMTEzXCI6IHtcXG4gICAgICB1c2RjQWRkcmVzczogXCIweDU0MjU4OTAyOThhZWQ2MDE1OTVhNzBBQjgxNWM5NjcxMWEzMUJjNjVcIixcXG4gICAgICB1c2RjTmFtZTogXCJVU0QgQ29pblwiXFxuICAgIH0sXFxuICAgIFwiNDMxMTRcIjoge1xcbiAgICAgIHVzZGNBZGRyZXNzOiBcIjB4Qjk3RUY5RWY4NzM0QzcxOTA0RDgwMDJGOGI2QmM2NkRkOWM0OGE2RVwiLFxcbiAgICAgIHVzZGNOYW1lOiBcIlVTRENcIlxcbiAgICB9LFxcbiAgICBcIjQ2ODlcIjoge1xcbiAgICAgIHVzZGNBZGRyZXNzOiBcIjB4Y2RmNzkxOTRjNmMyODUwNzdhNThkYTQ3NjQxZDRkYmU1MWY2MzU0MlwiLFxcbiAgICAgIHVzZGNOYW1lOiBcIkJyaWRnZWQgVVNEQ1wiXFxuICAgIH1cXG4gIH07XFxuXFxuICAvLyBzcmMvdHlwZXMvc2hhcmVkL2V2bS9laXAzMDA5LnRzXFxuICB2YXIgYXV0aG9yaXphdGlvblR5cGVzID0ge1xcbiAgICBUcmFuc2ZlcldpdGhBdXRob3JpemF0aW9uOiBbXFxuICAgICAgeyBuYW1lOiBcImZyb21cIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcXG4gICAgICB7IG5hbWU6IFwidG9cIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcXG4gICAgICB7IG5hbWU6IFwidmFsdWVcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcXG4gICAgICB7IG5hbWU6IFwidmFsaWRBZnRlclwiLCB0eXBlOiBcInVpbnQyNTZcIiB9LFxcbiAgICAgIHsgbmFtZTogXCJ2YWxpZEJlZm9yZVwiLCB0eXBlOiBcInVpbnQyNTZcIiB9LFxcbiAgICAgIHsgbmFtZTogXCJub25jZVwiLCB0eXBlOiBcImJ5dGVzMzJcIiB9XFxuICAgIF1cXG4gIH07XFxuXFxuICAvLyBzcmMvdHlwZXMvc2hhcmVkL2V2bS9lcmMyMFBlcm1pdEFCSS50c1xcbiAgdmFyIHVzZGNBQkkgPSBbXFxuICAgIHtcXG4gICAgICBhbm9ueW1vdXM6IGZhbHNlLFxcbiAgICAgIGlucHV0czogW1xcbiAgICAgICAge1xcbiAgICAgICAgICBpbmRleGVkOiB0cnVlLFxcbiAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxcbiAgICAgICAgICBuYW1lOiBcIm93bmVyXCIsXFxuICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXFxuICAgICAgICB9LFxcbiAgICAgICAge1xcbiAgICAgICAgICBpbmRleGVkOiB0cnVlLFxcbiAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxcbiAgICAgICAgICBuYW1lOiBcInNwZW5kZXJcIixcXG4gICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcXG4gICAgICAgIH0sXFxuICAgICAgICB7XFxuICAgICAgICAgIGluZGV4ZWQ6IGZhbHNlLFxcbiAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxcbiAgICAgICAgICBuYW1lOiBcInZhbHVlXCIsXFxuICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiXFxuICAgICAgICB9XFxuICAgICAgXSxcXG4gICAgICBuYW1lOiBcIkFwcHJvdmFsXCIsXFxuICAgICAgdHlwZTogXCJldmVudFwiXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICBhbm9ueW1vdXM6IGZhbHNlLFxcbiAgICAgIGlucHV0czogW1xcbiAgICAgICAge1xcbiAgICAgICAgICBpbmRleGVkOiB0cnVlLFxcbiAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxcbiAgICAgICAgICBuYW1lOiBcImF1dGhvcml6ZXJcIixcXG4gICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcXG4gICAgICAgIH0sXFxuICAgICAgICB7XFxuICAgICAgICAgIGluZGV4ZWQ6IHRydWUsXFxuICAgICAgICAgIGludGVybmFsVHlwZTogXCJieXRlczMyXCIsXFxuICAgICAgICAgIG5hbWU6IFwibm9uY2VcIixcXG4gICAgICAgICAgdHlwZTogXCJieXRlczMyXCJcXG4gICAgICAgIH1cXG4gICAgICBdLFxcbiAgICAgIG5hbWU6IFwiQXV0aG9yaXphdGlvbkNhbmNlbGVkXCIsXFxuICAgICAgdHlwZTogXCJldmVudFwiXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICBhbm9ueW1vdXM6IGZhbHNlLFxcbiAgICAgIGlucHV0czogW1xcbiAgICAgICAge1xcbiAgICAgICAgICBpbmRleGVkOiB0cnVlLFxcbiAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxcbiAgICAgICAgICBuYW1lOiBcImF1dGhvcml6ZXJcIixcXG4gICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcXG4gICAgICAgIH0sXFxuICAgICAgICB7XFxuICAgICAgICAgIGluZGV4ZWQ6IHRydWUsXFxuICAgICAgICAgIGludGVybmFsVHlwZTogXCJieXRlczMyXCIsXFxuICAgICAgICAgIG5hbWU6IFwibm9uY2VcIixcXG4gICAgICAgICAgdHlwZTogXCJieXRlczMyXCJcXG4gICAgICAgIH1cXG4gICAgICBdLFxcbiAgICAgIG5hbWU6IFwiQXV0aG9yaXphdGlvblVzZWRcIixcXG4gICAgICB0eXBlOiBcImV2ZW50XCJcXG4gICAgfSxcXG4gICAge1xcbiAgICAgIGFub255bW91czogZmFsc2UsXFxuICAgICAgaW5wdXRzOiBbXFxuICAgICAgICB7XFxuICAgICAgICAgIGluZGV4ZWQ6IHRydWUsXFxuICAgICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXFxuICAgICAgICAgIG5hbWU6IFwiX2FjY291bnRcIixcXG4gICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcXG4gICAgICAgIH1cXG4gICAgICBdLFxcbiAgICAgIG5hbWU6IFwiQmxhY2tsaXN0ZWRcIixcXG4gICAgICB0eXBlOiBcImV2ZW50XCJcXG4gICAgfSxcXG4gICAge1xcbiAgICAgIGFub255bW91czogZmFsc2UsXFxuICAgICAgaW5wdXRzOiBbXFxuICAgICAgICB7XFxuICAgICAgICAgIGluZGV4ZWQ6IHRydWUsXFxuICAgICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXFxuICAgICAgICAgIG5hbWU6IFwibmV3QmxhY2tsaXN0ZXJcIixcXG4gICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcXG4gICAgICAgIH1cXG4gICAgICBdLFxcbiAgICAgIG5hbWU6IFwiQmxhY2tsaXN0ZXJDaGFuZ2VkXCIsXFxuICAgICAgdHlwZTogXCJldmVudFwiXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICBhbm9ueW1vdXM6IGZhbHNlLFxcbiAgICAgIGlucHV0czogW1xcbiAgICAgICAge1xcbiAgICAgICAgICBpbmRleGVkOiB0cnVlLFxcbiAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxcbiAgICAgICAgICBuYW1lOiBcImJ1cm5lclwiLFxcbiAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxcbiAgICAgICAgfSxcXG4gICAgICAgIHtcXG4gICAgICAgICAgaW5kZXhlZDogZmFsc2UsXFxuICAgICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXFxuICAgICAgICAgIG5hbWU6IFwiYW1vdW50XCIsXFxuICAgICAgICAgIHR5cGU6IFwidWludDI1NlwiXFxuICAgICAgICB9XFxuICAgICAgXSxcXG4gICAgICBuYW1lOiBcIkJ1cm5cIixcXG4gICAgICB0eXBlOiBcImV2ZW50XCJcXG4gICAgfSxcXG4gICAge1xcbiAgICAgIGFub255bW91czogZmFsc2UsXFxuICAgICAgaW5wdXRzOiBbXFxuICAgICAgICB7XFxuICAgICAgICAgIGluZGV4ZWQ6IHRydWUsXFxuICAgICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXFxuICAgICAgICAgIG5hbWU6IFwibmV3TWFzdGVyTWludGVyXCIsXFxuICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXFxuICAgICAgICB9XFxuICAgICAgXSxcXG4gICAgICBuYW1lOiBcIk1hc3Rlck1pbnRlckNoYW5nZWRcIixcXG4gICAgICB0eXBlOiBcImV2ZW50XCJcXG4gICAgfSxcXG4gICAge1xcbiAgICAgIGFub255bW91czogZmFsc2UsXFxuICAgICAgaW5wdXRzOiBbXFxuICAgICAgICB7XFxuICAgICAgICAgIGluZGV4ZWQ6IHRydWUsXFxuICAgICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXFxuICAgICAgICAgIG5hbWU6IFwibWludGVyXCIsXFxuICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXFxuICAgICAgICB9LFxcbiAgICAgICAgeyBpbmRleGVkOiB0cnVlLCBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcInRvXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXFxuICAgICAgICB7XFxuICAgICAgICAgIGluZGV4ZWQ6IGZhbHNlLFxcbiAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxcbiAgICAgICAgICBuYW1lOiBcImFtb3VudFwiLFxcbiAgICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxcbiAgICAgICAgfVxcbiAgICAgIF0sXFxuICAgICAgbmFtZTogXCJNaW50XCIsXFxuICAgICAgdHlwZTogXCJldmVudFwiXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICBhbm9ueW1vdXM6IGZhbHNlLFxcbiAgICAgIGlucHV0czogW1xcbiAgICAgICAge1xcbiAgICAgICAgICBpbmRleGVkOiB0cnVlLFxcbiAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxcbiAgICAgICAgICBuYW1lOiBcIm1pbnRlclwiLFxcbiAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxcbiAgICAgICAgfSxcXG4gICAgICAgIHtcXG4gICAgICAgICAgaW5kZXhlZDogZmFsc2UsXFxuICAgICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXFxuICAgICAgICAgIG5hbWU6IFwibWludGVyQWxsb3dlZEFtb3VudFwiLFxcbiAgICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxcbiAgICAgICAgfVxcbiAgICAgIF0sXFxuICAgICAgbmFtZTogXCJNaW50ZXJDb25maWd1cmVkXCIsXFxuICAgICAgdHlwZTogXCJldmVudFwiXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICBhbm9ueW1vdXM6IGZhbHNlLFxcbiAgICAgIGlucHV0czogW1xcbiAgICAgICAge1xcbiAgICAgICAgICBpbmRleGVkOiB0cnVlLFxcbiAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxcbiAgICAgICAgICBuYW1lOiBcIm9sZE1pbnRlclwiLFxcbiAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxcbiAgICAgICAgfVxcbiAgICAgIF0sXFxuICAgICAgbmFtZTogXCJNaW50ZXJSZW1vdmVkXCIsXFxuICAgICAgdHlwZTogXCJldmVudFwiXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICBhbm9ueW1vdXM6IGZhbHNlLFxcbiAgICAgIGlucHV0czogW1xcbiAgICAgICAge1xcbiAgICAgICAgICBpbmRleGVkOiBmYWxzZSxcXG4gICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcXG4gICAgICAgICAgbmFtZTogXCJwcmV2aW91c093bmVyXCIsXFxuICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXFxuICAgICAgICB9LFxcbiAgICAgICAge1xcbiAgICAgICAgICBpbmRleGVkOiBmYWxzZSxcXG4gICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcXG4gICAgICAgICAgbmFtZTogXCJuZXdPd25lclwiLFxcbiAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxcbiAgICAgICAgfVxcbiAgICAgIF0sXFxuICAgICAgbmFtZTogXCJPd25lcnNoaXBUcmFuc2ZlcnJlZFwiLFxcbiAgICAgIHR5cGU6IFwiZXZlbnRcIlxcbiAgICB9LFxcbiAgICB7IGFub255bW91czogZmFsc2UsIGlucHV0czogW10sIG5hbWU6IFwiUGF1c2VcIiwgdHlwZTogXCJldmVudFwiIH0sXFxuICAgIHtcXG4gICAgICBhbm9ueW1vdXM6IGZhbHNlLFxcbiAgICAgIGlucHV0czogW1xcbiAgICAgICAge1xcbiAgICAgICAgICBpbmRleGVkOiB0cnVlLFxcbiAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxcbiAgICAgICAgICBuYW1lOiBcIm5ld0FkZHJlc3NcIixcXG4gICAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcXG4gICAgICAgIH1cXG4gICAgICBdLFxcbiAgICAgIG5hbWU6IFwiUGF1c2VyQ2hhbmdlZFwiLFxcbiAgICAgIHR5cGU6IFwiZXZlbnRcIlxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgYW5vbnltb3VzOiBmYWxzZSxcXG4gICAgICBpbnB1dHM6IFtcXG4gICAgICAgIHtcXG4gICAgICAgICAgaW5kZXhlZDogdHJ1ZSxcXG4gICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcXG4gICAgICAgICAgbmFtZTogXCJuZXdSZXNjdWVyXCIsXFxuICAgICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXFxuICAgICAgICB9XFxuICAgICAgXSxcXG4gICAgICBuYW1lOiBcIlJlc2N1ZXJDaGFuZ2VkXCIsXFxuICAgICAgdHlwZTogXCJldmVudFwiXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICBhbm9ueW1vdXM6IGZhbHNlLFxcbiAgICAgIGlucHV0czogW1xcbiAgICAgICAgeyBpbmRleGVkOiB0cnVlLCBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcImZyb21cIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcXG4gICAgICAgIHsgaW5kZXhlZDogdHJ1ZSwgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJ0b1wiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxcbiAgICAgICAge1xcbiAgICAgICAgICBpbmRleGVkOiBmYWxzZSxcXG4gICAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcXG4gICAgICAgICAgbmFtZTogXCJ2YWx1ZVwiLFxcbiAgICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxcbiAgICAgICAgfVxcbiAgICAgIF0sXFxuICAgICAgbmFtZTogXCJUcmFuc2ZlclwiLFxcbiAgICAgIHR5cGU6IFwiZXZlbnRcIlxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgYW5vbnltb3VzOiBmYWxzZSxcXG4gICAgICBpbnB1dHM6IFtcXG4gICAgICAgIHtcXG4gICAgICAgICAgaW5kZXhlZDogdHJ1ZSxcXG4gICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcXG4gICAgICAgICAgbmFtZTogXCJfYWNjb3VudFwiLFxcbiAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxcbiAgICAgICAgfVxcbiAgICAgIF0sXFxuICAgICAgbmFtZTogXCJVbkJsYWNrbGlzdGVkXCIsXFxuICAgICAgdHlwZTogXCJldmVudFwiXFxuICAgIH0sXFxuICAgIHsgYW5vbnltb3VzOiBmYWxzZSwgaW5wdXRzOiBbXSwgbmFtZTogXCJVbnBhdXNlXCIsIHR5cGU6IFwiZXZlbnRcIiB9LFxcbiAgICB7XFxuICAgICAgaW5wdXRzOiBbXSxcXG4gICAgICBuYW1lOiBcIkNBTkNFTF9BVVRIT1JJWkFUSU9OX1RZUEVIQVNIXCIsXFxuICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJieXRlczMyXCIgfV0sXFxuICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcXG4gICAgICB0eXBlOiBcImZ1bmN0aW9uXCJcXG4gICAgfSxcXG4gICAge1xcbiAgICAgIGlucHV0czogW10sXFxuICAgICAgbmFtZTogXCJET01BSU5fU0VQQVJBVE9SXCIsXFxuICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJieXRlczMyXCIgfV0sXFxuICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcXG4gICAgICB0eXBlOiBcImZ1bmN0aW9uXCJcXG4gICAgfSxcXG4gICAge1xcbiAgICAgIGlucHV0czogW10sXFxuICAgICAgbmFtZTogXCJQRVJNSVRfVFlQRUhBU0hcIixcXG4gICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYnl0ZXMzMlwiLCBuYW1lOiBcIlwiLCB0eXBlOiBcImJ5dGVzMzJcIiB9XSxcXG4gICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxcbiAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgaW5wdXRzOiBbXSxcXG4gICAgICBuYW1lOiBcIlJFQ0VJVkVfV0lUSF9BVVRIT1JJWkFUSU9OX1RZUEVIQVNIXCIsXFxuICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJieXRlczMyXCIgfV0sXFxuICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcXG4gICAgICB0eXBlOiBcImZ1bmN0aW9uXCJcXG4gICAgfSxcXG4gICAge1xcbiAgICAgIGlucHV0czogW10sXFxuICAgICAgbmFtZTogXCJUUkFOU0ZFUl9XSVRIX0FVVEhPUklaQVRJT05fVFlQRUhBU0hcIixcXG4gICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYnl0ZXMzMlwiLCBuYW1lOiBcIlwiLCB0eXBlOiBcImJ5dGVzMzJcIiB9XSxcXG4gICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxcbiAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgaW5wdXRzOiBbXFxuICAgICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwib3duZXJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcXG4gICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJzcGVuZGVyXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH1cXG4gICAgICBdLFxcbiAgICAgIG5hbWU6IFwiYWxsb3dhbmNlXCIsXFxuICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJ1aW50MjU2XCIgfV0sXFxuICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcXG4gICAgICB0eXBlOiBcImZ1bmN0aW9uXCJcXG4gICAgfSxcXG4gICAge1xcbiAgICAgIGlucHV0czogW1xcbiAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcInNwZW5kZXJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcXG4gICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJ2YWx1ZVwiLCB0eXBlOiBcInVpbnQyNTZcIiB9XFxuICAgICAgXSxcXG4gICAgICBuYW1lOiBcImFwcHJvdmVcIixcXG4gICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYm9vbFwiLCBuYW1lOiBcIlwiLCB0eXBlOiBcImJvb2xcIiB9XSxcXG4gICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxcbiAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgaW5wdXRzOiBbXFxuICAgICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiYXV0aG9yaXplclwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxcbiAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYnl0ZXMzMlwiLCBuYW1lOiBcIm5vbmNlXCIsIHR5cGU6IFwiYnl0ZXMzMlwiIH1cXG4gICAgICBdLFxcbiAgICAgIG5hbWU6IFwiYXV0aG9yaXphdGlvblN0YXRlXCIsXFxuICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImJvb2xcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJib29sXCIgfV0sXFxuICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcXG4gICAgICB0eXBlOiBcImZ1bmN0aW9uXCJcXG4gICAgfSxcXG4gICAge1xcbiAgICAgIGlucHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJhY2NvdW50XCIsIHR5cGU6IFwiYWRkcmVzc1wiIH1dLFxcbiAgICAgIG5hbWU6IFwiYmFsYW5jZU9mXCIsXFxuICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJ1aW50MjU2XCIgfV0sXFxuICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcXG4gICAgICB0eXBlOiBcImZ1bmN0aW9uXCJcXG4gICAgfSxcXG4gICAge1xcbiAgICAgIGlucHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJfYWNjb3VudFwiLCB0eXBlOiBcImFkZHJlc3NcIiB9XSxcXG4gICAgICBuYW1lOiBcImJsYWNrbGlzdFwiLFxcbiAgICAgIG91dHB1dHM6IFtdLFxcbiAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXFxuICAgICAgdHlwZTogXCJmdW5jdGlvblwiXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICBpbnB1dHM6IFtdLFxcbiAgICAgIG5hbWU6IFwiYmxhY2tsaXN0ZXJcIixcXG4gICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcIlwiLCB0eXBlOiBcImFkZHJlc3NcIiB9XSxcXG4gICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxcbiAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgaW5wdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcIl9hbW91bnRcIiwgdHlwZTogXCJ1aW50MjU2XCIgfV0sXFxuICAgICAgbmFtZTogXCJidXJuXCIsXFxuICAgICAgb3V0cHV0czogW10sXFxuICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcXG4gICAgICB0eXBlOiBcImZ1bmN0aW9uXCJcXG4gICAgfSxcXG4gICAge1xcbiAgICAgIGlucHV0czogW1xcbiAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcImF1dGhvcml6ZXJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcXG4gICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIiwgbmFtZTogXCJub25jZVwiLCB0eXBlOiBcImJ5dGVzMzJcIiB9LFxcbiAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDhcIiwgbmFtZTogXCJ2XCIsIHR5cGU6IFwidWludDhcIiB9LFxcbiAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYnl0ZXMzMlwiLCBuYW1lOiBcInJcIiwgdHlwZTogXCJieXRlczMyXCIgfSxcXG4gICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIiwgbmFtZTogXCJzXCIsIHR5cGU6IFwiYnl0ZXMzMlwiIH1cXG4gICAgICBdLFxcbiAgICAgIG5hbWU6IFwiY2FuY2VsQXV0aG9yaXphdGlvblwiLFxcbiAgICAgIG91dHB1dHM6IFtdLFxcbiAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXFxuICAgICAgdHlwZTogXCJmdW5jdGlvblwiXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICBpbnB1dHM6IFtcXG4gICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJhdXRob3JpemVyXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXFxuICAgICAgICB7IGludGVybmFsVHlwZTogXCJieXRlczMyXCIsIG5hbWU6IFwibm9uY2VcIiwgdHlwZTogXCJieXRlczMyXCIgfSxcXG4gICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImJ5dGVzXCIsIG5hbWU6IFwic2lnbmF0dXJlXCIsIHR5cGU6IFwiYnl0ZXNcIiB9XFxuICAgICAgXSxcXG4gICAgICBuYW1lOiBcImNhbmNlbEF1dGhvcml6YXRpb25cIixcXG4gICAgICBvdXRwdXRzOiBbXSxcXG4gICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxcbiAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgaW5wdXRzOiBbXFxuICAgICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwibWludGVyXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXFxuICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwibWludGVyQWxsb3dlZEFtb3VudFwiLCB0eXBlOiBcInVpbnQyNTZcIiB9XFxuICAgICAgXSxcXG4gICAgICBuYW1lOiBcImNvbmZpZ3VyZU1pbnRlclwiLFxcbiAgICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJib29sXCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwiYm9vbFwiIH1dLFxcbiAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXFxuICAgICAgdHlwZTogXCJmdW5jdGlvblwiXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICBpbnB1dHM6IFtdLFxcbiAgICAgIG5hbWU6IFwiY3VycmVuY3lcIixcXG4gICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwic3RyaW5nXCIgfV0sXFxuICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcXG4gICAgICB0eXBlOiBcImZ1bmN0aW9uXCJcXG4gICAgfSxcXG4gICAge1xcbiAgICAgIGlucHV0czogW10sXFxuICAgICAgbmFtZTogXCJkZWNpbWFsc1wiLFxcbiAgICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJ1aW50OFwiLCBuYW1lOiBcIlwiLCB0eXBlOiBcInVpbnQ4XCIgfV0sXFxuICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcXG4gICAgICB0eXBlOiBcImZ1bmN0aW9uXCJcXG4gICAgfSxcXG4gICAge1xcbiAgICAgIGlucHV0czogW1xcbiAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcInNwZW5kZXJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcXG4gICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJkZWNyZW1lbnRcIiwgdHlwZTogXCJ1aW50MjU2XCIgfVxcbiAgICAgIF0sXFxuICAgICAgbmFtZTogXCJkZWNyZWFzZUFsbG93YW5jZVwiLFxcbiAgICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJib29sXCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwiYm9vbFwiIH1dLFxcbiAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXFxuICAgICAgdHlwZTogXCJmdW5jdGlvblwiXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICBpbnB1dHM6IFtcXG4gICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJzcGVuZGVyXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXFxuICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwiaW5jcmVtZW50XCIsIHR5cGU6IFwidWludDI1NlwiIH1cXG4gICAgICBdLFxcbiAgICAgIG5hbWU6IFwiaW5jcmVhc2VBbGxvd2FuY2VcIixcXG4gICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYm9vbFwiLCBuYW1lOiBcIlwiLCB0eXBlOiBcImJvb2xcIiB9XSxcXG4gICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxcbiAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgaW5wdXRzOiBbXFxuICAgICAgICB7IGludGVybmFsVHlwZTogXCJzdHJpbmdcIiwgbmFtZTogXCJ0b2tlbk5hbWVcIiwgdHlwZTogXCJzdHJpbmdcIiB9LFxcbiAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsIG5hbWU6IFwidG9rZW5TeW1ib2xcIiwgdHlwZTogXCJzdHJpbmdcIiB9LFxcbiAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsIG5hbWU6IFwidG9rZW5DdXJyZW5jeVwiLCB0eXBlOiBcInN0cmluZ1wiIH0sXFxuICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50OFwiLCBuYW1lOiBcInRva2VuRGVjaW1hbHNcIiwgdHlwZTogXCJ1aW50OFwiIH0sXFxuICAgICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwibmV3TWFzdGVyTWludGVyXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXFxuICAgICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwibmV3UGF1c2VyXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXFxuICAgICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwibmV3QmxhY2tsaXN0ZXJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcXG4gICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJuZXdPd25lclwiLCB0eXBlOiBcImFkZHJlc3NcIiB9XFxuICAgICAgXSxcXG4gICAgICBuYW1lOiBcImluaXRpYWxpemVcIixcXG4gICAgICBvdXRwdXRzOiBbXSxcXG4gICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxcbiAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgaW5wdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsIG5hbWU6IFwibmV3TmFtZVwiLCB0eXBlOiBcInN0cmluZ1wiIH1dLFxcbiAgICAgIG5hbWU6IFwiaW5pdGlhbGl6ZVYyXCIsXFxuICAgICAgb3V0cHV0czogW10sXFxuICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcXG4gICAgICB0eXBlOiBcImZ1bmN0aW9uXCJcXG4gICAgfSxcXG4gICAge1xcbiAgICAgIGlucHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJsb3N0QW5kRm91bmRcIiwgdHlwZTogXCJhZGRyZXNzXCIgfV0sXFxuICAgICAgbmFtZTogXCJpbml0aWFsaXplVjJfMVwiLFxcbiAgICAgIG91dHB1dHM6IFtdLFxcbiAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXFxuICAgICAgdHlwZTogXCJmdW5jdGlvblwiXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICBpbnB1dHM6IFtcXG4gICAgICAgIHtcXG4gICAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NbXVwiLFxcbiAgICAgICAgICBuYW1lOiBcImFjY291bnRzVG9CbGFja2xpc3RcIixcXG4gICAgICAgICAgdHlwZTogXCJhZGRyZXNzW11cIlxcbiAgICAgICAgfSxcXG4gICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInN0cmluZ1wiLCBuYW1lOiBcIm5ld1N5bWJvbFwiLCB0eXBlOiBcInN0cmluZ1wiIH1cXG4gICAgICBdLFxcbiAgICAgIG5hbWU6IFwiaW5pdGlhbGl6ZVYyXzJcIixcXG4gICAgICBvdXRwdXRzOiBbXSxcXG4gICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxcbiAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgaW5wdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcIl9hY2NvdW50XCIsIHR5cGU6IFwiYWRkcmVzc1wiIH1dLFxcbiAgICAgIG5hbWU6IFwiaXNCbGFja2xpc3RlZFwiLFxcbiAgICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJib29sXCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwiYm9vbFwiIH1dLFxcbiAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXFxuICAgICAgdHlwZTogXCJmdW5jdGlvblwiXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICBpbnB1dHM6IFt7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiYWNjb3VudFwiLCB0eXBlOiBcImFkZHJlc3NcIiB9XSxcXG4gICAgICBuYW1lOiBcImlzTWludGVyXCIsXFxuICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImJvb2xcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJib29sXCIgfV0sXFxuICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcXG4gICAgICB0eXBlOiBcImZ1bmN0aW9uXCJcXG4gICAgfSxcXG4gICAge1xcbiAgICAgIGlucHV0czogW10sXFxuICAgICAgbmFtZTogXCJtYXN0ZXJNaW50ZXJcIixcXG4gICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcIlwiLCB0eXBlOiBcImFkZHJlc3NcIiB9XSxcXG4gICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxcbiAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgaW5wdXRzOiBbXFxuICAgICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiX3RvXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXFxuICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwiX2Ftb3VudFwiLCB0eXBlOiBcInVpbnQyNTZcIiB9XFxuICAgICAgXSxcXG4gICAgICBuYW1lOiBcIm1pbnRcIixcXG4gICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYm9vbFwiLCBuYW1lOiBcIlwiLCB0eXBlOiBcImJvb2xcIiB9XSxcXG4gICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxcbiAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgaW5wdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcIm1pbnRlclwiLCB0eXBlOiBcImFkZHJlc3NcIiB9XSxcXG4gICAgICBuYW1lOiBcIm1pbnRlckFsbG93YW5jZVwiLFxcbiAgICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwidWludDI1NlwiIH1dLFxcbiAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXFxuICAgICAgdHlwZTogXCJmdW5jdGlvblwiXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICBpbnB1dHM6IFtdLFxcbiAgICAgIG5hbWU6IFwibmFtZVwiLFxcbiAgICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJzdHJpbmdcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJzdHJpbmdcIiB9XSxcXG4gICAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxcbiAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgaW5wdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcIm93bmVyXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH1dLFxcbiAgICAgIG5hbWU6IFwibm9uY2VzXCIsXFxuICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJ1aW50MjU2XCIgfV0sXFxuICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcXG4gICAgICB0eXBlOiBcImZ1bmN0aW9uXCJcXG4gICAgfSxcXG4gICAge1xcbiAgICAgIGlucHV0czogW10sXFxuICAgICAgbmFtZTogXCJvd25lclwiLFxcbiAgICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH1dLFxcbiAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXFxuICAgICAgdHlwZTogXCJmdW5jdGlvblwiXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICBpbnB1dHM6IFtdLFxcbiAgICAgIG5hbWU6IFwicGF1c2VcIixcXG4gICAgICBvdXRwdXRzOiBbXSxcXG4gICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxcbiAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgaW5wdXRzOiBbXSxcXG4gICAgICBuYW1lOiBcInBhdXNlZFwiLFxcbiAgICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJib29sXCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwiYm9vbFwiIH1dLFxcbiAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXFxuICAgICAgdHlwZTogXCJmdW5jdGlvblwiXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICBpbnB1dHM6IFtdLFxcbiAgICAgIG5hbWU6IFwicGF1c2VyXCIsXFxuICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfV0sXFxuICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcXG4gICAgICB0eXBlOiBcImZ1bmN0aW9uXCJcXG4gICAgfSxcXG4gICAge1xcbiAgICAgIGlucHV0czogW1xcbiAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcIm93bmVyXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXFxuICAgICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwic3BlbmRlclwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxcbiAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcInZhbHVlXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXFxuICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwiZGVhZGxpbmVcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcXG4gICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImJ5dGVzXCIsIG5hbWU6IFwic2lnbmF0dXJlXCIsIHR5cGU6IFwiYnl0ZXNcIiB9XFxuICAgICAgXSxcXG4gICAgICBuYW1lOiBcInBlcm1pdFwiLFxcbiAgICAgIG91dHB1dHM6IFtdLFxcbiAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXFxuICAgICAgdHlwZTogXCJmdW5jdGlvblwiXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICBpbnB1dHM6IFtcXG4gICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJvd25lclwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxcbiAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcInNwZW5kZXJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcXG4gICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJ2YWx1ZVwiLCB0eXBlOiBcInVpbnQyNTZcIiB9LFxcbiAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcImRlYWRsaW5lXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXFxuICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50OFwiLCBuYW1lOiBcInZcIiwgdHlwZTogXCJ1aW50OFwiIH0sXFxuICAgICAgICB7IGludGVybmFsVHlwZTogXCJieXRlczMyXCIsIG5hbWU6IFwiclwiLCB0eXBlOiBcImJ5dGVzMzJcIiB9LFxcbiAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYnl0ZXMzMlwiLCBuYW1lOiBcInNcIiwgdHlwZTogXCJieXRlczMyXCIgfVxcbiAgICAgIF0sXFxuICAgICAgbmFtZTogXCJwZXJtaXRcIixcXG4gICAgICBvdXRwdXRzOiBbXSxcXG4gICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxcbiAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgaW5wdXRzOiBbXFxuICAgICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiZnJvbVwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxcbiAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcInRvXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXFxuICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwidmFsdWVcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcXG4gICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJ2YWxpZEFmdGVyXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXFxuICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwidmFsaWRCZWZvcmVcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcXG4gICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIiwgbmFtZTogXCJub25jZVwiLCB0eXBlOiBcImJ5dGVzMzJcIiB9LFxcbiAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYnl0ZXNcIiwgbmFtZTogXCJzaWduYXR1cmVcIiwgdHlwZTogXCJieXRlc1wiIH1cXG4gICAgICBdLFxcbiAgICAgIG5hbWU6IFwicmVjZWl2ZVdpdGhBdXRob3JpemF0aW9uXCIsXFxuICAgICAgb3V0cHV0czogW10sXFxuICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcXG4gICAgICB0eXBlOiBcImZ1bmN0aW9uXCJcXG4gICAgfSxcXG4gICAge1xcbiAgICAgIGlucHV0czogW1xcbiAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcImZyb21cIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcXG4gICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJ0b1wiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxcbiAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcInZhbHVlXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXFxuICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwidmFsaWRBZnRlclwiLCB0eXBlOiBcInVpbnQyNTZcIiB9LFxcbiAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcInZhbGlkQmVmb3JlXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXFxuICAgICAgICB7IGludGVybmFsVHlwZTogXCJieXRlczMyXCIsIG5hbWU6IFwibm9uY2VcIiwgdHlwZTogXCJieXRlczMyXCIgfSxcXG4gICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQ4XCIsIG5hbWU6IFwidlwiLCB0eXBlOiBcInVpbnQ4XCIgfSxcXG4gICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIiwgbmFtZTogXCJyXCIsIHR5cGU6IFwiYnl0ZXMzMlwiIH0sXFxuICAgICAgICB7IGludGVybmFsVHlwZTogXCJieXRlczMyXCIsIG5hbWU6IFwic1wiLCB0eXBlOiBcImJ5dGVzMzJcIiB9XFxuICAgICAgXSxcXG4gICAgICBuYW1lOiBcInJlY2VpdmVXaXRoQXV0aG9yaXphdGlvblwiLFxcbiAgICAgIG91dHB1dHM6IFtdLFxcbiAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXFxuICAgICAgdHlwZTogXCJmdW5jdGlvblwiXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICBpbnB1dHM6IFt7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwibWludGVyXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH1dLFxcbiAgICAgIG5hbWU6IFwicmVtb3ZlTWludGVyXCIsXFxuICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImJvb2xcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJib29sXCIgfV0sXFxuICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcXG4gICAgICB0eXBlOiBcImZ1bmN0aW9uXCJcXG4gICAgfSxcXG4gICAge1xcbiAgICAgIGlucHV0czogW1xcbiAgICAgICAge1xcbiAgICAgICAgICBpbnRlcm5hbFR5cGU6IFwiY29udHJhY3QgSUVSQzIwXCIsXFxuICAgICAgICAgIG5hbWU6IFwidG9rZW5Db250cmFjdFwiLFxcbiAgICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxcbiAgICAgICAgfSxcXG4gICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJ0b1wiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxcbiAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcImFtb3VudFwiLCB0eXBlOiBcInVpbnQyNTZcIiB9XFxuICAgICAgXSxcXG4gICAgICBuYW1lOiBcInJlc2N1ZUVSQzIwXCIsXFxuICAgICAgb3V0cHV0czogW10sXFxuICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcXG4gICAgICB0eXBlOiBcImZ1bmN0aW9uXCJcXG4gICAgfSxcXG4gICAge1xcbiAgICAgIGlucHV0czogW10sXFxuICAgICAgbmFtZTogXCJyZXNjdWVyXCIsXFxuICAgICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfV0sXFxuICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcXG4gICAgICB0eXBlOiBcImZ1bmN0aW9uXCJcXG4gICAgfSxcXG4gICAge1xcbiAgICAgIGlucHV0czogW10sXFxuICAgICAgbmFtZTogXCJzeW1ib2xcIixcXG4gICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwic3RyaW5nXCIgfV0sXFxuICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcXG4gICAgICB0eXBlOiBcImZ1bmN0aW9uXCJcXG4gICAgfSxcXG4gICAge1xcbiAgICAgIGlucHV0czogW10sXFxuICAgICAgbmFtZTogXCJ0b3RhbFN1cHBseVwiLFxcbiAgICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwidWludDI1NlwiIH1dLFxcbiAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXFxuICAgICAgdHlwZTogXCJmdW5jdGlvblwiXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICBpbnB1dHM6IFtcXG4gICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJ0b1wiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxcbiAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcInZhbHVlXCIsIHR5cGU6IFwidWludDI1NlwiIH1cXG4gICAgICBdLFxcbiAgICAgIG5hbWU6IFwidHJhbnNmZXJcIixcXG4gICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYm9vbFwiLCBuYW1lOiBcIlwiLCB0eXBlOiBcImJvb2xcIiB9XSxcXG4gICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxcbiAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgaW5wdXRzOiBbXFxuICAgICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiZnJvbVwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxcbiAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcInRvXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXFxuICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwidmFsdWVcIiwgdHlwZTogXCJ1aW50MjU2XCIgfVxcbiAgICAgIF0sXFxuICAgICAgbmFtZTogXCJ0cmFuc2ZlckZyb21cIixcXG4gICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYm9vbFwiLCBuYW1lOiBcIlwiLCB0eXBlOiBcImJvb2xcIiB9XSxcXG4gICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxcbiAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgaW5wdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcIm5ld093bmVyXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH1dLFxcbiAgICAgIG5hbWU6IFwidHJhbnNmZXJPd25lcnNoaXBcIixcXG4gICAgICBvdXRwdXRzOiBbXSxcXG4gICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxcbiAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgaW5wdXRzOiBbXFxuICAgICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiZnJvbVwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxcbiAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcInRvXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXFxuICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwidmFsdWVcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcXG4gICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJ2YWxpZEFmdGVyXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXFxuICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwidmFsaWRCZWZvcmVcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcXG4gICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIiwgbmFtZTogXCJub25jZVwiLCB0eXBlOiBcImJ5dGVzMzJcIiB9LFxcbiAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYnl0ZXNcIiwgbmFtZTogXCJzaWduYXR1cmVcIiwgdHlwZTogXCJieXRlc1wiIH1cXG4gICAgICBdLFxcbiAgICAgIG5hbWU6IFwidHJhbnNmZXJXaXRoQXV0aG9yaXphdGlvblwiLFxcbiAgICAgIG91dHB1dHM6IFtdLFxcbiAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXFxuICAgICAgdHlwZTogXCJmdW5jdGlvblwiXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICBpbnB1dHM6IFtcXG4gICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJmcm9tXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXFxuICAgICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwidG9cIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcXG4gICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJ2YWx1ZVwiLCB0eXBlOiBcInVpbnQyNTZcIiB9LFxcbiAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcInZhbGlkQWZ0ZXJcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcXG4gICAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJ2YWxpZEJlZm9yZVwiLCB0eXBlOiBcInVpbnQyNTZcIiB9LFxcbiAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYnl0ZXMzMlwiLCBuYW1lOiBcIm5vbmNlXCIsIHR5cGU6IFwiYnl0ZXMzMlwiIH0sXFxuICAgICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50OFwiLCBuYW1lOiBcInZcIiwgdHlwZTogXCJ1aW50OFwiIH0sXFxuICAgICAgICB7IGludGVybmFsVHlwZTogXCJieXRlczMyXCIsIG5hbWU6IFwiclwiLCB0eXBlOiBcImJ5dGVzMzJcIiB9LFxcbiAgICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYnl0ZXMzMlwiLCBuYW1lOiBcInNcIiwgdHlwZTogXCJieXRlczMyXCIgfVxcbiAgICAgIF0sXFxuICAgICAgbmFtZTogXCJ0cmFuc2ZlcldpdGhBdXRob3JpemF0aW9uXCIsXFxuICAgICAgb3V0cHV0czogW10sXFxuICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcXG4gICAgICB0eXBlOiBcImZ1bmN0aW9uXCJcXG4gICAgfSxcXG4gICAge1xcbiAgICAgIGlucHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJfYWNjb3VudFwiLCB0eXBlOiBcImFkZHJlc3NcIiB9XSxcXG4gICAgICBuYW1lOiBcInVuQmxhY2tsaXN0XCIsXFxuICAgICAgb3V0cHV0czogW10sXFxuICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcXG4gICAgICB0eXBlOiBcImZ1bmN0aW9uXCJcXG4gICAgfSxcXG4gICAge1xcbiAgICAgIGlucHV0czogW10sXFxuICAgICAgbmFtZTogXCJ1bnBhdXNlXCIsXFxuICAgICAgb3V0cHV0czogW10sXFxuICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcXG4gICAgICB0eXBlOiBcImZ1bmN0aW9uXCJcXG4gICAgfSxcXG4gICAge1xcbiAgICAgIGlucHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJfbmV3QmxhY2tsaXN0ZXJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfV0sXFxuICAgICAgbmFtZTogXCJ1cGRhdGVCbGFja2xpc3RlclwiLFxcbiAgICAgIG91dHB1dHM6IFtdLFxcbiAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXFxuICAgICAgdHlwZTogXCJmdW5jdGlvblwiXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICBpbnB1dHM6IFt7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiX25ld01hc3Rlck1pbnRlclwiLCB0eXBlOiBcImFkZHJlc3NcIiB9XSxcXG4gICAgICBuYW1lOiBcInVwZGF0ZU1hc3Rlck1pbnRlclwiLFxcbiAgICAgIG91dHB1dHM6IFtdLFxcbiAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXFxuICAgICAgdHlwZTogXCJmdW5jdGlvblwiXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICBpbnB1dHM6IFt7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiX25ld1BhdXNlclwiLCB0eXBlOiBcImFkZHJlc3NcIiB9XSxcXG4gICAgICBuYW1lOiBcInVwZGF0ZVBhdXNlclwiLFxcbiAgICAgIG91dHB1dHM6IFtdLFxcbiAgICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXFxuICAgICAgdHlwZTogXCJmdW5jdGlvblwiXFxuICAgIH0sXFxuICAgIHtcXG4gICAgICBpbnB1dHM6IFt7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwibmV3UmVzY3VlclwiLCB0eXBlOiBcImFkZHJlc3NcIiB9XSxcXG4gICAgICBuYW1lOiBcInVwZGF0ZVJlc2N1ZXJcIixcXG4gICAgICBvdXRwdXRzOiBbXSxcXG4gICAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxcbiAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxcbiAgICB9LFxcbiAgICB7XFxuICAgICAgaW5wdXRzOiBbXSxcXG4gICAgICBuYW1lOiBcInZlcnNpb25cIixcXG4gICAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwic3RyaW5nXCIgfV0sXFxuICAgICAgc3RhdGVNdXRhYmlsaXR5OiBcInB1cmVcIixcXG4gICAgICB0eXBlOiBcImZ1bmN0aW9uXCJcXG4gICAgfVxcbiAgXTtcXG5cXG4gIC8vIHNyYy90eXBlcy9zaGFyZWQvZXZtL3dhbGxldC50c1xcbiAgZnVuY3Rpb24gaXNTaWduZXJXYWxsZXQod2FsbGV0KSB7XFxuICAgIHJldHVybiBcImNoYWluXCIgaW4gd2FsbGV0ICYmIFwidHJhbnNwb3J0XCIgaW4gd2FsbGV0O1xcbiAgfVxcbiAgZnVuY3Rpb24gaXNBY2NvdW50KHdhbGxldCkge1xcbiAgICByZXR1cm4gXCJhZGRyZXNzXCIgaW4gd2FsbGV0ICYmIFwidHlwZVwiIGluIHdhbGxldDtcXG4gIH1cXG5cXG4gIC8vIHNyYy9zaGFyZWQvYmFzZTY0LnRzXFxuICBmdW5jdGlvbiBzYWZlQmFzZTY0RW5jb2RlKGRhdGEpIHtcXG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBnbG9iYWxUaGlzLmJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xcbiAgICAgIHJldHVybiBnbG9iYWxUaGlzLmJ0b2EoZGF0YSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGRhdGEpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xcbiAgfVxcblxcbiAgLy8gLi4vLi4vLi4vZXhhbXBsZXMvdHlwZXNjcmlwdC9ub2RlX21vZHVsZXMvLnBucG0vem9kQDMuMjQuMy9ub2RlX21vZHVsZXMvem9kL2xpYi9pbmRleC5tanNcXG4gIHZhciB1dGlsO1xcbiAgKGZ1bmN0aW9uKHV0aWwyKSB7XFxuICAgIHV0aWwyLmFzc2VydEVxdWFsID0gKHZhbCkgPT4gdmFsO1xcbiAgICBmdW5jdGlvbiBhc3NlcnRJcyhfYXJnKSB7XFxuICAgIH1cXG4gICAgdXRpbDIuYXNzZXJ0SXMgPSBhc3NlcnRJcztcXG4gICAgZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoX3gpIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcXG4gICAgfVxcbiAgICB1dGlsMi5hc3NlcnROZXZlciA9IGFzc2VydE5ldmVyO1xcbiAgICB1dGlsMi5hcnJheVRvRW51bSA9IChpdGVtcykgPT4ge1xcbiAgICAgIGNvbnN0IG9iaiA9IHt9O1xcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xcbiAgICAgICAgb2JqW2l0ZW1dID0gaXRlbTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIG9iajtcXG4gICAgfTtcXG4gICAgdXRpbDIuZ2V0VmFsaWRFbnVtVmFsdWVzID0gKG9iaikgPT4ge1xcbiAgICAgIGNvbnN0IHZhbGlkS2V5cyA9IHV0aWwyLm9iamVjdEtleXMob2JqKS5maWx0ZXIoKGspID0+IHR5cGVvZiBvYmpbb2JqW2tdXSAhPT0gXCJudW1iZXJcIik7XFxuICAgICAgY29uc3QgZmlsdGVyZWQgPSB7fTtcXG4gICAgICBmb3IgKGNvbnN0IGsgb2YgdmFsaWRLZXlzKSB7XFxuICAgICAgICBmaWx0ZXJlZFtrXSA9IG9ialtrXTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHV0aWwyLm9iamVjdFZhbHVlcyhmaWx0ZXJlZCk7XFxuICAgIH07XFxuICAgIHV0aWwyLm9iamVjdFZhbHVlcyA9IChvYmopID0+IHtcXG4gICAgICByZXR1cm4gdXRpbDIub2JqZWN0S2V5cyhvYmopLm1hcChmdW5jdGlvbihlKSB7XFxuICAgICAgICByZXR1cm4gb2JqW2VdO1xcbiAgICAgIH0pO1xcbiAgICB9O1xcbiAgICB1dGlsMi5vYmplY3RLZXlzID0gdHlwZW9mIE9iamVjdC5rZXlzID09PSBcImZ1bmN0aW9uXCIgPyAob2JqKSA9PiBPYmplY3Qua2V5cyhvYmopIDogKG9iamVjdCkgPT4ge1xcbiAgICAgIGNvbnN0IGtleXMgPSBbXTtcXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XFxuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4ga2V5cztcXG4gICAgfTtcXG4gICAgdXRpbDIuZmluZCA9IChhcnIsIGNoZWNrZXIpID0+IHtcXG4gICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKSB7XFxuICAgICAgICBpZiAoY2hlY2tlcihpdGVtKSlcXG4gICAgICAgICAgcmV0dXJuIGl0ZW07XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB2b2lkIDA7XFxuICAgIH07XFxuICAgIHV0aWwyLmlzSW50ZWdlciA9IHR5cGVvZiBOdW1iZXIuaXNJbnRlZ2VyID09PSBcImZ1bmN0aW9uXCIgPyAodmFsKSA9PiBOdW1iZXIuaXNJbnRlZ2VyKHZhbCkgOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKHZhbCkgJiYgTWF0aC5mbG9vcih2YWwpID09PSB2YWw7XFxuICAgIGZ1bmN0aW9uIGpvaW5WYWx1ZXMoYXJyYXksIHNlcGFyYXRvciA9IFwiIHwgXCIpIHtcXG4gICAgICByZXR1cm4gYXJyYXkubWFwKCh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgPyBgXFwnJHt2YWx9XFwnYCA6IHZhbCkuam9pbihzZXBhcmF0b3IpO1xcbiAgICB9XFxuICAgIHV0aWwyLmpvaW5WYWx1ZXMgPSBqb2luVmFsdWVzO1xcbiAgICB1dGlsMi5qc29uU3RyaW5naWZ5UmVwbGFjZXIgPSAoXywgdmFsdWUpID0+IHtcXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XFxuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICB9O1xcbiAgfSkodXRpbCB8fCAodXRpbCA9IHt9KSk7XFxuICB2YXIgb2JqZWN0VXRpbDtcXG4gIChmdW5jdGlvbihvYmplY3RVdGlsMikge1xcbiAgICBvYmplY3RVdGlsMi5tZXJnZVNoYXBlcyA9IChmaXJzdCwgc2Vjb25kKSA9PiB7XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIC4uLmZpcnN0LFxcbiAgICAgICAgLi4uc2Vjb25kXFxuICAgICAgICAvLyBzZWNvbmQgb3ZlcndyaXRlcyBmaXJzdFxcbiAgICAgIH07XFxuICAgIH07XFxuICB9KShvYmplY3RVdGlsIHx8IChvYmplY3RVdGlsID0ge30pKTtcXG4gIHZhciBab2RQYXJzZWRUeXBlID0gdXRpbC5hcnJheVRvRW51bShbXFxuICAgIFwic3RyaW5nXCIsXFxuICAgIFwibmFuXCIsXFxuICAgIFwibnVtYmVyXCIsXFxuICAgIFwiaW50ZWdlclwiLFxcbiAgICBcImZsb2F0XCIsXFxuICAgIFwiYm9vbGVhblwiLFxcbiAgICBcImRhdGVcIixcXG4gICAgXCJiaWdpbnRcIixcXG4gICAgXCJzeW1ib2xcIixcXG4gICAgXCJmdW5jdGlvblwiLFxcbiAgICBcInVuZGVmaW5lZFwiLFxcbiAgICBcIm51bGxcIixcXG4gICAgXCJhcnJheVwiLFxcbiAgICBcIm9iamVjdFwiLFxcbiAgICBcInVua25vd25cIixcXG4gICAgXCJwcm9taXNlXCIsXFxuICAgIFwidm9pZFwiLFxcbiAgICBcIm5ldmVyXCIsXFxuICAgIFwibWFwXCIsXFxuICAgIFwic2V0XCJcXG4gIF0pO1xcbiAgdmFyIGdldFBhcnNlZFR5cGUgPSAoZGF0YSkgPT4ge1xcbiAgICBjb25zdCB0ID0gdHlwZW9mIGRhdGE7XFxuICAgIHN3aXRjaCAodCkge1xcbiAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcXG4gICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZDtcXG4gICAgICBjYXNlIFwic3RyaW5nXCI6XFxuICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zdHJpbmc7XFxuICAgICAgY2FzZSBcIm51bWJlclwiOlxcbiAgICAgICAgcmV0dXJuIGlzTmFOKGRhdGEpID8gWm9kUGFyc2VkVHlwZS5uYW4gOiBab2RQYXJzZWRUeXBlLm51bWJlcjtcXG4gICAgICBjYXNlIFwiYm9vbGVhblwiOlxcbiAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYm9vbGVhbjtcXG4gICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcXG4gICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uO1xcbiAgICAgIGNhc2UgXCJiaWdpbnRcIjpcXG4gICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmJpZ2ludDtcXG4gICAgICBjYXNlIFwic3ltYm9sXCI6XFxuICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zeW1ib2w7XFxuICAgICAgY2FzZSBcIm9iamVjdFwiOlxcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcXG4gICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYXJyYXk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xcbiAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5udWxsO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGRhdGEudGhlbiAmJiB0eXBlb2YgZGF0YS50aGVuID09PSBcImZ1bmN0aW9uXCIgJiYgZGF0YS5jYXRjaCAmJiB0eXBlb2YgZGF0YS5jYXRjaCA9PT0gXCJmdW5jdGlvblwiKSB7XFxuICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnByb21pc2U7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodHlwZW9mIE1hcCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgTWFwKSB7XFxuICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm1hcDtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0eXBlb2YgU2V0ICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBTZXQpIHtcXG4gICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc2V0O1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHR5cGVvZiBEYXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBEYXRlKSB7XFxuICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmRhdGU7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5vYmplY3Q7XFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnVua25vd247XFxuICAgIH1cXG4gIH07XFxuICB2YXIgWm9kSXNzdWVDb2RlID0gdXRpbC5hcnJheVRvRW51bShbXFxuICAgIFwiaW52YWxpZF90eXBlXCIsXFxuICAgIFwiaW52YWxpZF9saXRlcmFsXCIsXFxuICAgIFwiY3VzdG9tXCIsXFxuICAgIFwiaW52YWxpZF91bmlvblwiLFxcbiAgICBcImludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvclwiLFxcbiAgICBcImludmFsaWRfZW51bV92YWx1ZVwiLFxcbiAgICBcInVucmVjb2duaXplZF9rZXlzXCIsXFxuICAgIFwiaW52YWxpZF9hcmd1bWVudHNcIixcXG4gICAgXCJpbnZhbGlkX3JldHVybl90eXBlXCIsXFxuICAgIFwiaW52YWxpZF9kYXRlXCIsXFxuICAgIFwiaW52YWxpZF9zdHJpbmdcIixcXG4gICAgXCJ0b29fc21hbGxcIixcXG4gICAgXCJ0b29fYmlnXCIsXFxuICAgIFwiaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXNcIixcXG4gICAgXCJub3RfbXVsdGlwbGVfb2ZcIixcXG4gICAgXCJub3RfZmluaXRlXCJcXG4gIF0pO1xcbiAgdmFyIHF1b3RlbGVzc0pzb24gPSAob2JqKSA9PiB7XFxuICAgIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeShvYmosIG51bGwsIDIpO1xcbiAgICByZXR1cm4ganNvbi5yZXBsYWNlKC9cIihbXlwiXSspXCI6L2csIFwiJDE6XCIpO1xcbiAgfTtcXG4gIHZhciBab2RFcnJvciA9IGNsYXNzIF9ab2RFcnJvciBleHRlbmRzIEVycm9yIHtcXG4gICAgZ2V0IGVycm9ycygpIHtcXG4gICAgICByZXR1cm4gdGhpcy5pc3N1ZXM7XFxuICAgIH1cXG4gICAgY29uc3RydWN0b3IoaXNzdWVzKSB7XFxuICAgICAgc3VwZXIoKTtcXG4gICAgICB0aGlzLmlzc3VlcyA9IFtdO1xcbiAgICAgIHRoaXMuYWRkSXNzdWUgPSAoc3ViKSA9PiB7XFxuICAgICAgICB0aGlzLmlzc3VlcyA9IFsuLi50aGlzLmlzc3Vlcywgc3ViXTtcXG4gICAgICB9O1xcbiAgICAgIHRoaXMuYWRkSXNzdWVzID0gKHN1YnMgPSBbXSkgPT4ge1xcbiAgICAgICAgdGhpcy5pc3N1ZXMgPSBbLi4udGhpcy5pc3N1ZXMsIC4uLnN1YnNdO1xcbiAgICAgIH07XFxuICAgICAgY29uc3QgYWN0dWFsUHJvdG8gPSBuZXcudGFyZ2V0LnByb3RvdHlwZTtcXG4gICAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XFxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgYWN0dWFsUHJvdG8pO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IGFjdHVhbFByb3RvO1xcbiAgICAgIH1cXG4gICAgICB0aGlzLm5hbWUgPSBcIlpvZEVycm9yXCI7XFxuICAgICAgdGhpcy5pc3N1ZXMgPSBpc3N1ZXM7XFxuICAgIH1cXG4gICAgZm9ybWF0KF9tYXBwZXIpIHtcXG4gICAgICBjb25zdCBtYXBwZXIgPSBfbWFwcGVyIHx8IGZ1bmN0aW9uKGlzc3VlKSB7XFxuICAgICAgICByZXR1cm4gaXNzdWUubWVzc2FnZTtcXG4gICAgICB9O1xcbiAgICAgIGNvbnN0IGZpZWxkRXJyb3JzID0geyBfZXJyb3JzOiBbXSB9O1xcbiAgICAgIGNvbnN0IHByb2Nlc3NFcnJvciA9IChlcnJvcikgPT4ge1xcbiAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBlcnJvci5pc3N1ZXMpIHtcXG4gICAgICAgICAgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF91bmlvblwiKSB7XFxuICAgICAgICAgICAgaXNzdWUudW5pb25FcnJvcnMubWFwKHByb2Nlc3NFcnJvcik7XFxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX3JldHVybl90eXBlXCIpIHtcXG4gICAgICAgICAgICBwcm9jZXNzRXJyb3IoaXNzdWUucmV0dXJuVHlwZUVycm9yKTtcXG4gICAgICAgICAgfSBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfYXJndW1lbnRzXCIpIHtcXG4gICAgICAgICAgICBwcm9jZXNzRXJyb3IoaXNzdWUuYXJndW1lbnRzRXJyb3IpO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzc3VlLnBhdGgubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICAgICAgZmllbGRFcnJvcnMuX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGxldCBjdXJyID0gZmllbGRFcnJvcnM7XFxuICAgICAgICAgICAgbGV0IGkgPSAwO1xcbiAgICAgICAgICAgIHdoaWxlIChpIDwgaXNzdWUucGF0aC5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgIGNvbnN0IGVsID0gaXNzdWUucGF0aFtpXTtcXG4gICAgICAgICAgICAgIGNvbnN0IHRlcm1pbmFsID0gaSA9PT0gaXNzdWUucGF0aC5sZW5ndGggLSAxO1xcbiAgICAgICAgICAgICAgaWYgKCF0ZXJtaW5hbCkge1xcbiAgICAgICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcXG4gICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xcbiAgICAgICAgICAgICAgICBjdXJyW2VsXS5fZXJyb3JzLnB1c2gobWFwcGVyKGlzc3VlKSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICBjdXJyID0gY3VycltlbF07XFxuICAgICAgICAgICAgICBpKys7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgICBwcm9jZXNzRXJyb3IodGhpcyk7XFxuICAgICAgcmV0dXJuIGZpZWxkRXJyb3JzO1xcbiAgICB9XFxuICAgIHN0YXRpYyBhc3NlcnQodmFsdWUpIHtcXG4gICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIF9ab2RFcnJvcikpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm90IGEgWm9kRXJyb3I6ICR7dmFsdWV9YCk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHRvU3RyaW5nKCkge1xcbiAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XFxuICAgIH1cXG4gICAgZ2V0IG1lc3NhZ2UoKSB7XFxuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuaXNzdWVzLCB1dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlciwgMik7XFxuICAgIH1cXG4gICAgZ2V0IGlzRW1wdHkoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuaXNzdWVzLmxlbmd0aCA9PT0gMDtcXG4gICAgfVxcbiAgICBmbGF0dGVuKG1hcHBlciA9IChpc3N1ZSkgPT4gaXNzdWUubWVzc2FnZSkge1xcbiAgICAgIGNvbnN0IGZpZWxkRXJyb3JzID0ge307XFxuICAgICAgY29uc3QgZm9ybUVycm9ycyA9IFtdO1xcbiAgICAgIGZvciAoY29uc3Qgc3ViIG9mIHRoaXMuaXNzdWVzKSB7XFxuICAgICAgICBpZiAoc3ViLnBhdGgubGVuZ3RoID4gMCkge1xcbiAgICAgICAgICBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0gPSBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0gfHwgW107XFxuICAgICAgICAgIGZpZWxkRXJyb3JzW3N1Yi5wYXRoWzBdXS5wdXNoKG1hcHBlcihzdWIpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGZvcm1FcnJvcnMucHVzaChtYXBwZXIoc3ViKSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB7IGZvcm1FcnJvcnMsIGZpZWxkRXJyb3JzIH07XFxuICAgIH1cXG4gICAgZ2V0IGZvcm1FcnJvcnMoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZmxhdHRlbigpO1xcbiAgICB9XFxuICB9O1xcbiAgWm9kRXJyb3IuY3JlYXRlID0gKGlzc3VlcykgPT4ge1xcbiAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihpc3N1ZXMpO1xcbiAgICByZXR1cm4gZXJyb3I7XFxuICB9O1xcbiAgdmFyIGVycm9yTWFwID0gKGlzc3VlLCBfY3R4KSA9PiB7XFxuICAgIGxldCBtZXNzYWdlO1xcbiAgICBzd2l0Y2ggKGlzc3VlLmNvZGUpIHtcXG4gICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGU6XFxuICAgICAgICBpZiAoaXNzdWUucmVjZWl2ZWQgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XFxuICAgICAgICAgIG1lc3NhZ2UgPSBcIlJlcXVpcmVkXCI7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBtZXNzYWdlID0gYEV4cGVjdGVkICR7aXNzdWUuZXhwZWN0ZWR9LCByZWNlaXZlZCAke2lzc3VlLnJlY2VpdmVkfWA7XFxuICAgICAgICB9XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWw6XFxuICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgbGl0ZXJhbCB2YWx1ZSwgZXhwZWN0ZWQgJHtKU09OLnN0cmluZ2lmeShpc3N1ZS5leHBlY3RlZCwgdXRpbC5qc29uU3RyaW5naWZ5UmVwbGFjZXIpfWA7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlIFpvZElzc3VlQ29kZS51bnJlY29nbml6ZWRfa2V5czpcXG4gICAgICAgIG1lc3NhZ2UgPSBgVW5yZWNvZ25pemVkIGtleShzKSBpbiBvYmplY3Q6ICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLmtleXMsIFwiLCBcIil9YDtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb246XFxuICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXRgO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yOlxcbiAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRpc2NyaW1pbmF0b3IgdmFsdWUuIEV4cGVjdGVkICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLm9wdGlvbnMpfWA7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWU6XFxuICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZW51bSB2YWx1ZS4gRXhwZWN0ZWQgJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUub3B0aW9ucyl9LCByZWNlaXZlZCBcXCcke2lzc3VlLnJlY2VpdmVkfVxcJ2A7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2FyZ3VtZW50czpcXG4gICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBmdW5jdGlvbiBhcmd1bWVudHNgO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9yZXR1cm5fdHlwZTpcXG4gICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBmdW5jdGlvbiByZXR1cm4gdHlwZWA7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2RhdGU6XFxuICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZGF0ZWA7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZzpcXG4gICAgICAgIGlmICh0eXBlb2YgaXNzdWUudmFsaWRhdGlvbiA9PT0gXCJvYmplY3RcIikge1xcbiAgICAgICAgICBpZiAoXCJpbmNsdWRlc1wiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcXG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXQ6IG11c3QgaW5jbHVkZSBcIiR7aXNzdWUudmFsaWRhdGlvbi5pbmNsdWRlc31cImA7XFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpc3N1ZS52YWxpZGF0aW9uLnBvc2l0aW9uID09PSBcIm51bWJlclwiKSB7XFxuICAgICAgICAgICAgICBtZXNzYWdlID0gYCR7bWVzc2FnZX0gYXQgb25lIG9yIG1vcmUgcG9zaXRpb25zIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAke2lzc3VlLnZhbGlkYXRpb24ucG9zaXRpb259YDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0gZWxzZSBpZiAoXCJzdGFydHNXaXRoXCIgaW4gaXNzdWUudmFsaWRhdGlvbikge1xcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBzdGFydCB3aXRoIFwiJHtpc3N1ZS52YWxpZGF0aW9uLnN0YXJ0c1dpdGh9XCJgO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKFwiZW5kc1dpdGhcIiBpbiBpc3N1ZS52YWxpZGF0aW9uKSB7XFxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IGVuZCB3aXRoIFwiJHtpc3N1ZS52YWxpZGF0aW9uLmVuZHNXaXRofVwiYDtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGlzc3VlLnZhbGlkYXRpb24pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2UgaWYgKGlzc3VlLnZhbGlkYXRpb24gIT09IFwicmVnZXhcIikge1xcbiAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgJHtpc3N1ZS52YWxpZGF0aW9ufWA7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkXCI7XFxuICAgICAgICB9XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlIFpvZElzc3VlQ29kZS50b29fc21hbGw6XFxuICAgICAgICBpZiAoaXNzdWUudHlwZSA9PT0gXCJhcnJheVwiKVxcbiAgICAgICAgICBtZXNzYWdlID0gYEFycmF5IG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gXCJleGFjdGx5XCIgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbGVhc3RgIDogYG1vcmUgdGhhbmB9ICR7aXNzdWUubWluaW11bX0gZWxlbWVudChzKWA7XFxuICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcInN0cmluZ1wiKVxcbiAgICAgICAgICBtZXNzYWdlID0gYFN0cmluZyBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IFwiZXhhY3RseVwiIDogaXNzdWUuaW5jbHVzaXZlID8gYGF0IGxlYXN0YCA6IGBvdmVyYH0gJHtpc3N1ZS5taW5pbXVtfSBjaGFyYWN0ZXIocylgO1xcbiAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJudW1iZXJcIilcXG4gICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHkgZXF1YWwgdG8gYCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYCA6IGBncmVhdGVyIHRoYW4gYH0ke2lzc3VlLm1pbmltdW19YDtcXG4gICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiZGF0ZVwiKVxcbiAgICAgICAgICBtZXNzYWdlID0gYERhdGUgbXVzdCBiZSAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHkgZXF1YWwgdG8gYCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYCA6IGBncmVhdGVyIHRoYW4gYH0ke25ldyBEYXRlKE51bWJlcihpc3N1ZS5taW5pbXVtKSl9YDtcXG4gICAgICAgIGVsc2VcXG4gICAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZCBpbnB1dFwiO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSBab2RJc3N1ZUNvZGUudG9vX2JpZzpcXG4gICAgICAgIGlmIChpc3N1ZS50eXBlID09PSBcImFycmF5XCIpXFxuICAgICAgICAgIG1lc3NhZ2UgPSBgQXJyYXkgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbW9zdGAgOiBgbGVzcyB0aGFuYH0gJHtpc3N1ZS5tYXhpbXVtfSBlbGVtZW50KHMpYDtcXG4gICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwic3RyaW5nXCIpXFxuICAgICAgICAgIG1lc3NhZ2UgPSBgU3RyaW5nIG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHlgIDogaXNzdWUuaW5jbHVzaXZlID8gYGF0IG1vc3RgIDogYHVuZGVyYH0gJHtpc3N1ZS5tYXhpbXVtfSBjaGFyYWN0ZXIocylgO1xcbiAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJudW1iZXJcIilcXG4gICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHlgIDogaXNzdWUuaW5jbHVzaXZlID8gYGxlc3MgdGhhbiBvciBlcXVhbCB0b2AgOiBgbGVzcyB0aGFuYH0gJHtpc3N1ZS5tYXhpbXVtfWA7XFxuICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcImJpZ2ludFwiKVxcbiAgICAgICAgICBtZXNzYWdlID0gYEJpZ0ludCBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgbGVzcyB0aGFuIG9yIGVxdWFsIHRvYCA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19YDtcXG4gICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiZGF0ZVwiKVxcbiAgICAgICAgICBtZXNzYWdlID0gYERhdGUgbXVzdCBiZSAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHlgIDogaXNzdWUuaW5jbHVzaXZlID8gYHNtYWxsZXIgdGhhbiBvciBlcXVhbCB0b2AgOiBgc21hbGxlciB0aGFuYH0gJHtuZXcgRGF0ZShOdW1iZXIoaXNzdWUubWF4aW11bSkpfWA7XFxuICAgICAgICBlbHNlXFxuICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWQgaW5wdXRcIjtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmN1c3RvbTpcXG4gICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dGA7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2ludGVyc2VjdGlvbl90eXBlczpcXG4gICAgICAgIG1lc3NhZ2UgPSBgSW50ZXJzZWN0aW9uIHJlc3VsdHMgY291bGQgbm90IGJlIG1lcmdlZGA7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlIFpvZElzc3VlQ29kZS5ub3RfbXVsdGlwbGVfb2Y6XFxuICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgJHtpc3N1ZS5tdWx0aXBsZU9mfWA7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlIFpvZElzc3VlQ29kZS5ub3RfZmluaXRlOlxcbiAgICAgICAgbWVzc2FnZSA9IFwiTnVtYmVyIG11c3QgYmUgZmluaXRlXCI7XFxuICAgICAgICBicmVhaztcXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgbWVzc2FnZSA9IF9jdHguZGVmYXVsdEVycm9yO1xcbiAgICAgICAgdXRpbC5hc3NlcnROZXZlcihpc3N1ZSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHsgbWVzc2FnZSB9O1xcbiAgfTtcXG4gIHZhciBvdmVycmlkZUVycm9yTWFwID0gZXJyb3JNYXA7XFxuICBmdW5jdGlvbiBzZXRFcnJvck1hcChtYXApIHtcXG4gICAgb3ZlcnJpZGVFcnJvck1hcCA9IG1hcDtcXG4gIH1cXG4gIGZ1bmN0aW9uIGdldEVycm9yTWFwKCkge1xcbiAgICByZXR1cm4gb3ZlcnJpZGVFcnJvck1hcDtcXG4gIH1cXG4gIHZhciBtYWtlSXNzdWUgPSAocGFyYW1zKSA9PiB7XFxuICAgIGNvbnN0IHsgZGF0YSwgcGF0aCwgZXJyb3JNYXBzLCBpc3N1ZURhdGEgfSA9IHBhcmFtcztcXG4gICAgY29uc3QgZnVsbFBhdGggPSBbLi4ucGF0aCwgLi4uaXNzdWVEYXRhLnBhdGggfHwgW11dO1xcbiAgICBjb25zdCBmdWxsSXNzdWUgPSB7XFxuICAgICAgLi4uaXNzdWVEYXRhLFxcbiAgICAgIHBhdGg6IGZ1bGxQYXRoXFxuICAgIH07XFxuICAgIGlmIChpc3N1ZURhdGEubWVzc2FnZSAhPT0gdm9pZCAwKSB7XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIC4uLmlzc3VlRGF0YSxcXG4gICAgICAgIHBhdGg6IGZ1bGxQYXRoLFxcbiAgICAgICAgbWVzc2FnZTogaXNzdWVEYXRhLm1lc3NhZ2VcXG4gICAgICB9O1xcbiAgICB9XFxuICAgIGxldCBlcnJvck1lc3NhZ2UgPSBcIlwiO1xcbiAgICBjb25zdCBtYXBzID0gZXJyb3JNYXBzLmZpbHRlcigobSkgPT4gISFtKS5zbGljZSgpLnJldmVyc2UoKTtcXG4gICAgZm9yIChjb25zdCBtYXAgb2YgbWFwcykge1xcbiAgICAgIGVycm9yTWVzc2FnZSA9IG1hcChmdWxsSXNzdWUsIHsgZGF0YSwgZGVmYXVsdEVycm9yOiBlcnJvck1lc3NhZ2UgfSkubWVzc2FnZTtcXG4gICAgfVxcbiAgICByZXR1cm4ge1xcbiAgICAgIC4uLmlzc3VlRGF0YSxcXG4gICAgICBwYXRoOiBmdWxsUGF0aCxcXG4gICAgICBtZXNzYWdlOiBlcnJvck1lc3NhZ2VcXG4gICAgfTtcXG4gIH07XFxuICB2YXIgRU1QVFlfUEFUSCA9IFtdO1xcbiAgZnVuY3Rpb24gYWRkSXNzdWVUb0NvbnRleHQoY3R4LCBpc3N1ZURhdGEpIHtcXG4gICAgY29uc3Qgb3ZlcnJpZGVNYXAgPSBnZXRFcnJvck1hcCgpO1xcbiAgICBjb25zdCBpc3N1ZSA9IG1ha2VJc3N1ZSh7XFxuICAgICAgaXNzdWVEYXRhLFxcbiAgICAgIGRhdGE6IGN0eC5kYXRhLFxcbiAgICAgIHBhdGg6IGN0eC5wYXRoLFxcbiAgICAgIGVycm9yTWFwczogW1xcbiAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXFxuICAgICAgICAvLyBjb250ZXh0dWFsIGVycm9yIG1hcCBpcyBmaXJzdCBwcmlvcml0eVxcbiAgICAgICAgY3R4LnNjaGVtYUVycm9yTWFwLFxcbiAgICAgICAgLy8gdGhlbiBzY2hlbWEtYm91bmQgbWFwIGlmIGF2YWlsYWJsZVxcbiAgICAgICAgb3ZlcnJpZGVNYXAsXFxuICAgICAgICAvLyB0aGVuIGdsb2JhbCBvdmVycmlkZSBtYXBcXG4gICAgICAgIG92ZXJyaWRlTWFwID09PSBlcnJvck1hcCA/IHZvaWQgMCA6IGVycm9yTWFwXFxuICAgICAgICAvLyB0aGVuIGdsb2JhbCBkZWZhdWx0IG1hcFxcbiAgICAgIF0uZmlsdGVyKCh4KSA9PiAhIXgpXFxuICAgIH0pO1xcbiAgICBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKGlzc3VlKTtcXG4gIH1cXG4gIHZhciBQYXJzZVN0YXR1cyA9IGNsYXNzIF9QYXJzZVN0YXR1cyB7XFxuICAgIGNvbnN0cnVjdG9yKCkge1xcbiAgICAgIHRoaXMudmFsdWUgPSBcInZhbGlkXCI7XFxuICAgIH1cXG4gICAgZGlydHkoKSB7XFxuICAgICAgaWYgKHRoaXMudmFsdWUgPT09IFwidmFsaWRcIilcXG4gICAgICAgIHRoaXMudmFsdWUgPSBcImRpcnR5XCI7XFxuICAgIH1cXG4gICAgYWJvcnQoKSB7XFxuICAgICAgaWYgKHRoaXMudmFsdWUgIT09IFwiYWJvcnRlZFwiKVxcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwiYWJvcnRlZFwiO1xcbiAgICB9XFxuICAgIHN0YXRpYyBtZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0cykge1xcbiAgICAgIGNvbnN0IGFycmF5VmFsdWUgPSBbXTtcXG4gICAgICBmb3IgKGNvbnN0IHMgb2YgcmVzdWx0cykge1xcbiAgICAgICAgaWYgKHMuc3RhdHVzID09PSBcImFib3J0ZWRcIilcXG4gICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XFxuICAgICAgICBpZiAocy5zdGF0dXMgPT09IFwiZGlydHlcIilcXG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XFxuICAgICAgICBhcnJheVZhbHVlLnB1c2gocy52YWx1ZSk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogYXJyYXlWYWx1ZSB9O1xcbiAgICB9XFxuICAgIHN0YXRpYyBhc3luYyBtZXJnZU9iamVjdEFzeW5jKHN0YXR1cywgcGFpcnMpIHtcXG4gICAgICBjb25zdCBzeW5jUGFpcnMgPSBbXTtcXG4gICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHBhaXIua2V5O1xcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xcbiAgICAgICAgc3luY1BhaXJzLnB1c2goe1xcbiAgICAgICAgICBrZXksXFxuICAgICAgICAgIHZhbHVlXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIF9QYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBzeW5jUGFpcnMpO1xcbiAgICB9XFxuICAgIHN0YXRpYyBtZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBwYWlycykge1xcbiAgICAgIGNvbnN0IGZpbmFsT2JqZWN0ID0ge307XFxuICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XFxuICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IHBhaXI7XFxuICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXFxuICAgICAgICAgIHJldHVybiBJTlZBTElEO1xcbiAgICAgICAgaWYgKHZhbHVlLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXFxuICAgICAgICAgIHJldHVybiBJTlZBTElEO1xcbiAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIilcXG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XFxuICAgICAgICBpZiAodmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpXFxuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xcbiAgICAgICAgaWYgKGtleS52YWx1ZSAhPT0gXCJfX3Byb3RvX19cIiAmJiAodHlwZW9mIHZhbHVlLnZhbHVlICE9PSBcInVuZGVmaW5lZFwiIHx8IHBhaXIuYWx3YXlzU2V0KSkge1xcbiAgICAgICAgICBmaW5hbE9iamVjdFtrZXkudmFsdWVdID0gdmFsdWUudmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogZmluYWxPYmplY3QgfTtcXG4gICAgfVxcbiAgfTtcXG4gIHZhciBJTlZBTElEID0gT2JqZWN0LmZyZWV6ZSh7XFxuICAgIHN0YXR1czogXCJhYm9ydGVkXCJcXG4gIH0pO1xcbiAgdmFyIERJUlRZID0gKHZhbHVlKSA9PiAoeyBzdGF0dXM6IFwiZGlydHlcIiwgdmFsdWUgfSk7XFxuICB2YXIgT0sgPSAodmFsdWUpID0+ICh7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZSB9KTtcXG4gIHZhciBpc0Fib3J0ZWQgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiO1xcbiAgdmFyIGlzRGlydHkgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwiZGlydHlcIjtcXG4gIHZhciBpc1ZhbGlkID0gKHgpID0+IHguc3RhdHVzID09PSBcInZhbGlkXCI7XFxuICB2YXIgaXNBc3luYyA9ICh4KSA9PiB0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB4IGluc3RhbmNlb2YgUHJvbWlzZTtcXG4gIGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XFxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XFxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XFxuICB9XFxuICBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcXG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XFxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XFxuICAgIHJldHVybiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpLCB2YWx1ZTtcXG4gIH1cXG4gIHZhciBlcnJvclV0aWw7XFxuICAoZnVuY3Rpb24oZXJyb3JVdGlsMikge1xcbiAgICBlcnJvclV0aWwyLmVyclRvT2JqID0gKG1lc3NhZ2UpID0+IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8geyBtZXNzYWdlIH0gOiBtZXNzYWdlIHx8IHt9O1xcbiAgICBlcnJvclV0aWwyLnRvU3RyaW5nID0gKG1lc3NhZ2UpID0+IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8gbWVzc2FnZSA6IG1lc3NhZ2UgPT09IG51bGwgfHwgbWVzc2FnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWVzc2FnZS5tZXNzYWdlO1xcbiAgfSkoZXJyb3JVdGlsIHx8IChlcnJvclV0aWwgPSB7fSkpO1xcbiAgdmFyIF9ab2RFbnVtX2NhY2hlO1xcbiAgdmFyIF9ab2ROYXRpdmVFbnVtX2NhY2hlO1xcbiAgdmFyIFBhcnNlSW5wdXRMYXp5UGF0aCA9IGNsYXNzIHtcXG4gICAgY29uc3RydWN0b3IocGFyZW50LCB2YWx1ZSwgcGF0aCwga2V5KSB7XFxuICAgICAgdGhpcy5fY2FjaGVkUGF0aCA9IFtdO1xcbiAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xcbiAgICAgIHRoaXMuZGF0YSA9IHZhbHVlO1xcbiAgICAgIHRoaXMuX3BhdGggPSBwYXRoO1xcbiAgICAgIHRoaXMuX2tleSA9IGtleTtcXG4gICAgfVxcbiAgICBnZXQgcGF0aCgpIHtcXG4gICAgICBpZiAoIXRoaXMuX2NhY2hlZFBhdGgubGVuZ3RoKSB7XFxuICAgICAgICBpZiAodGhpcy5fa2V5IGluc3RhbmNlb2YgQXJyYXkpIHtcXG4gICAgICAgICAgdGhpcy5fY2FjaGVkUGF0aC5wdXNoKC4uLnRoaXMuX3BhdGgsIC4uLnRoaXMuX2tleSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB0aGlzLl9jYWNoZWRQYXRoLnB1c2goLi4udGhpcy5fcGF0aCwgdGhpcy5fa2V5KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZFBhdGg7XFxuICAgIH1cXG4gIH07XFxuICB2YXIgaGFuZGxlUmVzdWx0ID0gKGN0eCwgcmVzdWx0KSA9PiB7XFxuICAgIGlmIChpc1ZhbGlkKHJlc3VsdCkpIHtcXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiByZXN1bHQudmFsdWUgfTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBpZiAoIWN0eC5jb21tb24uaXNzdWVzLmxlbmd0aCkge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWRhdGlvbiBmYWlsZWQgYnV0IG5vIGlzc3VlcyBkZXRlY3RlZC5cIik7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcXG4gICAgICAgIGdldCBlcnJvcigpIHtcXG4gICAgICAgICAgaWYgKHRoaXMuX2Vycm9yKVxcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcXG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgWm9kRXJyb3IoY3R4LmNvbW1vbi5pc3N1ZXMpO1xcbiAgICAgICAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgfVxcbiAgfTtcXG4gIGZ1bmN0aW9uIHByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSB7XFxuICAgIGlmICghcGFyYW1zKVxcbiAgICAgIHJldHVybiB7fTtcXG4gICAgY29uc3QgeyBlcnJvck1hcDogZXJyb3JNYXAyLCBpbnZhbGlkX3R5cGVfZXJyb3IsIHJlcXVpcmVkX2Vycm9yLCBkZXNjcmlwdGlvbiB9ID0gcGFyYW1zO1xcbiAgICBpZiAoZXJyb3JNYXAyICYmIChpbnZhbGlkX3R5cGVfZXJyb3IgfHwgcmVxdWlyZWRfZXJyb3IpKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5cXCd0IHVzZSBcImludmFsaWRfdHlwZV9lcnJvclwiIG9yIFwicmVxdWlyZWRfZXJyb3JcIiBpbiBjb25qdW5jdGlvbiB3aXRoIGN1c3RvbSBlcnJvciBtYXAuYCk7XFxuICAgIH1cXG4gICAgaWYgKGVycm9yTWFwMilcXG4gICAgICByZXR1cm4geyBlcnJvck1hcDogZXJyb3JNYXAyLCBkZXNjcmlwdGlvbiB9O1xcbiAgICBjb25zdCBjdXN0b21NYXAgPSAoaXNzLCBjdHgpID0+IHtcXG4gICAgICB2YXIgX2EsIF9iO1xcbiAgICAgIGNvbnN0IHsgbWVzc2FnZSB9ID0gcGFyYW1zO1xcbiAgICAgIGlmIChpc3MuY29kZSA9PT0gXCJpbnZhbGlkX2VudW1fdmFsdWVcIikge1xcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogY3R4LmRlZmF1bHRFcnJvciB9O1xcbiAgICAgIH1cXG4gICAgICBpZiAodHlwZW9mIGN0eC5kYXRhID09PSBcInVuZGVmaW5lZFwiKSB7XFxuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiAoX2EgPSBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiByZXF1aXJlZF9lcnJvcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY3R4LmRlZmF1bHRFcnJvciB9O1xcbiAgICAgIH1cXG4gICAgICBpZiAoaXNzLmNvZGUgIT09IFwiaW52YWxpZF90eXBlXCIpXFxuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBjdHguZGVmYXVsdEVycm9yIH07XFxuICAgICAgcmV0dXJuIHsgbWVzc2FnZTogKF9iID0gbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogaW52YWxpZF90eXBlX2Vycm9yKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBjdHguZGVmYXVsdEVycm9yIH07XFxuICAgIH07XFxuICAgIHJldHVybiB7IGVycm9yTWFwOiBjdXN0b21NYXAsIGRlc2NyaXB0aW9uIH07XFxuICB9XFxuICB2YXIgWm9kVHlwZSA9IGNsYXNzIHtcXG4gICAgZ2V0IGRlc2NyaXB0aW9uKCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9kZWYuZGVzY3JpcHRpb247XFxuICAgIH1cXG4gICAgX2dldFR5cGUoaW5wdXQpIHtcXG4gICAgICByZXR1cm4gZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKTtcXG4gICAgfVxcbiAgICBfZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCkge1xcbiAgICAgIHJldHVybiBjdHggfHwge1xcbiAgICAgICAgY29tbW9uOiBpbnB1dC5wYXJlbnQuY29tbW9uLFxcbiAgICAgICAgZGF0YTogaW5wdXQuZGF0YSxcXG4gICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSksXFxuICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxcbiAgICAgICAgcGF0aDogaW5wdXQucGF0aCxcXG4gICAgICAgIHBhcmVudDogaW5wdXQucGFyZW50XFxuICAgICAgfTtcXG4gICAgfVxcbiAgICBfcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KSB7XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIHN0YXR1czogbmV3IFBhcnNlU3RhdHVzKCksXFxuICAgICAgICBjdHg6IHtcXG4gICAgICAgICAgY29tbW9uOiBpbnB1dC5wYXJlbnQuY29tbW9uLFxcbiAgICAgICAgICBkYXRhOiBpbnB1dC5kYXRhLFxcbiAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGlucHV0LmRhdGEpLFxcbiAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxcbiAgICAgICAgICBwYXRoOiBpbnB1dC5wYXRoLFxcbiAgICAgICAgICBwYXJlbnQ6IGlucHV0LnBhcmVudFxcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgIH1cXG4gICAgX3BhcnNlU3luYyhpbnB1dCkge1xcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlKGlucHV0KTtcXG4gICAgICBpZiAoaXNBc3luYyhyZXN1bHQpKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTeW5jaHJvbm91cyBwYXJzZSBlbmNvdW50ZXJlZCBwcm9taXNlLlwiKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgfVxcbiAgICBfcGFyc2VBc3luYyhpbnB1dCkge1xcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlKGlucHV0KTtcXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XFxuICAgIH1cXG4gICAgcGFyc2UoZGF0YSwgcGFyYW1zKSB7XFxuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5zYWZlUGFyc2UoZGF0YSwgcGFyYW1zKTtcXG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpXFxuICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XFxuICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xcbiAgICB9XFxuICAgIHNhZmVQYXJzZShkYXRhLCBwYXJhbXMpIHtcXG4gICAgICB2YXIgX2E7XFxuICAgICAgY29uc3QgY3R4ID0ge1xcbiAgICAgICAgY29tbW9uOiB7XFxuICAgICAgICAgIGlzc3VlczogW10sXFxuICAgICAgICAgIGFzeW5jOiAoX2EgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYXN5bmMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxcbiAgICAgICAgICBjb250ZXh0dWFsRXJyb3JNYXA6IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5lcnJvck1hcFxcbiAgICAgICAgfSxcXG4gICAgICAgIHBhdGg6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGF0aCkgfHwgW10sXFxuICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxcbiAgICAgICAgcGFyZW50OiBudWxsLFxcbiAgICAgICAgZGF0YSxcXG4gICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSlcXG4gICAgICB9O1xcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlU3luYyh7IGRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcXG4gICAgICByZXR1cm4gaGFuZGxlUmVzdWx0KGN0eCwgcmVzdWx0KTtcXG4gICAgfVxcbiAgICBcIn52YWxpZGF0ZVwiKGRhdGEpIHtcXG4gICAgICB2YXIgX2EsIF9iO1xcbiAgICAgIGNvbnN0IGN0eCA9IHtcXG4gICAgICAgIGNvbW1vbjoge1xcbiAgICAgICAgICBpc3N1ZXM6IFtdLFxcbiAgICAgICAgICBhc3luYzogISF0aGlzW1wifnN0YW5kYXJkXCJdLmFzeW5jXFxuICAgICAgICB9LFxcbiAgICAgICAgcGF0aDogW10sXFxuICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxcbiAgICAgICAgcGFyZW50OiBudWxsLFxcbiAgICAgICAgZGF0YSxcXG4gICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSlcXG4gICAgICB9O1xcbiAgICAgIGlmICghdGhpc1tcIn5zdGFuZGFyZFwiXS5hc3luYykge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2VTeW5jKHsgZGF0YSwgcGF0aDogW10sIHBhcmVudDogY3R4IH0pO1xcbiAgICAgICAgICByZXR1cm4gaXNWYWxpZChyZXN1bHQpID8ge1xcbiAgICAgICAgICAgIHZhbHVlOiByZXN1bHQudmFsdWVcXG4gICAgICAgICAgfSA6IHtcXG4gICAgICAgICAgICBpc3N1ZXM6IGN0eC5jb21tb24uaXNzdWVzXFxuICAgICAgICAgIH07XFxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAgICAgaWYgKChfYiA9IChfYSA9IGVyciA9PT0gbnVsbCB8fCBlcnIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVyci5tZXNzYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9Mb3dlckNhc2UoKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKFwiZW5jb3VudGVyZWRcIikpIHtcXG4gICAgICAgICAgICB0aGlzW1wifnN0YW5kYXJkXCJdLmFzeW5jID0gdHJ1ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBjdHguY29tbW9uID0ge1xcbiAgICAgICAgICAgIGlzc3VlczogW10sXFxuICAgICAgICAgICAgYXN5bmM6IHRydWVcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlQXN5bmMoeyBkYXRhLCBwYXRoOiBbXSwgcGFyZW50OiBjdHggfSkudGhlbigocmVzdWx0KSA9PiBpc1ZhbGlkKHJlc3VsdCkgPyB7XFxuICAgICAgICB2YWx1ZTogcmVzdWx0LnZhbHVlXFxuICAgICAgfSA6IHtcXG4gICAgICAgIGlzc3VlczogY3R4LmNvbW1vbi5pc3N1ZXNcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICBhc3luYyBwYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2FmZVBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKTtcXG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpXFxuICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XFxuICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xcbiAgICB9XFxuICAgIGFzeW5jIHNhZmVQYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xcbiAgICAgIGNvbnN0IGN0eCA9IHtcXG4gICAgICAgIGNvbW1vbjoge1xcbiAgICAgICAgICBpc3N1ZXM6IFtdLFxcbiAgICAgICAgICBjb250ZXh0dWFsRXJyb3JNYXA6IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5lcnJvck1hcCxcXG4gICAgICAgICAgYXN5bmM6IHRydWVcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXRoOiAocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnBhdGgpIHx8IFtdLFxcbiAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcXG4gICAgICAgIHBhcmVudDogbnVsbCxcXG4gICAgICAgIGRhdGEsXFxuICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGRhdGEpXFxuICAgICAgfTtcXG4gICAgICBjb25zdCBtYXliZUFzeW5jUmVzdWx0ID0gdGhpcy5fcGFyc2UoeyBkYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKGlzQXN5bmMobWF5YmVBc3luY1Jlc3VsdCkgPyBtYXliZUFzeW5jUmVzdWx0IDogUHJvbWlzZS5yZXNvbHZlKG1heWJlQXN5bmNSZXN1bHQpKTtcXG4gICAgICByZXR1cm4gaGFuZGxlUmVzdWx0KGN0eCwgcmVzdWx0KTtcXG4gICAgfVxcbiAgICByZWZpbmUoY2hlY2ssIG1lc3NhZ2UpIHtcXG4gICAgICBjb25zdCBnZXRJc3N1ZVByb3BlcnRpZXMgPSAodmFsKSA9PiB7XFxuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG1lc3NhZ2UgPT09IFwidW5kZWZpbmVkXCIpIHtcXG4gICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZSB9O1xcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJmdW5jdGlvblwiKSB7XFxuICAgICAgICAgIHJldHVybiBtZXNzYWdlKHZhbCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KCh2YWwsIGN0eCkgPT4ge1xcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY2hlY2sodmFsKTtcXG4gICAgICAgIGNvbnN0IHNldEVycm9yID0gKCkgPT4gY3R4LmFkZElzc3VlKHtcXG4gICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmN1c3RvbSxcXG4gICAgICAgICAgLi4uZ2V0SXNzdWVQcm9wZXJ0aWVzKHZhbClcXG4gICAgICAgIH0pO1xcbiAgICAgICAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChkYXRhKSA9PiB7XFxuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XFxuICAgICAgICAgICAgICBzZXRFcnJvcigpO1xcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcXG4gICAgICAgICAgc2V0RXJyb3IoKTtcXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgcmVmaW5lbWVudChjaGVjaywgcmVmaW5lbWVudERhdGEpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudCgodmFsLCBjdHgpID0+IHtcXG4gICAgICAgIGlmICghY2hlY2sodmFsKSkge1xcbiAgICAgICAgICBjdHguYWRkSXNzdWUodHlwZW9mIHJlZmluZW1lbnREYXRhID09PSBcImZ1bmN0aW9uXCIgPyByZWZpbmVtZW50RGF0YSh2YWwsIGN0eCkgOiByZWZpbmVtZW50RGF0YSk7XFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIF9yZWZpbmVtZW50KHJlZmluZW1lbnQpIHtcXG4gICAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xcbiAgICAgICAgc2NoZW1hOiB0aGlzLFxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxcbiAgICAgICAgZWZmZWN0OiB7IHR5cGU6IFwicmVmaW5lbWVudFwiLCByZWZpbmVtZW50IH1cXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICBzdXBlclJlZmluZShyZWZpbmVtZW50KSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQocmVmaW5lbWVudCk7XFxuICAgIH1cXG4gICAgY29uc3RydWN0b3IoZGVmKSB7XFxuICAgICAgdGhpcy5zcGEgPSB0aGlzLnNhZmVQYXJzZUFzeW5jO1xcbiAgICAgIHRoaXMuX2RlZiA9IGRlZjtcXG4gICAgICB0aGlzLnBhcnNlID0gdGhpcy5wYXJzZS5iaW5kKHRoaXMpO1xcbiAgICAgIHRoaXMuc2FmZVBhcnNlID0gdGhpcy5zYWZlUGFyc2UuYmluZCh0aGlzKTtcXG4gICAgICB0aGlzLnBhcnNlQXN5bmMgPSB0aGlzLnBhcnNlQXN5bmMuYmluZCh0aGlzKTtcXG4gICAgICB0aGlzLnNhZmVQYXJzZUFzeW5jID0gdGhpcy5zYWZlUGFyc2VBc3luYy5iaW5kKHRoaXMpO1xcbiAgICAgIHRoaXMuc3BhID0gdGhpcy5zcGEuYmluZCh0aGlzKTtcXG4gICAgICB0aGlzLnJlZmluZSA9IHRoaXMucmVmaW5lLmJpbmQodGhpcyk7XFxuICAgICAgdGhpcy5yZWZpbmVtZW50ID0gdGhpcy5yZWZpbmVtZW50LmJpbmQodGhpcyk7XFxuICAgICAgdGhpcy5zdXBlclJlZmluZSA9IHRoaXMuc3VwZXJSZWZpbmUuYmluZCh0aGlzKTtcXG4gICAgICB0aGlzLm9wdGlvbmFsID0gdGhpcy5vcHRpb25hbC5iaW5kKHRoaXMpO1xcbiAgICAgIHRoaXMubnVsbGFibGUgPSB0aGlzLm51bGxhYmxlLmJpbmQodGhpcyk7XFxuICAgICAgdGhpcy5udWxsaXNoID0gdGhpcy5udWxsaXNoLmJpbmQodGhpcyk7XFxuICAgICAgdGhpcy5hcnJheSA9IHRoaXMuYXJyYXkuYmluZCh0aGlzKTtcXG4gICAgICB0aGlzLnByb21pc2UgPSB0aGlzLnByb21pc2UuYmluZCh0aGlzKTtcXG4gICAgICB0aGlzLm9yID0gdGhpcy5vci5iaW5kKHRoaXMpO1xcbiAgICAgIHRoaXMuYW5kID0gdGhpcy5hbmQuYmluZCh0aGlzKTtcXG4gICAgICB0aGlzLnRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtLmJpbmQodGhpcyk7XFxuICAgICAgdGhpcy5icmFuZCA9IHRoaXMuYnJhbmQuYmluZCh0aGlzKTtcXG4gICAgICB0aGlzLmRlZmF1bHQgPSB0aGlzLmRlZmF1bHQuYmluZCh0aGlzKTtcXG4gICAgICB0aGlzLmNhdGNoID0gdGhpcy5jYXRjaC5iaW5kKHRoaXMpO1xcbiAgICAgIHRoaXMuZGVzY3JpYmUgPSB0aGlzLmRlc2NyaWJlLmJpbmQodGhpcyk7XFxuICAgICAgdGhpcy5waXBlID0gdGhpcy5waXBlLmJpbmQodGhpcyk7XFxuICAgICAgdGhpcy5yZWFkb25seSA9IHRoaXMucmVhZG9ubHkuYmluZCh0aGlzKTtcXG4gICAgICB0aGlzLmlzTnVsbGFibGUgPSB0aGlzLmlzTnVsbGFibGUuYmluZCh0aGlzKTtcXG4gICAgICB0aGlzLmlzT3B0aW9uYWwgPSB0aGlzLmlzT3B0aW9uYWwuYmluZCh0aGlzKTtcXG4gICAgICB0aGlzW1wifnN0YW5kYXJkXCJdID0ge1xcbiAgICAgICAgdmVyc2lvbjogMSxcXG4gICAgICAgIHZlbmRvcjogXCJ6b2RcIixcXG4gICAgICAgIHZhbGlkYXRlOiAoZGF0YSkgPT4gdGhpc1tcIn52YWxpZGF0ZVwiXShkYXRhKVxcbiAgICAgIH07XFxuICAgIH1cXG4gICAgb3B0aW9uYWwoKSB7XFxuICAgICAgcmV0dXJuIFpvZE9wdGlvbmFsLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xcbiAgICB9XFxuICAgIG51bGxhYmxlKCkge1xcbiAgICAgIHJldHVybiBab2ROdWxsYWJsZS5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcXG4gICAgfVxcbiAgICBudWxsaXNoKCkge1xcbiAgICAgIHJldHVybiB0aGlzLm51bGxhYmxlKCkub3B0aW9uYWwoKTtcXG4gICAgfVxcbiAgICBhcnJheSgpIHtcXG4gICAgICByZXR1cm4gWm9kQXJyYXkuY3JlYXRlKHRoaXMpO1xcbiAgICB9XFxuICAgIHByb21pc2UoKSB7XFxuICAgICAgcmV0dXJuIFpvZFByb21pc2UuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XFxuICAgIH1cXG4gICAgb3Iob3B0aW9uKSB7XFxuICAgICAgcmV0dXJuIFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgb3B0aW9uXSwgdGhpcy5fZGVmKTtcXG4gICAgfVxcbiAgICBhbmQoaW5jb21pbmcpIHtcXG4gICAgICByZXR1cm4gWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZSh0aGlzLCBpbmNvbWluZywgdGhpcy5fZGVmKTtcXG4gICAgfVxcbiAgICB0cmFuc2Zvcm0odHJhbnNmb3JtKSB7XFxuICAgICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcXG4gICAgICAgIHNjaGVtYTogdGhpcyxcXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcXG4gICAgICAgIGVmZmVjdDogeyB0eXBlOiBcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0gfVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIGRlZmF1bHQoZGVmKSB7XFxuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlRnVuYyA9IHR5cGVvZiBkZWYgPT09IFwiZnVuY3Rpb25cIiA/IGRlZiA6ICgpID0+IGRlZjtcXG4gICAgICByZXR1cm4gbmV3IFpvZERlZmF1bHQoe1xcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxcbiAgICAgICAgaW5uZXJUeXBlOiB0aGlzLFxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiBkZWZhdWx0VmFsdWVGdW5jLFxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REZWZhdWx0XFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgYnJhbmQoKSB7XFxuICAgICAgcmV0dXJuIG5ldyBab2RCcmFuZGVkKHtcXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQnJhbmRlZCxcXG4gICAgICAgIHR5cGU6IHRoaXMsXFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZilcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICBjYXRjaChkZWYpIHtcXG4gICAgICBjb25zdCBjYXRjaFZhbHVlRnVuYyA9IHR5cGVvZiBkZWYgPT09IFwiZnVuY3Rpb25cIiA/IGRlZiA6ICgpID0+IGRlZjtcXG4gICAgICByZXR1cm4gbmV3IFpvZENhdGNoKHtcXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcXG4gICAgICAgIGlubmVyVHlwZTogdGhpcyxcXG4gICAgICAgIGNhdGNoVmFsdWU6IGNhdGNoVmFsdWVGdW5jLFxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RDYXRjaFxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIGRlc2NyaWJlKGRlc2NyaXB0aW9uKSB7XFxuICAgICAgY29uc3QgVGhpcyA9IHRoaXMuY29uc3RydWN0b3I7XFxuICAgICAgcmV0dXJuIG5ldyBUaGlzKHtcXG4gICAgICAgIC4uLnRoaXMuX2RlZixcXG4gICAgICAgIGRlc2NyaXB0aW9uXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgcGlwZSh0YXJnZXQpIHtcXG4gICAgICByZXR1cm4gWm9kUGlwZWxpbmUuY3JlYXRlKHRoaXMsIHRhcmdldCk7XFxuICAgIH1cXG4gICAgcmVhZG9ubHkoKSB7XFxuICAgICAgcmV0dXJuIFpvZFJlYWRvbmx5LmNyZWF0ZSh0aGlzKTtcXG4gICAgfVxcbiAgICBpc09wdGlvbmFsKCkge1xcbiAgICAgIHJldHVybiB0aGlzLnNhZmVQYXJzZSh2b2lkIDApLnN1Y2Nlc3M7XFxuICAgIH1cXG4gICAgaXNOdWxsYWJsZSgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5zYWZlUGFyc2UobnVsbCkuc3VjY2VzcztcXG4gICAgfVxcbiAgfTtcXG4gIHZhciBjdWlkUmVnZXggPSAvXmNbXlxcXFxzLV17OCx9JC9pO1xcbiAgdmFyIGN1aWQyUmVnZXggPSAvXlswLTlhLXpdKyQvO1xcbiAgdmFyIHVsaWRSZWdleCA9IC9eWzAtOUEtSEpLTU5QLVRWLVpdezI2fSQvaTtcXG4gIHZhciB1dWlkUmVnZXggPSAvXlswLTlhLWZBLUZdezh9XFxcXGItWzAtOWEtZkEtRl17NH1cXFxcYi1bMC05YS1mQS1GXXs0fVxcXFxiLVswLTlhLWZBLUZdezR9XFxcXGItWzAtOWEtZkEtRl17MTJ9JC9pO1xcbiAgdmFyIG5hbm9pZFJlZ2V4ID0gL15bYS16MC05Xy1dezIxfSQvaTtcXG4gIHZhciBqd3RSZWdleCA9IC9eW0EtWmEtejAtOS1fXStcXFxcLltBLVphLXowLTktX10rXFxcXC5bQS1aYS16MC05LV9dKiQvO1xcbiAgdmFyIGR1cmF0aW9uUmVnZXggPSAvXlstK10/UCg/ISQpKD86KD86Wy0rXT9cXFxcZCtZKXwoPzpbLStdP1xcXFxkK1suLF1cXFxcZCtZJCkpPyg/Oig/OlstK10/XFxcXGQrTSl8KD86Wy0rXT9cXFxcZCtbLixdXFxcXGQrTSQpKT8oPzooPzpbLStdP1xcXFxkK1cpfCg/OlstK10/XFxcXGQrWy4sXVxcXFxkK1ckKSk/KD86KD86Wy0rXT9cXFxcZCtEKXwoPzpbLStdP1xcXFxkK1suLF1cXFxcZCtEJCkpPyg/OlQoPz1bXFxcXGQrLV0pKD86KD86Wy0rXT9cXFxcZCtIKXwoPzpbLStdP1xcXFxkK1suLF1cXFxcZCtIJCkpPyg/Oig/OlstK10/XFxcXGQrTSl8KD86Wy0rXT9cXFxcZCtbLixdXFxcXGQrTSQpKT8oPzpbLStdP1xcXFxkKyg/OlsuLF1cXFxcZCspP1MpPyk/PyQvO1xcbiAgdmFyIGVtYWlsUmVnZXggPSAvXig/IVxcXFwuKSg/IS4qXFxcXC5cXFxcLikoW0EtWjAtOV9cXCcrXFxcXC1cXFxcLl0qKVtBLVowLTlfKy1dQChbQS1aMC05XVtBLVowLTlcXFxcLV0qXFxcXC4pK1tBLVpdezIsfSQvaTtcXG4gIHZhciBfZW1vamlSZWdleCA9IGBeKFxcXFxcXFxccHtFeHRlbmRlZF9QaWN0b2dyYXBoaWN9fFxcXFxcXFxccHtFbW9qaV9Db21wb25lbnR9KSskYDtcXG4gIHZhciBlbW9qaVJlZ2V4O1xcbiAgdmFyIGlwdjRSZWdleCA9IC9eKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSkkLztcXG4gIHZhciBpcHY0Q2lkclJlZ2V4ID0gL14oPzooPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFxcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcXFwvKDNbMC0yXXxbMTJdP1swLTldKSQvO1xcbiAgdmFyIGlwdjZSZWdleCA9IC9eKChbMC05YS1mQS1GXXsxLDR9Oil7Nyw3fVswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDd9OnwoWzAtOWEtZkEtRl17MSw0fTopezEsNn06WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsNX0oOlswLTlhLWZBLUZdezEsNH0pezEsMn18KFswLTlhLWZBLUZdezEsNH06KXsxLDR9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDN9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwzfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsMn0oOlswLTlhLWZBLUZdezEsNH0pezEsNX18WzAtOWEtZkEtRl17MSw0fTooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDZ9KXw6KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw3fXw6KXxmZTgwOig6WzAtOWEtZkEtRl17MCw0fSl7MCw0fSVbMC05YS16QS1aXXsxLH18OjooZmZmZig6MHsxLDR9KXswLDF9Oil7MCwxfSgoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFxcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pfChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fTooKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKSkkLztcXG4gIHZhciBpcHY2Q2lkclJlZ2V4ID0gL14oKFswLTlhLWZBLUZdezEsNH06KXs3LDd9WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsN306fChbMC05YS1mQS1GXXsxLDR9Oil7MSw2fTpbMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw1fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwyfXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH0oOlswLTlhLWZBLUZdezEsNH0pezEsM318KFswLTlhLWZBLUZdezEsNH06KXsxLDN9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwyfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw1fXxbMC05YS1mQS1GXXsxLDR9OigoOlswLTlhLWZBLUZdezEsNH0pezEsNn0pfDooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDd9fDopfGZlODA6KDpbMC05YS1mQS1GXXswLDR9KXswLDR9JVswLTlhLXpBLVpdezEsfXw6OihmZmZmKDowezEsNH0pezAsMX06KXswLDF9KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXFxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSl8KFswLTlhLWZBLUZdezEsNH06KXsxLDR9OigoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFxcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pKVxcXFwvKDEyWzAtOF18MVswMV1bMC05XXxbMS05XT9bMC05XSkkLztcXG4gIHZhciBiYXNlNjRSZWdleDIgPSAvXihbMC05YS16QS1aKy9dezR9KSooKFswLTlhLXpBLVorL117Mn09PSl8KFswLTlhLXpBLVorL117M309KSk/JC87XFxuICB2YXIgYmFzZTY0dXJsUmVnZXggPSAvXihbMC05YS16QS1aLV9dezR9KSooKFswLTlhLXpBLVotX117Mn0oPT0pPyl8KFswLTlhLXpBLVotX117M30oPSk/KSk/JC87XFxuICB2YXIgZGF0ZVJlZ2V4U291cmNlID0gYCgoXFxcXFxcXFxkXFxcXFxcXFxkWzI0NjhdWzA0OF18XFxcXFxcXFxkXFxcXFxcXFxkWzEzNTc5XVsyNl18XFxcXFxcXFxkXFxcXFxcXFxkMFs0OF18WzAyNDY4XVswNDhdMDB8WzEzNTc5XVsyNl0wMCktMDItMjl8XFxcXFxcXFxkezR9LSgoMFsxMzU3OF18MVswMl0pLSgwWzEtOV18WzEyXVxcXFxcXFxcZHwzWzAxXSl8KDBbNDY5XXwxMSktKDBbMS05XXxbMTJdXFxcXFxcXFxkfDMwKXwoMDIpLSgwWzEtOV18MVxcXFxcXFxcZHwyWzAtOF0pKSlgO1xcbiAgdmFyIGRhdGVSZWdleCA9IG5ldyBSZWdFeHAoYF4ke2RhdGVSZWdleFNvdXJjZX0kYCk7XFxuICBmdW5jdGlvbiB0aW1lUmVnZXhTb3VyY2UoYXJncykge1xcbiAgICBsZXQgcmVnZXggPSBgKFswMV1cXFxcXFxcXGR8MlswLTNdKTpbMC01XVxcXFxcXFxcZDpbMC01XVxcXFxcXFxcZGA7XFxuICAgIGlmIChhcmdzLnByZWNpc2lvbikge1xcbiAgICAgIHJlZ2V4ID0gYCR7cmVnZXh9XFxcXFxcXFwuXFxcXFxcXFxkeyR7YXJncy5wcmVjaXNpb259fWA7XFxuICAgIH0gZWxzZSBpZiAoYXJncy5wcmVjaXNpb24gPT0gbnVsbCkge1xcbiAgICAgIHJlZ2V4ID0gYCR7cmVnZXh9KFxcXFxcXFxcLlxcXFxcXFxcZCspP2A7XFxuICAgIH1cXG4gICAgcmV0dXJuIHJlZ2V4O1xcbiAgfVxcbiAgZnVuY3Rpb24gdGltZVJlZ2V4KGFyZ3MpIHtcXG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3RpbWVSZWdleFNvdXJjZShhcmdzKX0kYCk7XFxuICB9XFxuICBmdW5jdGlvbiBkYXRldGltZVJlZ2V4KGFyZ3MpIHtcXG4gICAgbGV0IHJlZ2V4ID0gYCR7ZGF0ZVJlZ2V4U291cmNlfVQke3RpbWVSZWdleFNvdXJjZShhcmdzKX1gO1xcbiAgICBjb25zdCBvcHRzID0gW107XFxuICAgIG9wdHMucHVzaChhcmdzLmxvY2FsID8gYFo/YCA6IGBaYCk7XFxuICAgIGlmIChhcmdzLm9mZnNldClcXG4gICAgICBvcHRzLnB1c2goYChbKy1dXFxcXFxcXFxkezJ9Oj9cXFxcXFxcXGR7Mn0pYCk7XFxuICAgIHJlZ2V4ID0gYCR7cmVnZXh9KCR7b3B0cy5qb2luKFwifFwiKX0pYDtcXG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3JlZ2V4fSRgKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGlzVmFsaWRJUChpcCwgdmVyc2lvbjQpIHtcXG4gICAgaWYgKCh2ZXJzaW9uNCA9PT0gXCJ2NFwiIHx8ICF2ZXJzaW9uNCkgJiYgaXB2NFJlZ2V4LnRlc3QoaXApKSB7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH1cXG4gICAgaWYgKCh2ZXJzaW9uNCA9PT0gXCJ2NlwiIHx8ICF2ZXJzaW9uNCkgJiYgaXB2NlJlZ2V4LnRlc3QoaXApKSB7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH1cXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcbiAgZnVuY3Rpb24gaXNWYWxpZEpXVChqd3QsIGFsZykge1xcbiAgICBpZiAoIWp3dFJlZ2V4LnRlc3Qoand0KSlcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIHRyeSB7XFxuICAgICAgY29uc3QgW2hlYWRlcl0gPSBqd3Quc3BsaXQoXCIuXCIpO1xcbiAgICAgIGNvbnN0IGJhc2U2NCA9IGhlYWRlci5yZXBsYWNlKC8tL2csIFwiK1wiKS5yZXBsYWNlKC9fL2csIFwiL1wiKS5wYWRFbmQoaGVhZGVyLmxlbmd0aCArICg0IC0gaGVhZGVyLmxlbmd0aCAlIDQpICUgNCwgXCI9XCIpO1xcbiAgICAgIGNvbnN0IGRlY29kZWQgPSBKU09OLnBhcnNlKGF0b2IoYmFzZTY0KSk7XFxuICAgICAgaWYgKHR5cGVvZiBkZWNvZGVkICE9PSBcIm9iamVjdFwiIHx8IGRlY29kZWQgPT09IG51bGwpXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgaWYgKCFkZWNvZGVkLnR5cCB8fCAhZGVjb2RlZC5hbGcpXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgaWYgKGFsZyAmJiBkZWNvZGVkLmFsZyAhPT0gYWxnKVxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9IGNhdGNoIChfYSkge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgfVxcbiAgZnVuY3Rpb24gaXNWYWxpZENpZHIoaXAsIHZlcnNpb240KSB7XFxuICAgIGlmICgodmVyc2lvbjQgPT09IFwidjRcIiB8fCAhdmVyc2lvbjQpICYmIGlwdjRDaWRyUmVnZXgudGVzdChpcCkpIHtcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcbiAgICBpZiAoKHZlcnNpb240ID09PSBcInY2XCIgfHwgIXZlcnNpb240KSAmJiBpcHY2Q2lkclJlZ2V4LnRlc3QoaXApKSB7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH1cXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcbiAgdmFyIFpvZFN0cmluZyA9IGNsYXNzIF9ab2RTdHJpbmcgZXh0ZW5kcyBab2RUeXBlIHtcXG4gICAgX3BhcnNlKGlucHV0KSB7XFxuICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcXG4gICAgICAgIGlucHV0LmRhdGEgPSBTdHJpbmcoaW5wdXQuZGF0YSk7XFxuICAgICAgfVxcbiAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcXG4gICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zdHJpbmcpIHtcXG4gICAgICAgIGNvbnN0IGN0eDIgPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XFxuICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgyLCB7XFxuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXFxuICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnN0cmluZyxcXG4gICAgICAgICAgcmVjZWl2ZWQ6IGN0eDIucGFyc2VkVHlwZVxcbiAgICAgICAgfSk7XFxuICAgICAgICByZXR1cm4gSU5WQUxJRDtcXG4gICAgICB9XFxuICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XFxuICAgICAgbGV0IGN0eCA9IHZvaWQgMDtcXG4gICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcXG4gICAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XFxuICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmxlbmd0aCA8IGNoZWNrLnZhbHVlKSB7XFxuICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XFxuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XFxuICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxcbiAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXFxuICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxcbiAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxcbiAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxcbiAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcXG4gICAgICAgICAgaWYgKGlucHV0LmRhdGEubGVuZ3RoID4gY2hlY2sudmFsdWUpIHtcXG4gICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcXG4gICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxcbiAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXFxuICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxcbiAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxcbiAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxcbiAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibGVuZ3RoXCIpIHtcXG4gICAgICAgICAgY29uc3QgdG9vQmlnID0gaW5wdXQuZGF0YS5sZW5ndGggPiBjaGVjay52YWx1ZTtcXG4gICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBpbnB1dC5kYXRhLmxlbmd0aCA8IGNoZWNrLnZhbHVlO1xcbiAgICAgICAgICBpZiAodG9vQmlnIHx8IHRvb1NtYWxsKSB7XFxuICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XFxuICAgICAgICAgICAgaWYgKHRvb0JpZykge1xcbiAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxcbiAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcXG4gICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxcbiAgICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxcbiAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfSBlbHNlIGlmICh0b29TbWFsbCkge1xcbiAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXFxuICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXFxuICAgICAgICAgICAgICAgIGV4YWN0OiB0cnVlLFxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXFxuICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJlbWFpbFwiKSB7XFxuICAgICAgICAgIGlmICghZW1haWxSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XFxuICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XFxuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XFxuICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImVtYWlsXCIsXFxuICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXFxuICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJlbW9qaVwiKSB7XFxuICAgICAgICAgIGlmICghZW1vamlSZWdleCkge1xcbiAgICAgICAgICAgIGVtb2ppUmVnZXggPSBuZXcgUmVnRXhwKF9lbW9qaVJlZ2V4LCBcInVcIik7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKCFlbW9qaVJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcXG4gICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcXG4gICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZW1vamlcIixcXG4gICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInV1aWRcIikge1xcbiAgICAgICAgICBpZiAoIXV1aWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XFxuICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XFxuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XFxuICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInV1aWRcIixcXG4gICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm5hbm9pZFwiKSB7XFxuICAgICAgICAgIGlmICghbmFub2lkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xcbiAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xcbiAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJuYW5vaWRcIixcXG4gICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImN1aWRcIikge1xcbiAgICAgICAgICBpZiAoIWN1aWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XFxuICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XFxuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XFxuICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImN1aWRcIixcXG4gICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImN1aWQyXCIpIHtcXG4gICAgICAgICAgaWYgKCFjdWlkMlJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcXG4gICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcXG4gICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiY3VpZDJcIixcXG4gICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInVsaWRcIikge1xcbiAgICAgICAgICBpZiAoIXVsaWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XFxuICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XFxuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XFxuICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInVsaWRcIixcXG4gICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInVybFwiKSB7XFxuICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgbmV3IFVSTChpbnB1dC5kYXRhKTtcXG4gICAgICAgICAgfSBjYXRjaCAoX2EpIHtcXG4gICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcXG4gICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidXJsXCIsXFxuICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXFxuICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJyZWdleFwiKSB7XFxuICAgICAgICAgIGNoZWNrLnJlZ2V4Lmxhc3RJbmRleCA9IDA7XFxuICAgICAgICAgIGNvbnN0IHRlc3RSZXN1bHQgPSBjaGVjay5yZWdleC50ZXN0KGlucHV0LmRhdGEpO1xcbiAgICAgICAgICBpZiAoIXRlc3RSZXN1bHQpIHtcXG4gICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcXG4gICAgICAgICAgICAgIHZhbGlkYXRpb246IFwicmVnZXhcIixcXG4gICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRyaW1cIikge1xcbiAgICAgICAgICBpbnB1dC5kYXRhID0gaW5wdXQuZGF0YS50cmltKCk7XFxuICAgICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiaW5jbHVkZXNcIikge1xcbiAgICAgICAgICBpZiAoIWlucHV0LmRhdGEuaW5jbHVkZXMoY2hlY2sudmFsdWUsIGNoZWNrLnBvc2l0aW9uKSkge1xcbiAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xcbiAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxcbiAgICAgICAgICAgICAgdmFsaWRhdGlvbjogeyBpbmNsdWRlczogY2hlY2sudmFsdWUsIHBvc2l0aW9uOiBjaGVjay5wb3NpdGlvbiB9LFxcbiAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidG9Mb3dlckNhc2VcIikge1xcbiAgICAgICAgICBpbnB1dC5kYXRhID0gaW5wdXQuZGF0YS50b0xvd2VyQ2FzZSgpO1xcbiAgICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRvVXBwZXJDYXNlXCIpIHtcXG4gICAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudG9VcHBlckNhc2UoKTtcXG4gICAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJzdGFydHNXaXRoXCIpIHtcXG4gICAgICAgICAgaWYgKCFpbnB1dC5kYXRhLnN0YXJ0c1dpdGgoY2hlY2sudmFsdWUpKSB7XFxuICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XFxuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XFxuICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXFxuICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IHN0YXJ0c1dpdGg6IGNoZWNrLnZhbHVlIH0sXFxuICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJlbmRzV2l0aFwiKSB7XFxuICAgICAgICAgIGlmICghaW5wdXQuZGF0YS5lbmRzV2l0aChjaGVjay52YWx1ZSkpIHtcXG4gICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcXG4gICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcXG4gICAgICAgICAgICAgIHZhbGlkYXRpb246IHsgZW5kc1dpdGg6IGNoZWNrLnZhbHVlIH0sXFxuICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJkYXRldGltZVwiKSB7XFxuICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gZGF0ZXRpbWVSZWdleChjaGVjayk7XFxuICAgICAgICAgIGlmICghcmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xcbiAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xcbiAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxcbiAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJkYXRldGltZVwiLFxcbiAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZGF0ZVwiKSB7XFxuICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gZGF0ZVJlZ2V4O1xcbiAgICAgICAgICBpZiAoIXJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcXG4gICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcXG4gICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcXG4gICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZGF0ZVwiLFxcbiAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidGltZVwiKSB7XFxuICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gdGltZVJlZ2V4KGNoZWNrKTtcXG4gICAgICAgICAgaWYgKCFyZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XFxuICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XFxuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XFxuICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXFxuICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInRpbWVcIixcXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImR1cmF0aW9uXCIpIHtcXG4gICAgICAgICAgaWYgKCFkdXJhdGlvblJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcXG4gICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcXG4gICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZHVyYXRpb25cIixcXG4gICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImlwXCIpIHtcXG4gICAgICAgICAgaWYgKCFpc1ZhbGlkSVAoaW5wdXQuZGF0YSwgY2hlY2sudmVyc2lvbikpIHtcXG4gICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcXG4gICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiaXBcIixcXG4gICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImp3dFwiKSB7XFxuICAgICAgICAgIGlmICghaXNWYWxpZEpXVChpbnB1dC5kYXRhLCBjaGVjay5hbGcpKSB7XFxuICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XFxuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XFxuICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImp3dFwiLFxcbiAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxcbiAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiY2lkclwiKSB7XFxuICAgICAgICAgIGlmICghaXNWYWxpZENpZHIoaW5wdXQuZGF0YSwgY2hlY2sudmVyc2lvbikpIHtcXG4gICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcXG4gICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiY2lkclwiLFxcbiAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxcbiAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiYmFzZTY0XCIpIHtcXG4gICAgICAgICAgaWYgKCFiYXNlNjRSZWdleDIudGVzdChpbnB1dC5kYXRhKSkge1xcbiAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xcbiAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJiYXNlNjRcIixcXG4gICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImJhc2U2NHVybFwiKSB7XFxuICAgICAgICAgIGlmICghYmFzZTY0dXJsUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xcbiAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xcbiAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJiYXNlNjR1cmxcIixcXG4gICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xcbiAgICB9XFxuICAgIF9yZWdleChyZWdleCwgdmFsaWRhdGlvbiwgbWVzc2FnZSkge1xcbiAgICAgIHJldHVybiB0aGlzLnJlZmluZW1lbnQoKGRhdGEpID0+IHJlZ2V4LnRlc3QoZGF0YSksIHtcXG4gICAgICAgIHZhbGlkYXRpb24sXFxuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXFxuICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSlcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcXG4gICAgICByZXR1cm4gbmV3IF9ab2RTdHJpbmcoe1xcbiAgICAgICAgLi4udGhpcy5fZGVmLFxcbiAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgZW1haWwobWVzc2FnZSkge1xcbiAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZW1haWxcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xcbiAgICB9XFxuICAgIHVybChtZXNzYWdlKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1cmxcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xcbiAgICB9XFxuICAgIGVtb2ppKG1lc3NhZ2UpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImVtb2ppXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcXG4gICAgfVxcbiAgICB1dWlkKG1lc3NhZ2UpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcInV1aWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xcbiAgICB9XFxuICAgIG5hbm9pZChtZXNzYWdlKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJuYW5vaWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xcbiAgICB9XFxuICAgIGN1aWQobWVzc2FnZSkge1xcbiAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiY3VpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XFxuICAgIH1cXG4gICAgY3VpZDIobWVzc2FnZSkge1xcbiAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiY3VpZDJcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xcbiAgICB9XFxuICAgIHVsaWQobWVzc2FnZSkge1xcbiAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidWxpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XFxuICAgIH1cXG4gICAgYmFzZTY0KG1lc3NhZ2UpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImJhc2U2NFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XFxuICAgIH1cXG4gICAgYmFzZTY0dXJsKG1lc3NhZ2UpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xcbiAgICAgICAga2luZDogXCJiYXNlNjR1cmxcIixcXG4gICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIGp3dChvcHRpb25zKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJqd3RcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMpIH0pO1xcbiAgICB9XFxuICAgIGlwKG9wdGlvbnMpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImlwXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zKSB9KTtcXG4gICAgfVxcbiAgICBjaWRyKG9wdGlvbnMpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImNpZHJcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMpIH0pO1xcbiAgICB9XFxuICAgIGRhdGV0aW1lKG9wdGlvbnMpIHtcXG4gICAgICB2YXIgX2EsIF9iO1xcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcXG4gICAgICAgICAga2luZDogXCJkYXRldGltZVwiLFxcbiAgICAgICAgICBwcmVjaXNpb246IG51bGwsXFxuICAgICAgICAgIG9mZnNldDogZmFsc2UsXFxuICAgICAgICAgIGxvY2FsOiBmYWxzZSxcXG4gICAgICAgICAgbWVzc2FnZTogb3B0aW9uc1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XFxuICAgICAgICBraW5kOiBcImRhdGV0aW1lXCIsXFxuICAgICAgICBwcmVjaXNpb246IHR5cGVvZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZWNpc2lvbikgPT09IFwidW5kZWZpbmVkXCIgPyBudWxsIDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZWNpc2lvbixcXG4gICAgICAgIG9mZnNldDogKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9mZnNldCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UsXFxuICAgICAgICBsb2NhbDogKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvY2FsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZSxcXG4gICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWVzc2FnZSlcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICBkYXRlKG1lc3NhZ2UpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImRhdGVcIiwgbWVzc2FnZSB9KTtcXG4gICAgfVxcbiAgICB0aW1lKG9wdGlvbnMpIHtcXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XFxuICAgICAgICAgIGtpbmQ6IFwidGltZVwiLFxcbiAgICAgICAgICBwcmVjaXNpb246IG51bGwsXFxuICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnNcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xcbiAgICAgICAga2luZDogXCJ0aW1lXCIsXFxuICAgICAgICBwcmVjaXNpb246IHR5cGVvZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZWNpc2lvbikgPT09IFwidW5kZWZpbmVkXCIgPyBudWxsIDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZWNpc2lvbixcXG4gICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWVzc2FnZSlcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICBkdXJhdGlvbihtZXNzYWdlKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJkdXJhdGlvblwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XFxuICAgIH1cXG4gICAgcmVnZXgocmVnZXgsIG1lc3NhZ2UpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xcbiAgICAgICAga2luZDogXCJyZWdleFwiLFxcbiAgICAgICAgcmVnZXgsXFxuICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSlcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICBpbmNsdWRlcyh2YWx1ZSwgb3B0aW9ucykge1xcbiAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XFxuICAgICAgICBraW5kOiBcImluY2x1ZGVzXCIsXFxuICAgICAgICB2YWx1ZSxcXG4gICAgICAgIHBvc2l0aW9uOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucG9zaXRpb24sXFxuICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1lc3NhZ2UpXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgc3RhcnRzV2l0aCh2YWx1ZSwgbWVzc2FnZSkge1xcbiAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XFxuICAgICAgICBraW5kOiBcInN0YXJ0c1dpdGhcIixcXG4gICAgICAgIHZhbHVlLFxcbiAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgZW5kc1dpdGgodmFsdWUsIG1lc3NhZ2UpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xcbiAgICAgICAga2luZDogXCJlbmRzV2l0aFwiLFxcbiAgICAgICAgdmFsdWUsXFxuICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSlcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICBtaW4obWluTGVuZ3RoLCBtZXNzYWdlKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcXG4gICAgICAgIGtpbmQ6IFwibWluXCIsXFxuICAgICAgICB2YWx1ZTogbWluTGVuZ3RoLFxcbiAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgbWF4KG1heExlbmd0aCwgbWVzc2FnZSkge1xcbiAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XFxuICAgICAgICBraW5kOiBcIm1heFwiLFxcbiAgICAgICAgdmFsdWU6IG1heExlbmd0aCxcXG4gICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIGxlbmd0aChsZW4sIG1lc3NhZ2UpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xcbiAgICAgICAga2luZDogXCJsZW5ndGhcIixcXG4gICAgICAgIHZhbHVlOiBsZW4sXFxuICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSlcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogRXF1aXZhbGVudCB0byBgLm1pbigxKWBcXG4gICAgICovXFxuICAgIG5vbmVtcHR5KG1lc3NhZ2UpIHtcXG4gICAgICByZXR1cm4gdGhpcy5taW4oMSwgZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpKTtcXG4gICAgfVxcbiAgICB0cmltKCkge1xcbiAgICAgIHJldHVybiBuZXcgX1pvZFN0cmluZyh7XFxuICAgICAgICAuLi50aGlzLl9kZWYsXFxuICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidHJpbVwiIH1dXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgdG9Mb3dlckNhc2UoKSB7XFxuICAgICAgcmV0dXJuIG5ldyBfWm9kU3RyaW5nKHtcXG4gICAgICAgIC4uLnRoaXMuX2RlZixcXG4gICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIHsga2luZDogXCJ0b0xvd2VyQ2FzZVwiIH1dXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgdG9VcHBlckNhc2UoKSB7XFxuICAgICAgcmV0dXJuIG5ldyBfWm9kU3RyaW5nKHtcXG4gICAgICAgIC4uLnRoaXMuX2RlZixcXG4gICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIHsga2luZDogXCJ0b1VwcGVyQ2FzZVwiIH1dXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgZ2V0IGlzRGF0ZXRpbWUoKSB7XFxuICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJkYXRldGltZVwiKTtcXG4gICAgfVxcbiAgICBnZXQgaXNEYXRlKCkge1xcbiAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZGF0ZVwiKTtcXG4gICAgfVxcbiAgICBnZXQgaXNUaW1lKCkge1xcbiAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidGltZVwiKTtcXG4gICAgfVxcbiAgICBnZXQgaXNEdXJhdGlvbigpIHtcXG4gICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImR1cmF0aW9uXCIpO1xcbiAgICB9XFxuICAgIGdldCBpc0VtYWlsKCkge1xcbiAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZW1haWxcIik7XFxuICAgIH1cXG4gICAgZ2V0IGlzVVJMKCkge1xcbiAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidXJsXCIpO1xcbiAgICB9XFxuICAgIGdldCBpc0Vtb2ppKCkge1xcbiAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZW1vamlcIik7XFxuICAgIH1cXG4gICAgZ2V0IGlzVVVJRCgpIHtcXG4gICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInV1aWRcIik7XFxuICAgIH1cXG4gICAgZ2V0IGlzTkFOT0lEKCkge1xcbiAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwibmFub2lkXCIpO1xcbiAgICB9XFxuICAgIGdldCBpc0NVSUQoKSB7XFxuICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJjdWlkXCIpO1xcbiAgICB9XFxuICAgIGdldCBpc0NVSUQyKCkge1xcbiAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiY3VpZDJcIik7XFxuICAgIH1cXG4gICAgZ2V0IGlzVUxJRCgpIHtcXG4gICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInVsaWRcIik7XFxuICAgIH1cXG4gICAgZ2V0IGlzSVAoKSB7XFxuICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJpcFwiKTtcXG4gICAgfVxcbiAgICBnZXQgaXNDSURSKCkge1xcbiAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiY2lkclwiKTtcXG4gICAgfVxcbiAgICBnZXQgaXNCYXNlNjQoKSB7XFxuICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJiYXNlNjRcIik7XFxuICAgIH1cXG4gICAgZ2V0IGlzQmFzZTY0dXJsKCkge1xcbiAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiYmFzZTY0dXJsXCIpO1xcbiAgICB9XFxuICAgIGdldCBtaW5MZW5ndGgoKSB7XFxuICAgICAgbGV0IG1pbiA9IG51bGw7XFxuICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XFxuICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xcbiAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxcbiAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gbWluO1xcbiAgICB9XFxuICAgIGdldCBtYXhMZW5ndGgoKSB7XFxuICAgICAgbGV0IG1heCA9IG51bGw7XFxuICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XFxuICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xcbiAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxcbiAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gbWF4O1xcbiAgICB9XFxuICB9O1xcbiAgWm9kU3RyaW5nLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcXG4gICAgdmFyIF9hO1xcbiAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XFxuICAgICAgY2hlY2tzOiBbXSxcXG4gICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFN0cmluZyxcXG4gICAgICBjb2VyY2U6IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxcbiAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxcbiAgICB9KTtcXG4gIH07XFxuICBmdW5jdGlvbiBmbG9hdFNhZmVSZW1haW5kZXIodmFsLCBzdGVwKSB7XFxuICAgIGNvbnN0IHZhbERlY0NvdW50ID0gKHZhbC50b1N0cmluZygpLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGg7XFxuICAgIGNvbnN0IHN0ZXBEZWNDb3VudCA9IChzdGVwLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aDtcXG4gICAgY29uc3QgZGVjQ291bnQgPSB2YWxEZWNDb3VudCA+IHN0ZXBEZWNDb3VudCA/IHZhbERlY0NvdW50IDogc3RlcERlY0NvdW50O1xcbiAgICBjb25zdCB2YWxJbnQgPSBwYXJzZUludCh2YWwudG9GaXhlZChkZWNDb3VudCkucmVwbGFjZShcIi5cIiwgXCJcIikpO1xcbiAgICBjb25zdCBzdGVwSW50ID0gcGFyc2VJbnQoc3RlcC50b0ZpeGVkKGRlY0NvdW50KS5yZXBsYWNlKFwiLlwiLCBcIlwiKSk7XFxuICAgIHJldHVybiB2YWxJbnQgJSBzdGVwSW50IC8gTWF0aC5wb3coMTAsIGRlY0NvdW50KTtcXG4gIH1cXG4gIHZhciBab2ROdW1iZXIgPSBjbGFzcyBfWm9kTnVtYmVyIGV4dGVuZHMgWm9kVHlwZSB7XFxuICAgIGNvbnN0cnVjdG9yKCkge1xcbiAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XFxuICAgICAgdGhpcy5taW4gPSB0aGlzLmd0ZTtcXG4gICAgICB0aGlzLm1heCA9IHRoaXMubHRlO1xcbiAgICAgIHRoaXMuc3RlcCA9IHRoaXMubXVsdGlwbGVPZjtcXG4gICAgfVxcbiAgICBfcGFyc2UoaW5wdXQpIHtcXG4gICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xcbiAgICAgICAgaW5wdXQuZGF0YSA9IE51bWJlcihpbnB1dC5kYXRhKTtcXG4gICAgICB9XFxuICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xcbiAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm51bWJlcikge1xcbiAgICAgICAgY29uc3QgY3R4MiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcXG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eDIsIHtcXG4gICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcXG4gICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubnVtYmVyLFxcbiAgICAgICAgICByZWNlaXZlZDogY3R4Mi5wYXJzZWRUeXBlXFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiBJTlZBTElEO1xcbiAgICAgIH1cXG4gICAgICBsZXQgY3R4ID0gdm9pZCAwO1xcbiAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xcbiAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xcbiAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwiaW50XCIpIHtcXG4gICAgICAgICAgaWYgKCF1dGlsLmlzSW50ZWdlcihpbnB1dC5kYXRhKSkge1xcbiAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xcbiAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcXG4gICAgICAgICAgICAgIGV4cGVjdGVkOiBcImludGVnZXJcIixcXG4gICAgICAgICAgICAgIHJlY2VpdmVkOiBcImZsb2F0XCIsXFxuICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xcbiAgICAgICAgICBjb25zdCB0b29TbWFsbCA9IGNoZWNrLmluY2x1c2l2ZSA/IGlucHV0LmRhdGEgPCBjaGVjay52YWx1ZSA6IGlucHV0LmRhdGEgPD0gY2hlY2sudmFsdWU7XFxuICAgICAgICAgIGlmICh0b29TbWFsbCkge1xcbiAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xcbiAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcXG4gICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxcbiAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcXG4gICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxcbiAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxcbiAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcXG4gICAgICAgICAgY29uc3QgdG9vQmlnID0gY2hlY2suaW5jbHVzaXZlID8gaW5wdXQuZGF0YSA+IGNoZWNrLnZhbHVlIDogaW5wdXQuZGF0YSA+PSBjaGVjay52YWx1ZTtcXG4gICAgICAgICAgaWYgKHRvb0JpZykge1xcbiAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xcbiAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXFxuICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcXG4gICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXFxuICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcXG4gICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm11bHRpcGxlT2ZcIikge1xcbiAgICAgICAgICBpZiAoZmxvYXRTYWZlUmVtYWluZGVyKGlucHV0LmRhdGEsIGNoZWNrLnZhbHVlKSAhPT0gMCkge1xcbiAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xcbiAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZixcXG4gICAgICAgICAgICAgIG11bHRpcGxlT2Y6IGNoZWNrLnZhbHVlLFxcbiAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZmluaXRlXCIpIHtcXG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoaW5wdXQuZGF0YSkpIHtcXG4gICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcXG4gICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5ub3RfZmluaXRlLFxcbiAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbnB1dC5kYXRhIH07XFxuICAgIH1cXG4gICAgZ3RlKHZhbHVlLCBtZXNzYWdlKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XFxuICAgIH1cXG4gICAgZ3QodmFsdWUsIG1lc3NhZ2UpIHtcXG4gICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XFxuICAgIH1cXG4gICAgbHRlKHZhbHVlLCBtZXNzYWdlKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XFxuICAgIH1cXG4gICAgbHQodmFsdWUsIG1lc3NhZ2UpIHtcXG4gICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XFxuICAgIH1cXG4gICAgc2V0TGltaXQoa2luZCwgdmFsdWUsIGluY2x1c2l2ZSwgbWVzc2FnZSkge1xcbiAgICAgIHJldHVybiBuZXcgX1pvZE51bWJlcih7XFxuICAgICAgICAuLi50aGlzLl9kZWYsXFxuICAgICAgICBjaGVja3M6IFtcXG4gICAgICAgICAgLi4udGhpcy5fZGVmLmNoZWNrcyxcXG4gICAgICAgICAge1xcbiAgICAgICAgICAgIGtpbmQsXFxuICAgICAgICAgICAgdmFsdWUsXFxuICAgICAgICAgICAgaW5jbHVzaXZlLFxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKVxcbiAgICAgICAgICB9XFxuICAgICAgICBdXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XFxuICAgICAgcmV0dXJuIG5ldyBfWm9kTnVtYmVyKHtcXG4gICAgICAgIC4uLnRoaXMuX2RlZixcXG4gICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIGludChtZXNzYWdlKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcXG4gICAgICAgIGtpbmQ6IFwiaW50XCIsXFxuICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICBwb3NpdGl2ZShtZXNzYWdlKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcXG4gICAgICAgIGtpbmQ6IFwibWluXCIsXFxuICAgICAgICB2YWx1ZTogMCxcXG4gICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXFxuICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICBuZWdhdGl2ZShtZXNzYWdlKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcXG4gICAgICAgIGtpbmQ6IFwibWF4XCIsXFxuICAgICAgICB2YWx1ZTogMCxcXG4gICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXFxuICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICBub25wb3NpdGl2ZShtZXNzYWdlKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcXG4gICAgICAgIGtpbmQ6IFwibWF4XCIsXFxuICAgICAgICB2YWx1ZTogMCxcXG4gICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIG5vbm5lZ2F0aXZlKG1lc3NhZ2UpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xcbiAgICAgICAga2luZDogXCJtaW5cIixcXG4gICAgICAgIHZhbHVlOiAwLFxcbiAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxcbiAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgbXVsdGlwbGVPZih2YWx1ZSwgbWVzc2FnZSkge1xcbiAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XFxuICAgICAgICBraW5kOiBcIm11bHRpcGxlT2ZcIixcXG4gICAgICAgIHZhbHVlLFxcbiAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgZmluaXRlKG1lc3NhZ2UpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xcbiAgICAgICAga2luZDogXCJmaW5pdGVcIixcXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIHNhZmUobWVzc2FnZSkge1xcbiAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XFxuICAgICAgICBraW5kOiBcIm1pblwiLFxcbiAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxcbiAgICAgICAgdmFsdWU6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSLFxcbiAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXFxuICAgICAgfSkuX2FkZENoZWNrKHtcXG4gICAgICAgIGtpbmQ6IFwibWF4XCIsXFxuICAgICAgICBpbmNsdXNpdmU6IHRydWUsXFxuICAgICAgICB2YWx1ZTogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXFxuICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICBnZXQgbWluVmFsdWUoKSB7XFxuICAgICAgbGV0IG1pbiA9IG51bGw7XFxuICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XFxuICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xcbiAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxcbiAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gbWluO1xcbiAgICB9XFxuICAgIGdldCBtYXhWYWx1ZSgpIHtcXG4gICAgICBsZXQgbWF4ID0gbnVsbDtcXG4gICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcXG4gICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XFxuICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXFxuICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBtYXg7XFxuICAgIH1cXG4gICAgZ2V0IGlzSW50KCkge1xcbiAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiaW50XCIgfHwgY2gua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIgJiYgdXRpbC5pc0ludGVnZXIoY2gudmFsdWUpKTtcXG4gICAgfVxcbiAgICBnZXQgaXNGaW5pdGUoKSB7XFxuICAgICAgbGV0IG1heCA9IG51bGwsIG1pbiA9IG51bGw7XFxuICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XFxuICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJmaW5pdGVcIiB8fCBjaC5raW5kID09PSBcImludFwiIHx8IGNoLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XFxuICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgfSBlbHNlIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XFxuICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXFxuICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XFxuICAgICAgICB9IGVsc2UgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcXG4gICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcXG4gICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShtaW4pICYmIE51bWJlci5pc0Zpbml0ZShtYXgpO1xcbiAgICB9XFxuICB9O1xcbiAgWm9kTnVtYmVyLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcXG4gICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xcbiAgICAgIGNoZWNrczogW10sXFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdW1iZXIsXFxuICAgICAgY29lcmNlOiAocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvZXJjZSkgfHwgZmFsc2UsXFxuICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXFxuICAgIH0pO1xcbiAgfTtcXG4gIHZhciBab2RCaWdJbnQgPSBjbGFzcyBfWm9kQmlnSW50IGV4dGVuZHMgWm9kVHlwZSB7XFxuICAgIGNvbnN0cnVjdG9yKCkge1xcbiAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XFxuICAgICAgdGhpcy5taW4gPSB0aGlzLmd0ZTtcXG4gICAgICB0aGlzLm1heCA9IHRoaXMubHRlO1xcbiAgICB9XFxuICAgIF9wYXJzZShpbnB1dCkge1xcbiAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICBpbnB1dC5kYXRhID0gQmlnSW50KGlucHV0LmRhdGEpO1xcbiAgICAgICAgfSBjYXRjaCAoX2EpIHtcXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEludmFsaWRJbnB1dChpbnB1dCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcXG4gICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5iaWdpbnQpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRJbnZhbGlkSW5wdXQoaW5wdXQpO1xcbiAgICAgIH1cXG4gICAgICBsZXQgY3R4ID0gdm9pZCAwO1xcbiAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xcbiAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xcbiAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcXG4gICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjaGVjay5pbmNsdXNpdmUgPyBpbnB1dC5kYXRhIDwgY2hlY2sudmFsdWUgOiBpbnB1dC5kYXRhIDw9IGNoZWNrLnZhbHVlO1xcbiAgICAgICAgICBpZiAodG9vU21hbGwpIHtcXG4gICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcXG4gICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXFxuICAgICAgICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxcbiAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXFxuICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XFxuICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGNoZWNrLmluY2x1c2l2ZSA/IGlucHV0LmRhdGEgPiBjaGVjay52YWx1ZSA6IGlucHV0LmRhdGEgPj0gY2hlY2sudmFsdWU7XFxuICAgICAgICAgIGlmICh0b29CaWcpIHtcXG4gICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcXG4gICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxcbiAgICAgICAgICAgICAgdHlwZTogXCJiaWdpbnRcIixcXG4gICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxcbiAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXFxuICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcXG4gICAgICAgICAgaWYgKGlucHV0LmRhdGEgJSBjaGVjay52YWx1ZSAhPT0gQmlnSW50KDApKSB7XFxuICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XFxuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XFxuICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mLFxcbiAgICAgICAgICAgICAgbXVsdGlwbGVPZjogY2hlY2sudmFsdWUsXFxuICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcXG4gICAgfVxcbiAgICBfZ2V0SW52YWxpZElucHV0KGlucHV0KSB7XFxuICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmJpZ2ludCxcXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxcbiAgICAgIH0pO1xcbiAgICAgIHJldHVybiBJTlZBTElEO1xcbiAgICB9XFxuICAgIGd0ZSh2YWx1ZSwgbWVzc2FnZSkge1xcbiAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xcbiAgICB9XFxuICAgIGd0KHZhbHVlLCBtZXNzYWdlKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xcbiAgICB9XFxuICAgIGx0ZSh2YWx1ZSwgbWVzc2FnZSkge1xcbiAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xcbiAgICB9XFxuICAgIGx0KHZhbHVlLCBtZXNzYWdlKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xcbiAgICB9XFxuICAgIHNldExpbWl0KGtpbmQsIHZhbHVlLCBpbmNsdXNpdmUsIG1lc3NhZ2UpIHtcXG4gICAgICByZXR1cm4gbmV3IF9ab2RCaWdJbnQoe1xcbiAgICAgICAgLi4udGhpcy5fZGVmLFxcbiAgICAgICAgY2hlY2tzOiBbXFxuICAgICAgICAgIC4uLnRoaXMuX2RlZi5jaGVja3MsXFxuICAgICAgICAgIHtcXG4gICAgICAgICAgICBraW5kLFxcbiAgICAgICAgICAgIHZhbHVlLFxcbiAgICAgICAgICAgIGluY2x1c2l2ZSxcXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcXG4gICAgICAgICAgfVxcbiAgICAgICAgXVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIF9hZGRDaGVjayhjaGVjaykge1xcbiAgICAgIHJldHVybiBuZXcgX1pvZEJpZ0ludCh7XFxuICAgICAgICAuLi50aGlzLl9kZWYsXFxuICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja11cXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICBwb3NpdGl2ZShtZXNzYWdlKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcXG4gICAgICAgIGtpbmQ6IFwibWluXCIsXFxuICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxcbiAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIG5lZ2F0aXZlKG1lc3NhZ2UpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xcbiAgICAgICAga2luZDogXCJtYXhcIixcXG4gICAgICAgIHZhbHVlOiBCaWdJbnQoMCksXFxuICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxcbiAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgbm9ucG9zaXRpdmUobWVzc2FnZSkge1xcbiAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XFxuICAgICAgICBraW5kOiBcIm1heFwiLFxcbiAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcXG4gICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIG5vbm5lZ2F0aXZlKG1lc3NhZ2UpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xcbiAgICAgICAga2luZDogXCJtaW5cIixcXG4gICAgICAgIHZhbHVlOiBCaWdJbnQoMCksXFxuICAgICAgICBpbmNsdXNpdmU6IHRydWUsXFxuICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICBtdWx0aXBsZU9mKHZhbHVlLCBtZXNzYWdlKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcXG4gICAgICAgIGtpbmQ6IFwibXVsdGlwbGVPZlwiLFxcbiAgICAgICAgdmFsdWUsXFxuICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICBnZXQgbWluVmFsdWUoKSB7XFxuICAgICAgbGV0IG1pbiA9IG51bGw7XFxuICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XFxuICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xcbiAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxcbiAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gbWluO1xcbiAgICB9XFxuICAgIGdldCBtYXhWYWx1ZSgpIHtcXG4gICAgICBsZXQgbWF4ID0gbnVsbDtcXG4gICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcXG4gICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XFxuICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXFxuICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBtYXg7XFxuICAgIH1cXG4gIH07XFxuICBab2RCaWdJbnQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xcbiAgICB2YXIgX2E7XFxuICAgIHJldHVybiBuZXcgWm9kQmlnSW50KHtcXG4gICAgICBjaGVja3M6IFtdLFxcbiAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQmlnSW50LFxcbiAgICAgIGNvZXJjZTogKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmNvZXJjZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UsXFxuICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXFxuICAgIH0pO1xcbiAgfTtcXG4gIHZhciBab2RCb29sZWFuID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcXG4gICAgX3BhcnNlKGlucHV0KSB7XFxuICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcXG4gICAgICAgIGlucHV0LmRhdGEgPSBCb29sZWFuKGlucHV0LmRhdGEpO1xcbiAgICAgIH1cXG4gICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XFxuICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuYm9vbGVhbikge1xcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XFxuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXFxuICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmJvb2xlYW4sXFxuICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxcbiAgICAgICAgfSk7XFxuICAgICAgICByZXR1cm4gSU5WQUxJRDtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xcbiAgICB9XFxuICB9O1xcbiAgWm9kQm9vbGVhbi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XFxuICAgIHJldHVybiBuZXcgWm9kQm9vbGVhbih7XFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCb29sZWFuLFxcbiAgICAgIGNvZXJjZTogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpIHx8IGZhbHNlLFxcbiAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxcbiAgICB9KTtcXG4gIH07XFxuICB2YXIgWm9kRGF0ZSA9IGNsYXNzIF9ab2REYXRlIGV4dGVuZHMgWm9kVHlwZSB7XFxuICAgIF9wYXJzZShpbnB1dCkge1xcbiAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XFxuICAgICAgICBpbnB1dC5kYXRhID0gbmV3IERhdGUoaW5wdXQuZGF0YSk7XFxuICAgICAgfVxcbiAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcXG4gICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5kYXRlKSB7XFxuICAgICAgICBjb25zdCBjdHgyID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4Miwge1xcbiAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxcbiAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5kYXRlLFxcbiAgICAgICAgICByZWNlaXZlZDogY3R4Mi5wYXJzZWRUeXBlXFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiBJTlZBTElEO1xcbiAgICAgIH1cXG4gICAgICBpZiAoaXNOYU4oaW5wdXQuZGF0YS5nZXRUaW1lKCkpKSB7XFxuICAgICAgICBjb25zdCBjdHgyID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4Miwge1xcbiAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9kYXRlXFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiBJTlZBTElEO1xcbiAgICAgIH1cXG4gICAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXMoKTtcXG4gICAgICBsZXQgY3R4ID0gdm9pZCAwO1xcbiAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xcbiAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcXG4gICAgICAgICAgaWYgKGlucHV0LmRhdGEuZ2V0VGltZSgpIDwgY2hlY2sudmFsdWUpIHtcXG4gICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcXG4gICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXFxuICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxcbiAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxcbiAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxcbiAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXFxuICAgICAgICAgICAgICB0eXBlOiBcImRhdGVcIlxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcXG4gICAgICAgICAgaWYgKGlucHV0LmRhdGEuZ2V0VGltZSgpID4gY2hlY2sudmFsdWUpIHtcXG4gICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcXG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcXG4gICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxcbiAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcXG4gICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcXG4gICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcXG4gICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxcbiAgICAgICAgICAgICAgdHlwZTogXCJkYXRlXCJcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBzdGF0dXM6IHN0YXR1cy52YWx1ZSxcXG4gICAgICAgIHZhbHVlOiBuZXcgRGF0ZShpbnB1dC5kYXRhLmdldFRpbWUoKSlcXG4gICAgICB9O1xcbiAgICB9XFxuICAgIF9hZGRDaGVjayhjaGVjaykge1xcbiAgICAgIHJldHVybiBuZXcgX1pvZERhdGUoe1xcbiAgICAgICAgLi4udGhpcy5fZGVmLFxcbiAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgbWluKG1pbkRhdGUsIG1lc3NhZ2UpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xcbiAgICAgICAga2luZDogXCJtaW5cIixcXG4gICAgICAgIHZhbHVlOiBtaW5EYXRlLmdldFRpbWUoKSxcXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIG1heChtYXhEYXRlLCBtZXNzYWdlKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcXG4gICAgICAgIGtpbmQ6IFwibWF4XCIsXFxuICAgICAgICB2YWx1ZTogbWF4RGF0ZS5nZXRUaW1lKCksXFxuICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICBnZXQgbWluRGF0ZSgpIHtcXG4gICAgICBsZXQgbWluID0gbnVsbDtcXG4gICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcXG4gICAgICAgIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XFxuICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXFxuICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBtaW4gIT0gbnVsbCA/IG5ldyBEYXRlKG1pbikgOiBudWxsO1xcbiAgICB9XFxuICAgIGdldCBtYXhEYXRlKCkge1xcbiAgICAgIGxldCBtYXggPSBudWxsO1xcbiAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xcbiAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcXG4gICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcXG4gICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgcmV0dXJuIG1heCAhPSBudWxsID8gbmV3IERhdGUobWF4KSA6IG51bGw7XFxuICAgIH1cXG4gIH07XFxuICBab2REYXRlLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcXG4gICAgcmV0dXJuIG5ldyBab2REYXRlKHtcXG4gICAgICBjaGVja3M6IFtdLFxcbiAgICAgIGNvZXJjZTogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpIHx8IGZhbHNlLFxcbiAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGF0ZSxcXG4gICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcXG4gICAgfSk7XFxuICB9O1xcbiAgdmFyIFpvZFN5bWJvbCA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XFxuICAgIF9wYXJzZShpbnB1dCkge1xcbiAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcXG4gICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zeW1ib2wpIHtcXG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcXG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xcbiAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxcbiAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5zeW1ib2wsXFxuICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxcbiAgICAgICAgfSk7XFxuICAgICAgICByZXR1cm4gSU5WQUxJRDtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xcbiAgICB9XFxuICB9O1xcbiAgWm9kU3ltYm9sLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcXG4gICAgcmV0dXJuIG5ldyBab2RTeW1ib2woe1xcbiAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU3ltYm9sLFxcbiAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxcbiAgICB9KTtcXG4gIH07XFxuICB2YXIgWm9kVW5kZWZpbmVkID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcXG4gICAgX3BhcnNlKGlucHV0KSB7XFxuICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xcbiAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XFxuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXFxuICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCxcXG4gICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiBJTlZBTElEO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XFxuICAgIH1cXG4gIH07XFxuICBab2RVbmRlZmluZWQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xcbiAgICByZXR1cm4gbmV3IFpvZFVuZGVmaW5lZCh7XFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmRlZmluZWQsXFxuICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXFxuICAgIH0pO1xcbiAgfTtcXG4gIHZhciBab2ROdWxsID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcXG4gICAgX3BhcnNlKGlucHV0KSB7XFxuICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xcbiAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm51bGwpIHtcXG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcXG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xcbiAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxcbiAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5udWxsLFxcbiAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcXG4gICAgfVxcbiAgfTtcXG4gIFpvZE51bGwuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xcbiAgICByZXR1cm4gbmV3IFpvZE51bGwoe1xcbiAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVsbCxcXG4gICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcXG4gICAgfSk7XFxuICB9O1xcbiAgdmFyIFpvZEFueSA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XFxuICAgIGNvbnN0cnVjdG9yKCkge1xcbiAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XFxuICAgICAgdGhpcy5fYW55ID0gdHJ1ZTtcXG4gICAgfVxcbiAgICBfcGFyc2UoaW5wdXQpIHtcXG4gICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XFxuICAgIH1cXG4gIH07XFxuICBab2RBbnkuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xcbiAgICByZXR1cm4gbmV3IFpvZEFueSh7XFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RBbnksXFxuICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXFxuICAgIH0pO1xcbiAgfTtcXG4gIHZhciBab2RVbmtub3duID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcXG4gICAgY29uc3RydWN0b3IoKSB7XFxuICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcXG4gICAgICB0aGlzLl91bmtub3duID0gdHJ1ZTtcXG4gICAgfVxcbiAgICBfcGFyc2UoaW5wdXQpIHtcXG4gICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XFxuICAgIH1cXG4gIH07XFxuICBab2RVbmtub3duLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcXG4gICAgcmV0dXJuIG5ldyBab2RVbmtub3duKHtcXG4gICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVua25vd24sXFxuICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXFxuICAgIH0pO1xcbiAgfTtcXG4gIHZhciBab2ROZXZlciA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XFxuICAgIF9wYXJzZShpbnB1dCkge1xcbiAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcXG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcXG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXFxuICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5uZXZlcixcXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxcbiAgICAgIH0pO1xcbiAgICAgIHJldHVybiBJTlZBTElEO1xcbiAgICB9XFxuICB9O1xcbiAgWm9kTmV2ZXIuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xcbiAgICByZXR1cm4gbmV3IFpvZE5ldmVyKHtcXG4gICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5ldmVyLFxcbiAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxcbiAgICB9KTtcXG4gIH07XFxuICB2YXIgWm9kVm9pZCA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XFxuICAgIF9wYXJzZShpbnB1dCkge1xcbiAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcXG4gICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcXG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcXG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xcbiAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxcbiAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS52b2lkLFxcbiAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcXG4gICAgfVxcbiAgfTtcXG4gIFpvZFZvaWQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xcbiAgICByZXR1cm4gbmV3IFpvZFZvaWQoe1xcbiAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVm9pZCxcXG4gICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcXG4gICAgfSk7XFxuICB9O1xcbiAgdmFyIFpvZEFycmF5ID0gY2xhc3MgX1pvZEFycmF5IGV4dGVuZHMgWm9kVHlwZSB7XFxuICAgIF9wYXJzZShpbnB1dCkge1xcbiAgICAgIGNvbnN0IHsgY3R4LCBzdGF0dXMgfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XFxuICAgICAgY29uc3QgZGVmID0gdGhpcy5fZGVmO1xcbiAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5hcnJheSkge1xcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XFxuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXFxuICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmFycmF5LFxcbiAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XFxuICAgICAgfVxcbiAgICAgIGlmIChkZWYuZXhhY3RMZW5ndGggIT09IG51bGwpIHtcXG4gICAgICAgIGNvbnN0IHRvb0JpZyA9IGN0eC5kYXRhLmxlbmd0aCA+IGRlZi5leGFjdExlbmd0aC52YWx1ZTtcXG4gICAgICAgIGNvbnN0IHRvb1NtYWxsID0gY3R4LmRhdGEubGVuZ3RoIDwgZGVmLmV4YWN0TGVuZ3RoLnZhbHVlO1xcbiAgICAgICAgaWYgKHRvb0JpZyB8fCB0b29TbWFsbCkge1xcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcXG4gICAgICAgICAgICBjb2RlOiB0b29CaWcgPyBab2RJc3N1ZUNvZGUudG9vX2JpZyA6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXFxuICAgICAgICAgICAgbWluaW11bTogdG9vU21hbGwgPyBkZWYuZXhhY3RMZW5ndGgudmFsdWUgOiB2b2lkIDAsXFxuICAgICAgICAgICAgbWF4aW11bTogdG9vQmlnID8gZGVmLmV4YWN0TGVuZ3RoLnZhbHVlIDogdm9pZCAwLFxcbiAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXFxuICAgICAgICAgICAgZXhhY3Q6IHRydWUsXFxuICAgICAgICAgICAgbWVzc2FnZTogZGVmLmV4YWN0TGVuZ3RoLm1lc3NhZ2VcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBpZiAoZGVmLm1pbkxlbmd0aCAhPT0gbnVsbCkge1xcbiAgICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA8IGRlZi5taW5MZW5ndGgudmFsdWUpIHtcXG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XFxuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcXG4gICAgICAgICAgICBtaW5pbXVtOiBkZWYubWluTGVuZ3RoLnZhbHVlLFxcbiAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXFxuICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5taW5MZW5ndGgubWVzc2FnZVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGlmIChkZWYubWF4TGVuZ3RoICE9PSBudWxsKSB7XFxuICAgICAgICBpZiAoY3R4LmRhdGEubGVuZ3RoID4gZGVmLm1heExlbmd0aC52YWx1ZSkge1xcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcXG4gICAgICAgICAgICBtYXhpbXVtOiBkZWYubWF4TGVuZ3RoLnZhbHVlLFxcbiAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXFxuICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5tYXhMZW5ndGgubWVzc2FnZVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XFxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoWy4uLmN0eC5kYXRhXS5tYXAoKGl0ZW0sIGkpID0+IHtcXG4gICAgICAgICAgcmV0dXJuIGRlZi50eXBlLl9wYXJzZUFzeW5jKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpO1xcbiAgICAgICAgfSkpLnRoZW4oKHJlc3VsdDIpID0+IHtcXG4gICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHQyKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgICBjb25zdCByZXN1bHQgPSBbLi4uY3R4LmRhdGFdLm1hcCgoaXRlbSwgaSkgPT4ge1xcbiAgICAgICAgcmV0dXJuIGRlZi50eXBlLl9wYXJzZVN5bmMobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpKSk7XFxuICAgICAgfSk7XFxuICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHQpO1xcbiAgICB9XFxuICAgIGdldCBlbGVtZW50KCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcXG4gICAgfVxcbiAgICBtaW4obWluTGVuZ3RoLCBtZXNzYWdlKSB7XFxuICAgICAgcmV0dXJuIG5ldyBfWm9kQXJyYXkoe1xcbiAgICAgICAgLi4udGhpcy5fZGVmLFxcbiAgICAgICAgbWluTGVuZ3RoOiB7IHZhbHVlOiBtaW5MZW5ndGgsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9XFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgbWF4KG1heExlbmd0aCwgbWVzc2FnZSkge1xcbiAgICAgIHJldHVybiBuZXcgX1pvZEFycmF5KHtcXG4gICAgICAgIC4uLnRoaXMuX2RlZixcXG4gICAgICAgIG1heExlbmd0aDogeyB2YWx1ZTogbWF4TGVuZ3RoLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIGxlbmd0aChsZW4sIG1lc3NhZ2UpIHtcXG4gICAgICByZXR1cm4gbmV3IF9ab2RBcnJheSh7XFxuICAgICAgICAuLi50aGlzLl9kZWYsXFxuICAgICAgICBleGFjdExlbmd0aDogeyB2YWx1ZTogbGVuLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIG5vbmVtcHR5KG1lc3NhZ2UpIHtcXG4gICAgICByZXR1cm4gdGhpcy5taW4oMSwgbWVzc2FnZSk7XFxuICAgIH1cXG4gIH07XFxuICBab2RBcnJheS5jcmVhdGUgPSAoc2NoZW1hLCBwYXJhbXMpID0+IHtcXG4gICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XFxuICAgICAgdHlwZTogc2NoZW1hLFxcbiAgICAgIG1pbkxlbmd0aDogbnVsbCxcXG4gICAgICBtYXhMZW5ndGg6IG51bGwsXFxuICAgICAgZXhhY3RMZW5ndGg6IG51bGwsXFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RBcnJheSxcXG4gICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcXG4gICAgfSk7XFxuICB9O1xcbiAgZnVuY3Rpb24gZGVlcFBhcnRpYWxpZnkoc2NoZW1hKSB7XFxuICAgIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RPYmplY3QpIHtcXG4gICAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5zaGFwZSkge1xcbiAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSBzY2hlbWEuc2hhcGVba2V5XTtcXG4gICAgICAgIG5ld1NoYXBlW2tleV0gPSBab2RPcHRpb25hbC5jcmVhdGUoZGVlcFBhcnRpYWxpZnkoZmllbGRTY2hlbWEpKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xcbiAgICAgICAgLi4uc2NoZW1hLl9kZWYsXFxuICAgICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGVcXG4gICAgICB9KTtcXG4gICAgfSBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RBcnJheSkge1xcbiAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xcbiAgICAgICAgLi4uc2NoZW1hLl9kZWYsXFxuICAgICAgICB0eXBlOiBkZWVwUGFydGlhbGlmeShzY2hlbWEuZWxlbWVudClcXG4gICAgICB9KTtcXG4gICAgfSBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xcbiAgICAgIHJldHVybiBab2RPcHRpb25hbC5jcmVhdGUoZGVlcFBhcnRpYWxpZnkoc2NoZW1hLnVud3JhcCgpKSk7XFxuICAgIH0gZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kTnVsbGFibGUpIHtcXG4gICAgICByZXR1cm4gWm9kTnVsbGFibGUuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS51bndyYXAoKSkpO1xcbiAgICB9IGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZFR1cGxlKSB7XFxuICAgICAgcmV0dXJuIFpvZFR1cGxlLmNyZWF0ZShzY2hlbWEuaXRlbXMubWFwKChpdGVtKSA9PiBkZWVwUGFydGlhbGlmeShpdGVtKSkpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBzY2hlbWE7XFxuICAgIH1cXG4gIH1cXG4gIHZhciBab2RPYmplY3QgPSBjbGFzcyBfWm9kT2JqZWN0IGV4dGVuZHMgWm9kVHlwZSB7XFxuICAgIGNvbnN0cnVjdG9yKCkge1xcbiAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XFxuICAgICAgdGhpcy5fY2FjaGVkID0gbnVsbDtcXG4gICAgICB0aGlzLm5vbnN0cmljdCA9IHRoaXMucGFzc3Rocm91Z2g7XFxuICAgICAgdGhpcy5hdWdtZW50ID0gdGhpcy5leHRlbmQ7XFxuICAgIH1cXG4gICAgX2dldENhY2hlZCgpIHtcXG4gICAgICBpZiAodGhpcy5fY2FjaGVkICE9PSBudWxsKVxcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZDtcXG4gICAgICBjb25zdCBzaGFwZSA9IHRoaXMuX2RlZi5zaGFwZSgpO1xcbiAgICAgIGNvbnN0IGtleXMgPSB1dGlsLm9iamVjdEtleXMoc2hhcGUpO1xcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZWQgPSB7IHNoYXBlLCBrZXlzIH07XFxuICAgIH1cXG4gICAgX3BhcnNlKGlucHV0KSB7XFxuICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xcbiAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xcbiAgICAgICAgY29uc3QgY3R4MiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcXG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eDIsIHtcXG4gICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcXG4gICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxcbiAgICAgICAgICByZWNlaXZlZDogY3R4Mi5wYXJzZWRUeXBlXFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiBJTlZBTElEO1xcbiAgICAgIH1cXG4gICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xcbiAgICAgIGNvbnN0IHsgc2hhcGUsIGtleXM6IHNoYXBlS2V5cyB9ID0gdGhpcy5fZ2V0Q2FjaGVkKCk7XFxuICAgICAgY29uc3QgZXh0cmFLZXlzID0gW107XFxuICAgICAgaWYgKCEodGhpcy5fZGVmLmNhdGNoYWxsIGluc3RhbmNlb2YgWm9kTmV2ZXIgJiYgdGhpcy5fZGVmLnVua25vd25LZXlzID09PSBcInN0cmlwXCIpKSB7XFxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjdHguZGF0YSkge1xcbiAgICAgICAgICBpZiAoIXNoYXBlS2V5cy5pbmNsdWRlcyhrZXkpKSB7XFxuICAgICAgICAgICAgZXh0cmFLZXlzLnB1c2goa2V5KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBjb25zdCBwYWlycyA9IFtdO1xcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIHNoYXBlS2V5cykge1xcbiAgICAgICAgY29uc3Qga2V5VmFsaWRhdG9yID0gc2hhcGVba2V5XTtcXG4gICAgICAgIGNvbnN0IHZhbHVlID0gY3R4LmRhdGFba2V5XTtcXG4gICAgICAgIHBhaXJzLnB1c2goe1xcbiAgICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBrZXkgfSxcXG4gICAgICAgICAgdmFsdWU6IGtleVZhbGlkYXRvci5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIHZhbHVlLCBjdHgucGF0aCwga2V5KSksXFxuICAgICAgICAgIGFsd2F5c1NldDoga2V5IGluIGN0eC5kYXRhXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgICAgaWYgKHRoaXMuX2RlZi5jYXRjaGFsbCBpbnN0YW5jZW9mIFpvZE5ldmVyKSB7XFxuICAgICAgICBjb25zdCB1bmtub3duS2V5cyA9IHRoaXMuX2RlZi51bmtub3duS2V5cztcXG4gICAgICAgIGlmICh1bmtub3duS2V5cyA9PT0gXCJwYXNzdGhyb3VnaFwiKSB7XFxuICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGV4dHJhS2V5cykge1xcbiAgICAgICAgICAgIHBhaXJzLnB1c2goe1xcbiAgICAgICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXFxuICAgICAgICAgICAgICB2YWx1ZTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGN0eC5kYXRhW2tleV0gfVxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2UgaWYgKHVua25vd25LZXlzID09PSBcInN0cmljdFwiKSB7XFxuICAgICAgICAgIGlmIChleHRyYUtleXMubGVuZ3RoID4gMCkge1xcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xcbiAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnVucmVjb2duaXplZF9rZXlzLFxcbiAgICAgICAgICAgICAga2V5czogZXh0cmFLZXlzXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSBpZiAodW5rbm93bktleXMgPT09IFwic3RyaXBcIikgO1xcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW50ZXJuYWwgWm9kT2JqZWN0IGVycm9yOiBpbnZhbGlkIHVua25vd25LZXlzIHZhbHVlLmApO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBjb25zdCBjYXRjaGFsbCA9IHRoaXMuX2RlZi5jYXRjaGFsbDtcXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGV4dHJhS2V5cykge1xcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGN0eC5kYXRhW2tleV07XFxuICAgICAgICAgIHBhaXJzLnB1c2goe1xcbiAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxcbiAgICAgICAgICAgIHZhbHVlOiBjYXRjaGFsbC5fcGFyc2UoXFxuICAgICAgICAgICAgICBuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgdmFsdWUsIGN0eC5wYXRoLCBrZXkpXFxuICAgICAgICAgICAgICAvLywgY3R4LmNoaWxkKGtleSksIHZhbHVlLCBnZXRQYXJzZWRUeXBlKHZhbHVlKVxcbiAgICAgICAgICAgICksXFxuICAgICAgICAgICAgYWx3YXlzU2V0OiBrZXkgaW4gY3R4LmRhdGFcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XFxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihhc3luYyAoKSA9PiB7XFxuICAgICAgICAgIGNvbnN0IHN5bmNQYWlycyA9IFtdO1xcbiAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBwYWlyLmtleTtcXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHBhaXIudmFsdWU7XFxuICAgICAgICAgICAgc3luY1BhaXJzLnB1c2goe1xcbiAgICAgICAgICAgICAga2V5LFxcbiAgICAgICAgICAgICAgdmFsdWUsXFxuICAgICAgICAgICAgICBhbHdheXNTZXQ6IHBhaXIuYWx3YXlzU2V0XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgcmV0dXJuIHN5bmNQYWlycztcXG4gICAgICAgIH0pLnRoZW4oKHN5bmNQYWlycykgPT4ge1xcbiAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgc3luY1BhaXJzKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBnZXQgc2hhcGUoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zaGFwZSgpO1xcbiAgICB9XFxuICAgIHN0cmljdChtZXNzYWdlKSB7XFxuICAgICAgZXJyb3JVdGlsLmVyclRvT2JqO1xcbiAgICAgIHJldHVybiBuZXcgX1pvZE9iamVjdCh7XFxuICAgICAgICAuLi50aGlzLl9kZWYsXFxuICAgICAgICB1bmtub3duS2V5czogXCJzdHJpY3RcIixcXG4gICAgICAgIC4uLm1lc3NhZ2UgIT09IHZvaWQgMCA/IHtcXG4gICAgICAgICAgZXJyb3JNYXA6IChpc3N1ZSwgY3R4KSA9PiB7XFxuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRFcnJvciA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuX2RlZikuZXJyb3JNYXApID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBpc3N1ZSwgY3R4KS5tZXNzYWdlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBjdHguZGVmYXVsdEVycm9yO1xcbiAgICAgICAgICAgIGlmIChpc3N1ZS5jb2RlID09PSBcInVucmVjb2duaXplZF9rZXlzXCIpXFxuICAgICAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAoX2QgPSBlcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkubWVzc2FnZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZGVmYXVsdEVycm9yXFxuICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICBtZXNzYWdlOiBkZWZhdWx0RXJyb3JcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IDoge31cXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICBzdHJpcCgpIHtcXG4gICAgICByZXR1cm4gbmV3IF9ab2RPYmplY3Qoe1xcbiAgICAgICAgLi4udGhpcy5fZGVmLFxcbiAgICAgICAgdW5rbm93bktleXM6IFwic3RyaXBcIlxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIHBhc3N0aHJvdWdoKCkge1xcbiAgICAgIHJldHVybiBuZXcgX1pvZE9iamVjdCh7XFxuICAgICAgICAuLi50aGlzLl9kZWYsXFxuICAgICAgICB1bmtub3duS2V5czogXCJwYXNzdGhyb3VnaFwiXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLy8gY29uc3QgQXVnbWVudEZhY3RvcnkgPVxcbiAgICAvLyAgIDxEZWYgZXh0ZW5kcyBab2RPYmplY3REZWY+KGRlZjogRGVmKSA9PlxcbiAgICAvLyAgIDxBdWdtZW50YXRpb24gZXh0ZW5kcyBab2RSYXdTaGFwZT4oXFxuICAgIC8vICAgICBhdWdtZW50YXRpb246IEF1Z21lbnRhdGlvblxcbiAgICAvLyAgICk6IFpvZE9iamVjdDxcXG4gICAgLy8gICAgIGV4dGVuZFNoYXBlPFJldHVyblR5cGU8RGVmW1wic2hhcGVcIl0+LCBBdWdtZW50YXRpb24+LFxcbiAgICAvLyAgICAgRGVmW1widW5rbm93bktleXNcIl0sXFxuICAgIC8vICAgICBEZWZbXCJjYXRjaGFsbFwiXVxcbiAgICAvLyAgID4gPT4ge1xcbiAgICAvLyAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xcbiAgICAvLyAgICAgICAuLi5kZWYsXFxuICAgIC8vICAgICAgIHNoYXBlOiAoKSA9PiAoe1xcbiAgICAvLyAgICAgICAgIC4uLmRlZi5zaGFwZSgpLFxcbiAgICAvLyAgICAgICAgIC4uLmF1Z21lbnRhdGlvbixcXG4gICAgLy8gICAgICAgfSksXFxuICAgIC8vICAgICB9KSBhcyBhbnk7XFxuICAgIC8vICAgfTtcXG4gICAgZXh0ZW5kKGF1Z21lbnRhdGlvbikge1xcbiAgICAgIHJldHVybiBuZXcgX1pvZE9iamVjdCh7XFxuICAgICAgICAuLi50aGlzLl9kZWYsXFxuICAgICAgICBzaGFwZTogKCkgPT4gKHtcXG4gICAgICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXFxuICAgICAgICAgIC4uLmF1Z21lbnRhdGlvblxcbiAgICAgICAgfSlcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogUHJpb3IgdG8gem9kQDEuMC4xMiB0aGVyZSB3YXMgYSBidWcgaW4gdGhlXFxuICAgICAqIGluZmVycmVkIHR5cGUgb2YgbWVyZ2VkIG9iamVjdHMuIFBsZWFzZVxcbiAgICAgKiB1cGdyYWRlIGlmIHlvdSBhcmUgZXhwZXJpZW5jaW5nIGlzc3Vlcy5cXG4gICAgICovXFxuICAgIG1lcmdlKG1lcmdpbmcpIHtcXG4gICAgICBjb25zdCBtZXJnZWQgPSBuZXcgX1pvZE9iamVjdCh7XFxuICAgICAgICB1bmtub3duS2V5czogbWVyZ2luZy5fZGVmLnVua25vd25LZXlzLFxcbiAgICAgICAgY2F0Y2hhbGw6IG1lcmdpbmcuX2RlZi5jYXRjaGFsbCxcXG4gICAgICAgIHNoYXBlOiAoKSA9PiAoe1xcbiAgICAgICAgICAuLi50aGlzLl9kZWYuc2hhcGUoKSxcXG4gICAgICAgICAgLi4ubWVyZ2luZy5fZGVmLnNoYXBlKClcXG4gICAgICAgIH0pLFxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3RcXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gbWVyZ2VkO1xcbiAgICB9XFxuICAgIC8vIG1lcmdlPFxcbiAgICAvLyAgIEluY29taW5nIGV4dGVuZHMgQW55Wm9kT2JqZWN0LFxcbiAgICAvLyAgIEF1Z21lbnRhdGlvbiBleHRlbmRzIEluY29taW5nW1wic2hhcGVcIl0sXFxuICAgIC8vICAgTmV3T3V0cHV0IGV4dGVuZHMge1xcbiAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgT3V0cHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxcbiAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9vdXRwdXRcIl1cXG4gICAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgT3V0cHV0XFxuICAgIC8vICAgICAgID8gT3V0cHV0W2tdXFxuICAgIC8vICAgICAgIDogbmV2ZXI7XFxuICAgIC8vICAgfSxcXG4gICAgLy8gICBOZXdJbnB1dCBleHRlbmRzIHtcXG4gICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIElucHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxcbiAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9pbnB1dFwiXVxcbiAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBJbnB1dFxcbiAgICAvLyAgICAgICA/IElucHV0W2tdXFxuICAgIC8vICAgICAgIDogbmV2ZXI7XFxuICAgIC8vICAgfVxcbiAgICAvLyA+KFxcbiAgICAvLyAgIG1lcmdpbmc6IEluY29taW5nXFxuICAgIC8vICk6IFpvZE9iamVjdDxcXG4gICAgLy8gICBleHRlbmRTaGFwZTxULCBSZXR1cm5UeXBlPEluY29taW5nW1wiX2RlZlwiXVtcInNoYXBlXCJdPj4sXFxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1widW5rbm93bktleXNcIl0sXFxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1wiY2F0Y2hhbGxcIl0sXFxuICAgIC8vICAgTmV3T3V0cHV0LFxcbiAgICAvLyAgIE5ld0lucHV0XFxuICAgIC8vID4ge1xcbiAgICAvLyAgIGNvbnN0IG1lcmdlZDogYW55ID0gbmV3IFpvZE9iamVjdCh7XFxuICAgIC8vICAgICB1bmtub3duS2V5czogbWVyZ2luZy5fZGVmLnVua25vd25LZXlzLFxcbiAgICAvLyAgICAgY2F0Y2hhbGw6IG1lcmdpbmcuX2RlZi5jYXRjaGFsbCxcXG4gICAgLy8gICAgIHNoYXBlOiAoKSA9PlxcbiAgICAvLyAgICAgICBvYmplY3RVdGlsLm1lcmdlU2hhcGVzKHRoaXMuX2RlZi5zaGFwZSgpLCBtZXJnaW5nLl9kZWYuc2hhcGUoKSksXFxuICAgIC8vICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcXG4gICAgLy8gICB9KSBhcyBhbnk7XFxuICAgIC8vICAgcmV0dXJuIG1lcmdlZDtcXG4gICAgLy8gfVxcbiAgICBzZXRLZXkoa2V5LCBzY2hlbWEpIHtcXG4gICAgICByZXR1cm4gdGhpcy5hdWdtZW50KHsgW2tleV06IHNjaGVtYSB9KTtcXG4gICAgfVxcbiAgICAvLyBtZXJnZTxJbmNvbWluZyBleHRlbmRzIEFueVpvZE9iamVjdD4oXFxuICAgIC8vICAgbWVyZ2luZzogSW5jb21pbmdcXG4gICAgLy8gKTogLy9ab2RPYmplY3Q8VCAmIEluY29taW5nW1wiX3NoYXBlXCJdLCBVbmtub3duS2V5cywgQ2F0Y2hhbGw+ID0gKG1lcmdpbmcpID0+IHtcXG4gICAgLy8gWm9kT2JqZWN0PFxcbiAgICAvLyAgIGV4dGVuZFNoYXBlPFQsIFJldHVyblR5cGU8SW5jb21pbmdbXCJfZGVmXCJdW1wic2hhcGVcIl0+PixcXG4gICAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJ1bmtub3duS2V5c1wiXSxcXG4gICAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJjYXRjaGFsbFwiXVxcbiAgICAvLyA+IHtcXG4gICAgLy8gICAvLyBjb25zdCBtZXJnZWRTaGFwZSA9IG9iamVjdFV0aWwubWVyZ2VTaGFwZXMoXFxuICAgIC8vICAgLy8gICB0aGlzLl9kZWYuc2hhcGUoKSxcXG4gICAgLy8gICAvLyAgIG1lcmdpbmcuX2RlZi5zaGFwZSgpXFxuICAgIC8vICAgLy8gKTtcXG4gICAgLy8gICBjb25zdCBtZXJnZWQ6IGFueSA9IG5ldyBab2RPYmplY3Qoe1xcbiAgICAvLyAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcXG4gICAgLy8gICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXFxuICAgIC8vICAgICBzaGFwZTogKCkgPT5cXG4gICAgLy8gICAgICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyh0aGlzLl9kZWYuc2hhcGUoKSwgbWVyZ2luZy5fZGVmLnNoYXBlKCkpLFxcbiAgICAvLyAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXFxuICAgIC8vICAgfSkgYXMgYW55O1xcbiAgICAvLyAgIHJldHVybiBtZXJnZWQ7XFxuICAgIC8vIH1cXG4gICAgY2F0Y2hhbGwoaW5kZXgyKSB7XFxuICAgICAgcmV0dXJuIG5ldyBfWm9kT2JqZWN0KHtcXG4gICAgICAgIC4uLnRoaXMuX2RlZixcXG4gICAgICAgIGNhdGNoYWxsOiBpbmRleDJcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICBwaWNrKG1hc2spIHtcXG4gICAgICBjb25zdCBzaGFwZSA9IHt9O1xcbiAgICAgIHV0aWwub2JqZWN0S2V5cyhtYXNrKS5mb3JFYWNoKChrZXkpID0+IHtcXG4gICAgICAgIGlmIChtYXNrW2tleV0gJiYgdGhpcy5zaGFwZVtrZXldKSB7XFxuICAgICAgICAgIHNoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAgcmV0dXJuIG5ldyBfWm9kT2JqZWN0KHtcXG4gICAgICAgIC4uLnRoaXMuX2RlZixcXG4gICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIG9taXQobWFzaykge1xcbiAgICAgIGNvbnN0IHNoYXBlID0ge307XFxuICAgICAgdXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpLmZvckVhY2goKGtleSkgPT4ge1xcbiAgICAgICAgaWYgKCFtYXNrW2tleV0pIHtcXG4gICAgICAgICAgc2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gbmV3IF9ab2RPYmplY3Qoe1xcbiAgICAgICAgLi4udGhpcy5fZGVmLFxcbiAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgLyoqXFxuICAgICAqIEBkZXByZWNhdGVkXFxuICAgICAqL1xcbiAgICBkZWVwUGFydGlhbCgpIHtcXG4gICAgICByZXR1cm4gZGVlcFBhcnRpYWxpZnkodGhpcyk7XFxuICAgIH1cXG4gICAgcGFydGlhbChtYXNrKSB7XFxuICAgICAgY29uc3QgbmV3U2hhcGUgPSB7fTtcXG4gICAgICB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkuZm9yRWFjaCgoa2V5KSA9PiB7XFxuICAgICAgICBjb25zdCBmaWVsZFNjaGVtYSA9IHRoaXMuc2hhcGVba2V5XTtcXG4gICAgICAgIGlmIChtYXNrICYmICFtYXNrW2tleV0pIHtcXG4gICAgICAgICAgbmV3U2hhcGVba2V5XSA9IGZpZWxkU2NoZW1hO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgbmV3U2hhcGVba2V5XSA9IGZpZWxkU2NoZW1hLm9wdGlvbmFsKCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAgcmV0dXJuIG5ldyBfWm9kT2JqZWN0KHtcXG4gICAgICAgIC4uLnRoaXMuX2RlZixcXG4gICAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIHJlcXVpcmVkKG1hc2spIHtcXG4gICAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xcbiAgICAgIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKS5mb3JFYWNoKChrZXkpID0+IHtcXG4gICAgICAgIGlmIChtYXNrICYmICFtYXNrW2tleV0pIHtcXG4gICAgICAgICAgbmV3U2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gdGhpcy5zaGFwZVtrZXldO1xcbiAgICAgICAgICBsZXQgbmV3RmllbGQgPSBmaWVsZFNjaGVtYTtcXG4gICAgICAgICAgd2hpbGUgKG5ld0ZpZWxkIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcXG4gICAgICAgICAgICBuZXdGaWVsZCA9IG5ld0ZpZWxkLl9kZWYuaW5uZXJUeXBlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBuZXdGaWVsZDtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gbmV3IF9ab2RPYmplY3Qoe1xcbiAgICAgICAgLi4udGhpcy5fZGVmLFxcbiAgICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAga2V5b2YoKSB7XFxuICAgICAgcmV0dXJuIGNyZWF0ZVpvZEVudW0odXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpKTtcXG4gICAgfVxcbiAgfTtcXG4gIFpvZE9iamVjdC5jcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XFxuICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxcbiAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXFxuICAgICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxcbiAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxcbiAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxcbiAgICB9KTtcXG4gIH07XFxuICBab2RPYmplY3Quc3RyaWN0Q3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcXG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xcbiAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcXG4gICAgICB1bmtub3duS2V5czogXCJzdHJpY3RcIixcXG4gICAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXFxuICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXFxuICAgIH0pO1xcbiAgfTtcXG4gIFpvZE9iamVjdC5sYXp5Y3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcXG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xcbiAgICAgIHNoYXBlLFxcbiAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXFxuICAgICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxcbiAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxcbiAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxcbiAgICB9KTtcXG4gIH07XFxuICB2YXIgWm9kVW5pb24gPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xcbiAgICBfcGFyc2UoaW5wdXQpIHtcXG4gICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcXG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fZGVmLm9wdGlvbnM7XFxuICAgICAgZnVuY3Rpb24gaGFuZGxlUmVzdWx0cyhyZXN1bHRzKSB7XFxuICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XFxuICAgICAgICAgIGlmIChyZXN1bHQucmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcXG4gICAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcXG4gICAgICAgICAgICBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKC4uLnJlc3VsdC5jdHguY29tbW9uLmlzc3Vlcyk7XFxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGNvbnN0IHVuaW9uRXJyb3JzID0gcmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4gbmV3IFpvZEVycm9yKHJlc3VsdC5jdHguY29tbW9uLmlzc3VlcykpO1xcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XFxuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uLFxcbiAgICAgICAgICB1bmlvbkVycm9yc1xcbiAgICAgICAgfSk7XFxuICAgICAgICByZXR1cm4gSU5WQUxJRDtcXG4gICAgICB9XFxuICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChvcHRpb25zLm1hcChhc3luYyAob3B0aW9uKSA9PiB7XFxuICAgICAgICAgIGNvbnN0IGNoaWxkQ3R4ID0ge1xcbiAgICAgICAgICAgIC4uLmN0eCxcXG4gICAgICAgICAgICBjb21tb246IHtcXG4gICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXFxuICAgICAgICAgICAgICBpc3N1ZXM6IFtdXFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBwYXJlbnQ6IG51bGxcXG4gICAgICAgICAgfTtcXG4gICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICByZXN1bHQ6IGF3YWl0IG9wdGlvbi5fcGFyc2VBc3luYyh7XFxuICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcXG4gICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxcbiAgICAgICAgICAgICAgcGFyZW50OiBjaGlsZEN0eFxcbiAgICAgICAgICAgIH0pLFxcbiAgICAgICAgICAgIGN0eDogY2hpbGRDdHhcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH0pKS50aGVuKGhhbmRsZVJlc3VsdHMpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBsZXQgZGlydHkgPSB2b2lkIDA7XFxuICAgICAgICBjb25zdCBpc3N1ZXMgPSBbXTtcXG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIG9wdGlvbnMpIHtcXG4gICAgICAgICAgY29uc3QgY2hpbGRDdHggPSB7XFxuICAgICAgICAgICAgLi4uY3R4LFxcbiAgICAgICAgICAgIGNvbW1vbjoge1xcbiAgICAgICAgICAgICAgLi4uY3R4LmNvbW1vbixcXG4gICAgICAgICAgICAgIGlzc3VlczogW11cXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIHBhcmVudDogbnVsbFxcbiAgICAgICAgICB9O1xcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBvcHRpb24uX3BhcnNlU3luYyh7XFxuICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXFxuICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXFxuICAgICAgICAgICAgcGFyZW50OiBjaGlsZEN0eFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIikge1xcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiICYmICFkaXJ0eSkge1xcbiAgICAgICAgICAgIGRpcnR5ID0geyByZXN1bHQsIGN0eDogY2hpbGRDdHggfTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAoY2hpbGRDdHguY29tbW9uLmlzc3Vlcy5sZW5ndGgpIHtcXG4gICAgICAgICAgICBpc3N1ZXMucHVzaChjaGlsZEN0eC5jb21tb24uaXNzdWVzKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKGRpcnR5KSB7XFxuICAgICAgICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goLi4uZGlydHkuY3R4LmNvbW1vbi5pc3N1ZXMpO1xcbiAgICAgICAgICByZXR1cm4gZGlydHkucmVzdWx0O1xcbiAgICAgICAgfVxcbiAgICAgICAgY29uc3QgdW5pb25FcnJvcnMgPSBpc3N1ZXMubWFwKChpc3N1ZXMyKSA9PiBuZXcgWm9kRXJyb3IoaXNzdWVzMikpO1xcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XFxuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uLFxcbiAgICAgICAgICB1bmlvbkVycm9yc1xcbiAgICAgICAgfSk7XFxuICAgICAgICByZXR1cm4gSU5WQUxJRDtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgZ2V0IG9wdGlvbnMoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vcHRpb25zO1xcbiAgICB9XFxuICB9O1xcbiAgWm9kVW5pb24uY3JlYXRlID0gKHR5cGVzLCBwYXJhbXMpID0+IHtcXG4gICAgcmV0dXJuIG5ldyBab2RVbmlvbih7XFxuICAgICAgb3B0aW9uczogdHlwZXMsXFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmlvbixcXG4gICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcXG4gICAgfSk7XFxuICB9O1xcbiAgdmFyIGdldERpc2NyaW1pbmF0b3IgPSAodHlwZSkgPT4ge1xcbiAgICBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZExhenkpIHtcXG4gICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnNjaGVtYSk7XFxuICAgIH0gZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZEVmZmVjdHMpIHtcXG4gICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLmlubmVyVHlwZSgpKTtcXG4gICAgfSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTGl0ZXJhbCkge1xcbiAgICAgIHJldHVybiBbdHlwZS52YWx1ZV07XFxuICAgIH0gZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZEVudW0pIHtcXG4gICAgICByZXR1cm4gdHlwZS5vcHRpb25zO1xcbiAgICB9IGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2ROYXRpdmVFbnVtKSB7XFxuICAgICAgcmV0dXJuIHV0aWwub2JqZWN0VmFsdWVzKHR5cGUuZW51bSk7XFxuICAgIH0gZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZERlZmF1bHQpIHtcXG4gICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLl9kZWYuaW5uZXJUeXBlKTtcXG4gICAgfSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kVW5kZWZpbmVkKSB7XFxuICAgICAgcmV0dXJuIFt2b2lkIDBdO1xcbiAgICB9IGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2ROdWxsKSB7XFxuICAgICAgcmV0dXJuIFtudWxsXTtcXG4gICAgfSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcXG4gICAgICByZXR1cm4gW3ZvaWQgMCwgLi4uZ2V0RGlzY3JpbWluYXRvcih0eXBlLnVud3JhcCgpKV07XFxuICAgIH0gZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE51bGxhYmxlKSB7XFxuICAgICAgcmV0dXJuIFtudWxsLCAuLi5nZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpXTtcXG4gICAgfSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kQnJhbmRlZCkge1xcbiAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpO1xcbiAgICB9IGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RSZWFkb25seSkge1xcbiAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpO1xcbiAgICB9IGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RDYXRjaCkge1xcbiAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuX2RlZi5pbm5lclR5cGUpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBbXTtcXG4gICAgfVxcbiAgfTtcXG4gIHZhciBab2REaXNjcmltaW5hdGVkVW5pb24gPSBjbGFzcyBfWm9kRGlzY3JpbWluYXRlZFVuaW9uIGV4dGVuZHMgWm9kVHlwZSB7XFxuICAgIF9wYXJzZShpbnB1dCkge1xcbiAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xcbiAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcXG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xcbiAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxcbiAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXFxuICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxcbiAgICAgICAgfSk7XFxuICAgICAgICByZXR1cm4gSU5WQUxJRDtcXG4gICAgICB9XFxuICAgICAgY29uc3QgZGlzY3JpbWluYXRvciA9IHRoaXMuZGlzY3JpbWluYXRvcjtcXG4gICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWUgPSBjdHguZGF0YVtkaXNjcmltaW5hdG9yXTtcXG4gICAgICBjb25zdCBvcHRpb24gPSB0aGlzLm9wdGlvbnNNYXAuZ2V0KGRpc2NyaW1pbmF0b3JWYWx1ZSk7XFxuICAgICAgaWYgKCFvcHRpb24pIHtcXG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xcbiAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yLFxcbiAgICAgICAgICBvcHRpb25zOiBBcnJheS5mcm9tKHRoaXMub3B0aW9uc01hcC5rZXlzKCkpLFxcbiAgICAgICAgICBwYXRoOiBbZGlzY3JpbWluYXRvcl1cXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XFxuICAgICAgfVxcbiAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XFxuICAgICAgICByZXR1cm4gb3B0aW9uLl9wYXJzZUFzeW5jKHtcXG4gICAgICAgICAgZGF0YTogY3R4LmRhdGEsXFxuICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxcbiAgICAgICAgICBwYXJlbnQ6IGN0eFxcbiAgICAgICAgfSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBvcHRpb24uX3BhcnNlU3luYyh7XFxuICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxcbiAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcXG4gICAgICAgICAgcGFyZW50OiBjdHhcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBnZXQgZGlzY3JpbWluYXRvcigpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fZGVmLmRpc2NyaW1pbmF0b3I7XFxuICAgIH1cXG4gICAgZ2V0IG9wdGlvbnMoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vcHRpb25zO1xcbiAgICB9XFxuICAgIGdldCBvcHRpb25zTWFwKCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9uc01hcDtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBkaXNjcmltaW5hdGVkIHVuaW9uIHNjaGVtYS4gSXRzIGJlaGF2aW91ciBpcyB2ZXJ5IHNpbWlsYXIgdG8gdGhhdCBvZiB0aGUgbm9ybWFsIHoudW5pb24oKSBjb25zdHJ1Y3Rvci5cXG4gICAgICogSG93ZXZlciwgaXQgb25seSBhbGxvd3MgYSB1bmlvbiBvZiBvYmplY3RzLCBhbGwgb2Ygd2hpY2ggbmVlZCB0byBzaGFyZSBhIGRpc2NyaW1pbmF0b3IgcHJvcGVydHkuIFRoaXMgcHJvcGVydHkgbXVzdFxcbiAgICAgKiBoYXZlIGEgZGlmZmVyZW50IHZhbHVlIGZvciBlYWNoIG9iamVjdCBpbiB0aGUgdW5pb24uXFxuICAgICAqIEBwYXJhbSBkaXNjcmltaW5hdG9yIHRoZSBuYW1lIG9mIHRoZSBkaXNjcmltaW5hdG9yIHByb3BlcnR5XFxuICAgICAqIEBwYXJhbSB0eXBlcyBhbiBhcnJheSBvZiBvYmplY3Qgc2NoZW1hc1xcbiAgICAgKiBAcGFyYW0gcGFyYW1zXFxuICAgICAqL1xcbiAgICBzdGF0aWMgY3JlYXRlKGRpc2NyaW1pbmF0b3IsIG9wdGlvbnMsIHBhcmFtcykge1xcbiAgICAgIGNvbnN0IG9wdGlvbnNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xcbiAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBvcHRpb25zKSB7XFxuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWVzID0gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnNoYXBlW2Rpc2NyaW1pbmF0b3JdKTtcXG4gICAgICAgIGlmICghZGlzY3JpbWluYXRvclZhbHVlcy5sZW5ndGgpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIGRpc2NyaW1pbmF0b3IgdmFsdWUgZm9yIGtleSBcXFxcYCR7ZGlzY3JpbWluYXRvcn1cXFxcYCBjb3VsZCBub3QgYmUgZXh0cmFjdGVkIGZyb20gYWxsIHNjaGVtYSBvcHRpb25zYCk7XFxuICAgICAgICB9XFxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGRpc2NyaW1pbmF0b3JWYWx1ZXMpIHtcXG4gICAgICAgICAgaWYgKG9wdGlvbnNNYXAuaGFzKHZhbHVlKSkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGlzY3JpbWluYXRvciBwcm9wZXJ0eSAke1N0cmluZyhkaXNjcmltaW5hdG9yKX0gaGFzIGR1cGxpY2F0ZSB2YWx1ZSAke1N0cmluZyh2YWx1ZSl9YCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgb3B0aW9uc01hcC5zZXQodmFsdWUsIHR5cGUpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gbmV3IF9ab2REaXNjcmltaW5hdGVkVW5pb24oe1xcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REaXNjcmltaW5hdGVkVW5pb24sXFxuICAgICAgICBkaXNjcmltaW5hdG9yLFxcbiAgICAgICAgb3B0aW9ucyxcXG4gICAgICAgIG9wdGlvbnNNYXAsXFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfTtcXG4gIGZ1bmN0aW9uIG1lcmdlVmFsdWVzKGEsIGIpIHtcXG4gICAgY29uc3QgYVR5cGUgPSBnZXRQYXJzZWRUeXBlKGEpO1xcbiAgICBjb25zdCBiVHlwZSA9IGdldFBhcnNlZFR5cGUoYik7XFxuICAgIGlmIChhID09PSBiKSB7XFxuICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IGEgfTtcXG4gICAgfSBlbHNlIGlmIChhVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5vYmplY3QgJiYgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XFxuICAgICAgY29uc3QgYktleXMgPSB1dGlsLm9iamVjdEtleXMoYik7XFxuICAgICAgY29uc3Qgc2hhcmVkS2V5cyA9IHV0aWwub2JqZWN0S2V5cyhhKS5maWx0ZXIoKGtleSkgPT4gYktleXMuaW5kZXhPZihrZXkpICE9PSAtMSk7XFxuICAgICAgY29uc3QgbmV3T2JqID0geyAuLi5hLCAuLi5iIH07XFxuICAgICAgZm9yIChjb25zdCBrZXkgb2Ygc2hhcmVkS2V5cykge1xcbiAgICAgICAgY29uc3Qgc2hhcmVkVmFsdWUgPSBtZXJnZVZhbHVlcyhhW2tleV0sIGJba2V5XSk7XFxuICAgICAgICBpZiAoIXNoYXJlZFZhbHVlLnZhbGlkKSB7XFxuICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xcbiAgICAgICAgfVxcbiAgICAgICAgbmV3T2JqW2tleV0gPSBzaGFyZWRWYWx1ZS5kYXRhO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogbmV3T2JqIH07XFxuICAgIH0gZWxzZSBpZiAoYVR5cGUgPT09IFpvZFBhcnNlZFR5cGUuYXJyYXkgJiYgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUuYXJyYXkpIHtcXG4gICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XFxuICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcXG4gICAgICB9XFxuICAgICAgY29uc3QgbmV3QXJyYXkgPSBbXTtcXG4gICAgICBmb3IgKGxldCBpbmRleDIgPSAwOyBpbmRleDIgPCBhLmxlbmd0aDsgaW5kZXgyKyspIHtcXG4gICAgICAgIGNvbnN0IGl0ZW1BID0gYVtpbmRleDJdO1xcbiAgICAgICAgY29uc3QgaXRlbUIgPSBiW2luZGV4Ml07XFxuICAgICAgICBjb25zdCBzaGFyZWRWYWx1ZSA9IG1lcmdlVmFsdWVzKGl0ZW1BLCBpdGVtQik7XFxuICAgICAgICBpZiAoIXNoYXJlZFZhbHVlLnZhbGlkKSB7XFxuICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xcbiAgICAgICAgfVxcbiAgICAgICAgbmV3QXJyYXkucHVzaChzaGFyZWRWYWx1ZS5kYXRhKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IG5ld0FycmF5IH07XFxuICAgIH0gZWxzZSBpZiAoYVR5cGUgPT09IFpvZFBhcnNlZFR5cGUuZGF0ZSAmJiBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5kYXRlICYmICthID09PSArYikge1xcbiAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XFxuICAgIH1cXG4gIH1cXG4gIHZhciBab2RJbnRlcnNlY3Rpb24gPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xcbiAgICBfcGFyc2UoaW5wdXQpIHtcXG4gICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xcbiAgICAgIGNvbnN0IGhhbmRsZVBhcnNlZCA9IChwYXJzZWRMZWZ0LCBwYXJzZWRSaWdodCkgPT4ge1xcbiAgICAgICAgaWYgKGlzQWJvcnRlZChwYXJzZWRMZWZ0KSB8fCBpc0Fib3J0ZWQocGFyc2VkUmlnaHQpKSB7XFxuICAgICAgICAgIHJldHVybiBJTlZBTElEO1xcbiAgICAgICAgfVxcbiAgICAgICAgY29uc3QgbWVyZ2VkID0gbWVyZ2VWYWx1ZXMocGFyc2VkTGVmdC52YWx1ZSwgcGFyc2VkUmlnaHQudmFsdWUpO1xcbiAgICAgICAgaWYgKCFtZXJnZWQudmFsaWQpIHtcXG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XFxuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChpc0RpcnR5KHBhcnNlZExlZnQpIHx8IGlzRGlydHkocGFyc2VkUmlnaHQpKSB7XFxuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBtZXJnZWQuZGF0YSB9O1xcbiAgICAgIH07XFxuICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXFxuICAgICAgICAgIHRoaXMuX2RlZi5sZWZ0Ll9wYXJzZUFzeW5jKHtcXG4gICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcXG4gICAgICAgICAgICBwYXJlbnQ6IGN0eFxcbiAgICAgICAgICB9KSxcXG4gICAgICAgICAgdGhpcy5fZGVmLnJpZ2h0Ll9wYXJzZUFzeW5jKHtcXG4gICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcXG4gICAgICAgICAgICBwYXJlbnQ6IGN0eFxcbiAgICAgICAgICB9KVxcbiAgICAgICAgXSkudGhlbigoW2xlZnQsIHJpZ2h0XSkgPT4gaGFuZGxlUGFyc2VkKGxlZnQsIHJpZ2h0KSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBoYW5kbGVQYXJzZWQodGhpcy5fZGVmLmxlZnQuX3BhcnNlU3luYyh7XFxuICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxcbiAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcXG4gICAgICAgICAgcGFyZW50OiBjdHhcXG4gICAgICAgIH0pLCB0aGlzLl9kZWYucmlnaHQuX3BhcnNlU3luYyh7XFxuICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxcbiAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcXG4gICAgICAgICAgcGFyZW50OiBjdHhcXG4gICAgICAgIH0pKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH07XFxuICBab2RJbnRlcnNlY3Rpb24uY3JlYXRlID0gKGxlZnQsIHJpZ2h0LCBwYXJhbXMpID0+IHtcXG4gICAgcmV0dXJuIG5ldyBab2RJbnRlcnNlY3Rpb24oe1xcbiAgICAgIGxlZnQsXFxuICAgICAgcmlnaHQsXFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RJbnRlcnNlY3Rpb24sXFxuICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXFxuICAgIH0pO1xcbiAgfTtcXG4gIHZhciBab2RUdXBsZSA9IGNsYXNzIF9ab2RUdXBsZSBleHRlbmRzIFpvZFR5cGUge1xcbiAgICBfcGFyc2UoaW5wdXQpIHtcXG4gICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xcbiAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5hcnJheSkge1xcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XFxuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXFxuICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmFycmF5LFxcbiAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XFxuICAgICAgfVxcbiAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPCB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoKSB7XFxuICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcXG4gICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcXG4gICAgICAgICAgbWluaW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcXG4gICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxcbiAgICAgICAgICBleGFjdDogZmFsc2UsXFxuICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIlxcbiAgICAgICAgfSk7XFxuICAgICAgICByZXR1cm4gSU5WQUxJRDtcXG4gICAgICB9XFxuICAgICAgY29uc3QgcmVzdCA9IHRoaXMuX2RlZi5yZXN0O1xcbiAgICAgIGlmICghcmVzdCAmJiBjdHguZGF0YS5sZW5ndGggPiB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoKSB7XFxuICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcXG4gICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXFxuICAgICAgICAgIG1heGltdW06IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgsXFxuICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcXG4gICAgICAgICAgZXhhY3Q6IGZhbHNlLFxcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCJcXG4gICAgICAgIH0pO1xcbiAgICAgICAgc3RhdHVzLmRpcnR5KCk7XFxuICAgICAgfVxcbiAgICAgIGNvbnN0IGl0ZW1zID0gWy4uLmN0eC5kYXRhXS5tYXAoKGl0ZW0sIGl0ZW1JbmRleCkgPT4ge1xcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5fZGVmLml0ZW1zW2l0ZW1JbmRleF0gfHwgdGhpcy5fZGVmLnJlc3Q7XFxuICAgICAgICBpZiAoIXNjaGVtYSlcXG4gICAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgICByZXR1cm4gc2NoZW1hLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGl0ZW1JbmRleCkpO1xcbiAgICAgIH0pLmZpbHRlcigoeCkgPT4gISF4KTtcXG4gICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGl0ZW1zKS50aGVuKChyZXN1bHRzKSA9PiB7XFxuICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0cyk7XFxuICAgICAgICB9KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCBpdGVtcyk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGdldCBpdGVtcygpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fZGVmLml0ZW1zO1xcbiAgICB9XFxuICAgIHJlc3QocmVzdCkge1xcbiAgICAgIHJldHVybiBuZXcgX1pvZFR1cGxlKHtcXG4gICAgICAgIC4uLnRoaXMuX2RlZixcXG4gICAgICAgIHJlc3RcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfTtcXG4gIFpvZFR1cGxlLmNyZWF0ZSA9IChzY2hlbWFzLCBwYXJhbXMpID0+IHtcXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYXMpKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3QgcGFzcyBhbiBhcnJheSBvZiBzY2hlbWFzIHRvIHoudHVwbGUoWyAuLi4gXSlcIik7XFxuICAgIH1cXG4gICAgcmV0dXJuIG5ldyBab2RUdXBsZSh7XFxuICAgICAgaXRlbXM6IHNjaGVtYXMsXFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RUdXBsZSxcXG4gICAgICByZXN0OiBudWxsLFxcbiAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxcbiAgICB9KTtcXG4gIH07XFxuICB2YXIgWm9kUmVjb3JkID0gY2xhc3MgX1pvZFJlY29yZCBleHRlbmRzIFpvZFR5cGUge1xcbiAgICBnZXQga2V5U2NoZW1hKCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcXG4gICAgfVxcbiAgICBnZXQgdmFsdWVTY2hlbWEoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XFxuICAgIH1cXG4gICAgX3BhcnNlKGlucHV0KSB7XFxuICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcXG4gICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XFxuICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcXG4gICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcXG4gICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxcbiAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XFxuICAgICAgfVxcbiAgICAgIGNvbnN0IHBhaXJzID0gW107XFxuICAgICAgY29uc3Qga2V5VHlwZSA9IHRoaXMuX2RlZi5rZXlUeXBlO1xcbiAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XFxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3R4LmRhdGEpIHtcXG4gICAgICAgIHBhaXJzLnB1c2goe1xcbiAgICAgICAgICBrZXk6IGtleVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBrZXksIGN0eC5wYXRoLCBrZXkpKSxcXG4gICAgICAgICAgdmFsdWU6IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGN0eC5kYXRhW2tleV0sIGN0eC5wYXRoLCBrZXkpKSxcXG4gICAgICAgICAgYWx3YXlzU2V0OiBrZXkgaW4gY3R4LmRhdGFcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xcbiAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0QXN5bmMoc3RhdHVzLCBwYWlycyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBwYWlycyk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGdldCBlbGVtZW50KCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVUeXBlO1xcbiAgICB9XFxuICAgIHN0YXRpYyBjcmVhdGUoZmlyc3QsIHNlY29uZCwgdGhpcmQpIHtcXG4gICAgICBpZiAoc2Vjb25kIGluc3RhbmNlb2YgWm9kVHlwZSkge1xcbiAgICAgICAgcmV0dXJuIG5ldyBfWm9kUmVjb3JkKHtcXG4gICAgICAgICAga2V5VHlwZTogZmlyc3QsXFxuICAgICAgICAgIHZhbHVlVHlwZTogc2Vjb25kLFxcbiAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFJlY29yZCxcXG4gICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlyZClcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gbmV3IF9ab2RSZWNvcmQoe1xcbiAgICAgICAga2V5VHlwZTogWm9kU3RyaW5nLmNyZWF0ZSgpLFxcbiAgICAgICAgdmFsdWVUeXBlOiBmaXJzdCxcXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVjb3JkLFxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhzZWNvbmQpXFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH07XFxuICB2YXIgWm9kTWFwID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcXG4gICAgZ2V0IGtleVNjaGVtYSgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fZGVmLmtleVR5cGU7XFxuICAgIH1cXG4gICAgZ2V0IHZhbHVlU2NoZW1hKCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVUeXBlO1xcbiAgICB9XFxuICAgIF9wYXJzZShpbnB1dCkge1xcbiAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XFxuICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm1hcCkge1xcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XFxuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXFxuICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm1hcCxcXG4gICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiBJTlZBTElEO1xcbiAgICAgIH1cXG4gICAgICBjb25zdCBrZXlUeXBlID0gdGhpcy5fZGVmLmtleVR5cGU7XFxuICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcXG4gICAgICBjb25zdCBwYWlycyA9IFsuLi5jdHguZGF0YS5lbnRyaWVzKCldLm1hcCgoW2tleSwgdmFsdWVdLCBpbmRleDIpID0+IHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIGtleToga2V5VHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGtleSwgY3R4LnBhdGgsIFtpbmRleDIsIFwia2V5XCJdKSksXFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIFtpbmRleDIsIFwidmFsdWVcIl0pKVxcbiAgICAgICAgfTtcXG4gICAgICB9KTtcXG4gICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xcbiAgICAgICAgY29uc3QgZmluYWxNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oYXN5bmMgKCkgPT4ge1xcbiAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBwYWlyLmtleTtcXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHBhaXIudmFsdWU7XFxuICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpIHtcXG4gICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XFxuICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgZmluYWxNYXAuc2V0KGtleS52YWx1ZSwgdmFsdWUudmFsdWUpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogZmluYWxNYXAgfTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBjb25zdCBmaW5hbE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XFxuICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcXG4gICAgICAgICAgY29uc3Qga2V5ID0gcGFpci5rZXk7XFxuICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFpci52YWx1ZTtcXG4gICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpIHtcXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XFxuICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgZmluYWxNYXAuc2V0KGtleS52YWx1ZSwgdmFsdWUudmFsdWUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE1hcCB9O1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfTtcXG4gIFpvZE1hcC5jcmVhdGUgPSAoa2V5VHlwZSwgdmFsdWVUeXBlLCBwYXJhbXMpID0+IHtcXG4gICAgcmV0dXJuIG5ldyBab2RNYXAoe1xcbiAgICAgIHZhbHVlVHlwZSxcXG4gICAgICBrZXlUeXBlLFxcbiAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTWFwLFxcbiAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxcbiAgICB9KTtcXG4gIH07XFxuICB2YXIgWm9kU2V0ID0gY2xhc3MgX1pvZFNldCBleHRlbmRzIFpvZFR5cGUge1xcbiAgICBfcGFyc2UoaW5wdXQpIHtcXG4gICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xcbiAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zZXQpIHtcXG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xcbiAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxcbiAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5zZXQsXFxuICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxcbiAgICAgICAgfSk7XFxuICAgICAgICByZXR1cm4gSU5WQUxJRDtcXG4gICAgICB9XFxuICAgICAgY29uc3QgZGVmID0gdGhpcy5fZGVmO1xcbiAgICAgIGlmIChkZWYubWluU2l6ZSAhPT0gbnVsbCkge1xcbiAgICAgICAgaWYgKGN0eC5kYXRhLnNpemUgPCBkZWYubWluU2l6ZS52YWx1ZSkge1xcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxcbiAgICAgICAgICAgIG1pbmltdW06IGRlZi5taW5TaXplLnZhbHVlLFxcbiAgICAgICAgICAgIHR5cGU6IFwic2V0XCIsXFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxcbiAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcXG4gICAgICAgICAgICBtZXNzYWdlOiBkZWYubWluU2l6ZS5tZXNzYWdlXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgaWYgKGRlZi5tYXhTaXplICE9PSBudWxsKSB7XFxuICAgICAgICBpZiAoY3R4LmRhdGEuc2l6ZSA+IGRlZi5tYXhTaXplLnZhbHVlKSB7XFxuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxcbiAgICAgICAgICAgIG1heGltdW06IGRlZi5tYXhTaXplLnZhbHVlLFxcbiAgICAgICAgICAgIHR5cGU6IFwic2V0XCIsXFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxcbiAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcXG4gICAgICAgICAgICBtZXNzYWdlOiBkZWYubWF4U2l6ZS5tZXNzYWdlXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcXG4gICAgICBmdW5jdGlvbiBmaW5hbGl6ZVNldChlbGVtZW50czIpIHtcXG4gICAgICAgIGNvbnN0IHBhcnNlZFNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XFxuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMyKSB7XFxuICAgICAgICAgIGlmIChlbGVtZW50LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXFxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XFxuICAgICAgICAgIGlmIChlbGVtZW50LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxcbiAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xcbiAgICAgICAgICBwYXJzZWRTZXQuYWRkKGVsZW1lbnQudmFsdWUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBwYXJzZWRTZXQgfTtcXG4gICAgICB9XFxuICAgICAgY29uc3QgZWxlbWVudHMgPSBbLi4uY3R4LmRhdGEudmFsdWVzKCldLm1hcCgoaXRlbSwgaSkgPT4gdmFsdWVUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKSk7XFxuICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChlbGVtZW50cykudGhlbigoZWxlbWVudHMyKSA9PiBmaW5hbGl6ZVNldChlbGVtZW50czIpKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0dXJuIGZpbmFsaXplU2V0KGVsZW1lbnRzKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgbWluKG1pblNpemUsIG1lc3NhZ2UpIHtcXG4gICAgICByZXR1cm4gbmV3IF9ab2RTZXQoe1xcbiAgICAgICAgLi4udGhpcy5fZGVmLFxcbiAgICAgICAgbWluU2l6ZTogeyB2YWx1ZTogbWluU2l6ZSwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH1cXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICBtYXgobWF4U2l6ZSwgbWVzc2FnZSkge1xcbiAgICAgIHJldHVybiBuZXcgX1pvZFNldCh7XFxuICAgICAgICAuLi50aGlzLl9kZWYsXFxuICAgICAgICBtYXhTaXplOiB7IHZhbHVlOiBtYXhTaXplLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIHNpemUoc2l6ZTUsIG1lc3NhZ2UpIHtcXG4gICAgICByZXR1cm4gdGhpcy5taW4oc2l6ZTUsIG1lc3NhZ2UpLm1heChzaXplNSwgbWVzc2FnZSk7XFxuICAgIH1cXG4gICAgbm9uZW1wdHkobWVzc2FnZSkge1xcbiAgICAgIHJldHVybiB0aGlzLm1pbigxLCBtZXNzYWdlKTtcXG4gICAgfVxcbiAgfTtcXG4gIFpvZFNldC5jcmVhdGUgPSAodmFsdWVUeXBlLCBwYXJhbXMpID0+IHtcXG4gICAgcmV0dXJuIG5ldyBab2RTZXQoe1xcbiAgICAgIHZhbHVlVHlwZSxcXG4gICAgICBtaW5TaXplOiBudWxsLFxcbiAgICAgIG1heFNpemU6IG51bGwsXFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTZXQsXFxuICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXFxuICAgIH0pO1xcbiAgfTtcXG4gIHZhciBab2RGdW5jdGlvbiA9IGNsYXNzIF9ab2RGdW5jdGlvbiBleHRlbmRzIFpvZFR5cGUge1xcbiAgICBjb25zdHJ1Y3RvcigpIHtcXG4gICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xcbiAgICAgIHRoaXMudmFsaWRhdGUgPSB0aGlzLmltcGxlbWVudDtcXG4gICAgfVxcbiAgICBfcGFyc2UoaW5wdXQpIHtcXG4gICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcXG4gICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuZnVuY3Rpb24pIHtcXG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xcbiAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxcbiAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5mdW5jdGlvbixcXG4gICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiBJTlZBTElEO1xcbiAgICAgIH1cXG4gICAgICBmdW5jdGlvbiBtYWtlQXJnc0lzc3VlKGFyZ3MsIGVycm9yKSB7XFxuICAgICAgICByZXR1cm4gbWFrZUlzc3VlKHtcXG4gICAgICAgICAgZGF0YTogYXJncyxcXG4gICAgICAgICAgcGF0aDogY3R4LnBhdGgsXFxuICAgICAgICAgIGVycm9yTWFwczogW1xcbiAgICAgICAgICAgIGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLFxcbiAgICAgICAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCxcXG4gICAgICAgICAgICBnZXRFcnJvck1hcCgpLFxcbiAgICAgICAgICAgIGVycm9yTWFwXFxuICAgICAgICAgIF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxcbiAgICAgICAgICBpc3N1ZURhdGE6IHtcXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9hcmd1bWVudHMsXFxuICAgICAgICAgICAgYXJndW1lbnRzRXJyb3I6IGVycm9yXFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgICBmdW5jdGlvbiBtYWtlUmV0dXJuc0lzc3VlKHJldHVybnMsIGVycm9yKSB7XFxuICAgICAgICByZXR1cm4gbWFrZUlzc3VlKHtcXG4gICAgICAgICAgZGF0YTogcmV0dXJucyxcXG4gICAgICAgICAgcGF0aDogY3R4LnBhdGgsXFxuICAgICAgICAgIGVycm9yTWFwczogW1xcbiAgICAgICAgICAgIGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLFxcbiAgICAgICAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCxcXG4gICAgICAgICAgICBnZXRFcnJvck1hcCgpLFxcbiAgICAgICAgICAgIGVycm9yTWFwXFxuICAgICAgICAgIF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxcbiAgICAgICAgICBpc3N1ZURhdGE6IHtcXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9yZXR1cm5fdHlwZSxcXG4gICAgICAgICAgICByZXR1cm5UeXBlRXJyb3I6IGVycm9yXFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgICBjb25zdCBwYXJhbXMgPSB7IGVycm9yTWFwOiBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCB9O1xcbiAgICAgIGNvbnN0IGZuID0gY3R4LmRhdGE7XFxuICAgICAgaWYgKHRoaXMuX2RlZi5yZXR1cm5zIGluc3RhbmNlb2YgWm9kUHJvbWlzZSkge1xcbiAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xcbiAgICAgICAgcmV0dXJuIE9LKGFzeW5jIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcXG4gICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgWm9kRXJyb3IoW10pO1xcbiAgICAgICAgICBjb25zdCBwYXJzZWRBcmdzID0gYXdhaXQgbWUuX2RlZi5hcmdzLnBhcnNlQXN5bmMoYXJncywgcGFyYW1zKS5jYXRjaCgoZSkgPT4ge1xcbiAgICAgICAgICAgIGVycm9yLmFkZElzc3VlKG1ha2VBcmdzSXNzdWUoYXJncywgZSkpO1xcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUmVmbGVjdC5hcHBseShmbiwgdGhpcywgcGFyc2VkQXJncyk7XFxuICAgICAgICAgIGNvbnN0IHBhcnNlZFJldHVybnMgPSBhd2FpdCBtZS5fZGVmLnJldHVybnMuX2RlZi50eXBlLnBhcnNlQXN5bmMocmVzdWx0LCBwYXJhbXMpLmNhdGNoKChlKSA9PiB7XFxuICAgICAgICAgICAgZXJyb3IuYWRkSXNzdWUobWFrZVJldHVybnNJc3N1ZShyZXN1bHQsIGUpKTtcXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIHJldHVybiBwYXJzZWRSZXR1cm5zO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGNvbnN0IG1lID0gdGhpcztcXG4gICAgICAgIHJldHVybiBPSyhmdW5jdGlvbiguLi5hcmdzKSB7XFxuICAgICAgICAgIGNvbnN0IHBhcnNlZEFyZ3MgPSBtZS5fZGVmLmFyZ3Muc2FmZVBhcnNlKGFyZ3MsIHBhcmFtcyk7XFxuICAgICAgICAgIGlmICghcGFyc2VkQXJncy5zdWNjZXNzKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IFpvZEVycm9yKFttYWtlQXJnc0lzc3VlKGFyZ3MsIHBhcnNlZEFyZ3MuZXJyb3IpXSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5hcHBseShmbiwgdGhpcywgcGFyc2VkQXJncy5kYXRhKTtcXG4gICAgICAgICAgY29uc3QgcGFyc2VkUmV0dXJucyA9IG1lLl9kZWYucmV0dXJucy5zYWZlUGFyc2UocmVzdWx0LCBwYXJhbXMpO1xcbiAgICAgICAgICBpZiAoIXBhcnNlZFJldHVybnMuc3VjY2Vzcykge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBab2RFcnJvcihbbWFrZVJldHVybnNJc3N1ZShyZXN1bHQsIHBhcnNlZFJldHVybnMuZXJyb3IpXSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgcmV0dXJuIHBhcnNlZFJldHVybnMuZGF0YTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBwYXJhbWV0ZXJzKCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9kZWYuYXJncztcXG4gICAgfVxcbiAgICByZXR1cm5UeXBlKCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9kZWYucmV0dXJucztcXG4gICAgfVxcbiAgICBhcmdzKC4uLml0ZW1zKSB7XFxuICAgICAgcmV0dXJuIG5ldyBfWm9kRnVuY3Rpb24oe1xcbiAgICAgICAgLi4udGhpcy5fZGVmLFxcbiAgICAgICAgYXJnczogWm9kVHVwbGUuY3JlYXRlKGl0ZW1zKS5yZXN0KFpvZFVua25vd24uY3JlYXRlKCkpXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgcmV0dXJucyhyZXR1cm5UeXBlKSB7XFxuICAgICAgcmV0dXJuIG5ldyBfWm9kRnVuY3Rpb24oe1xcbiAgICAgICAgLi4udGhpcy5fZGVmLFxcbiAgICAgICAgcmV0dXJuczogcmV0dXJuVHlwZVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIGltcGxlbWVudChmdW5jKSB7XFxuICAgICAgY29uc3QgdmFsaWRhdGVkRnVuYyA9IHRoaXMucGFyc2UoZnVuYyk7XFxuICAgICAgcmV0dXJuIHZhbGlkYXRlZEZ1bmM7XFxuICAgIH1cXG4gICAgc3RyaWN0SW1wbGVtZW50KGZ1bmMpIHtcXG4gICAgICBjb25zdCB2YWxpZGF0ZWRGdW5jID0gdGhpcy5wYXJzZShmdW5jKTtcXG4gICAgICByZXR1cm4gdmFsaWRhdGVkRnVuYztcXG4gICAgfVxcbiAgICBzdGF0aWMgY3JlYXRlKGFyZ3MsIHJldHVybnMsIHBhcmFtcykge1xcbiAgICAgIHJldHVybiBuZXcgX1pvZEZ1bmN0aW9uKHtcXG4gICAgICAgIGFyZ3M6IGFyZ3MgPyBhcmdzIDogWm9kVHVwbGUuY3JlYXRlKFtdKS5yZXN0KFpvZFVua25vd24uY3JlYXRlKCkpLFxcbiAgICAgICAgcmV0dXJuczogcmV0dXJucyB8fCBab2RVbmtub3duLmNyZWF0ZSgpLFxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RGdW5jdGlvbixcXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9O1xcbiAgdmFyIFpvZExhenkgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xcbiAgICBnZXQgc2NoZW1hKCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9kZWYuZ2V0dGVyKCk7XFxuICAgIH1cXG4gICAgX3BhcnNlKGlucHV0KSB7XFxuICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XFxuICAgICAgY29uc3QgbGF6eVNjaGVtYSA9IHRoaXMuX2RlZi5nZXR0ZXIoKTtcXG4gICAgICByZXR1cm4gbGF6eVNjaGVtYS5fcGFyc2UoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pO1xcbiAgICB9XFxuICB9O1xcbiAgWm9kTGF6eS5jcmVhdGUgPSAoZ2V0dGVyLCBwYXJhbXMpID0+IHtcXG4gICAgcmV0dXJuIG5ldyBab2RMYXp5KHtcXG4gICAgICBnZXR0ZXIsXFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RMYXp5LFxcbiAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxcbiAgICB9KTtcXG4gIH07XFxuICB2YXIgWm9kTGl0ZXJhbCA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XFxuICAgIF9wYXJzZShpbnB1dCkge1xcbiAgICAgIGlmIChpbnB1dC5kYXRhICE9PSB0aGlzLl9kZWYudmFsdWUpIHtcXG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcXG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xcbiAgICAgICAgICByZWNlaXZlZDogY3R4LmRhdGEsXFxuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWwsXFxuICAgICAgICAgIGV4cGVjdGVkOiB0aGlzLl9kZWYudmFsdWVcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xcbiAgICB9XFxuICAgIGdldCB2YWx1ZSgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlO1xcbiAgICB9XFxuICB9O1xcbiAgWm9kTGl0ZXJhbC5jcmVhdGUgPSAodmFsdWUsIHBhcmFtcykgPT4ge1xcbiAgICByZXR1cm4gbmV3IFpvZExpdGVyYWwoe1xcbiAgICAgIHZhbHVlLFxcbiAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTGl0ZXJhbCxcXG4gICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcXG4gICAgfSk7XFxuICB9O1xcbiAgZnVuY3Rpb24gY3JlYXRlWm9kRW51bSh2YWx1ZXMsIHBhcmFtcykge1xcbiAgICByZXR1cm4gbmV3IFpvZEVudW0oe1xcbiAgICAgIHZhbHVlcyxcXG4gICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVudW0sXFxuICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXFxuICAgIH0pO1xcbiAgfVxcbiAgdmFyIFpvZEVudW0gPSBjbGFzcyBfWm9kRW51bSBleHRlbmRzIFpvZFR5cGUge1xcbiAgICBjb25zdHJ1Y3RvcigpIHtcXG4gICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xcbiAgICAgIF9ab2RFbnVtX2NhY2hlLnNldCh0aGlzLCB2b2lkIDApO1xcbiAgICB9XFxuICAgIF9wYXJzZShpbnB1dCkge1xcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQuZGF0YSAhPT0gXCJzdHJpbmdcIikge1xcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB0aGlzLl9kZWYudmFsdWVzO1xcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XFxuICAgICAgICAgIGV4cGVjdGVkOiB1dGlsLmpvaW5WYWx1ZXMoZXhwZWN0ZWRWYWx1ZXMpLFxcbiAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXFxuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGVcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XFxuICAgICAgfVxcbiAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfWm9kRW51bV9jYWNoZSwgXCJmXCIpKSB7XFxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9ab2RFbnVtX2NhY2hlLCBuZXcgU2V0KHRoaXMuX2RlZi52YWx1ZXMpLCBcImZcIik7XFxuICAgICAgfVxcbiAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfWm9kRW51bV9jYWNoZSwgXCJmXCIpLmhhcyhpbnB1dC5kYXRhKSkge1xcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB0aGlzLl9kZWYudmFsdWVzO1xcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XFxuICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcXG4gICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfZW51bV92YWx1ZSxcXG4gICAgICAgICAgb3B0aW9uczogZXhwZWN0ZWRWYWx1ZXNcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcXG4gICAgfVxcbiAgICBnZXQgb3B0aW9ucygpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlcztcXG4gICAgfVxcbiAgICBnZXQgZW51bSgpIHtcXG4gICAgICBjb25zdCBlbnVtVmFsdWVzID0ge307XFxuICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xcbiAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gZW51bVZhbHVlcztcXG4gICAgfVxcbiAgICBnZXQgVmFsdWVzKCkge1xcbiAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcXG4gICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XFxuICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xcbiAgICB9XFxuICAgIGdldCBFbnVtKCkge1xcbiAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcXG4gICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XFxuICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xcbiAgICB9XFxuICAgIGV4dHJhY3QodmFsdWVzLCBuZXdEZWYgPSB0aGlzLl9kZWYpIHtcXG4gICAgICByZXR1cm4gX1pvZEVudW0uY3JlYXRlKHZhbHVlcywge1xcbiAgICAgICAgLi4udGhpcy5fZGVmLFxcbiAgICAgICAgLi4ubmV3RGVmXFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgZXhjbHVkZSh2YWx1ZXMsIG5ld0RlZiA9IHRoaXMuX2RlZikge1xcbiAgICAgIHJldHVybiBfWm9kRW51bS5jcmVhdGUodGhpcy5vcHRpb25zLmZpbHRlcigob3B0KSA9PiAhdmFsdWVzLmluY2x1ZGVzKG9wdCkpLCB7XFxuICAgICAgICAuLi50aGlzLl9kZWYsXFxuICAgICAgICAuLi5uZXdEZWZcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfTtcXG4gIF9ab2RFbnVtX2NhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XFxuICBab2RFbnVtLmNyZWF0ZSA9IGNyZWF0ZVpvZEVudW07XFxuICB2YXIgWm9kTmF0aXZlRW51bSA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XFxuICAgIGNvbnN0cnVjdG9yKCkge1xcbiAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XFxuICAgICAgX1pvZE5hdGl2ZUVudW1fY2FjaGUuc2V0KHRoaXMsIHZvaWQgMCk7XFxuICAgIH1cXG4gICAgX3BhcnNlKGlucHV0KSB7XFxuICAgICAgY29uc3QgbmF0aXZlRW51bVZhbHVlcyA9IHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzKHRoaXMuX2RlZi52YWx1ZXMpO1xcbiAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcXG4gICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc3RyaW5nICYmIGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm51bWJlcikge1xcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB1dGlsLm9iamVjdFZhbHVlcyhuYXRpdmVFbnVtVmFsdWVzKTtcXG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xcbiAgICAgICAgICBleHBlY3RlZDogdXRpbC5qb2luVmFsdWVzKGV4cGVjdGVkVmFsdWVzKSxcXG4gICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxcbiAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlXFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiBJTlZBTElEO1xcbiAgICAgIH1cXG4gICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1pvZE5hdGl2ZUVudW1fY2FjaGUsIFwiZlwiKSkge1xcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfWm9kTmF0aXZlRW51bV9jYWNoZSwgbmV3IFNldCh1dGlsLmdldFZhbGlkRW51bVZhbHVlcyh0aGlzLl9kZWYudmFsdWVzKSksIFwiZlwiKTtcXG4gICAgICB9XFxuICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9ab2ROYXRpdmVFbnVtX2NhY2hlLCBcImZcIikuaGFzKGlucHV0LmRhdGEpKSB7XFxuICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHV0aWwub2JqZWN0VmFsdWVzKG5hdGl2ZUVudW1WYWx1ZXMpO1xcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XFxuICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcXG4gICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfZW51bV92YWx1ZSxcXG4gICAgICAgICAgb3B0aW9uczogZXhwZWN0ZWRWYWx1ZXNcXG4gICAgICAgIH0pO1xcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcXG4gICAgfVxcbiAgICBnZXQgZW51bSgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlcztcXG4gICAgfVxcbiAgfTtcXG4gIF9ab2ROYXRpdmVFbnVtX2NhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XFxuICBab2ROYXRpdmVFbnVtLmNyZWF0ZSA9ICh2YWx1ZXMsIHBhcmFtcykgPT4ge1xcbiAgICByZXR1cm4gbmV3IFpvZE5hdGl2ZUVudW0oe1xcbiAgICAgIHZhbHVlcyxcXG4gICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5hdGl2ZUVudW0sXFxuICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXFxuICAgIH0pO1xcbiAgfTtcXG4gIHZhciBab2RQcm9taXNlID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcXG4gICAgdW53cmFwKCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcXG4gICAgfVxcbiAgICBfcGFyc2UoaW5wdXQpIHtcXG4gICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcXG4gICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUucHJvbWlzZSAmJiBjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XFxuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXFxuICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnByb21pc2UsXFxuICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxcbiAgICAgICAgfSk7XFxuICAgICAgICByZXR1cm4gSU5WQUxJRDtcXG4gICAgICB9XFxuICAgICAgY29uc3QgcHJvbWlzaWZpZWQgPSBjdHgucGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5wcm9taXNlID8gY3R4LmRhdGEgOiBQcm9taXNlLnJlc29sdmUoY3R4LmRhdGEpO1xcbiAgICAgIHJldHVybiBPSyhwcm9taXNpZmllZC50aGVuKChkYXRhKSA9PiB7XFxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGUucGFyc2VBc3luYyhkYXRhLCB7XFxuICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxcbiAgICAgICAgICBlcnJvck1hcDogY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXBcXG4gICAgICAgIH0pO1xcbiAgICAgIH0pKTtcXG4gICAgfVxcbiAgfTtcXG4gIFpvZFByb21pc2UuY3JlYXRlID0gKHNjaGVtYSwgcGFyYW1zKSA9PiB7XFxuICAgIHJldHVybiBuZXcgWm9kUHJvbWlzZSh7XFxuICAgICAgdHlwZTogc2NoZW1hLFxcbiAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUHJvbWlzZSxcXG4gICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcXG4gICAgfSk7XFxuICB9O1xcbiAgdmFyIFpvZEVmZmVjdHMgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xcbiAgICBpbm5lclR5cGUoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWE7XFxuICAgIH1cXG4gICAgc291cmNlVHlwZSgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYS5fZGVmLnR5cGVOYW1lID09PSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyA/IHRoaXMuX2RlZi5zY2hlbWEuc291cmNlVHlwZSgpIDogdGhpcy5fZGVmLnNjaGVtYTtcXG4gICAgfVxcbiAgICBfcGFyc2UoaW5wdXQpIHtcXG4gICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xcbiAgICAgIGNvbnN0IGVmZmVjdCA9IHRoaXMuX2RlZi5lZmZlY3QgfHwgbnVsbDtcXG4gICAgICBjb25zdCBjaGVja0N0eCA9IHtcXG4gICAgICAgIGFkZElzc3VlOiAoYXJnKSA9PiB7XFxuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwgYXJnKTtcXG4gICAgICAgICAgaWYgKGFyZy5mYXRhbCkge1xcbiAgICAgICAgICAgIHN0YXR1cy5hYm9ydCgpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgZ2V0IHBhdGgoKSB7XFxuICAgICAgICAgIHJldHVybiBjdHgucGF0aDtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIGNoZWNrQ3R4LmFkZElzc3VlID0gY2hlY2tDdHguYWRkSXNzdWUuYmluZChjaGVja0N0eCk7XFxuICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInByZXByb2Nlc3NcIikge1xcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gZWZmZWN0LnRyYW5zZm9ybShjdHguZGF0YSwgY2hlY2tDdHgpO1xcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwcm9jZXNzZWQpLnRoZW4oYXN5bmMgKHByb2Nlc3NlZDIpID0+IHtcXG4gICAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImFib3J0ZWRcIilcXG4gICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlQXN5bmMoe1xcbiAgICAgICAgICAgICAgZGF0YTogcHJvY2Vzc2VkMixcXG4gICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxcbiAgICAgICAgICAgICAgcGFyZW50OiBjdHhcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXFxuICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcXG4gICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxcbiAgICAgICAgICAgICAgcmV0dXJuIERJUlRZKHJlc3VsdC52YWx1ZSk7XFxuICAgICAgICAgICAgaWYgKHN0YXR1cy52YWx1ZSA9PT0gXCJkaXJ0eVwiKVxcbiAgICAgICAgICAgICAgcmV0dXJuIERJUlRZKHJlc3VsdC52YWx1ZSk7XFxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImFib3J0ZWRcIilcXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcXG4gICAgICAgICAgICBkYXRhOiBwcm9jZXNzZWQsXFxuICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXFxuICAgICAgICAgICAgcGFyZW50OiBjdHhcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcXG4gICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIilcXG4gICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcXG4gICAgICAgICAgaWYgKHN0YXR1cy52YWx1ZSA9PT0gXCJkaXJ0eVwiKVxcbiAgICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQudmFsdWUpO1xcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwicmVmaW5lbWVudFwiKSB7XFxuICAgICAgICBjb25zdCBleGVjdXRlUmVmaW5lbWVudCA9IChhY2MpID0+IHtcXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gZWZmZWN0LnJlZmluZW1lbnQoYWNjLCBjaGVja0N0eCk7XFxuICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XFxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXN5bmMgcmVmaW5lbWVudCBlbmNvdW50ZXJlZCBkdXJpbmcgc3luY2hyb25vdXMgcGFyc2Ugb3BlcmF0aW9uLiBVc2UgLnBhcnNlQXN5bmMgaW5zdGVhZC5cIik7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgcmV0dXJuIGFjYztcXG4gICAgICAgIH07XFxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcXG4gICAgICAgICAgY29uc3QgaW5uZXIgPSB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoe1xcbiAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxcbiAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxcbiAgICAgICAgICAgIHBhcmVudDogY3R4XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcXG4gICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxcbiAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xcbiAgICAgICAgICBleGVjdXRlUmVmaW5lbWVudChpbm5lci52YWx1ZSk7XFxuICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5uZXIudmFsdWUgfTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZUFzeW5jKHsgZGF0YTogY3R4LmRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KS50aGVuKChpbm5lcikgPT4ge1xcbiAgICAgICAgICAgIGlmIChpbm5lci5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxcbiAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XFxuICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxcbiAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XFxuICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKS50aGVuKCgpID0+IHtcXG4gICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5uZXIudmFsdWUgfTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGlmIChlZmZlY3QudHlwZSA9PT0gXCJ0cmFuc2Zvcm1cIikge1xcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMgPT09IGZhbHNlKSB7XFxuICAgICAgICAgIGNvbnN0IGJhc2UyID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcXG4gICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcXG4gICAgICAgICAgICBwYXJlbnQ6IGN0eFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgaWYgKCFpc1ZhbGlkKGJhc2UyKSlcXG4gICAgICAgICAgICByZXR1cm4gYmFzZTI7XFxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGVmZmVjdC50cmFuc2Zvcm0oYmFzZTIudmFsdWUsIGNoZWNrQ3R4KTtcXG4gICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFzeW5jaHJvbm91cyB0cmFuc2Zvcm0gZW5jb3VudGVyZWQgZHVyaW5nIHN5bmNocm9ub3VzIHBhcnNlIG9wZXJhdGlvbi4gVXNlIC5wYXJzZUFzeW5jIGluc3RlYWQuYCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiByZXN1bHQgfTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZUFzeW5jKHsgZGF0YTogY3R4LmRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KS50aGVuKChiYXNlMikgPT4ge1xcbiAgICAgICAgICAgIGlmICghaXNWYWxpZChiYXNlMikpXFxuICAgICAgICAgICAgICByZXR1cm4gYmFzZTI7XFxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShlZmZlY3QudHJhbnNmb3JtKGJhc2UyLnZhbHVlLCBjaGVja0N0eCkpLnRoZW4oKHJlc3VsdCkgPT4gKHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiByZXN1bHQgfSkpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgdXRpbC5hc3NlcnROZXZlcihlZmZlY3QpO1xcbiAgICB9XFxuICB9O1xcbiAgWm9kRWZmZWN0cy5jcmVhdGUgPSAoc2NoZW1hLCBlZmZlY3QsIHBhcmFtcykgPT4ge1xcbiAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xcbiAgICAgIHNjaGVtYSxcXG4gICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXFxuICAgICAgZWZmZWN0LFxcbiAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxcbiAgICB9KTtcXG4gIH07XFxuICBab2RFZmZlY3RzLmNyZWF0ZVdpdGhQcmVwcm9jZXNzID0gKHByZXByb2Nlc3MsIHNjaGVtYSwgcGFyYW1zKSA9PiB7XFxuICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XFxuICAgICAgc2NoZW1hLFxcbiAgICAgIGVmZmVjdDogeyB0eXBlOiBcInByZXByb2Nlc3NcIiwgdHJhbnNmb3JtOiBwcmVwcm9jZXNzIH0sXFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxcbiAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxcbiAgICB9KTtcXG4gIH07XFxuICB2YXIgWm9kT3B0aW9uYWwgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xcbiAgICBfcGFyc2UoaW5wdXQpIHtcXG4gICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XFxuICAgICAgaWYgKHBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XFxuICAgICAgICByZXR1cm4gT0sodm9pZCAwKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KTtcXG4gICAgfVxcbiAgICB1bndyYXAoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XFxuICAgIH1cXG4gIH07XFxuICBab2RPcHRpb25hbC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XFxuICAgIHJldHVybiBuZXcgWm9kT3B0aW9uYWwoe1xcbiAgICAgIGlubmVyVHlwZTogdHlwZSxcXG4gICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9wdGlvbmFsLFxcbiAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxcbiAgICB9KTtcXG4gIH07XFxuICB2YXIgWm9kTnVsbGFibGUgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xcbiAgICBfcGFyc2UoaW5wdXQpIHtcXG4gICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XFxuICAgICAgaWYgKHBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUubnVsbCkge1xcbiAgICAgICAgcmV0dXJuIE9LKG51bGwpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xcbiAgICB9XFxuICAgIHVud3JhcCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcXG4gICAgfVxcbiAgfTtcXG4gIFpvZE51bGxhYmxlLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcXG4gICAgcmV0dXJuIG5ldyBab2ROdWxsYWJsZSh7XFxuICAgICAgaW5uZXJUeXBlOiB0eXBlLFxcbiAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVsbGFibGUsXFxuICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXFxuICAgIH0pO1xcbiAgfTtcXG4gIHZhciBab2REZWZhdWx0ID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcXG4gICAgX3BhcnNlKGlucHV0KSB7XFxuICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XFxuICAgICAgbGV0IGRhdGEgPSBjdHguZGF0YTtcXG4gICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XFxuICAgICAgICBkYXRhID0gdGhpcy5fZGVmLmRlZmF1bHRWYWx1ZSgpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2Uoe1xcbiAgICAgICAgZGF0YSxcXG4gICAgICAgIHBhdGg6IGN0eC5wYXRoLFxcbiAgICAgICAgcGFyZW50OiBjdHhcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICByZW1vdmVEZWZhdWx0KCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xcbiAgICB9XFxuICB9O1xcbiAgWm9kRGVmYXVsdC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XFxuICAgIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XFxuICAgICAgaW5uZXJUeXBlOiB0eXBlLFxcbiAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGVmYXVsdCxcXG4gICAgICBkZWZhdWx0VmFsdWU6IHR5cGVvZiBwYXJhbXMuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiID8gcGFyYW1zLmRlZmF1bHQgOiAoKSA9PiBwYXJhbXMuZGVmYXVsdCxcXG4gICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcXG4gICAgfSk7XFxuICB9O1xcbiAgdmFyIFpvZENhdGNoID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcXG4gICAgX3BhcnNlKGlucHV0KSB7XFxuICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XFxuICAgICAgY29uc3QgbmV3Q3R4ID0ge1xcbiAgICAgICAgLi4uY3R4LFxcbiAgICAgICAgY29tbW9uOiB7XFxuICAgICAgICAgIC4uLmN0eC5jb21tb24sXFxuICAgICAgICAgIGlzc3VlczogW11cXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcXG4gICAgICAgIGRhdGE6IG5ld0N0eC5kYXRhLFxcbiAgICAgICAgcGF0aDogbmV3Q3R4LnBhdGgsXFxuICAgICAgICBwYXJlbnQ6IHtcXG4gICAgICAgICAgLi4ubmV3Q3R4XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAgaWYgKGlzQXN5bmMocmVzdWx0KSkge1xcbiAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQyKSA9PiB7XFxuICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgc3RhdHVzOiBcInZhbGlkXCIsXFxuICAgICAgICAgICAgdmFsdWU6IHJlc3VsdDIuc3RhdHVzID09PSBcInZhbGlkXCIgPyByZXN1bHQyLnZhbHVlIDogdGhpcy5fZGVmLmNhdGNoVmFsdWUoe1xcbiAgICAgICAgICAgICAgZ2V0IGVycm9yKCkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFpvZEVycm9yKG5ld0N0eC5jb21tb24uaXNzdWVzKTtcXG4gICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICBpbnB1dDogbmV3Q3R4LmRhdGFcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgICB9O1xcbiAgICAgICAgfSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIHN0YXR1czogXCJ2YWxpZFwiLFxcbiAgICAgICAgICB2YWx1ZTogcmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiID8gcmVzdWx0LnZhbHVlIDogdGhpcy5fZGVmLmNhdGNoVmFsdWUoe1xcbiAgICAgICAgICAgIGdldCBlcnJvcigpIHtcXG4gICAgICAgICAgICAgIHJldHVybiBuZXcgWm9kRXJyb3IobmV3Q3R4LmNvbW1vbi5pc3N1ZXMpO1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgaW5wdXQ6IG5ld0N0eC5kYXRhXFxuICAgICAgICAgIH0pXFxuICAgICAgICB9O1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZW1vdmVDYXRjaCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcXG4gICAgfVxcbiAgfTtcXG4gIFpvZENhdGNoLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcXG4gICAgcmV0dXJuIG5ldyBab2RDYXRjaCh7XFxuICAgICAgaW5uZXJUeXBlOiB0eXBlLFxcbiAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQ2F0Y2gsXFxuICAgICAgY2F0Y2hWYWx1ZTogdHlwZW9mIHBhcmFtcy5jYXRjaCA9PT0gXCJmdW5jdGlvblwiID8gcGFyYW1zLmNhdGNoIDogKCkgPT4gcGFyYW1zLmNhdGNoLFxcbiAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxcbiAgICB9KTtcXG4gIH07XFxuICB2YXIgWm9kTmFOID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcXG4gICAgX3BhcnNlKGlucHV0KSB7XFxuICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xcbiAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm5hbikge1xcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XFxuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXFxuICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm5hbixcXG4gICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiBJTlZBTElEO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4geyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGlucHV0LmRhdGEgfTtcXG4gICAgfVxcbiAgfTtcXG4gIFpvZE5hTi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XFxuICAgIHJldHVybiBuZXcgWm9kTmFOKHtcXG4gICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5hTixcXG4gICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcXG4gICAgfSk7XFxuICB9O1xcbiAgdmFyIEJSQU5EID0gU3ltYm9sKFwiem9kX2JyYW5kXCIpO1xcbiAgdmFyIFpvZEJyYW5kZWQgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xcbiAgICBfcGFyc2UoaW5wdXQpIHtcXG4gICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcXG4gICAgICBjb25zdCBkYXRhID0gY3R4LmRhdGE7XFxuICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlLl9wYXJzZSh7XFxuICAgICAgICBkYXRhLFxcbiAgICAgICAgcGF0aDogY3R4LnBhdGgsXFxuICAgICAgICBwYXJlbnQ6IGN0eFxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIHVud3JhcCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XFxuICAgIH1cXG4gIH07XFxuICB2YXIgWm9kUGlwZWxpbmUgPSBjbGFzcyBfWm9kUGlwZWxpbmUgZXh0ZW5kcyBab2RUeXBlIHtcXG4gICAgX3BhcnNlKGlucHV0KSB7XFxuICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcXG4gICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xcbiAgICAgICAgY29uc3QgaGFuZGxlQXN5bmMgPSBhc3luYyAoKSA9PiB7XFxuICAgICAgICAgIGNvbnN0IGluUmVzdWx0ID0gYXdhaXQgdGhpcy5fZGVmLmluLl9wYXJzZUFzeW5jKHtcXG4gICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcXG4gICAgICAgICAgICBwYXJlbnQ6IGN0eFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXFxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XFxuICAgICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xcbiAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xcbiAgICAgICAgICAgIHJldHVybiBESVJUWShpblJlc3VsdC52YWx1ZSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vdXQuX3BhcnNlQXN5bmMoe1xcbiAgICAgICAgICAgICAgZGF0YTogaW5SZXN1bHQudmFsdWUsXFxuICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcXG4gICAgICAgICAgICAgIHBhcmVudDogY3R4XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH07XFxuICAgICAgICByZXR1cm4gaGFuZGxlQXN5bmMoKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgY29uc3QgaW5SZXN1bHQgPSB0aGlzLl9kZWYuaW4uX3BhcnNlU3luYyh7XFxuICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxcbiAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcXG4gICAgICAgICAgcGFyZW50OiBjdHhcXG4gICAgICAgIH0pO1xcbiAgICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXFxuICAgICAgICAgIHJldHVybiBJTlZBTElEO1xcbiAgICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XFxuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xcbiAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIHN0YXR1czogXCJkaXJ0eVwiLFxcbiAgICAgICAgICAgIHZhbHVlOiBpblJlc3VsdC52YWx1ZVxcbiAgICAgICAgICB9O1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vdXQuX3BhcnNlU3luYyh7XFxuICAgICAgICAgICAgZGF0YTogaW5SZXN1bHQudmFsdWUsXFxuICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXFxuICAgICAgICAgICAgcGFyZW50OiBjdHhcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHN0YXRpYyBjcmVhdGUoYSwgYikge1xcbiAgICAgIHJldHVybiBuZXcgX1pvZFBpcGVsaW5lKHtcXG4gICAgICAgIGluOiBhLFxcbiAgICAgICAgb3V0OiBiLFxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQaXBlbGluZVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9O1xcbiAgdmFyIFpvZFJlYWRvbmx5ID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcXG4gICAgX3BhcnNlKGlucHV0KSB7XFxuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xcbiAgICAgIGNvbnN0IGZyZWV6ZSA9IChkYXRhKSA9PiB7XFxuICAgICAgICBpZiAoaXNWYWxpZChkYXRhKSkge1xcbiAgICAgICAgICBkYXRhLnZhbHVlID0gT2JqZWN0LmZyZWV6ZShkYXRhLnZhbHVlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBkYXRhO1xcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIGlzQXN5bmMocmVzdWx0KSA/IHJlc3VsdC50aGVuKChkYXRhKSA9PiBmcmVlemUoZGF0YSkpIDogZnJlZXplKHJlc3VsdCk7XFxuICAgIH1cXG4gICAgdW53cmFwKCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xcbiAgICB9XFxuICB9O1xcbiAgWm9kUmVhZG9ubHkuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xcbiAgICByZXR1cm4gbmV3IFpvZFJlYWRvbmx5KHtcXG4gICAgICBpbm5lclR5cGU6IHR5cGUsXFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWFkb25seSxcXG4gICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcXG4gICAgfSk7XFxuICB9O1xcbiAgZnVuY3Rpb24gY2xlYW5QYXJhbXMocGFyYW1zLCBkYXRhKSB7XFxuICAgIGNvbnN0IHAgPSB0eXBlb2YgcGFyYW1zID09PSBcImZ1bmN0aW9uXCIgPyBwYXJhbXMoZGF0YSkgOiB0eXBlb2YgcGFyYW1zID09PSBcInN0cmluZ1wiID8geyBtZXNzYWdlOiBwYXJhbXMgfSA6IHBhcmFtcztcXG4gICAgY29uc3QgcDIgPSB0eXBlb2YgcCA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZTogcCB9IDogcDtcXG4gICAgcmV0dXJuIHAyO1xcbiAgfVxcbiAgZnVuY3Rpb24gY3VzdG9tMihjaGVjaywgX3BhcmFtcyA9IHt9LCBmYXRhbCkge1xcbiAgICBpZiAoY2hlY2spXFxuICAgICAgcmV0dXJuIFpvZEFueS5jcmVhdGUoKS5zdXBlclJlZmluZSgoZGF0YSwgY3R4KSA9PiB7XFxuICAgICAgICB2YXIgX2EsIF9iO1xcbiAgICAgICAgY29uc3QgciA9IGNoZWNrKGRhdGEpO1xcbiAgICAgICAgaWYgKHIgaW5zdGFuY2VvZiBQcm9taXNlKSB7XFxuICAgICAgICAgIHJldHVybiByLnRoZW4oKHIyKSA9PiB7XFxuICAgICAgICAgICAgdmFyIF9hMiwgX2IyO1xcbiAgICAgICAgICAgIGlmICghcjIpIHtcXG4gICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGNsZWFuUGFyYW1zKF9wYXJhbXMsIGRhdGEpO1xcbiAgICAgICAgICAgICAgY29uc3QgX2ZhdGFsID0gKF9iMiA9IChfYTIgPSBwYXJhbXMuZmF0YWwpICE9PSBudWxsICYmIF9hMiAhPT0gdm9pZCAwID8gX2EyIDogZmF0YWwpICE9PSBudWxsICYmIF9iMiAhPT0gdm9pZCAwID8gX2IyIDogdHJ1ZTtcXG4gICAgICAgICAgICAgIGN0eC5hZGRJc3N1ZSh7IGNvZGU6IFwiY3VzdG9tXCIsIC4uLnBhcmFtcywgZmF0YWw6IF9mYXRhbCB9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCFyKSB7XFxuICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGNsZWFuUGFyYW1zKF9wYXJhbXMsIGRhdGEpO1xcbiAgICAgICAgICBjb25zdCBfZmF0YWwgPSAoX2IgPSAoX2EgPSBwYXJhbXMuZmF0YWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhdGFsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlO1xcbiAgICAgICAgICBjdHguYWRkSXNzdWUoeyBjb2RlOiBcImN1c3RvbVwiLCAuLi5wYXJhbXMsIGZhdGFsOiBfZmF0YWwgfSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfSk7XFxuICAgIHJldHVybiBab2RBbnkuY3JlYXRlKCk7XFxuICB9XFxuICB2YXIgbGF0ZSA9IHtcXG4gICAgb2JqZWN0OiBab2RPYmplY3QubGF6eWNyZWF0ZVxcbiAgfTtcXG4gIHZhciBab2RGaXJzdFBhcnR5VHlwZUtpbmQ7XFxuICAoZnVuY3Rpb24oWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMikge1xcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kU3RyaW5nXCJdID0gXCJab2RTdHJpbmdcIjtcXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZE51bWJlclwiXSA9IFwiWm9kTnVtYmVyXCI7XFxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2ROYU5cIl0gPSBcIlpvZE5hTlwiO1xcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kQmlnSW50XCJdID0gXCJab2RCaWdJbnRcIjtcXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZEJvb2xlYW5cIl0gPSBcIlpvZEJvb2xlYW5cIjtcXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZERhdGVcIl0gPSBcIlpvZERhdGVcIjtcXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZFN5bWJvbFwiXSA9IFwiWm9kU3ltYm9sXCI7XFxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RVbmRlZmluZWRcIl0gPSBcIlpvZFVuZGVmaW5lZFwiO1xcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kTnVsbFwiXSA9IFwiWm9kTnVsbFwiO1xcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kQW55XCJdID0gXCJab2RBbnlcIjtcXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZFVua25vd25cIl0gPSBcIlpvZFVua25vd25cIjtcXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZE5ldmVyXCJdID0gXCJab2ROZXZlclwiO1xcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kVm9pZFwiXSA9IFwiWm9kVm9pZFwiO1xcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kQXJyYXlcIl0gPSBcIlpvZEFycmF5XCI7XFxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RPYmplY3RcIl0gPSBcIlpvZE9iamVjdFwiO1xcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kVW5pb25cIl0gPSBcIlpvZFVuaW9uXCI7XFxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2REaXNjcmltaW5hdGVkVW5pb25cIl0gPSBcIlpvZERpc2NyaW1pbmF0ZWRVbmlvblwiO1xcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kSW50ZXJzZWN0aW9uXCJdID0gXCJab2RJbnRlcnNlY3Rpb25cIjtcXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZFR1cGxlXCJdID0gXCJab2RUdXBsZVwiO1xcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kUmVjb3JkXCJdID0gXCJab2RSZWNvcmRcIjtcXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZE1hcFwiXSA9IFwiWm9kTWFwXCI7XFxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RTZXRcIl0gPSBcIlpvZFNldFwiO1xcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kRnVuY3Rpb25cIl0gPSBcIlpvZEZ1bmN0aW9uXCI7XFxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RMYXp5XCJdID0gXCJab2RMYXp5XCI7XFxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RMaXRlcmFsXCJdID0gXCJab2RMaXRlcmFsXCI7XFxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RFbnVtXCJdID0gXCJab2RFbnVtXCI7XFxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RFZmZlY3RzXCJdID0gXCJab2RFZmZlY3RzXCI7XFxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2ROYXRpdmVFbnVtXCJdID0gXCJab2ROYXRpdmVFbnVtXCI7XFxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RPcHRpb25hbFwiXSA9IFwiWm9kT3B0aW9uYWxcIjtcXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZE51bGxhYmxlXCJdID0gXCJab2ROdWxsYWJsZVwiO1xcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kRGVmYXVsdFwiXSA9IFwiWm9kRGVmYXVsdFwiO1xcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kQ2F0Y2hcIl0gPSBcIlpvZENhdGNoXCI7XFxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RQcm9taXNlXCJdID0gXCJab2RQcm9taXNlXCI7XFxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RCcmFuZGVkXCJdID0gXCJab2RCcmFuZGVkXCI7XFxuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RQaXBlbGluZVwiXSA9IFwiWm9kUGlwZWxpbmVcIjtcXG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZFJlYWRvbmx5XCJdID0gXCJab2RSZWFkb25seVwiO1xcbiAgfSkoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kIHx8IChab2RGaXJzdFBhcnR5VHlwZUtpbmQgPSB7fSkpO1xcbiAgdmFyIGluc3RhbmNlT2ZUeXBlID0gKGNscywgcGFyYW1zID0ge1xcbiAgICBtZXNzYWdlOiBgSW5wdXQgbm90IGluc3RhbmNlIG9mICR7Y2xzLm5hbWV9YFxcbiAgfSkgPT4gY3VzdG9tMigoZGF0YSkgPT4gZGF0YSBpbnN0YW5jZW9mIGNscywgcGFyYW1zKTtcXG4gIHZhciBzdHJpbmdUeXBlID0gWm9kU3RyaW5nLmNyZWF0ZTtcXG4gIHZhciBudW1iZXJUeXBlID0gWm9kTnVtYmVyLmNyZWF0ZTtcXG4gIHZhciBuYW5UeXBlID0gWm9kTmFOLmNyZWF0ZTtcXG4gIHZhciBiaWdJbnRUeXBlID0gWm9kQmlnSW50LmNyZWF0ZTtcXG4gIHZhciBib29sZWFuVHlwZSA9IFpvZEJvb2xlYW4uY3JlYXRlO1xcbiAgdmFyIGRhdGVUeXBlID0gWm9kRGF0ZS5jcmVhdGU7XFxuICB2YXIgc3ltYm9sVHlwZSA9IFpvZFN5bWJvbC5jcmVhdGU7XFxuICB2YXIgdW5kZWZpbmVkVHlwZSA9IFpvZFVuZGVmaW5lZC5jcmVhdGU7XFxuICB2YXIgbnVsbFR5cGUgPSBab2ROdWxsLmNyZWF0ZTtcXG4gIHZhciBhbnlUeXBlID0gWm9kQW55LmNyZWF0ZTtcXG4gIHZhciB1bmtub3duVHlwZSA9IFpvZFVua25vd24uY3JlYXRlO1xcbiAgdmFyIG5ldmVyVHlwZSA9IFpvZE5ldmVyLmNyZWF0ZTtcXG4gIHZhciB2b2lkVHlwZSA9IFpvZFZvaWQuY3JlYXRlO1xcbiAgdmFyIGFycmF5VHlwZSA9IFpvZEFycmF5LmNyZWF0ZTtcXG4gIHZhciBvYmplY3RUeXBlID0gWm9kT2JqZWN0LmNyZWF0ZTtcXG4gIHZhciBzdHJpY3RPYmplY3RUeXBlID0gWm9kT2JqZWN0LnN0cmljdENyZWF0ZTtcXG4gIHZhciB1bmlvblR5cGUgPSBab2RVbmlvbi5jcmVhdGU7XFxuICB2YXIgZGlzY3JpbWluYXRlZFVuaW9uVHlwZSA9IFpvZERpc2NyaW1pbmF0ZWRVbmlvbi5jcmVhdGU7XFxuICB2YXIgaW50ZXJzZWN0aW9uVHlwZSA9IFpvZEludGVyc2VjdGlvbi5jcmVhdGU7XFxuICB2YXIgdHVwbGVUeXBlID0gWm9kVHVwbGUuY3JlYXRlO1xcbiAgdmFyIHJlY29yZFR5cGUgPSBab2RSZWNvcmQuY3JlYXRlO1xcbiAgdmFyIG1hcFR5cGUgPSBab2RNYXAuY3JlYXRlO1xcbiAgdmFyIHNldFR5cGUgPSBab2RTZXQuY3JlYXRlO1xcbiAgdmFyIGZ1bmN0aW9uVHlwZSA9IFpvZEZ1bmN0aW9uLmNyZWF0ZTtcXG4gIHZhciBsYXp5VHlwZSA9IFpvZExhenkuY3JlYXRlO1xcbiAgdmFyIGxpdGVyYWxUeXBlID0gWm9kTGl0ZXJhbC5jcmVhdGU7XFxuICB2YXIgZW51bVR5cGUgPSBab2RFbnVtLmNyZWF0ZTtcXG4gIHZhciBuYXRpdmVFbnVtVHlwZSA9IFpvZE5hdGl2ZUVudW0uY3JlYXRlO1xcbiAgdmFyIHByb21pc2VUeXBlID0gWm9kUHJvbWlzZS5jcmVhdGU7XFxuICB2YXIgZWZmZWN0c1R5cGUgPSBab2RFZmZlY3RzLmNyZWF0ZTtcXG4gIHZhciBvcHRpb25hbFR5cGUgPSBab2RPcHRpb25hbC5jcmVhdGU7XFxuICB2YXIgbnVsbGFibGVUeXBlID0gWm9kTnVsbGFibGUuY3JlYXRlO1xcbiAgdmFyIHByZXByb2Nlc3NUeXBlID0gWm9kRWZmZWN0cy5jcmVhdGVXaXRoUHJlcHJvY2VzcztcXG4gIHZhciBwaXBlbGluZVR5cGUgPSBab2RQaXBlbGluZS5jcmVhdGU7XFxuICB2YXIgb3N0cmluZyA9ICgpID0+IHN0cmluZ1R5cGUoKS5vcHRpb25hbCgpO1xcbiAgdmFyIG9udW1iZXIgPSAoKSA9PiBudW1iZXJUeXBlKCkub3B0aW9uYWwoKTtcXG4gIHZhciBvYm9vbGVhbiA9ICgpID0+IGJvb2xlYW5UeXBlKCkub3B0aW9uYWwoKTtcXG4gIHZhciBjb2VyY2UgPSB7XFxuICAgIHN0cmluZzogKGFyZykgPT4gWm9kU3RyaW5nLmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pLFxcbiAgICBudW1iZXI6IChhcmcpID0+IFpvZE51bWJlci5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSxcXG4gICAgYm9vbGVhbjogKGFyZykgPT4gWm9kQm9vbGVhbi5jcmVhdGUoe1xcbiAgICAgIC4uLmFyZyxcXG4gICAgICBjb2VyY2U6IHRydWVcXG4gICAgfSksXFxuICAgIGJpZ2ludDogKGFyZykgPT4gWm9kQmlnSW50LmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pLFxcbiAgICBkYXRlOiAoYXJnKSA9PiBab2REYXRlLmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pXFxuICB9O1xcbiAgdmFyIE5FVkVSID0gSU5WQUxJRDtcXG4gIHZhciB6ID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoe1xcbiAgICBfX3Byb3RvX186IG51bGwsXFxuICAgIGRlZmF1bHRFcnJvck1hcDogZXJyb3JNYXAsXFxuICAgIHNldEVycm9yTWFwLFxcbiAgICBnZXRFcnJvck1hcCxcXG4gICAgbWFrZUlzc3VlLFxcbiAgICBFTVBUWV9QQVRILFxcbiAgICBhZGRJc3N1ZVRvQ29udGV4dCxcXG4gICAgUGFyc2VTdGF0dXMsXFxuICAgIElOVkFMSUQsXFxuICAgIERJUlRZLFxcbiAgICBPSyxcXG4gICAgaXNBYm9ydGVkLFxcbiAgICBpc0RpcnR5LFxcbiAgICBpc1ZhbGlkLFxcbiAgICBpc0FzeW5jLFxcbiAgICBnZXQgdXRpbCgpIHtcXG4gICAgICByZXR1cm4gdXRpbDtcXG4gICAgfSxcXG4gICAgZ2V0IG9iamVjdFV0aWwoKSB7XFxuICAgICAgcmV0dXJuIG9iamVjdFV0aWw7XFxuICAgIH0sXFxuICAgIFpvZFBhcnNlZFR5cGUsXFxuICAgIGdldFBhcnNlZFR5cGUsXFxuICAgIFpvZFR5cGUsXFxuICAgIGRhdGV0aW1lUmVnZXgsXFxuICAgIFpvZFN0cmluZyxcXG4gICAgWm9kTnVtYmVyLFxcbiAgICBab2RCaWdJbnQsXFxuICAgIFpvZEJvb2xlYW4sXFxuICAgIFpvZERhdGUsXFxuICAgIFpvZFN5bWJvbCxcXG4gICAgWm9kVW5kZWZpbmVkLFxcbiAgICBab2ROdWxsLFxcbiAgICBab2RBbnksXFxuICAgIFpvZFVua25vd24sXFxuICAgIFpvZE5ldmVyLFxcbiAgICBab2RWb2lkLFxcbiAgICBab2RBcnJheSxcXG4gICAgWm9kT2JqZWN0LFxcbiAgICBab2RVbmlvbixcXG4gICAgWm9kRGlzY3JpbWluYXRlZFVuaW9uLFxcbiAgICBab2RJbnRlcnNlY3Rpb24sXFxuICAgIFpvZFR1cGxlLFxcbiAgICBab2RSZWNvcmQsXFxuICAgIFpvZE1hcCxcXG4gICAgWm9kU2V0LFxcbiAgICBab2RGdW5jdGlvbixcXG4gICAgWm9kTGF6eSxcXG4gICAgWm9kTGl0ZXJhbCxcXG4gICAgWm9kRW51bSxcXG4gICAgWm9kTmF0aXZlRW51bSxcXG4gICAgWm9kUHJvbWlzZSxcXG4gICAgWm9kRWZmZWN0cyxcXG4gICAgWm9kVHJhbnNmb3JtZXI6IFpvZEVmZmVjdHMsXFxuICAgIFpvZE9wdGlvbmFsLFxcbiAgICBab2ROdWxsYWJsZSxcXG4gICAgWm9kRGVmYXVsdCxcXG4gICAgWm9kQ2F0Y2gsXFxuICAgIFpvZE5hTixcXG4gICAgQlJBTkQsXFxuICAgIFpvZEJyYW5kZWQsXFxuICAgIFpvZFBpcGVsaW5lLFxcbiAgICBab2RSZWFkb25seSxcXG4gICAgY3VzdG9tOiBjdXN0b20yLFxcbiAgICBTY2hlbWE6IFpvZFR5cGUsXFxuICAgIFpvZFNjaGVtYTogWm9kVHlwZSxcXG4gICAgbGF0ZSxcXG4gICAgZ2V0IFpvZEZpcnN0UGFydHlUeXBlS2luZCgpIHtcXG4gICAgICByZXR1cm4gWm9kRmlyc3RQYXJ0eVR5cGVLaW5kO1xcbiAgICB9LFxcbiAgICBjb2VyY2UsXFxuICAgIGFueTogYW55VHlwZSxcXG4gICAgYXJyYXk6IGFycmF5VHlwZSxcXG4gICAgYmlnaW50OiBiaWdJbnRUeXBlLFxcbiAgICBib29sZWFuOiBib29sZWFuVHlwZSxcXG4gICAgZGF0ZTogZGF0ZVR5cGUsXFxuICAgIGRpc2NyaW1pbmF0ZWRVbmlvbjogZGlzY3JpbWluYXRlZFVuaW9uVHlwZSxcXG4gICAgZWZmZWN0OiBlZmZlY3RzVHlwZSxcXG4gICAgXCJlbnVtXCI6IGVudW1UeXBlLFxcbiAgICBcImZ1bmN0aW9uXCI6IGZ1bmN0aW9uVHlwZSxcXG4gICAgXCJpbnN0YW5jZW9mXCI6IGluc3RhbmNlT2ZUeXBlLFxcbiAgICBpbnRlcnNlY3Rpb246IGludGVyc2VjdGlvblR5cGUsXFxuICAgIGxhenk6IGxhenlUeXBlLFxcbiAgICBsaXRlcmFsOiBsaXRlcmFsVHlwZSxcXG4gICAgbWFwOiBtYXBUeXBlLFxcbiAgICBuYW46IG5hblR5cGUsXFxuICAgIG5hdGl2ZUVudW06IG5hdGl2ZUVudW1UeXBlLFxcbiAgICBuZXZlcjogbmV2ZXJUeXBlLFxcbiAgICBcIm51bGxcIjogbnVsbFR5cGUsXFxuICAgIG51bGxhYmxlOiBudWxsYWJsZVR5cGUsXFxuICAgIG51bWJlcjogbnVtYmVyVHlwZSxcXG4gICAgb2JqZWN0OiBvYmplY3RUeXBlLFxcbiAgICBvYm9vbGVhbixcXG4gICAgb251bWJlcixcXG4gICAgb3B0aW9uYWw6IG9wdGlvbmFsVHlwZSxcXG4gICAgb3N0cmluZyxcXG4gICAgcGlwZWxpbmU6IHBpcGVsaW5lVHlwZSxcXG4gICAgcHJlcHJvY2VzczogcHJlcHJvY2Vzc1R5cGUsXFxuICAgIHByb21pc2U6IHByb21pc2VUeXBlLFxcbiAgICByZWNvcmQ6IHJlY29yZFR5cGUsXFxuICAgIHNldDogc2V0VHlwZSxcXG4gICAgc3RyaWN0T2JqZWN0OiBzdHJpY3RPYmplY3RUeXBlLFxcbiAgICBzdHJpbmc6IHN0cmluZ1R5cGUsXFxuICAgIHN5bWJvbDogc3ltYm9sVHlwZSxcXG4gICAgdHJhbnNmb3JtZXI6IGVmZmVjdHNUeXBlLFxcbiAgICB0dXBsZTogdHVwbGVUeXBlLFxcbiAgICBcInVuZGVmaW5lZFwiOiB1bmRlZmluZWRUeXBlLFxcbiAgICB1bmlvbjogdW5pb25UeXBlLFxcbiAgICB1bmtub3duOiB1bmtub3duVHlwZSxcXG4gICAgXCJ2b2lkXCI6IHZvaWRUeXBlLFxcbiAgICBORVZFUixcXG4gICAgWm9kSXNzdWVDb2RlLFxcbiAgICBxdW90ZWxlc3NKc29uLFxcbiAgICBab2RFcnJvclxcbiAgfSk7XFxuXFxuICAvLyBzcmMvdHlwZXMvc2hhcmVkL21vbmV5LnRzXFxuICB2YXIgbW9uZXlTY2hlbWEgPSB6LnVuaW9uKFt6LnN0cmluZygpLnRyYW5zZm9ybSgoeCkgPT4geC5yZXBsYWNlKC9bXjAtOS4tXSsvZywgXCJcIikpLCB6Lm51bWJlcigpXSkucGlwZSh6LmNvZXJjZS5udW1iZXIoKS5taW4oMWUtNCkubWF4KDk5OTk5OTk5OSkpO1xcblxcbiAgLy8gc3JjL3R5cGVzL3NoYXJlZC9uZXR3b3JrLnRzXFxuICB2YXIgTmV0d29ya1NjaGVtYSA9IHouZW51bShbXFxuICAgIFwiYmFzZS1zZXBvbGlhXCIsXFxuICAgIFwiYmFzZVwiLFxcbiAgICBcImF2YWxhbmNoZS1mdWppXCIsXFxuICAgIFwiYXZhbGFuY2hlXCIsXFxuICAgIFwiaW90ZXhcIlxcbiAgXSk7XFxuICB2YXIgU3VwcG9ydGVkRVZNTmV0d29ya3MgPSBbXFxuICAgIFwiYmFzZS1zZXBvbGlhXCIsXFxuICAgIFwiYmFzZVwiLFxcbiAgICBcImF2YWxhbmNoZS1mdWppXCIsXFxuICAgIFwiYXZhbGFuY2hlXCIsXFxuICAgIFwiaW90ZXhcIlxcbiAgXTtcXG4gIHZhciBFdm1OZXR3b3JrVG9DaGFpbklkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xcbiAgICBbXCJiYXNlLXNlcG9saWFcIiwgODQ1MzJdLFxcbiAgICBbXCJiYXNlXCIsIDg0NTNdLFxcbiAgICBbXCJhdmFsYW5jaGUtZnVqaVwiLCA0MzExM10sXFxuICAgIFtcImF2YWxhbmNoZVwiLCA0MzExNF0sXFxuICAgIFtcImlvdGV4XCIsIDQ2ODldXFxuICBdKTtcXG4gIHZhciBDaGFpbklkVG9OZXR3b3JrID0gT2JqZWN0LmZyb21FbnRyaWVzKFxcbiAgICBTdXBwb3J0ZWRFVk1OZXR3b3Jrcy5tYXAoKG5ldHdvcmspID0+IFtFdm1OZXR3b3JrVG9DaGFpbklkLmdldChuZXR3b3JrKSwgbmV0d29ya10pXFxuICApO1xcblxcbiAgLy8gc3JjL3NoYXJlZC9uZXR3b3JrLnRzXFxuICBmdW5jdGlvbiBnZXROZXR3b3JrSWQobmV0d29yaykge1xcbiAgICBpZiAoRXZtTmV0d29ya1RvQ2hhaW5JZC5oYXMobmV0d29yaykpIHtcXG4gICAgICByZXR1cm4gRXZtTmV0d29ya1RvQ2hhaW5JZC5nZXQobmV0d29yayk7XFxuICAgIH1cXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBuZXR3b3JrOiAke25ldHdvcmt9YCk7XFxuICB9XFxuXFxuICAvLyBzcmMvdHlwZXMvdmVyaWZ5L3g0MDJTcGVjcy50c1xcbiAgdmFyIEV2bU1heEF0b21pY1VuaXRzID0gMTg7XFxuICB2YXIgRXZtQWRkcmVzc1JlZ2V4ID0gL14weFswLTlhLWZBLUZdezQwfSQvO1xcbiAgdmFyIE1peGVkQWRkcmVzc1JlZ2V4ID0gL14weFthLWZBLUYwLTldezQwfXxbQS1aYS16MC05XVtBLVphLXowLTktXXswLDM0fVtBLVphLXowLTldJC87XFxuICB2YXIgSGV4RW5jb2RlZDY0Qnl0ZVJlZ2V4ID0gL14weFswLTlhLWZBLUZdezY0fSQvO1xcbiAgdmFyIEV2bVNpZ25hdHVyZVJlZ2V4ID0gL14weFswLTlhLWZBLUZdezEzMH0kLztcXG4gIHZhciBzY2hlbWVzID0gW1wiZXhhY3RcIl07XFxuICB2YXIgeDQwMlZlcnNpb25zID0gWzFdO1xcbiAgdmFyIEVycm9yUmVhc29ucyA9IFtcImluc3VmZmljaWVudF9mdW5kc1wiLCBcImludmFsaWRfc2NoZW1lXCIsIFwiaW52YWxpZF9uZXR3b3JrXCJdO1xcbiAgdmFyIGlzSW50ZWdlciA9ICh2YWx1ZSkgPT4gTnVtYmVyLmlzSW50ZWdlcihOdW1iZXIodmFsdWUpKSAmJiBOdW1iZXIodmFsdWUpID49IDA7XFxuICB2YXIgaGFzTWF4TGVuZ3RoID0gKG1heExlbmd0aCkgPT4gKHZhbHVlKSA9PiB2YWx1ZS5sZW5ndGggPD0gbWF4TGVuZ3RoO1xcbiAgdmFyIFBheW1lbnRSZXF1aXJlbWVudHNTY2hlbWEgPSB6Lm9iamVjdCh7XFxuICAgIHNjaGVtZTogei5lbnVtKHNjaGVtZXMpLFxcbiAgICBuZXR3b3JrOiBOZXR3b3JrU2NoZW1hLFxcbiAgICBtYXhBbW91bnRSZXF1aXJlZDogei5zdHJpbmcoKS5yZWZpbmUoaXNJbnRlZ2VyKSxcXG4gICAgcmVzb3VyY2U6IHouc3RyaW5nKCkudXJsKCksXFxuICAgIGRlc2NyaXB0aW9uOiB6LnN0cmluZygpLFxcbiAgICBtaW1lVHlwZTogei5zdHJpbmcoKSxcXG4gICAgb3V0cHV0U2NoZW1hOiB6LnJlY29yZCh6LmFueSgpKS5vcHRpb25hbCgpLFxcbiAgICBwYXlUbzogei5zdHJpbmcoKS5yZWdleChNaXhlZEFkZHJlc3NSZWdleCksXFxuICAgIG1heFRpbWVvdXRTZWNvbmRzOiB6Lm51bWJlcigpLmludCgpLFxcbiAgICBhc3NldDogei5zdHJpbmcoKS5yZWdleChNaXhlZEFkZHJlc3NSZWdleCksXFxuICAgIGV4dHJhOiB6LnJlY29yZCh6LmFueSgpKS5vcHRpb25hbCgpXFxuICB9KTtcXG4gIHZhciBFeGFjdEV2bVBheWxvYWRBdXRob3JpemF0aW9uU2NoZW1hID0gei5vYmplY3Qoe1xcbiAgICBmcm9tOiB6LnN0cmluZygpLnJlZ2V4KEV2bUFkZHJlc3NSZWdleCksXFxuICAgIHRvOiB6LnN0cmluZygpLnJlZ2V4KEV2bUFkZHJlc3NSZWdleCksXFxuICAgIHZhbHVlOiB6LnN0cmluZygpLnJlZmluZShpc0ludGVnZXIpLnJlZmluZShoYXNNYXhMZW5ndGgoRXZtTWF4QXRvbWljVW5pdHMpKSxcXG4gICAgdmFsaWRBZnRlcjogei5zdHJpbmcoKS5yZWZpbmUoaXNJbnRlZ2VyKSxcXG4gICAgdmFsaWRCZWZvcmU6IHouc3RyaW5nKCkucmVmaW5lKGlzSW50ZWdlciksXFxuICAgIG5vbmNlOiB6LnN0cmluZygpLnJlZ2V4KEhleEVuY29kZWQ2NEJ5dGVSZWdleClcXG4gIH0pO1xcbiAgdmFyIEV4YWN0RXZtUGF5bG9hZFNjaGVtYSA9IHoub2JqZWN0KHtcXG4gICAgc2lnbmF0dXJlOiB6LnN0cmluZygpLnJlZ2V4KEV2bVNpZ25hdHVyZVJlZ2V4KSxcXG4gICAgYXV0aG9yaXphdGlvbjogRXhhY3RFdm1QYXlsb2FkQXV0aG9yaXphdGlvblNjaGVtYVxcbiAgfSk7XFxuICB2YXIgUGF5bWVudFBheWxvYWRTY2hlbWEgPSB6Lm9iamVjdCh7XFxuICAgIHg0MDJWZXJzaW9uOiB6Lm51bWJlcigpLnJlZmluZSgodmFsKSA9PiB4NDAyVmVyc2lvbnMuaW5jbHVkZXModmFsKSksXFxuICAgIHNjaGVtZTogei5lbnVtKHNjaGVtZXMpLFxcbiAgICBuZXR3b3JrOiBOZXR3b3JrU2NoZW1hLFxcbiAgICBwYXlsb2FkOiBFeGFjdEV2bVBheWxvYWRTY2hlbWFcXG4gIH0pO1xcbiAgdmFyIFZlcmlmeVJlc3BvbnNlU2NoZW1hID0gei5vYmplY3Qoe1xcbiAgICBpc1ZhbGlkOiB6LmJvb2xlYW4oKSxcXG4gICAgaW52YWxpZFJlYXNvbjogei5lbnVtKEVycm9yUmVhc29ucykub3B0aW9uYWwoKSxcXG4gICAgcGF5ZXI6IHouc3RyaW5nKCkucmVnZXgoTWl4ZWRBZGRyZXNzUmVnZXgpLm9wdGlvbmFsKClcXG4gIH0pO1xcbiAgdmFyIFNldHRsZVJlc3BvbnNlU2NoZW1hID0gei5vYmplY3Qoe1xcbiAgICBzdWNjZXNzOiB6LmJvb2xlYW4oKSxcXG4gICAgZXJyb3JSZWFzb246IHouZW51bShFcnJvclJlYXNvbnMpLm9wdGlvbmFsKCksXFxuICAgIHBheWVyOiB6LnN0cmluZygpLnJlZ2V4KE1peGVkQWRkcmVzc1JlZ2V4KS5vcHRpb25hbCgpLFxcbiAgICB0cmFuc2FjdGlvbjogei5zdHJpbmcoKS5yZWdleChNaXhlZEFkZHJlc3NSZWdleCksXFxuICAgIG5ldHdvcms6IE5ldHdvcmtTY2hlbWFcXG4gIH0pO1xcbiAgdmFyIFN1cHBvcnRlZFBheW1lbnRLaW5kU2NoZW1hID0gei5vYmplY3Qoe1xcbiAgICB4NDAyVmVyc2lvbjogei5udW1iZXIoKS5yZWZpbmUoKHZhbCkgPT4geDQwMlZlcnNpb25zLmluY2x1ZGVzKHZhbCkpLFxcbiAgICBzY2hlbWU6IHouZW51bShzY2hlbWVzKSxcXG4gICAgbmV0d29yazogTmV0d29ya1NjaGVtYVxcbiAgfSk7XFxuICB2YXIgU3VwcG9ydGVkUGF5bWVudEtpbmRzUmVzcG9uc2VTY2hlbWEgPSB6Lm9iamVjdCh7XFxuICAgIGtpbmRzOiB6LmFycmF5KFN1cHBvcnRlZFBheW1lbnRLaW5kU2NoZW1hKVxcbiAgfSk7XFxuXFxuICAvLyBzcmMvdHlwZXMvdmVyaWZ5L2ZhY2lsaXRhdG9yLnRzXFxuICB2YXIgZmFjaWxpdGF0b3JSZXF1ZXN0U2NoZW1hID0gei5vYmplY3Qoe1xcbiAgICBwYXltZW50SGVhZGVyOiB6LnN0cmluZygpLFxcbiAgICBwYXltZW50UmVxdWlyZW1lbnRzOiBQYXltZW50UmVxdWlyZW1lbnRzU2NoZW1hXFxuICB9KTtcXG5cXG4gIC8vIHNyYy9zaGFyZWQvZXZtL3VzZGMudHNcXG4gIGZ1bmN0aW9uIGdldFVzZGNBZGRyZXNzKGNsaWVudCkge1xcbiAgICByZXR1cm4gY29uZmlnW2NsaWVudC5jaGFpbi5pZC50b1N0cmluZygpXS51c2RjQWRkcmVzcztcXG4gIH1cXG4gIGZ1bmN0aW9uIGdldFVzZGNBZGRyZXNzRm9yQ2hhaW4oY2hhaW5JZCkge1xcbiAgICByZXR1cm4gY29uZmlnW2NoYWluSWQudG9TdHJpbmcoKV0udXNkY0FkZHJlc3M7XFxuICB9XFxuICB2YXIgdmVyc2lvbkNhY2hlID0gbnVsbDtcXG4gIGFzeW5jIGZ1bmN0aW9uIGdldFZlcnNpb24yKGNsaWVudCkge1xcbiAgICBpZiAodmVyc2lvbkNhY2hlICE9PSBudWxsKSB7XFxuICAgICAgcmV0dXJuIHZlcnNpb25DYWNoZTtcXG4gICAgfVxcbiAgICBjb25zdCB2ZXJzaW9uNCA9IGF3YWl0IGNsaWVudC5yZWFkQ29udHJhY3Qoe1xcbiAgICAgIGFkZHJlc3M6IGdldFVzZGNBZGRyZXNzKGNsaWVudCksXFxuICAgICAgYWJpOiB1c2RjQUJJLFxcbiAgICAgIGZ1bmN0aW9uTmFtZTogXCJ2ZXJzaW9uXCJcXG4gICAgfSk7XFxuICAgIHZlcnNpb25DYWNoZSA9IHZlcnNpb240O1xcbiAgICByZXR1cm4gdmVyc2lvbkNhY2hlO1xcbiAgfVxcbiAgYXN5bmMgZnVuY3Rpb24gZ2V0VVNEQ0JhbGFuY2UoY2xpZW50LCBhZGRyZXNzKSB7XFxuICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBjbGllbnQucmVhZENvbnRyYWN0KHtcXG4gICAgICBhZGRyZXNzOiBnZXRVc2RjQWRkcmVzc0ZvckNoYWluKGNsaWVudC5jaGFpbi5pZCksXFxuICAgICAgYWJpOiB1c2RjQUJJLFxcbiAgICAgIGZ1bmN0aW9uTmFtZTogXCJiYWxhbmNlT2ZcIixcXG4gICAgICBhcmdzOiBbYWRkcmVzc11cXG4gICAgfSk7XFxuICAgIHJldHVybiBiYWxhbmNlO1xcbiAgfVxcblxcbiAgLy8gc3JjL3NjaGVtZXMvZXhhY3QvZXZtL3NpZ24udHNcXG4gIGFzeW5jIGZ1bmN0aW9uIHNpZ25BdXRob3JpemF0aW9uMih3YWxsZXRDbGllbnQsIHsgZnJvbTogZnJvbTUsIHRvLCB2YWx1ZSwgdmFsaWRBZnRlciwgdmFsaWRCZWZvcmUsIG5vbmNlIH0sIHsgYXNzZXQsIG5ldHdvcmssIGV4dHJhIH0pIHtcXG4gICAgY29uc3QgY2hhaW5JZCA9IGdldE5ldHdvcmtJZChuZXR3b3JrKTtcXG4gICAgY29uc3QgbmFtZSA9IGV4dHJhPy5uYW1lO1xcbiAgICBjb25zdCB2ZXJzaW9uNCA9IGV4dHJhPy52ZXJzaW9uO1xcbiAgICBjb25zdCBhY2NvdW50ID0gaXNTaWduZXJXYWxsZXQod2FsbGV0Q2xpZW50KSA/IHdhbGxldENsaWVudC5hY2NvdW50IDogd2FsbGV0Q2xpZW50O1xcbiAgICBjb25zdCBkYXRhID0ge1xcbiAgICAgIGFjY291bnQsXFxuICAgICAgdHlwZXM6IGF1dGhvcml6YXRpb25UeXBlcyxcXG4gICAgICBkb21haW46IHtcXG4gICAgICAgIG5hbWUsXFxuICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uNCxcXG4gICAgICAgIGNoYWluSWQsXFxuICAgICAgICB2ZXJpZnlpbmdDb250cmFjdDogYXNzZXRcXG4gICAgICB9LFxcbiAgICAgIHByaW1hcnlUeXBlOiBcIlRyYW5zZmVyV2l0aEF1dGhvcml6YXRpb25cIixcXG4gICAgICBtZXNzYWdlOiB7XFxuICAgICAgICBmcm9tOiBmcm9tNSxcXG4gICAgICAgIHRvLFxcbiAgICAgICAgdmFsdWUsXFxuICAgICAgICB2YWxpZEFmdGVyLFxcbiAgICAgICAgdmFsaWRCZWZvcmUsXFxuICAgICAgICBub25jZVxcbiAgICAgIH1cXG4gICAgfTtcXG4gICAgaWYgKGlzU2lnbmVyV2FsbGV0KHdhbGxldENsaWVudCkpIHtcXG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB3YWxsZXRDbGllbnQuc2lnblR5cGVkRGF0YShkYXRhKTtcXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgc2lnbmF0dXJlXFxuICAgICAgfTtcXG4gICAgfSBlbHNlIGlmIChpc0FjY291bnQod2FsbGV0Q2xpZW50KSAmJiB3YWxsZXRDbGllbnQuc2lnblR5cGVkRGF0YSkge1xcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHdhbGxldENsaWVudC5zaWduVHlwZWREYXRhKGRhdGEpO1xcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBzaWduYXR1cmVcXG4gICAgICB9O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgd2FsbGV0IGNsaWVudCBwcm92aWRlZCBkb2VzIG5vdCBzdXBwb3J0IHNpZ25UeXBlZERhdGFcIik7XFxuICAgIH1cXG4gIH1cXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vbmNlKCkge1xcbiAgICBjb25zdCBjcnlwdG9PYmogPSB0eXBlb2YgZ2xvYmFsVGhpcy5jcnlwdG8gIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGdsb2JhbFRoaXMuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gZ2xvYmFsVGhpcy5jcnlwdG8gOiAoXFxuICAgICAgLy8gRHluYW1pYyByZXF1aXJlIGlzIG5lZWRlZCB0byBzdXBwb3J0IG5vZGUuanNcXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xcbiAgICAgIF9fcmVxdWlyZShcImNyeXB0b1wiKS53ZWJjcnlwdG9cXG4gICAgKTtcXG4gICAgcmV0dXJuIHRvSGV4KGNyeXB0b09iai5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMzIpKSk7XFxuICB9XFxuXFxuICAvLyBzcmMvc2NoZW1lcy9leGFjdC9ldm0vdXRpbHMvcGF5bWVudFV0aWxzLnRzXFxuICBmdW5jdGlvbiBlbmNvZGVQYXltZW50KHBheW1lbnQpIHtcXG4gICAgY29uc3Qgc2FmZSA9IHtcXG4gICAgICAuLi5wYXltZW50LFxcbiAgICAgIHBheWxvYWQ6IHtcXG4gICAgICAgIC4uLnBheW1lbnQucGF5bG9hZCxcXG4gICAgICAgIGF1dGhvcml6YXRpb246IE9iamVjdC5mcm9tRW50cmllcyhcXG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMocGF5bWVudC5wYXlsb2FkLmF1dGhvcml6YXRpb24pLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBbXFxuICAgICAgICAgICAga2V5LFxcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIiA/IHZhbHVlLnRvU3RyaW5nKCkgOiB2YWx1ZVxcbiAgICAgICAgICBdKVxcbiAgICAgICAgKVxcbiAgICAgIH1cXG4gICAgfTtcXG4gICAgcmV0dXJuIHNhZmVCYXNlNjRFbmNvZGUoSlNPTi5zdHJpbmdpZnkoc2FmZSkpO1xcbiAgfVxcblxcbiAgLy8gc3JjL3NjaGVtZXMvZXhhY3QvZXZtL2NsaWVudC50c1xcbiAgZnVuY3Rpb24gcHJlcGFyZVBheW1lbnRIZWFkZXIoZnJvbTUsIHg0MDJWZXJzaW9uLCBwYXltZW50UmVxdWlyZW1lbnRzKSB7XFxuICAgIGNvbnN0IG5vbmNlID0gY3JlYXRlTm9uY2UoKTtcXG4gICAgY29uc3QgdmFsaWRBZnRlciA9IEJpZ0ludChcXG4gICAgICBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMpIC0gNjAwXFxuICAgICAgLy8gMTAgbWludXRlcyBiZWZvcmVcXG4gICAgKS50b1N0cmluZygpO1xcbiAgICBjb25zdCB2YWxpZEJlZm9yZSA9IEJpZ0ludChcXG4gICAgICBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMgKyBwYXltZW50UmVxdWlyZW1lbnRzLm1heFRpbWVvdXRTZWNvbmRzKVxcbiAgICApLnRvU3RyaW5nKCk7XFxuICAgIHJldHVybiB7XFxuICAgICAgeDQwMlZlcnNpb24sXFxuICAgICAgc2NoZW1lOiBwYXltZW50UmVxdWlyZW1lbnRzLnNjaGVtZSxcXG4gICAgICBuZXR3b3JrOiBwYXltZW50UmVxdWlyZW1lbnRzLm5ldHdvcmssXFxuICAgICAgcGF5bG9hZDoge1xcbiAgICAgICAgc2lnbmF0dXJlOiB2b2lkIDAsXFxuICAgICAgICBhdXRob3JpemF0aW9uOiB7XFxuICAgICAgICAgIGZyb206IGZyb201LFxcbiAgICAgICAgICB0bzogcGF5bWVudFJlcXVpcmVtZW50cy5wYXlUbyxcXG4gICAgICAgICAgdmFsdWU6IHBheW1lbnRSZXF1aXJlbWVudHMubWF4QW1vdW50UmVxdWlyZWQsXFxuICAgICAgICAgIHZhbGlkQWZ0ZXI6IHZhbGlkQWZ0ZXIudG9TdHJpbmcoKSxcXG4gICAgICAgICAgdmFsaWRCZWZvcmU6IHZhbGlkQmVmb3JlLnRvU3RyaW5nKCksXFxuICAgICAgICAgIG5vbmNlXFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfVxcbiAgYXN5bmMgZnVuY3Rpb24gc2lnblBheW1lbnRIZWFkZXIoY2xpZW50LCBwYXltZW50UmVxdWlyZW1lbnRzLCB1bnNpZ25lZFBheW1lbnRIZWFkZXIpIHtcXG4gICAgY29uc3QgeyBzaWduYXR1cmUgfSA9IGF3YWl0IHNpZ25BdXRob3JpemF0aW9uMihcXG4gICAgICBjbGllbnQsXFxuICAgICAgdW5zaWduZWRQYXltZW50SGVhZGVyLnBheWxvYWQuYXV0aG9yaXphdGlvbixcXG4gICAgICBwYXltZW50UmVxdWlyZW1lbnRzXFxuICAgICk7XFxuICAgIHJldHVybiB7XFxuICAgICAgLi4udW5zaWduZWRQYXltZW50SGVhZGVyLFxcbiAgICAgIHBheWxvYWQ6IHtcXG4gICAgICAgIC4uLnVuc2lnbmVkUGF5bWVudEhlYWRlci5wYXlsb2FkLFxcbiAgICAgICAgc2lnbmF0dXJlXFxuICAgICAgfVxcbiAgICB9O1xcbiAgfVxcbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlUGF5bWVudChjbGllbnQsIHg0MDJWZXJzaW9uLCBwYXltZW50UmVxdWlyZW1lbnRzKSB7XFxuICAgIGNvbnN0IGZyb201ID0gaXNTaWduZXJXYWxsZXQoY2xpZW50KSA/IGNsaWVudC5hY2NvdW50LmFkZHJlc3MgOiBjbGllbnQuYWRkcmVzcztcXG4gICAgY29uc3QgdW5zaWduZWRQYXltZW50SGVhZGVyID0gcHJlcGFyZVBheW1lbnRIZWFkZXIoZnJvbTUsIHg0MDJWZXJzaW9uLCBwYXltZW50UmVxdWlyZW1lbnRzKTtcXG4gICAgcmV0dXJuIHNpZ25QYXltZW50SGVhZGVyKGNsaWVudCwgcGF5bWVudFJlcXVpcmVtZW50cywgdW5zaWduZWRQYXltZW50SGVhZGVyKTtcXG4gIH1cXG4gIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVBheW1lbnRIZWFkZXIoY2xpZW50LCB4NDAyVmVyc2lvbiwgcGF5bWVudFJlcXVpcmVtZW50cykge1xcbiAgICBjb25zdCBwYXltZW50ID0gYXdhaXQgY3JlYXRlUGF5bWVudChjbGllbnQsIHg0MDJWZXJzaW9uLCBwYXltZW50UmVxdWlyZW1lbnRzKTtcXG4gICAgcmV0dXJuIGVuY29kZVBheW1lbnQocGF5bWVudCk7XFxuICB9XFxuXFxuICAvLyBzcmMvcGF5d2FsbC9zY3JpcHRzLnRzXFxuICBmdW5jdGlvbiBzYWZlQmFzZTY0RW5jb2RlMihkYXRhKSB7XFxuICAgIHJldHVybiB3aW5kb3cuYnRvYShkYXRhKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIHNlbGVjdFBheW1lbnRSZXF1aXJlbWVudHMocGF5bWVudFJlcXVpcmVtZW50cywgbmV0d29yaywgc2NoZW1lID0gXCJleGFjdFwiKSB7XFxuICAgIGNvbnN0IHJlcXVpcmVtZW50c0FycmF5ID0gQXJyYXkuaXNBcnJheShwYXltZW50UmVxdWlyZW1lbnRzKSA/IHBheW1lbnRSZXF1aXJlbWVudHMgOiBbcGF5bWVudFJlcXVpcmVtZW50c107XFxuICAgIGNvbnN0IG1hdGNoaW5nID0gcmVxdWlyZW1lbnRzQXJyYXkuZmlsdGVyKChyZXEpID0+IHtcXG4gICAgICBjb25zdCBzY2hlbWVNYXRjaCA9ICFzY2hlbWUgfHwgcmVxLnNjaGVtZSA9PT0gc2NoZW1lO1xcbiAgICAgIGNvbnN0IG5ldHdvcmtNYXRjaCA9ICFuZXR3b3JrIHx8IHJlcS5uZXR3b3JrID09PSBuZXR3b3JrO1xcbiAgICAgIHJldHVybiBzY2hlbWVNYXRjaCAmJiBuZXR3b3JrTWF0Y2g7XFxuICAgIH0pO1xcbiAgICByZXR1cm4gbWF0Y2hpbmcubGVuZ3RoID4gMCA/IG1hdGNoaW5nWzBdIDogcmVxdWlyZW1lbnRzQXJyYXlbMF07XFxuICB9XFxuICBmdW5jdGlvbiBlbnN1cmVWYWxpZEFtb3VudChwYXltZW50UmVxdWlyZW1lbnRzKSB7XFxuICAgIGNvbnN0IHVwZGF0ZWRSZXF1aXJlbWVudHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHBheW1lbnRSZXF1aXJlbWVudHMpKTtcXG4gICAgaWYgKHdpbmRvdy54NDAyPy5hbW91bnQpIHtcXG4gICAgICB0cnkge1xcbiAgICAgICAgY29uc3QgYW1vdW50SW5CYXNlVW5pdHMgPSBNYXRoLnJvdW5kKHdpbmRvdy54NDAyLmFtb3VudCAqIDFlNik7XFxuICAgICAgICB1cGRhdGVkUmVxdWlyZW1lbnRzLm1heEFtb3VudFJlcXVpcmVkID0gYW1vdW50SW5CYXNlVW5pdHMudG9TdHJpbmcoKTtcXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBwYXJzZSBhbW91bnQ6XCIsIGVycm9yKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKCF1cGRhdGVkUmVxdWlyZW1lbnRzLm1heEFtb3VudFJlcXVpcmVkIHx8ICEvXlxcXFxkKyQvLnRlc3QodXBkYXRlZFJlcXVpcmVtZW50cy5tYXhBbW91bnRSZXF1aXJlZCkpIHtcXG4gICAgICB1cGRhdGVkUmVxdWlyZW1lbnRzLm1heEFtb3VudFJlcXVpcmVkID0gXCIxMDAwMFwiO1xcbiAgICB9XFxuICAgIHJldHVybiB1cGRhdGVkUmVxdWlyZW1lbnRzO1xcbiAgfVxcbiAgZnVuY3Rpb24gZW5zdXJlRnVuY3Rpb25zQXJlQXZhaWxhYmxlKCkge1xcbiAgICByZXR1cm4ge1xcbiAgICAgIGNyZWF0ZVBheW1lbnRIZWFkZXIsXFxuICAgICAgY3JlYXRlUGF5bWVudCxcXG4gICAgICBzaWduQXV0aG9yaXphdGlvbjogc2lnbkF1dGhvcml6YXRpb24yLFxcbiAgICAgIGNyZWF0ZU5vbmNlLFxcbiAgICAgIGdldFZlcnNpb246IGdldFZlcnNpb24yLFxcbiAgICAgIGVuY29kZVBheW1lbnRcXG4gICAgfTtcXG4gIH1cXG4gIGZ1bmN0aW9uIHVwZGF0ZVBheW1lbnRVSSh4NDAyKSB7XFxuICAgIGlmICgheDQwMikgcmV0dXJuO1xcbiAgICBjb25zdCBhbW91bnQgPSB4NDAyLmFtb3VudCB8fCAwO1xcbiAgICBjb25zdCB0ZXN0bmV0ID0geDQwMi50ZXN0bmV0ID8/IHRydWU7XFxuICAgIGNvbnN0IGNoYWluTmFtZSA9IHRlc3RuZXQgPyBcIkJhc2UgU2Vwb2xpYVwiIDogXCJCYXNlXCI7XFxuICAgIGNvbnN0IG5ldHdvcmsgPSB0ZXN0bmV0ID8gXCJiYXNlLXNlcG9saWFcIiA6IFwiYmFzZVwiO1xcbiAgICBjb25zdCBwYXltZW50UmVxdWlyZW1lbnRzID0gc2VsZWN0UGF5bWVudFJlcXVpcmVtZW50cyhcXG4gICAgICB4NDAyLnBheW1lbnRSZXF1aXJlbWVudHMsXFxuICAgICAgbmV0d29yayxcXG4gICAgICBcImV4YWN0XCJcXG4gICAgKTtcXG4gICAgY29uc3QgZGVzY3JpcHRpb25FbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGF5bWVudC1kZXNjcmlwdGlvblwiKTtcXG4gICAgaWYgKGRlc2NyaXB0aW9uRWwpIHtcXG4gICAgICBkZXNjcmlwdGlvbkVsLnRleHRDb250ZW50ID0gcGF5bWVudFJlcXVpcmVtZW50cy5kZXNjcmlwdGlvbiA/IGAke3BheW1lbnRSZXF1aXJlbWVudHMuZGVzY3JpcHRpb259LiBUbyBhY2Nlc3MgdGhpcyBjb250ZW50LCBwbGVhc2UgcGF5ICQke2Ftb3VudH0gJHtjaGFpbk5hbWV9IFVTREMuYCA6IGBUbyBhY2Nlc3MgdGhpcyBjb250ZW50LCBwbGVhc2UgcGF5ICQke2Ftb3VudH0gJHtjaGFpbk5hbWV9IFVTREMuYDtcXG4gICAgfVxcbiAgICBjb25zdCBpbnN0cnVjdGlvbnNFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5zdHJ1Y3Rpb25zXCIpO1xcbiAgICBpZiAoaW5zdHJ1Y3Rpb25zRWwpIHtcXG4gICAgICBpZiAodGVzdG5ldCkge1xcbiAgICAgICAgaW5zdHJ1Y3Rpb25zRWwuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaW5zdHJ1Y3Rpb25zRWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBjb25zdCBhbW91bnRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGF5bWVudC1hbW91bnRcIik7XFxuICAgIGlmIChhbW91bnRFbCkge1xcbiAgICAgIGFtb3VudEVsLnRleHRDb250ZW50ID0gYCQke2Ftb3VudH0gVVNEQ2A7XFxuICAgIH1cXG4gICAgY29uc3QgbmV0d29ya0VsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwYXltZW50LW5ldHdvcmtcIik7XFxuICAgIGlmIChuZXR3b3JrRWwpIHtcXG4gICAgICBuZXR3b3JrRWwudGV4dENvbnRlbnQgPSBjaGFpbk5hbWU7XFxuICAgIH1cXG4gICAgY29uc3QgbG9hZGluZ0VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxvYWRpbmctbWVzc2FnZVwiKTtcXG4gICAgaWYgKGxvYWRpbmdFbGVtZW50KSB7XFxuICAgICAgbG9hZGluZ0VsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xcbiAgICB9XFxuICAgIGNvbnN0IHdhbGxldENvbm5lY3Rpb25FbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ3YWxsZXQtY29ubmVjdGlvblwiKTtcXG4gICAgaWYgKHdhbGxldENvbm5lY3Rpb25FbGVtZW50KSB7XFxuICAgICAgd2FsbGV0Q29ubmVjdGlvbkVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcXG4gICAgfVxcbiAgfVxcbiAgYXN5bmMgZnVuY3Rpb24gY29ubmVjdFdhbGxldChjaGFpbikge1xcbiAgICBpZiAoIXdpbmRvdy5ldGhlcmV1bSkge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGluamVjdGVkIEV0aGVyZXVtIHByb3ZpZGVyIGZvdW5kLiBQbGVhc2UgaW5zdGFsbCBNZXRhTWFzayBvciBzaW1pbGFyLlwiKTtcXG4gICAgfVxcbiAgICBjb25zdCBhZGRyZXNzZXMgPSBhd2FpdCB3aW5kb3cuZXRoZXJldW0ucmVxdWVzdCh7XFxuICAgICAgbWV0aG9kOiBcImV0aF9yZXF1ZXN0QWNjb3VudHNcIlxcbiAgICB9KTtcXG4gICAgaWYgKCFhZGRyZXNzZXMgfHwgYWRkcmVzc2VzLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGFjY291bnRzIGZvdW5kXCIpO1xcbiAgICB9XFxuICAgIHRyeSB7XFxuICAgICAgYXdhaXQgd2luZG93LmV0aGVyZXVtLnJlcXVlc3Qoe1xcbiAgICAgICAgbWV0aG9kOiBcIndhbGxldF9zd2l0Y2hFdGhlcmV1bUNoYWluXCIsXFxuICAgICAgICBwYXJhbXM6IFt7IGNoYWluSWQ6IGAweCR7Y2hhaW4uaWQudG9TdHJpbmcoMTYpfWAgfV1cXG4gICAgICB9KTtcXG4gICAgfSBjYXRjaCAoc3dpdGNoRXJyb3IpIHtcXG4gICAgICBjb25zdCBlcnJvciA9IHN3aXRjaEVycm9yO1xcbiAgICAgIGlmIChlcnJvci5jb2RlID09PSA0OTAyKSB7XFxuICAgICAgICBhd2FpdCB3aW5kb3cuZXRoZXJldW0ucmVxdWVzdCh7XFxuICAgICAgICAgIG1ldGhvZDogXCJ3YWxsZXRfYWRkRXRoZXJldW1DaGFpblwiLFxcbiAgICAgICAgICBwYXJhbXM6IFtcXG4gICAgICAgICAgICB7XFxuICAgICAgICAgICAgICBjaGFpbklkOiBgMHgke2NoYWluLmlkLnRvU3RyaW5nKDE2KX1gLFxcbiAgICAgICAgICAgICAgY2hhaW5OYW1lOiBjaGFpbi5uYW1lLFxcbiAgICAgICAgICAgICAgbmF0aXZlQ3VycmVuY3k6IGNoYWluLm5hdGl2ZUN1cnJlbmN5LFxcbiAgICAgICAgICAgICAgcnBjVXJsczogW2NoYWluLnJwY1VybHMuZGVmYXVsdC5odHRwWzBdXSxcXG4gICAgICAgICAgICAgIGJsb2NrRXhwbG9yZXJVcmxzOiBbY2hhaW4uYmxvY2tFeHBsb3JlcnM/LmRlZmF1bHQudXJsXVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgXVxcbiAgICAgICAgfSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRocm93IHN3aXRjaEVycm9yO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gYWRkcmVzc2VzWzBdO1xcbiAgfVxcbiAgYXN5bmMgZnVuY3Rpb24gaW5pdGlhbGl6ZUFwcCgpIHtcXG4gICAgY29uc3QgeDQwMiA9IHdpbmRvdy54NDAyO1xcbiAgICBpZiAoIXg0MDIpIHtcXG4gICAgICBjb25zb2xlLmVycm9yKFwieDQwMiBjb25maWd1cmF0aW9uIG5vdCBmb3VuZFwiKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgZW5zdXJlRnVuY3Rpb25zQXJlQXZhaWxhYmxlKCk7XFxuICAgIGNvbnN0IGNoYWluID0geDQwMi50ZXN0bmV0ID8gYmFzZVNlcG9saWEgOiBiYXNlO1xcbiAgICBjb25zdCBuZXR3b3JrID0geDQwMi50ZXN0bmV0ID8gXCJiYXNlLXNlcG9saWFcIiA6IFwiYmFzZVwiO1xcbiAgICBsZXQgd2FsbGV0Q2xpZW50ID0gbnVsbDtcXG4gICAgbGV0IGFkZHJlc3M7XFxuICAgIGNvbnN0IHB1YmxpY0NsaWVudCA9IGNyZWF0ZVB1YmxpY0NsaWVudCh7XFxuICAgICAgY2hhaW4sXFxuICAgICAgdHJhbnNwb3J0OiBodHRwKClcXG4gICAgfSkuZXh0ZW5kKHB1YmxpY0FjdGlvbnMpO1xcbiAgICBjb25zdCBjb25uZWN0V2FsbGV0QnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjb25uZWN0LXdhbGxldFwiKTtcXG4gICAgY29uc3QgcGF5bWVudFNlY3Rpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInBheW1lbnQtc2VjdGlvblwiKTtcXG4gICAgY29uc3QgcGF5QnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwYXktYnV0dG9uXCIpO1xcbiAgICBjb25zdCBzdGF0dXNEaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN0YXR1c1wiKTtcXG4gICAgaWYgKCFjb25uZWN0V2FsbGV0QnRuIHx8ICFwYXltZW50U2VjdGlvbiB8fCAhcGF5QnV0dG9uIHx8ICFzdGF0dXNEaXYpIHtcXG4gICAgICBjb25zb2xlLmVycm9yKFwiUmVxdWlyZWQgRE9NIGVsZW1lbnRzIG5vdCBmb3VuZFwiKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgY29uc3QgaGFuZGxlV2FsbGV0Q29ubmVjdCA9IGFzeW5jICgpID0+IHtcXG4gICAgICB0cnkge1xcbiAgICAgICAgc3RhdHVzRGl2LnRleHRDb250ZW50ID0gXCJDb25uZWN0aW5nIHdhbGxldC4uLlwiO1xcbiAgICAgICAgYWRkcmVzcyA9IGF3YWl0IGNvbm5lY3RXYWxsZXQoY2hhaW4pO1xcbiAgICAgICAgaWYgKCFhZGRyZXNzIHx8ICF3aW5kb3cuZXRoZXJldW0pIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYWNjb3VudCBzZWxlY3RlZCBpbiB5b3VyIHdhbGxldFwiKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHdhbGxldENsaWVudCA9IGNyZWF0ZVdhbGxldENsaWVudCh7XFxuICAgICAgICAgIGNoYWluLFxcbiAgICAgICAgICB0cmFuc3BvcnQ6IGN1c3RvbSh3aW5kb3cuZXRoZXJldW0pLFxcbiAgICAgICAgICBhY2NvdW50OiBhZGRyZXNzXFxuICAgICAgICB9KS5leHRlbmQocHVibGljQWN0aW9ucyk7XFxuICAgICAgICBjb25zdCBhY2NvdW50RWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInBheW1lbnQtYWNjb3VudFwiKTtcXG4gICAgICAgIGlmIChhY2NvdW50RWwpIHtcXG4gICAgICAgICAgYWNjb3VudEVsLnRleHRDb250ZW50ID0gYCR7YWRkcmVzcy5zbGljZSgwLCA2KX0uLi4ke2FkZHJlc3Muc2xpY2UoLTQpfWA7XFxuICAgICAgICB9XFxuICAgICAgICBjb25uZWN0V2FsbGV0QnRuLnRleHRDb250ZW50ID0gXCJDb25uZWN0ZWRcIjtcXG4gICAgICAgIGNvbm5lY3RXYWxsZXRCdG4uY2xhc3NMaXN0LmFkZChcImNvbm5lY3RlZFwiKTtcXG4gICAgICAgIGNvbm5lY3RXYWxsZXRCdG4uZGlzYWJsZWQgPSB0cnVlO1xcbiAgICAgICAgcGF5bWVudFNlY3Rpb24uY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcXG4gICAgICAgIHN0YXR1c0Rpdi50ZXh0Q29udGVudCA9IFwiV2FsbGV0IGNvbm5lY3RlZCEgWW91IGNhbiBub3cgcHJvY2VlZCB3aXRoIHBheW1lbnQuXCI7XFxuICAgICAgICBjb25uZWN0V2FsbGV0QnRuLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVXYWxsZXRDb25uZWN0KTtcXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xcbiAgICAgICAgc3RhdHVzRGl2LnRleHRDb250ZW50ID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIkZhaWxlZCB0byBjb25uZWN0IHdhbGxldFwiO1xcbiAgICAgICAgY29ubmVjdFdhbGxldEJ0bi50ZXh0Q29udGVudCA9IFwiQ29ubmVjdCB3YWxsZXRcIjtcXG4gICAgICAgIGNvbm5lY3RXYWxsZXRCdG4uY2xhc3NMaXN0LnJlbW92ZShcImNvbm5lY3RlZFwiKTtcXG4gICAgICAgIGNvbm5lY3RXYWxsZXRCdG4uZGlzYWJsZWQgPSBmYWxzZTtcXG4gICAgICAgIHBheW1lbnRTZWN0aW9uLmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIik7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgICBjb25zdCBoYW5kbGVQYXltZW50ID0gYXN5bmMgKCkgPT4ge1xcbiAgICAgIGlmICghd2FsbGV0Q2xpZW50IHx8ICFhZGRyZXNzKSB7XFxuICAgICAgICBzdGF0dXNEaXYudGV4dENvbnRlbnQgPSBcIk5vIHdhbGxldCBjb25uZWN0ZWQuIFBsZWFzZSBjb25uZWN0IHlvdXIgd2FsbGV0IGZpcnN0LlwiO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgICB0cnkge1xcbiAgICAgICAgc3RhdHVzRGl2LnRleHRDb250ZW50ID0gXCJDaGVja2luZyBVU0RDIGJhbGFuY2UuLi5cIjtcXG4gICAgICAgIGNvbnN0IGJhbGFuY2UgPSBhd2FpdCBnZXRVU0RDQmFsYW5jZShwdWJsaWNDbGllbnQsIGFkZHJlc3MpO1xcbiAgICAgICAgaWYgKGJhbGFuY2UgPT09IDBuKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXG4gICAgICAgICAgICBgWW91ciBVU0RDIGJhbGFuY2UgaXMgMC4gUGxlYXNlIG1ha2Ugc3VyZSB5b3UgaGF2ZSBVU0RDIHRva2VucyBvbiAke2NoYWluLm5hbWV9YFxcbiAgICAgICAgICApO1xcbiAgICAgICAgfVxcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XFxuICAgICAgICBzdGF0dXNEaXYudGV4dENvbnRlbnQgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiRmFpbGVkIHRvIGNoZWNrIFVTREMgYmFsYW5jZVwiO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgICBzdGF0dXNEaXYudGV4dENvbnRlbnQgPSBcIkNyZWF0aW5nIHBheW1lbnQgc2lnbmF0dXJlLi4uXCI7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIGNvbnN0IHBheW1lbnRSZXF1aXJlbWVudHMgPSBzZWxlY3RQYXltZW50UmVxdWlyZW1lbnRzKFxcbiAgICAgICAgICB4NDAyLnBheW1lbnRSZXF1aXJlbWVudHMsXFxuICAgICAgICAgIG5ldHdvcmssXFxuICAgICAgICAgIFwiZXhhY3RcIlxcbiAgICAgICAgKTtcXG4gICAgICAgIGNvbnN0IHZhbGlkUGF5bWVudFJlcXVpcmVtZW50cyA9IGVuc3VyZVZhbGlkQW1vdW50KHBheW1lbnRSZXF1aXJlbWVudHMpO1xcbiAgICAgICAgY29uc3QgaW5pdGlhbFBheW1lbnQgPSBhd2FpdCBjcmVhdGVQYXltZW50KHdhbGxldENsaWVudCwgMSwgdmFsaWRQYXltZW50UmVxdWlyZW1lbnRzKTtcXG4gICAgICAgIGluaXRpYWxQYXltZW50Lng0MDJWZXJzaW9uID0gMTtcXG4gICAgICAgIGNvbnN0IHBheW1lbnRIZWFkZXIgPSBzYWZlQmFzZTY0RW5jb2RlMihKU09OLnN0cmluZ2lmeShpbml0aWFsUGF5bWVudCkpO1xcbiAgICAgICAgc3RhdHVzRGl2LnRleHRDb250ZW50ID0gXCJSZXF1ZXN0aW5nIGNvbnRlbnQgd2l0aCBwYXltZW50Li4uXCI7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHg0MDIuY3VycmVudFVybCwge1xcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgIFwiWC1QQVlNRU5UXCI6IHBheW1lbnRIZWFkZXIsXFxuICAgICAgICAgICAgICBcIkFjY2Vzcy1Db250cm9sLUV4cG9zZS1IZWFkZXJzXCI6IFwiWC1QQVlNRU5ULVJFU1BPTlNFXCJcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBpZiAocmVzcG9uc2Uub2spIHtcXG4gICAgICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpO1xcbiAgICAgICAgICAgIGlmIChjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmNsdWRlcyhcInRleHQvaHRtbFwiKSkge1xcbiAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmlubmVySFRNTCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcXG4gICAgICAgICAgICAgIGNvbnN0IHVybCA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xcbiAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAyKSB7XFxuICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcXG4gICAgICAgICAgICAgIGlmIChlcnJvckRhdGEgJiYgdHlwZW9mIGVycm9yRGF0YS54NDAyVmVyc2lvbiA9PT0gXCJudW1iZXJcIikge1xcbiAgICAgICAgICAgICAgICBjb25zdCByZXRyeVBheW1lbnQgPSBhd2FpdCBjcmVhdGVQYXltZW50KFxcbiAgICAgICAgICAgICAgICAgIHdhbGxldENsaWVudCxcXG4gICAgICAgICAgICAgICAgICBlcnJvckRhdGEueDQwMlZlcnNpb24sXFxuICAgICAgICAgICAgICAgICAgdmFsaWRQYXltZW50UmVxdWlyZW1lbnRzXFxuICAgICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgICAgIHJldHJ5UGF5bWVudC54NDAyVmVyc2lvbiA9IGVycm9yRGF0YS54NDAyVmVyc2lvbjtcXG4gICAgICAgICAgICAgICAgY29uc3QgcmV0cnlIZWFkZXIgPSBzYWZlQmFzZTY0RW5jb2RlMihKU09OLnN0cmluZ2lmeShyZXRyeVBheW1lbnQpKTtcXG4gICAgICAgICAgICAgICAgY29uc3QgcmV0cnlSZXNwb25zZSA9IGF3YWl0IGZldGNoKHg0MDIuY3VycmVudFVybCwge1xcbiAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcXG4gICAgICAgICAgICAgICAgICAgIFwiWC1QQVlNRU5UXCI6IHJldHJ5SGVhZGVyLFxcbiAgICAgICAgICAgICAgICAgICAgXCJBY2Nlc3MtQ29udHJvbC1FeHBvc2UtSGVhZGVyc1wiOiBcIlgtUEFZTUVOVC1SRVNQT05TRVwiXFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgaWYgKHJldHJ5UmVzcG9uc2Uub2spIHtcXG4gICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJldHJ5UmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIik7XFxuICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwidGV4dC9odG1sXCIpKSB7XFxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuaW5uZXJIVE1MID0gYXdhaXQgcmV0cnlSZXNwb25zZS50ZXh0KCk7XFxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCByZXRyeVJlc3BvbnNlLmJsb2IoKTtcXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBheW1lbnQgZmFpbGVkOiAke3JldHJ5UmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXltZW50IGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0gY2F0Y2gge1xcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXltZW50IGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlcXVlc3QgZmFpbGVkOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGNhdGNoIChmZXRjaEVycm9yKSB7XFxuICAgICAgICAgIHRocm93IGZldGNoRXJyb3I7XFxuICAgICAgICB9XFxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcXG4gICAgICAgIHN0YXR1c0Rpdi50ZXh0Q29udGVudCA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJQYXltZW50IGZhaWxlZFwiO1xcbiAgICAgIH1cXG4gICAgfTtcXG4gICAgY29ubmVjdFdhbGxldEJ0bi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlV2FsbGV0Q29ubmVjdCk7XFxuICAgIHBheUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlUGF5bWVudCk7XFxuICB9XFxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4ge1xcbiAgICB1cGRhdGVQYXltZW50VUkod2luZG93Lng0MDIpO1xcbiAgICBpbml0aWFsaXplQXBwKCkuY2F0Y2goKGVycm9yKSA9PiB7XFxuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBpbml0aWFsaXplIGFwcDpcIiwgZXJyb3IpO1xcbiAgICAgIGNvbnN0IHN0YXR1c0RpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3RhdHVzXCIpO1xcbiAgICAgIGlmIChzdGF0dXNEaXYpIHtcXG4gICAgICAgIHN0YXR1c0Rpdi50ZXh0Q29udGVudCA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJGYWlsZWQgdG8gaW5pdGlhbGl6ZSBhcHBcIjtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfSk7XFxufSkoKTtcXG4vKiEgQnVuZGxlZCBsaWNlbnNlIGluZm9ybWF0aW9uOlxcblxcbkBub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzOlxcbkBub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzOlxcbiAgKCohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqKVxcblxcbkBub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3V0aWxzLmpzOlxcbkBub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L21vZHVsYXIuanM6XFxuQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvY3VydmUuanM6XFxuQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanM6XFxuQG5vYmxlL2N1cnZlcy9lc20vX3Nob3J0d191dGlscy5qczpcXG5Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanM6XFxuICAoKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICopXFxuKi9cXG48L3NjcmlwdD48L2JvZHk+PC9odG1sPic7XG5cbi8vIHNyYy90eXBlcy9zaGFyZWQvZXZtL2NvbmZpZy50c1xudmFyIGNvbmZpZyA9IHtcbiAgXCI4NDUzMlwiOiB7XG4gICAgdXNkY0FkZHJlc3M6IFwiMHgwMzZDYkQ1Mzg0MmM1NDI2NjM0ZTc5Mjk1NDFlQzIzMThmM2RDRjdlXCIsXG4gICAgdXNkY05hbWU6IFwiVVNEQ1wiXG4gIH0sXG4gIFwiODQ1M1wiOiB7XG4gICAgdXNkY0FkZHJlc3M6IFwiMHg4MzM1ODlmQ0Q2ZURiNkUwOGY0YzdDMzJENGY3MWI1NGJkQTAyOTEzXCIsXG4gICAgdXNkY05hbWU6IFwiVVNEQ1wiXG4gIH0sXG4gIFwiNDMxMTNcIjoge1xuICAgIHVzZGNBZGRyZXNzOiBcIjB4NTQyNTg5MDI5OGFlZDYwMTU5NWE3MEFCODE1Yzk2NzExYTMxQmM2NVwiLFxuICAgIHVzZGNOYW1lOiBcIlVTRCBDb2luXCJcbiAgfSxcbiAgXCI0MzExNFwiOiB7XG4gICAgdXNkY0FkZHJlc3M6IFwiMHhCOTdFRjlFZjg3MzRDNzE5MDREODAwMkY4YjZCYzY2RGQ5YzQ4YTZFXCIsXG4gICAgdXNkY05hbWU6IFwiVVNEQ1wiXG4gIH0sXG4gIFwiNDY4OVwiOiB7XG4gICAgdXNkY0FkZHJlc3M6IFwiMHhjZGY3OTE5NGM2YzI4NTA3N2E1OGRhNDc2NDFkNGRiZTUxZjYzNTQyXCIsXG4gICAgdXNkY05hbWU6IFwiQnJpZGdlZCBVU0RDXCJcbiAgfVxufTtcblxuLy8gc3JjL3NoYXJlZC9wYXl3YWxsLnRzXG5mdW5jdGlvbiBnZXRQYXl3YWxsSHRtbCh7XG4gIGFtb3VudCxcbiAgdGVzdG5ldCxcbiAgcGF5bWVudFJlcXVpcmVtZW50cyxcbiAgY3VycmVudFVybFxufSkge1xuICBjb25zdCBjb25maWdTY3JpcHQgPSBgXG4gIDxzY3JpcHQ+XG4gICAgd2luZG93Lng0MDIgPSB7XG4gICAgICBhbW91bnQ6ICR7YW1vdW50fSxcbiAgICAgIHBheW1lbnRSZXF1aXJlbWVudHM6ICR7SlNPTi5zdHJpbmdpZnkocGF5bWVudFJlcXVpcmVtZW50cyl9LFxuICAgICAgdGVzdG5ldDogJHt0ZXN0bmV0fSxcbiAgICAgIGN1cnJlbnRVcmw6IFwiJHtjdXJyZW50VXJsfVwiLFxuICAgICAgY29uZmlnOiB7XG4gICAgICAgIGNoYWluQ29uZmlnOiAke0pTT04uc3RyaW5naWZ5KGNvbmZpZyl9LFxuICAgICAgfVxuICAgIH07XG4gICAgY29uc29sZS5sb2coJ1BheW1lbnQgZGV0YWlscyBpbml0aWFsaXplZDonLCB3aW5kb3cueDQwMi5wYXltZW50RGV0YWlscyk7XG4gIDwvc2NyaXB0PmA7XG4gIHJldHVybiBQQVlXQUxMX1RFTVBMQVRFLnJlcGxhY2UoXCI8L2hlYWQ+XCIsIGAke2NvbmZpZ1NjcmlwdH1cbjwvaGVhZD5gKTtcbn1cblxuLy8gc3JjL3NoYXJlZC9iYXNlNjQudHNcbmZ1bmN0aW9uIHNhZmVCYXNlNjRFbmNvZGUoZGF0YSkge1xuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGdsb2JhbFRoaXMuYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXMuYnRvYShkYXRhKTtcbiAgfVxuICByZXR1cm4gQnVmZmVyLmZyb20oZGF0YSkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG59XG5mdW5jdGlvbiBzYWZlQmFzZTY0RGVjb2RlKGRhdGEpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBnbG9iYWxUaGlzLmF0b2IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBnbG9iYWxUaGlzLmF0b2IoZGF0YSk7XG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGRhdGEsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKFwidXRmLThcIik7XG59XG5cbi8vIHNyYy90eXBlcy9zaGFyZWQvbW9uZXkudHNcbnZhciBpbXBvcnRfem9kID0gcmVxdWlyZShcInpvZFwiKTtcbnZhciBtb25leVNjaGVtYSA9IGltcG9ydF96b2Quei51bmlvbihbaW1wb3J0X3pvZC56LnN0cmluZygpLnRyYW5zZm9ybSgoeCkgPT4geC5yZXBsYWNlKC9bXjAtOS4tXSsvZywgXCJcIikpLCBpbXBvcnRfem9kLnoubnVtYmVyKCldKS5waXBlKGltcG9ydF96b2Quei5jb2VyY2UubnVtYmVyKCkubWluKDFlLTQpLm1heCg5OTk5OTk5OTkpKTtcblxuLy8gc3JjL3R5cGVzL3NoYXJlZC9uZXR3b3JrLnRzXG52YXIgaW1wb3J0X3pvZDIgPSByZXF1aXJlKFwiem9kXCIpO1xudmFyIE5ldHdvcmtTY2hlbWEgPSBpbXBvcnRfem9kMi56LmVudW0oW1xuICBcImJhc2Utc2Vwb2xpYVwiLFxuICBcImJhc2VcIixcbiAgXCJhdmFsYW5jaGUtZnVqaVwiLFxuICBcImF2YWxhbmNoZVwiLFxuICBcImlvdGV4XCJcbl0pO1xudmFyIFN1cHBvcnRlZEVWTU5ldHdvcmtzID0gW1xuICBcImJhc2Utc2Vwb2xpYVwiLFxuICBcImJhc2VcIixcbiAgXCJhdmFsYW5jaGUtZnVqaVwiLFxuICBcImF2YWxhbmNoZVwiLFxuICBcImlvdGV4XCJcbl07XG52YXIgRXZtTmV0d29ya1RvQ2hhaW5JZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgW1wiYmFzZS1zZXBvbGlhXCIsIDg0NTMyXSxcbiAgW1wiYmFzZVwiLCA4NDUzXSxcbiAgW1wiYXZhbGFuY2hlLWZ1amlcIiwgNDMxMTNdLFxuICBbXCJhdmFsYW5jaGVcIiwgNDMxMTRdLFxuICBbXCJpb3RleFwiLCA0Njg5XVxuXSk7XG52YXIgQ2hhaW5JZFRvTmV0d29yayA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgU3VwcG9ydGVkRVZNTmV0d29ya3MubWFwKChuZXR3b3JrKSA9PiBbRXZtTmV0d29ya1RvQ2hhaW5JZC5nZXQobmV0d29yayksIG5ldHdvcmtdKVxuKTtcblxuLy8gc3JjL3R5cGVzL3NoYXJlZC9ldm0vd2FsbGV0LnRzXG52YXIgaW1wb3J0X3ZpZW0gPSByZXF1aXJlKFwidmllbVwiKTtcbnZhciBpbXBvcnRfY2hhaW5zID0gcmVxdWlyZShcInZpZW0vY2hhaW5zXCIpO1xudmFyIGltcG9ydF9hY2NvdW50cyA9IHJlcXVpcmUoXCJ2aWVtL2FjY291bnRzXCIpO1xuXG4vLyBzcmMvc2hhcmVkL25ldHdvcmsudHNcbmZ1bmN0aW9uIGdldE5ldHdvcmtJZChuZXR3b3JrKSB7XG4gIGlmIChFdm1OZXR3b3JrVG9DaGFpbklkLmhhcyhuZXR3b3JrKSkge1xuICAgIHJldHVybiBFdm1OZXR3b3JrVG9DaGFpbklkLmdldChuZXR3b3JrKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG5ldHdvcms6ICR7bmV0d29ya31gKTtcbn1cblxuLy8gc3JjL3R5cGVzL3ZlcmlmeS94NDAyU3BlY3MudHNcbnZhciBpbXBvcnRfem9kMyA9IHJlcXVpcmUoXCJ6b2RcIik7XG52YXIgRXZtTWF4QXRvbWljVW5pdHMgPSAxODtcbnZhciBFdm1BZGRyZXNzUmVnZXggPSAvXjB4WzAtOWEtZkEtRl17NDB9JC87XG52YXIgTWl4ZWRBZGRyZXNzUmVnZXggPSAvXjB4W2EtZkEtRjAtOV17NDB9fFtBLVphLXowLTldW0EtWmEtejAtOS1dezAsMzR9W0EtWmEtejAtOV0kLztcbnZhciBIZXhFbmNvZGVkNjRCeXRlUmVnZXggPSAvXjB4WzAtOWEtZkEtRl17NjR9JC87XG52YXIgRXZtU2lnbmF0dXJlUmVnZXggPSAvXjB4WzAtOWEtZkEtRl17MTMwfSQvO1xudmFyIHNjaGVtZXMgPSBbXCJleGFjdFwiXTtcbnZhciB4NDAyVmVyc2lvbnMgPSBbMV07XG52YXIgRXJyb3JSZWFzb25zID0gW1xuICBcImluc3VmZmljaWVudF9mdW5kc1wiLFxuICBcImludmFsaWRfZXhhY3RfZXZtX3BheWxvYWRfYXV0aG9yaXphdGlvbl92YWxpZF9hZnRlclwiLFxuICBcImludmFsaWRfZXhhY3RfZXZtX3BheWxvYWRfYXV0aG9yaXphdGlvbl92YWxpZF9iZWZvcmVcIixcbiAgXCJpbnZhbGlkX2V4YWN0X2V2bV9wYXlsb2FkX2F1dGhvcml6YXRpb25fdmFsdWVcIixcbiAgXCJpbnZhbGlkX2V4YWN0X2V2bV9wYXlsb2FkX3NpZ25hdHVyZVwiLFxuICBcImludmFsaWRfZXhhY3RfZXZtX3BheWxvYWRfcmVjaXBpZW50X21pc21hdGNoXCIsXG4gIFwiaW52YWxpZF9uZXR3b3JrXCIsXG4gIFwiaW52YWxpZF9wYXlsb2FkXCIsXG4gIFwiaW52YWxpZF9wYXltZW50X3JlcXVpcmVtZW50c1wiLFxuICBcImludmFsaWRfc2NoZW1lXCIsXG4gIFwidW5zdXBwb3J0ZWRfc2NoZW1lXCIsXG4gIFwiaW52YWxpZF94NDAyX3ZlcnNpb25cIixcbiAgXCJpbnZhbGlkX3RyYW5zYWN0aW9uX3N0YXRlXCIsXG4gIFwidW5leHBlY3RlZF92ZXJpZnlfZXJyb3JcIixcbiAgXCJ1bmV4cGVjdGVkX3NldHRsZV9lcnJvclwiXG5dO1xudmFyIGlzSW50ZWdlciA9ICh2YWx1ZSkgPT4gTnVtYmVyLmlzSW50ZWdlcihOdW1iZXIodmFsdWUpKSAmJiBOdW1iZXIodmFsdWUpID49IDA7XG52YXIgaGFzTWF4TGVuZ3RoID0gKG1heExlbmd0aCkgPT4gKHZhbHVlKSA9PiB2YWx1ZS5sZW5ndGggPD0gbWF4TGVuZ3RoO1xudmFyIFBheW1lbnRSZXF1aXJlbWVudHNTY2hlbWEgPSBpbXBvcnRfem9kMy56Lm9iamVjdCh7XG4gIHNjaGVtZTogaW1wb3J0X3pvZDMuei5lbnVtKHNjaGVtZXMpLFxuICBuZXR3b3JrOiBOZXR3b3JrU2NoZW1hLFxuICBtYXhBbW91bnRSZXF1aXJlZDogaW1wb3J0X3pvZDMuei5zdHJpbmcoKS5yZWZpbmUoaXNJbnRlZ2VyKSxcbiAgcmVzb3VyY2U6IGltcG9ydF96b2QzLnouc3RyaW5nKCkudXJsKCksXG4gIGRlc2NyaXB0aW9uOiBpbXBvcnRfem9kMy56LnN0cmluZygpLFxuICBtaW1lVHlwZTogaW1wb3J0X3pvZDMuei5zdHJpbmcoKSxcbiAgb3V0cHV0U2NoZW1hOiBpbXBvcnRfem9kMy56LnJlY29yZChpbXBvcnRfem9kMy56LmFueSgpKS5vcHRpb25hbCgpLFxuICBwYXlUbzogaW1wb3J0X3pvZDMuei5zdHJpbmcoKS5yZWdleChNaXhlZEFkZHJlc3NSZWdleCksXG4gIG1heFRpbWVvdXRTZWNvbmRzOiBpbXBvcnRfem9kMy56Lm51bWJlcigpLmludCgpLFxuICBhc3NldDogaW1wb3J0X3pvZDMuei5zdHJpbmcoKS5yZWdleChNaXhlZEFkZHJlc3NSZWdleCksXG4gIGV4dHJhOiBpbXBvcnRfem9kMy56LnJlY29yZChpbXBvcnRfem9kMy56LmFueSgpKS5vcHRpb25hbCgpXG59KTtcbnZhciBFeGFjdEV2bVBheWxvYWRBdXRob3JpemF0aW9uU2NoZW1hID0gaW1wb3J0X3pvZDMuei5vYmplY3Qoe1xuICBmcm9tOiBpbXBvcnRfem9kMy56LnN0cmluZygpLnJlZ2V4KEV2bUFkZHJlc3NSZWdleCksXG4gIHRvOiBpbXBvcnRfem9kMy56LnN0cmluZygpLnJlZ2V4KEV2bUFkZHJlc3NSZWdleCksXG4gIHZhbHVlOiBpbXBvcnRfem9kMy56LnN0cmluZygpLnJlZmluZShpc0ludGVnZXIpLnJlZmluZShoYXNNYXhMZW5ndGgoRXZtTWF4QXRvbWljVW5pdHMpKSxcbiAgdmFsaWRBZnRlcjogaW1wb3J0X3pvZDMuei5zdHJpbmcoKS5yZWZpbmUoaXNJbnRlZ2VyKSxcbiAgdmFsaWRCZWZvcmU6IGltcG9ydF96b2QzLnouc3RyaW5nKCkucmVmaW5lKGlzSW50ZWdlciksXG4gIG5vbmNlOiBpbXBvcnRfem9kMy56LnN0cmluZygpLnJlZ2V4KEhleEVuY29kZWQ2NEJ5dGVSZWdleClcbn0pO1xudmFyIEV4YWN0RXZtUGF5bG9hZFNjaGVtYSA9IGltcG9ydF96b2QzLnoub2JqZWN0KHtcbiAgc2lnbmF0dXJlOiBpbXBvcnRfem9kMy56LnN0cmluZygpLnJlZ2V4KEV2bVNpZ25hdHVyZVJlZ2V4KSxcbiAgYXV0aG9yaXphdGlvbjogRXhhY3RFdm1QYXlsb2FkQXV0aG9yaXphdGlvblNjaGVtYVxufSk7XG52YXIgUGF5bWVudFBheWxvYWRTY2hlbWEgPSBpbXBvcnRfem9kMy56Lm9iamVjdCh7XG4gIHg0MDJWZXJzaW9uOiBpbXBvcnRfem9kMy56Lm51bWJlcigpLnJlZmluZSgodmFsKSA9PiB4NDAyVmVyc2lvbnMuaW5jbHVkZXModmFsKSksXG4gIHNjaGVtZTogaW1wb3J0X3pvZDMuei5lbnVtKHNjaGVtZXMpLFxuICBuZXR3b3JrOiBOZXR3b3JrU2NoZW1hLFxuICBwYXlsb2FkOiBFeGFjdEV2bVBheWxvYWRTY2hlbWFcbn0pO1xudmFyIFZlcmlmeVJlc3BvbnNlU2NoZW1hID0gaW1wb3J0X3pvZDMuei5vYmplY3Qoe1xuICBpc1ZhbGlkOiBpbXBvcnRfem9kMy56LmJvb2xlYW4oKSxcbiAgaW52YWxpZFJlYXNvbjogaW1wb3J0X3pvZDMuei5lbnVtKEVycm9yUmVhc29ucykub3B0aW9uYWwoKSxcbiAgcGF5ZXI6IGltcG9ydF96b2QzLnouc3RyaW5nKCkucmVnZXgoTWl4ZWRBZGRyZXNzUmVnZXgpLm9wdGlvbmFsKClcbn0pO1xudmFyIFNldHRsZVJlc3BvbnNlU2NoZW1hID0gaW1wb3J0X3pvZDMuei5vYmplY3Qoe1xuICBzdWNjZXNzOiBpbXBvcnRfem9kMy56LmJvb2xlYW4oKSxcbiAgZXJyb3JSZWFzb246IGltcG9ydF96b2QzLnouZW51bShFcnJvclJlYXNvbnMpLm9wdGlvbmFsKCksXG4gIHBheWVyOiBpbXBvcnRfem9kMy56LnN0cmluZygpLnJlZ2V4KE1peGVkQWRkcmVzc1JlZ2V4KS5vcHRpb25hbCgpLFxuICB0cmFuc2FjdGlvbjogaW1wb3J0X3pvZDMuei5zdHJpbmcoKS5yZWdleChNaXhlZEFkZHJlc3NSZWdleCksXG4gIG5ldHdvcms6IE5ldHdvcmtTY2hlbWFcbn0pO1xudmFyIFN1cHBvcnRlZFBheW1lbnRLaW5kU2NoZW1hID0gaW1wb3J0X3pvZDMuei5vYmplY3Qoe1xuICB4NDAyVmVyc2lvbjogaW1wb3J0X3pvZDMuei5udW1iZXIoKS5yZWZpbmUoKHZhbCkgPT4geDQwMlZlcnNpb25zLmluY2x1ZGVzKHZhbCkpLFxuICBzY2hlbWU6IGltcG9ydF96b2QzLnouZW51bShzY2hlbWVzKSxcbiAgbmV0d29yazogTmV0d29ya1NjaGVtYVxufSk7XG52YXIgU3VwcG9ydGVkUGF5bWVudEtpbmRzUmVzcG9uc2VTY2hlbWEgPSBpbXBvcnRfem9kMy56Lm9iamVjdCh7XG4gIGtpbmRzOiBpbXBvcnRfem9kMy56LmFycmF5KFN1cHBvcnRlZFBheW1lbnRLaW5kU2NoZW1hKVxufSk7XG5cbi8vIHNyYy90eXBlcy92ZXJpZnkvZmFjaWxpdGF0b3IudHNcbnZhciBpbXBvcnRfem9kNCA9IHJlcXVpcmUoXCJ6b2RcIik7XG52YXIgZmFjaWxpdGF0b3JSZXF1ZXN0U2NoZW1hID0gaW1wb3J0X3pvZDQuei5vYmplY3Qoe1xuICBwYXltZW50SGVhZGVyOiBpbXBvcnRfem9kNC56LnN0cmluZygpLFxuICBwYXltZW50UmVxdWlyZW1lbnRzOiBQYXltZW50UmVxdWlyZW1lbnRzU2NoZW1hXG59KTtcblxuLy8gc3JjL3NoYXJlZC9ldm0vdXNkYy50c1xuZnVuY3Rpb24gZ2V0VXNkY0FkZHJlc3NGb3JDaGFpbihjaGFpbklkKSB7XG4gIHJldHVybiBjb25maWdbY2hhaW5JZC50b1N0cmluZygpXS51c2RjQWRkcmVzcztcbn1cblxuLy8gc3JjL3NoYXJlZC9taWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBjb21wdXRlUm91dGVQYXR0ZXJucyhyb3V0ZXMpIHtcbiAgY29uc3Qgbm9ybWFsaXplZFJvdXRlcyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhyb3V0ZXMpLm1hcCgoW3BhdHRlcm4sIHZhbHVlXSkgPT4gW1xuICAgICAgcGF0dGVybixcbiAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgPyB7IHByaWNlOiB2YWx1ZSwgbmV0d29yazogXCJiYXNlLXNlcG9saWFcIiB9IDogdmFsdWVcbiAgICBdKVxuICApO1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMobm9ybWFsaXplZFJvdXRlcykubWFwKChbcGF0dGVybiwgcm91dGVDb25maWddKSA9PiB7XG4gICAgY29uc3QgW3ZlcmIsIHBhdGhdID0gcGF0dGVybi5pbmNsdWRlcyhcIiBcIikgPyBwYXR0ZXJuLnNwbGl0KC9cXHMrLykgOiBbXCIqXCIsIHBhdHRlcm5dO1xuICAgIGlmICghcGF0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJvdXRlIHBhdHRlcm46ICR7cGF0dGVybn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHZlcmI6IHZlcmIudG9VcHBlckNhc2UoKSxcbiAgICAgIHBhdHRlcm46IG5ldyBSZWdFeHAoXG4gICAgICAgIGBeJHtwYXRoLnJlcGxhY2UoL1xcKi9nLCBcIi4qP1wiKS5yZXBsYWNlKC9cXFsoW15cXF1dKylcXF0vZywgXCJbXi9dK1wiKS5yZXBsYWNlKC9cXC8vZywgXCJcXFxcL1wiKX0kYCxcbiAgICAgICAgXCJpXCJcbiAgICAgICksXG4gICAgICBjb25maWc6IHJvdXRlQ29uZmlnXG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBmaW5kTWF0Y2hpbmdSb3V0ZShyb3V0ZVBhdHRlcm5zLCBwYXRoLCBtZXRob2QpIHtcbiAgY29uc3QgbWF0Y2hpbmdSb3V0ZXMgPSByb3V0ZVBhdHRlcm5zLmZpbHRlcigoeyBwYXR0ZXJuLCB2ZXJiIH0pID0+IHtcbiAgICBjb25zdCBtYXRjaGVzUGF0aCA9IHBhdHRlcm4udGVzdChwYXRoKTtcbiAgICBjb25zdCBtYXRjaGVzVmVyYiA9IHZlcmIgPT09IFwiKlwiIHx8IHZlcmIgPT09IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBtYXRjaGVzUGF0aCAmJiBtYXRjaGVzVmVyYjtcbiAgfSk7XG4gIGlmIChtYXRjaGluZ1JvdXRlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IG1hdGNoaW5nUm91dGUgPSBtYXRjaGluZ1JvdXRlcy5yZWR1Y2UoXG4gICAgKGEsIGIpID0+IGIucGF0dGVybi5zb3VyY2UubGVuZ3RoID4gYS5wYXR0ZXJuLnNvdXJjZS5sZW5ndGggPyBiIDogYVxuICApO1xuICByZXR1cm4gbWF0Y2hpbmdSb3V0ZTtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRBc3NldChuZXR3b3JrKSB7XG4gIHJldHVybiB7XG4gICAgYWRkcmVzczogZ2V0VXNkY0FkZHJlc3NGb3JDaGFpbihnZXROZXR3b3JrSWQobmV0d29yaykpLFxuICAgIGRlY2ltYWxzOiA2LFxuICAgIGVpcDcxMjoge1xuICAgICAgbmFtZTogbmV0d29yayA9PT0gXCJiYXNlXCIgPyBcIlVTRCBDb2luXCIgOiBuZXR3b3JrID09PSBcImlvdGV4XCIgPyBcIkJyaWRnZWQgVVNEQ1wiIDogXCJVU0RDXCIsXG4gICAgICB2ZXJzaW9uOiBcIjJcIlxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NQcmljZVRvQXRvbWljQW1vdW50KHByaWNlLCBuZXR3b3JrKSB7XG4gIGxldCBtYXhBbW91bnRSZXF1aXJlZDtcbiAgbGV0IGFzc2V0O1xuICBpZiAodHlwZW9mIHByaWNlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBwcmljZSA9PT0gXCJudW1iZXJcIikge1xuICAgIGNvbnN0IHBhcnNlZEFtb3VudCA9IG1vbmV5U2NoZW1hLnNhZmVQYXJzZShwcmljZSk7XG4gICAgaWYgKCFwYXJzZWRBbW91bnQuc3VjY2Vzcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IGBJbnZhbGlkIHByaWNlIChwcmljZTogJHtwcmljZX0pLiBNdXN0IGJlIGluIHRoZSBmb3JtIFwiJDMuMTBcIiwgMC4xMCwgXCIwLjAwMVwiLCAke3BhcnNlZEFtb3VudC5lcnJvcn1gXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRVc2RBbW91bnQgPSBwYXJzZWRBbW91bnQuZGF0YTtcbiAgICBhc3NldCA9IGdldERlZmF1bHRBc3NldChuZXR3b3JrKTtcbiAgICBtYXhBbW91bnRSZXF1aXJlZCA9IChwYXJzZWRVc2RBbW91bnQgKiAxMCAqKiBhc3NldC5kZWNpbWFscykudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICBtYXhBbW91bnRSZXF1aXJlZCA9IHByaWNlLmFtb3VudDtcbiAgICBhc3NldCA9IHByaWNlLmFzc2V0O1xuICB9XG4gIHJldHVybiB7XG4gICAgbWF4QW1vdW50UmVxdWlyZWQsXG4gICAgYXNzZXRcbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbmRNYXRjaGluZ1BheW1lbnRSZXF1aXJlbWVudHMocGF5bWVudFJlcXVpcmVtZW50cywgcGF5bWVudCkge1xuICByZXR1cm4gcGF5bWVudFJlcXVpcmVtZW50cy5maW5kKFxuICAgICh2YWx1ZSkgPT4gdmFsdWUuc2NoZW1lID09PSBwYXltZW50LnNjaGVtZSAmJiB2YWx1ZS5uZXR3b3JrID09PSBwYXltZW50Lm5ldHdvcmtcbiAgKTtcbn1cbmZ1bmN0aW9uIGRlY29kZVhQYXltZW50UmVzcG9uc2UoaGVhZGVyKSB7XG4gIGNvbnN0IGRlY29kZWQgPSBzYWZlQmFzZTY0RGVjb2RlKGhlYWRlcik7XG4gIHJldHVybiBKU09OLnBhcnNlKGRlY29kZWQpO1xufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbXB1dGVSb3V0ZVBhdHRlcm5zLFxuICBkZWNvZGVYUGF5bWVudFJlc3BvbnNlLFxuICBmaW5kTWF0Y2hpbmdQYXltZW50UmVxdWlyZW1lbnRzLFxuICBmaW5kTWF0Y2hpbmdSb3V0ZSxcbiAgZ2V0RGVmYXVsdEFzc2V0LFxuICBnZXROZXR3b3JrSWQsXG4gIGdldFBheXdhbGxIdG1sLFxuICBwcm9jZXNzUHJpY2VUb0F0b21pY0Ftb3VudCxcbiAgc2FmZUJhc2U2NERlY29kZSxcbiAgc2FmZUJhc2U2NEVuY29kZSxcbiAgdG9Kc29uU2FmZVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/x402-axios/node_modules/x402/dist/cjs/shared/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/x402-axios/node_modules/x402/dist/cjs/types/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/x402-axios/node_modules/x402/dist/cjs/types/index.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/types/index.ts\nvar types_exports = {};\n__export(types_exports, {\n  ChainIdToNetwork: () => ChainIdToNetwork,\n  ErrorReasons: () => ErrorReasons,\n  EvmNetworkToChainId: () => EvmNetworkToChainId,\n  ExactEvmPayloadAuthorizationSchema: () => ExactEvmPayloadAuthorizationSchema,\n  ExactEvmPayloadSchema: () => ExactEvmPayloadSchema,\n  NetworkSchema: () => NetworkSchema,\n  PaymentPayloadSchema: () => PaymentPayloadSchema,\n  PaymentRequirementsSchema: () => PaymentRequirementsSchema,\n  SettleResponseSchema: () => SettleResponseSchema,\n  SupportedEVMNetworks: () => SupportedEVMNetworks,\n  SupportedPaymentKindSchema: () => SupportedPaymentKindSchema,\n  SupportedPaymentKindsResponseSchema: () => SupportedPaymentKindsResponseSchema,\n  VerifyResponseSchema: () => VerifyResponseSchema,\n  evm: () => evm_exports,\n  facilitatorRequestSchema: () => facilitatorRequestSchema,\n  moneySchema: () => moneySchema,\n  schemes: () => schemes,\n  settleResponseFromHeader: () => settleResponseFromHeader,\n  settleResponseHeader: () => settleResponseHeader,\n  x402Versions: () => x402Versions\n});\nmodule.exports = __toCommonJS(types_exports);\n\n// src/types/shared/money.ts\nvar import_zod = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/index.cjs\");\nvar moneySchema = import_zod.z.union([import_zod.z.string().transform((x) => x.replace(/[^0-9.-]+/g, \"\")), import_zod.z.number()]).pipe(import_zod.z.coerce.number().min(1e-4).max(999999999));\n\n// src/types/shared/network.ts\nvar import_zod2 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/index.cjs\");\nvar NetworkSchema = import_zod2.z.enum([\n  \"base-sepolia\",\n  \"base\",\n  \"avalanche-fuji\",\n  \"avalanche\",\n  \"iotex\"\n]);\nvar SupportedEVMNetworks = [\n  \"base-sepolia\",\n  \"base\",\n  \"avalanche-fuji\",\n  \"avalanche\",\n  \"iotex\"\n];\nvar EvmNetworkToChainId = /* @__PURE__ */ new Map([\n  [\"base-sepolia\", 84532],\n  [\"base\", 8453],\n  [\"avalanche-fuji\", 43113],\n  [\"avalanche\", 43114],\n  [\"iotex\", 4689]\n]);\nvar ChainIdToNetwork = Object.fromEntries(\n  SupportedEVMNetworks.map((network) => [EvmNetworkToChainId.get(network), network])\n);\n\n// src/types/shared/evm/index.ts\nvar evm_exports = {};\n__export(evm_exports, {\n  authorizationPrimaryType: () => authorizationPrimaryType,\n  authorizationTypes: () => authorizationTypes,\n  config: () => config,\n  createClientAvalancheFuji: () => createClientAvalancheFuji,\n  createClientSepolia: () => createClientSepolia,\n  createSignerAvalancheFuji: () => createSignerAvalancheFuji,\n  createSignerSepolia: () => createSignerSepolia,\n  isAccount: () => isAccount,\n  isSignerWallet: () => isSignerWallet,\n  usdcABI: () => usdcABI\n});\n\n// src/types/shared/evm/config.ts\nvar config = {\n  \"84532\": {\n    usdcAddress: \"0x036CbD53842c5426634e7929541eC2318f3dCF7e\",\n    usdcName: \"USDC\"\n  },\n  \"8453\": {\n    usdcAddress: \"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\",\n    usdcName: \"USDC\"\n  },\n  \"43113\": {\n    usdcAddress: \"0x5425890298aed601595a70AB815c96711a31Bc65\",\n    usdcName: \"USD Coin\"\n  },\n  \"43114\": {\n    usdcAddress: \"0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E\",\n    usdcName: \"USDC\"\n  },\n  \"4689\": {\n    usdcAddress: \"0xcdf79194c6c285077a58da47641d4dbe51f63542\",\n    usdcName: \"Bridged USDC\"\n  }\n};\n\n// src/types/shared/evm/eip3009.ts\nvar authorizationTypes = {\n  TransferWithAuthorization: [\n    { name: \"from\", type: \"address\" },\n    { name: \"to\", type: \"address\" },\n    { name: \"value\", type: \"uint256\" },\n    { name: \"validAfter\", type: \"uint256\" },\n    { name: \"validBefore\", type: \"uint256\" },\n    { name: \"nonce\", type: \"bytes32\" }\n  ]\n};\nvar authorizationPrimaryType = \"TransferWithAuthorization\";\n\n// src/types/shared/evm/erc20PermitABI.ts\nvar usdcABI = [\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\"\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"spender\",\n        type: \"address\"\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"value\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"Approval\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"authorizer\",\n        type: \"address\"\n      },\n      {\n        indexed: true,\n        internalType: \"bytes32\",\n        name: \"nonce\",\n        type: \"bytes32\"\n      }\n    ],\n    name: \"AuthorizationCanceled\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"authorizer\",\n        type: \"address\"\n      },\n      {\n        indexed: true,\n        internalType: \"bytes32\",\n        name: \"nonce\",\n        type: \"bytes32\"\n      }\n    ],\n    name: \"AuthorizationUsed\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"_account\",\n        type: \"address\"\n      }\n    ],\n    name: \"Blacklisted\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"newBlacklister\",\n        type: \"address\"\n      }\n    ],\n    name: \"BlacklisterChanged\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"burner\",\n        type: \"address\"\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"Burn\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"newMasterMinter\",\n        type: \"address\"\n      }\n    ],\n    name: \"MasterMinterChanged\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"minter\",\n        type: \"address\"\n      },\n      { indexed: true, internalType: \"address\", name: \"to\", type: \"address\" },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"Mint\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"minter\",\n        type: \"address\"\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"minterAllowedAmount\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"MinterConfigured\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"oldMinter\",\n        type: \"address\"\n      }\n    ],\n    name: \"MinterRemoved\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: \"address\",\n        name: \"previousOwner\",\n        type: \"address\"\n      },\n      {\n        indexed: false,\n        internalType: \"address\",\n        name: \"newOwner\",\n        type: \"address\"\n      }\n    ],\n    name: \"OwnershipTransferred\",\n    type: \"event\"\n  },\n  { anonymous: false, inputs: [], name: \"Pause\", type: \"event\" },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"newAddress\",\n        type: \"address\"\n      }\n    ],\n    name: \"PauserChanged\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"newRescuer\",\n        type: \"address\"\n      }\n    ],\n    name: \"RescuerChanged\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      { indexed: true, internalType: \"address\", name: \"from\", type: \"address\" },\n      { indexed: true, internalType: \"address\", name: \"to\", type: \"address\" },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"value\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"Transfer\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"_account\",\n        type: \"address\"\n      }\n    ],\n    name: \"UnBlacklisted\",\n    type: \"event\"\n  },\n  { anonymous: false, inputs: [], name: \"Unpause\", type: \"event\" },\n  {\n    inputs: [],\n    name: \"CANCEL_AUTHORIZATION_TYPEHASH\",\n    outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"DOMAIN_SEPARATOR\",\n    outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"PERMIT_TYPEHASH\",\n    outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"RECEIVE_WITH_AUTHORIZATION_TYPEHASH\",\n    outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"TRANSFER_WITH_AUTHORIZATION_TYPEHASH\",\n    outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"owner\", type: \"address\" },\n      { internalType: \"address\", name: \"spender\", type: \"address\" }\n    ],\n    name: \"allowance\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" }\n    ],\n    name: \"approve\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"authorizer\", type: \"address\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" }\n    ],\n    name: \"authorizationState\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"account\", type: \"address\" }],\n    name: \"balanceOf\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"_account\", type: \"address\" }],\n    name: \"blacklist\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"blacklister\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"uint256\", name: \"_amount\", type: \"uint256\" }],\n    name: \"burn\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"authorizer\", type: \"address\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n      { internalType: \"uint8\", name: \"v\", type: \"uint8\" },\n      { internalType: \"bytes32\", name: \"r\", type: \"bytes32\" },\n      { internalType: \"bytes32\", name: \"s\", type: \"bytes32\" }\n    ],\n    name: \"cancelAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"authorizer\", type: \"address\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n      { internalType: \"bytes\", name: \"signature\", type: \"bytes\" }\n    ],\n    name: \"cancelAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"minter\", type: \"address\" },\n      { internalType: \"uint256\", name: \"minterAllowedAmount\", type: \"uint256\" }\n    ],\n    name: \"configureMinter\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"currency\",\n    outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"decimals\",\n    outputs: [{ internalType: \"uint8\", name: \"\", type: \"uint8\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n      { internalType: \"uint256\", name: \"decrement\", type: \"uint256\" }\n    ],\n    name: \"decreaseAllowance\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n      { internalType: \"uint256\", name: \"increment\", type: \"uint256\" }\n    ],\n    name: \"increaseAllowance\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"string\", name: \"tokenName\", type: \"string\" },\n      { internalType: \"string\", name: \"tokenSymbol\", type: \"string\" },\n      { internalType: \"string\", name: \"tokenCurrency\", type: \"string\" },\n      { internalType: \"uint8\", name: \"tokenDecimals\", type: \"uint8\" },\n      { internalType: \"address\", name: \"newMasterMinter\", type: \"address\" },\n      { internalType: \"address\", name: \"newPauser\", type: \"address\" },\n      { internalType: \"address\", name: \"newBlacklister\", type: \"address\" },\n      { internalType: \"address\", name: \"newOwner\", type: \"address\" }\n    ],\n    name: \"initialize\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"string\", name: \"newName\", type: \"string\" }],\n    name: \"initializeV2\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"lostAndFound\", type: \"address\" }],\n    name: \"initializeV2_1\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address[]\",\n        name: \"accountsToBlacklist\",\n        type: \"address[]\"\n      },\n      { internalType: \"string\", name: \"newSymbol\", type: \"string\" }\n    ],\n    name: \"initializeV2_2\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"_account\", type: \"address\" }],\n    name: \"isBlacklisted\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"account\", type: \"address\" }],\n    name: \"isMinter\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"masterMinter\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"_to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"_amount\", type: \"uint256\" }\n    ],\n    name: \"mint\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"minter\", type: \"address\" }],\n    name: \"minterAllowance\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"name\",\n    outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"owner\", type: \"address\" }],\n    name: \"nonces\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"owner\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"pause\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"paused\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"pauser\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"owner\", type: \"address\" },\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"deadline\", type: \"uint256\" },\n      { internalType: \"bytes\", name: \"signature\", type: \"bytes\" }\n    ],\n    name: \"permit\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"owner\", type: \"address\" },\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"deadline\", type: \"uint256\" },\n      { internalType: \"uint8\", name: \"v\", type: \"uint8\" },\n      { internalType: \"bytes32\", name: \"r\", type: \"bytes32\" },\n      { internalType: \"bytes32\", name: \"s\", type: \"bytes32\" }\n    ],\n    name: \"permit\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"from\", type: \"address\" },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validAfter\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validBefore\", type: \"uint256\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n      { internalType: \"bytes\", name: \"signature\", type: \"bytes\" }\n    ],\n    name: \"receiveWithAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"from\", type: \"address\" },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validAfter\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validBefore\", type: \"uint256\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n      { internalType: \"uint8\", name: \"v\", type: \"uint8\" },\n      { internalType: \"bytes32\", name: \"r\", type: \"bytes32\" },\n      { internalType: \"bytes32\", name: \"s\", type: \"bytes32\" }\n    ],\n    name: \"receiveWithAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"minter\", type: \"address\" }],\n    name: \"removeMinter\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"contract IERC20\",\n        name: \"tokenContract\",\n        type: \"address\"\n      },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"amount\", type: \"uint256\" }\n    ],\n    name: \"rescueERC20\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"rescuer\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"symbol\",\n    outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"totalSupply\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" }\n    ],\n    name: \"transfer\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"from\", type: \"address\" },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" }\n    ],\n    name: \"transferFrom\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"newOwner\", type: \"address\" }],\n    name: \"transferOwnership\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"from\", type: \"address\" },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validAfter\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validBefore\", type: \"uint256\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n      { internalType: \"bytes\", name: \"signature\", type: \"bytes\" }\n    ],\n    name: \"transferWithAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"from\", type: \"address\" },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validAfter\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validBefore\", type: \"uint256\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n      { internalType: \"uint8\", name: \"v\", type: \"uint8\" },\n      { internalType: \"bytes32\", name: \"r\", type: \"bytes32\" },\n      { internalType: \"bytes32\", name: \"s\", type: \"bytes32\" }\n    ],\n    name: \"transferWithAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"_account\", type: \"address\" }],\n    name: \"unBlacklist\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"unpause\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"_newBlacklister\", type: \"address\" }],\n    name: \"updateBlacklister\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"_newMasterMinter\", type: \"address\" }],\n    name: \"updateMasterMinter\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"_newPauser\", type: \"address\" }],\n    name: \"updatePauser\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"newRescuer\", type: \"address\" }],\n    name: \"updateRescuer\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"version\",\n    outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\n    stateMutability: \"pure\",\n    type: \"function\"\n  }\n];\n\n// src/types/shared/evm/wallet.ts\nvar import_viem = __webpack_require__(/*! viem */ \"(rsc)/./node_modules/viem/_cjs/index.js\");\nvar import_chains = __webpack_require__(/*! viem/chains */ \"(rsc)/./node_modules/viem/_cjs/chains/index.js\");\nvar import_accounts = __webpack_require__(/*! viem/accounts */ \"(rsc)/./node_modules/viem/_cjs/accounts/index.js\");\nfunction createClientSepolia() {\n  return (0, import_viem.createPublicClient)({\n    chain: import_chains.baseSepolia,\n    transport: (0, import_viem.http)()\n  }).extend(import_viem.publicActions);\n}\nfunction createClientAvalancheFuji() {\n  return (0, import_viem.createPublicClient)({\n    chain: import_chains.avalancheFuji,\n    transport: (0, import_viem.http)()\n  }).extend(import_viem.publicActions);\n}\nfunction createSignerSepolia(privateKey) {\n  return (0, import_viem.createWalletClient)({\n    chain: import_chains.baseSepolia,\n    transport: (0, import_viem.http)(),\n    account: (0, import_accounts.privateKeyToAccount)(privateKey)\n  }).extend(import_viem.publicActions);\n}\nfunction createSignerAvalancheFuji(privateKey) {\n  return (0, import_viem.createWalletClient)({\n    chain: import_chains.avalancheFuji,\n    transport: (0, import_viem.http)(),\n    account: (0, import_accounts.privateKeyToAccount)(privateKey)\n  }).extend(import_viem.publicActions);\n}\nfunction isSignerWallet(wallet) {\n  return \"chain\" in wallet && \"transport\" in wallet;\n}\nfunction isAccount(wallet) {\n  return \"address\" in wallet && \"type\" in wallet;\n}\n\n// src/types/verify/x402Specs.ts\nvar import_zod3 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/index.cjs\");\nvar EvmMaxAtomicUnits = 18;\nvar EvmAddressRegex = /^0x[0-9a-fA-F]{40}$/;\nvar MixedAddressRegex = /^0x[a-fA-F0-9]{40}|[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$/;\nvar HexEncoded64ByteRegex = /^0x[0-9a-fA-F]{64}$/;\nvar EvmSignatureRegex = /^0x[0-9a-fA-F]{130}$/;\nvar schemes = [\"exact\"];\nvar x402Versions = [1];\nvar ErrorReasons = [\n  \"insufficient_funds\",\n  \"invalid_exact_evm_payload_authorization_valid_after\",\n  \"invalid_exact_evm_payload_authorization_valid_before\",\n  \"invalid_exact_evm_payload_authorization_value\",\n  \"invalid_exact_evm_payload_signature\",\n  \"invalid_exact_evm_payload_recipient_mismatch\",\n  \"invalid_network\",\n  \"invalid_payload\",\n  \"invalid_payment_requirements\",\n  \"invalid_scheme\",\n  \"unsupported_scheme\",\n  \"invalid_x402_version\",\n  \"invalid_transaction_state\",\n  \"unexpected_verify_error\",\n  \"unexpected_settle_error\"\n];\nvar isInteger = (value) => Number.isInteger(Number(value)) && Number(value) >= 0;\nvar hasMaxLength = (maxLength) => (value) => value.length <= maxLength;\nvar PaymentRequirementsSchema = import_zod3.z.object({\n  scheme: import_zod3.z.enum(schemes),\n  network: NetworkSchema,\n  maxAmountRequired: import_zod3.z.string().refine(isInteger),\n  resource: import_zod3.z.string().url(),\n  description: import_zod3.z.string(),\n  mimeType: import_zod3.z.string(),\n  outputSchema: import_zod3.z.record(import_zod3.z.any()).optional(),\n  payTo: import_zod3.z.string().regex(MixedAddressRegex),\n  maxTimeoutSeconds: import_zod3.z.number().int(),\n  asset: import_zod3.z.string().regex(MixedAddressRegex),\n  extra: import_zod3.z.record(import_zod3.z.any()).optional()\n});\nvar ExactEvmPayloadAuthorizationSchema = import_zod3.z.object({\n  from: import_zod3.z.string().regex(EvmAddressRegex),\n  to: import_zod3.z.string().regex(EvmAddressRegex),\n  value: import_zod3.z.string().refine(isInteger).refine(hasMaxLength(EvmMaxAtomicUnits)),\n  validAfter: import_zod3.z.string().refine(isInteger),\n  validBefore: import_zod3.z.string().refine(isInteger),\n  nonce: import_zod3.z.string().regex(HexEncoded64ByteRegex)\n});\nvar ExactEvmPayloadSchema = import_zod3.z.object({\n  signature: import_zod3.z.string().regex(EvmSignatureRegex),\n  authorization: ExactEvmPayloadAuthorizationSchema\n});\nvar PaymentPayloadSchema = import_zod3.z.object({\n  x402Version: import_zod3.z.number().refine((val) => x402Versions.includes(val)),\n  scheme: import_zod3.z.enum(schemes),\n  network: NetworkSchema,\n  payload: ExactEvmPayloadSchema\n});\nvar VerifyResponseSchema = import_zod3.z.object({\n  isValid: import_zod3.z.boolean(),\n  invalidReason: import_zod3.z.enum(ErrorReasons).optional(),\n  payer: import_zod3.z.string().regex(MixedAddressRegex).optional()\n});\nvar SettleResponseSchema = import_zod3.z.object({\n  success: import_zod3.z.boolean(),\n  errorReason: import_zod3.z.enum(ErrorReasons).optional(),\n  payer: import_zod3.z.string().regex(MixedAddressRegex).optional(),\n  transaction: import_zod3.z.string().regex(MixedAddressRegex),\n  network: NetworkSchema\n});\nvar SupportedPaymentKindSchema = import_zod3.z.object({\n  x402Version: import_zod3.z.number().refine((val) => x402Versions.includes(val)),\n  scheme: import_zod3.z.enum(schemes),\n  network: NetworkSchema\n});\nvar SupportedPaymentKindsResponseSchema = import_zod3.z.object({\n  kinds: import_zod3.z.array(SupportedPaymentKindSchema)\n});\n\n// src/types/verify/facilitator.ts\nvar import_zod4 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/index.cjs\");\n\n// src/shared/base64.ts\nfunction safeBase64Encode(data) {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.btoa === \"function\") {\n    return globalThis.btoa(data);\n  }\n  return Buffer.from(data).toString(\"base64\");\n}\nfunction safeBase64Decode(data) {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.atob === \"function\") {\n    return globalThis.atob(data);\n  }\n  return Buffer.from(data, \"base64\").toString(\"utf-8\");\n}\n\n// src/types/verify/facilitator.ts\nvar facilitatorRequestSchema = import_zod4.z.object({\n  paymentHeader: import_zod4.z.string(),\n  paymentRequirements: PaymentRequirementsSchema\n});\nfunction settleResponseHeader(response) {\n  return safeBase64Encode(JSON.stringify(response));\n}\nfunction settleResponseFromHeader(header) {\n  const decoded = safeBase64Decode(header);\n  return JSON.parse(decoded);\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveDQwMi1heGlvcy9ub2RlX21vZHVsZXMveDQwMi9kaXN0L2Nqcy90eXBlcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsK0NBQUs7QUFDOUI7O0FBRUE7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQywrQ0FBSztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLCtCQUErQjtBQUNyQyxNQUFNLDZCQUE2QjtBQUNuQyxNQUFNLGdDQUFnQztBQUN0QyxNQUFNLHFDQUFxQztBQUMzQyxNQUFNLHNDQUFzQztBQUM1QyxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsUUFBUSxxRUFBcUU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQywrQ0FBSzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FxQkw7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL29uY2hhaW4tYWdlbnQvLi9ub2RlX21vZHVsZXMveDQwMi1heGlvcy9ub2RlX21vZHVsZXMveDQwMi9kaXN0L2Nqcy90eXBlcy9pbmRleC5qcz9hMmM2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcblxuLy8gc3JjL3R5cGVzL2luZGV4LnRzXG52YXIgdHlwZXNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodHlwZXNfZXhwb3J0cywge1xuICBDaGFpbklkVG9OZXR3b3JrOiAoKSA9PiBDaGFpbklkVG9OZXR3b3JrLFxuICBFcnJvclJlYXNvbnM6ICgpID0+IEVycm9yUmVhc29ucyxcbiAgRXZtTmV0d29ya1RvQ2hhaW5JZDogKCkgPT4gRXZtTmV0d29ya1RvQ2hhaW5JZCxcbiAgRXhhY3RFdm1QYXlsb2FkQXV0aG9yaXphdGlvblNjaGVtYTogKCkgPT4gRXhhY3RFdm1QYXlsb2FkQXV0aG9yaXphdGlvblNjaGVtYSxcbiAgRXhhY3RFdm1QYXlsb2FkU2NoZW1hOiAoKSA9PiBFeGFjdEV2bVBheWxvYWRTY2hlbWEsXG4gIE5ldHdvcmtTY2hlbWE6ICgpID0+IE5ldHdvcmtTY2hlbWEsXG4gIFBheW1lbnRQYXlsb2FkU2NoZW1hOiAoKSA9PiBQYXltZW50UGF5bG9hZFNjaGVtYSxcbiAgUGF5bWVudFJlcXVpcmVtZW50c1NjaGVtYTogKCkgPT4gUGF5bWVudFJlcXVpcmVtZW50c1NjaGVtYSxcbiAgU2V0dGxlUmVzcG9uc2VTY2hlbWE6ICgpID0+IFNldHRsZVJlc3BvbnNlU2NoZW1hLFxuICBTdXBwb3J0ZWRFVk1OZXR3b3JrczogKCkgPT4gU3VwcG9ydGVkRVZNTmV0d29ya3MsXG4gIFN1cHBvcnRlZFBheW1lbnRLaW5kU2NoZW1hOiAoKSA9PiBTdXBwb3J0ZWRQYXltZW50S2luZFNjaGVtYSxcbiAgU3VwcG9ydGVkUGF5bWVudEtpbmRzUmVzcG9uc2VTY2hlbWE6ICgpID0+IFN1cHBvcnRlZFBheW1lbnRLaW5kc1Jlc3BvbnNlU2NoZW1hLFxuICBWZXJpZnlSZXNwb25zZVNjaGVtYTogKCkgPT4gVmVyaWZ5UmVzcG9uc2VTY2hlbWEsXG4gIGV2bTogKCkgPT4gZXZtX2V4cG9ydHMsXG4gIGZhY2lsaXRhdG9yUmVxdWVzdFNjaGVtYTogKCkgPT4gZmFjaWxpdGF0b3JSZXF1ZXN0U2NoZW1hLFxuICBtb25leVNjaGVtYTogKCkgPT4gbW9uZXlTY2hlbWEsXG4gIHNjaGVtZXM6ICgpID0+IHNjaGVtZXMsXG4gIHNldHRsZVJlc3BvbnNlRnJvbUhlYWRlcjogKCkgPT4gc2V0dGxlUmVzcG9uc2VGcm9tSGVhZGVyLFxuICBzZXR0bGVSZXNwb25zZUhlYWRlcjogKCkgPT4gc2V0dGxlUmVzcG9uc2VIZWFkZXIsXG4gIHg0MDJWZXJzaW9uczogKCkgPT4geDQwMlZlcnNpb25zXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHR5cGVzX2V4cG9ydHMpO1xuXG4vLyBzcmMvdHlwZXMvc2hhcmVkL21vbmV5LnRzXG52YXIgaW1wb3J0X3pvZCA9IHJlcXVpcmUoXCJ6b2RcIik7XG52YXIgbW9uZXlTY2hlbWEgPSBpbXBvcnRfem9kLnoudW5pb24oW2ltcG9ydF96b2Quei5zdHJpbmcoKS50cmFuc2Zvcm0oKHgpID0+IHgucmVwbGFjZSgvW14wLTkuLV0rL2csIFwiXCIpKSwgaW1wb3J0X3pvZC56Lm51bWJlcigpXSkucGlwZShpbXBvcnRfem9kLnouY29lcmNlLm51bWJlcigpLm1pbigxZS00KS5tYXgoOTk5OTk5OTk5KSk7XG5cbi8vIHNyYy90eXBlcy9zaGFyZWQvbmV0d29yay50c1xudmFyIGltcG9ydF96b2QyID0gcmVxdWlyZShcInpvZFwiKTtcbnZhciBOZXR3b3JrU2NoZW1hID0gaW1wb3J0X3pvZDIuei5lbnVtKFtcbiAgXCJiYXNlLXNlcG9saWFcIixcbiAgXCJiYXNlXCIsXG4gIFwiYXZhbGFuY2hlLWZ1amlcIixcbiAgXCJhdmFsYW5jaGVcIixcbiAgXCJpb3RleFwiXG5dKTtcbnZhciBTdXBwb3J0ZWRFVk1OZXR3b3JrcyA9IFtcbiAgXCJiYXNlLXNlcG9saWFcIixcbiAgXCJiYXNlXCIsXG4gIFwiYXZhbGFuY2hlLWZ1amlcIixcbiAgXCJhdmFsYW5jaGVcIixcbiAgXCJpb3RleFwiXG5dO1xudmFyIEV2bU5ldHdvcmtUb0NoYWluSWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gIFtcImJhc2Utc2Vwb2xpYVwiLCA4NDUzMl0sXG4gIFtcImJhc2VcIiwgODQ1M10sXG4gIFtcImF2YWxhbmNoZS1mdWppXCIsIDQzMTEzXSxcbiAgW1wiYXZhbGFuY2hlXCIsIDQzMTE0XSxcbiAgW1wiaW90ZXhcIiwgNDY4OV1cbl0pO1xudmFyIENoYWluSWRUb05ldHdvcmsgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gIFN1cHBvcnRlZEVWTU5ldHdvcmtzLm1hcCgobmV0d29yaykgPT4gW0V2bU5ldHdvcmtUb0NoYWluSWQuZ2V0KG5ldHdvcmspLCBuZXR3b3JrXSlcbik7XG5cbi8vIHNyYy90eXBlcy9zaGFyZWQvZXZtL2luZGV4LnRzXG52YXIgZXZtX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGV2bV9leHBvcnRzLCB7XG4gIGF1dGhvcml6YXRpb25QcmltYXJ5VHlwZTogKCkgPT4gYXV0aG9yaXphdGlvblByaW1hcnlUeXBlLFxuICBhdXRob3JpemF0aW9uVHlwZXM6ICgpID0+IGF1dGhvcml6YXRpb25UeXBlcyxcbiAgY29uZmlnOiAoKSA9PiBjb25maWcsXG4gIGNyZWF0ZUNsaWVudEF2YWxhbmNoZUZ1amk6ICgpID0+IGNyZWF0ZUNsaWVudEF2YWxhbmNoZUZ1amksXG4gIGNyZWF0ZUNsaWVudFNlcG9saWE6ICgpID0+IGNyZWF0ZUNsaWVudFNlcG9saWEsXG4gIGNyZWF0ZVNpZ25lckF2YWxhbmNoZUZ1amk6ICgpID0+IGNyZWF0ZVNpZ25lckF2YWxhbmNoZUZ1amksXG4gIGNyZWF0ZVNpZ25lclNlcG9saWE6ICgpID0+IGNyZWF0ZVNpZ25lclNlcG9saWEsXG4gIGlzQWNjb3VudDogKCkgPT4gaXNBY2NvdW50LFxuICBpc1NpZ25lcldhbGxldDogKCkgPT4gaXNTaWduZXJXYWxsZXQsXG4gIHVzZGNBQkk6ICgpID0+IHVzZGNBQklcbn0pO1xuXG4vLyBzcmMvdHlwZXMvc2hhcmVkL2V2bS9jb25maWcudHNcbnZhciBjb25maWcgPSB7XG4gIFwiODQ1MzJcIjoge1xuICAgIHVzZGNBZGRyZXNzOiBcIjB4MDM2Q2JENTM4NDJjNTQyNjYzNGU3OTI5NTQxZUMyMzE4ZjNkQ0Y3ZVwiLFxuICAgIHVzZGNOYW1lOiBcIlVTRENcIlxuICB9LFxuICBcIjg0NTNcIjoge1xuICAgIHVzZGNBZGRyZXNzOiBcIjB4ODMzNTg5ZkNENmVEYjZFMDhmNGM3QzMyRDRmNzFiNTRiZEEwMjkxM1wiLFxuICAgIHVzZGNOYW1lOiBcIlVTRENcIlxuICB9LFxuICBcIjQzMTEzXCI6IHtcbiAgICB1c2RjQWRkcmVzczogXCIweDU0MjU4OTAyOThhZWQ2MDE1OTVhNzBBQjgxNWM5NjcxMWEzMUJjNjVcIixcbiAgICB1c2RjTmFtZTogXCJVU0QgQ29pblwiXG4gIH0sXG4gIFwiNDMxMTRcIjoge1xuICAgIHVzZGNBZGRyZXNzOiBcIjB4Qjk3RUY5RWY4NzM0QzcxOTA0RDgwMDJGOGI2QmM2NkRkOWM0OGE2RVwiLFxuICAgIHVzZGNOYW1lOiBcIlVTRENcIlxuICB9LFxuICBcIjQ2ODlcIjoge1xuICAgIHVzZGNBZGRyZXNzOiBcIjB4Y2RmNzkxOTRjNmMyODUwNzdhNThkYTQ3NjQxZDRkYmU1MWY2MzU0MlwiLFxuICAgIHVzZGNOYW1lOiBcIkJyaWRnZWQgVVNEQ1wiXG4gIH1cbn07XG5cbi8vIHNyYy90eXBlcy9zaGFyZWQvZXZtL2VpcDMwMDkudHNcbnZhciBhdXRob3JpemF0aW9uVHlwZXMgPSB7XG4gIFRyYW5zZmVyV2l0aEF1dGhvcml6YXRpb246IFtcbiAgICB7IG5hbWU6IFwiZnJvbVwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgIHsgbmFtZTogXCJ0b1wiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgIHsgbmFtZTogXCJ2YWx1ZVwiLCB0eXBlOiBcInVpbnQyNTZcIiB9LFxuICAgIHsgbmFtZTogXCJ2YWxpZEFmdGVyXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXG4gICAgeyBuYW1lOiBcInZhbGlkQmVmb3JlXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXG4gICAgeyBuYW1lOiBcIm5vbmNlXCIsIHR5cGU6IFwiYnl0ZXMzMlwiIH1cbiAgXVxufTtcbnZhciBhdXRob3JpemF0aW9uUHJpbWFyeVR5cGUgPSBcIlRyYW5zZmVyV2l0aEF1dGhvcml6YXRpb25cIjtcblxuLy8gc3JjL3R5cGVzL3NoYXJlZC9ldm0vZXJjMjBQZXJtaXRBQkkudHNcbnZhciB1c2RjQUJJID0gW1xuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJvd25lclwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJzcGVuZGVyXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJ2YWx1ZVwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgbmFtZTogXCJBcHByb3ZhbFwiLFxuICAgIHR5cGU6IFwiZXZlbnRcIlxuICB9LFxuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJhdXRob3JpemVyXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYnl0ZXMzMlwiLFxuICAgICAgICBuYW1lOiBcIm5vbmNlXCIsXG4gICAgICAgIHR5cGU6IFwiYnl0ZXMzMlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcIkF1dGhvcml6YXRpb25DYW5jZWxlZFwiLFxuICAgIHR5cGU6IFwiZXZlbnRcIlxuICB9LFxuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJhdXRob3JpemVyXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYnl0ZXMzMlwiLFxuICAgICAgICBuYW1lOiBcIm5vbmNlXCIsXG4gICAgICAgIHR5cGU6IFwiYnl0ZXMzMlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcIkF1dGhvcml6YXRpb25Vc2VkXCIsXG4gICAgdHlwZTogXCJldmVudFwiXG4gIH0sXG4gIHtcbiAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcIl9hY2NvdW50XCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcIkJsYWNrbGlzdGVkXCIsXG4gICAgdHlwZTogXCJldmVudFwiXG4gIH0sXG4gIHtcbiAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcIm5ld0JsYWNrbGlzdGVyXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcIkJsYWNrbGlzdGVyQ2hhbmdlZFwiLFxuICAgIHR5cGU6IFwiZXZlbnRcIlxuICB9LFxuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJidXJuZXJcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGluZGV4ZWQ6IGZhbHNlLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcImFtb3VudFwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgbmFtZTogXCJCdXJuXCIsXG4gICAgdHlwZTogXCJldmVudFwiXG4gIH0sXG4gIHtcbiAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcIm5ld01hc3Rlck1pbnRlclwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfVxuICAgIF0sXG4gICAgbmFtZTogXCJNYXN0ZXJNaW50ZXJDaGFuZ2VkXCIsXG4gICAgdHlwZTogXCJldmVudFwiXG4gIH0sXG4gIHtcbiAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcIm1pbnRlclwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfSxcbiAgICAgIHsgaW5kZXhlZDogdHJ1ZSwgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJ0b1wiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAge1xuICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJhbW91bnRcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIG5hbWU6IFwiTWludFwiLFxuICAgIHR5cGU6IFwiZXZlbnRcIlxuICB9LFxuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJtaW50ZXJcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGluZGV4ZWQ6IGZhbHNlLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIm1pbnRlckFsbG93ZWRBbW91bnRcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIG5hbWU6IFwiTWludGVyQ29uZmlndXJlZFwiLFxuICAgIHR5cGU6IFwiZXZlbnRcIlxuICB9LFxuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJvbGRNaW50ZXJcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIG5hbWU6IFwiTWludGVyUmVtb3ZlZFwiLFxuICAgIHR5cGU6IFwiZXZlbnRcIlxuICB9LFxuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogZmFsc2UsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwicHJldmlvdXNPd25lclwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogZmFsc2UsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwibmV3T3duZXJcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIG5hbWU6IFwiT3duZXJzaGlwVHJhbnNmZXJyZWRcIixcbiAgICB0eXBlOiBcImV2ZW50XCJcbiAgfSxcbiAgeyBhbm9ueW1vdXM6IGZhbHNlLCBpbnB1dHM6IFtdLCBuYW1lOiBcIlBhdXNlXCIsIHR5cGU6IFwiZXZlbnRcIiB9LFxuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJuZXdBZGRyZXNzXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcIlBhdXNlckNoYW5nZWRcIixcbiAgICB0eXBlOiBcImV2ZW50XCJcbiAgfSxcbiAge1xuICAgIGFub255bW91czogZmFsc2UsXG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwibmV3UmVzY3VlclwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfVxuICAgIF0sXG4gICAgbmFtZTogXCJSZXNjdWVyQ2hhbmdlZFwiLFxuICAgIHR5cGU6IFwiZXZlbnRcIlxuICB9LFxuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHsgaW5kZXhlZDogdHJ1ZSwgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJmcm9tXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICB7IGluZGV4ZWQ6IHRydWUsIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwidG9cIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogZmFsc2UsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwidmFsdWVcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIG5hbWU6IFwiVHJhbnNmZXJcIixcbiAgICB0eXBlOiBcImV2ZW50XCJcbiAgfSxcbiAge1xuICAgIGFub255bW91czogZmFsc2UsXG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiX2FjY291bnRcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIG5hbWU6IFwiVW5CbGFja2xpc3RlZFwiLFxuICAgIHR5cGU6IFwiZXZlbnRcIlxuICB9LFxuICB7IGFub255bW91czogZmFsc2UsIGlucHV0czogW10sIG5hbWU6IFwiVW5wYXVzZVwiLCB0eXBlOiBcImV2ZW50XCIgfSxcbiAge1xuICAgIGlucHV0czogW10sXG4gICAgbmFtZTogXCJDQU5DRUxfQVVUSE9SSVpBVElPTl9UWVBFSEFTSFwiLFxuICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJieXRlczMyXCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwiYnl0ZXMzMlwiIH1dLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwiRE9NQUlOX1NFUEFSQVRPUlwiLFxuICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJieXRlczMyXCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwiYnl0ZXMzMlwiIH1dLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwiUEVSTUlUX1RZUEVIQVNIXCIsXG4gICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJieXRlczMyXCIgfV0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW10sXG4gICAgbmFtZTogXCJSRUNFSVZFX1dJVEhfQVVUSE9SSVpBVElPTl9UWVBFSEFTSFwiLFxuICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJieXRlczMyXCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwiYnl0ZXMzMlwiIH1dLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwiVFJBTlNGRVJfV0lUSF9BVVRIT1JJWkFUSU9OX1RZUEVIQVNIXCIsXG4gICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJieXRlczMyXCIgfV0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcIm93bmVyXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwic3BlbmRlclwiLCB0eXBlOiBcImFkZHJlc3NcIiB9XG4gICAgXSxcbiAgICBuYW1lOiBcImFsbG93YW5jZVwiLFxuICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwidWludDI1NlwiIH1dLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJzcGVuZGVyXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwidmFsdWVcIiwgdHlwZTogXCJ1aW50MjU2XCIgfVxuICAgIF0sXG4gICAgbmFtZTogXCJhcHByb3ZlXCIsXG4gICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImJvb2xcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJib29sXCIgfV0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcImF1dGhvcml6ZXJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIiwgbmFtZTogXCJub25jZVwiLCB0eXBlOiBcImJ5dGVzMzJcIiB9XG4gICAgXSxcbiAgICBuYW1lOiBcImF1dGhvcml6YXRpb25TdGF0ZVwiLFxuICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJib29sXCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwiYm9vbFwiIH1dLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFt7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiYWNjb3VudFwiLCB0eXBlOiBcImFkZHJlc3NcIiB9XSxcbiAgICBuYW1lOiBcImJhbGFuY2VPZlwiLFxuICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwidWludDI1NlwiIH1dLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFt7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiX2FjY291bnRcIiwgdHlwZTogXCJhZGRyZXNzXCIgfV0sXG4gICAgbmFtZTogXCJibGFja2xpc3RcIixcbiAgICBvdXRwdXRzOiBbXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXSxcbiAgICBuYW1lOiBcImJsYWNrbGlzdGVyXCIsXG4gICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfV0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW3sgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJfYW1vdW50XCIsIHR5cGU6IFwidWludDI1NlwiIH1dLFxuICAgIG5hbWU6IFwiYnVyblwiLFxuICAgIG91dHB1dHM6IFtdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJhdXRob3JpemVyXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICB7IGludGVybmFsVHlwZTogXCJieXRlczMyXCIsIG5hbWU6IFwibm9uY2VcIiwgdHlwZTogXCJieXRlczMyXCIgfSxcbiAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQ4XCIsIG5hbWU6IFwidlwiLCB0eXBlOiBcInVpbnQ4XCIgfSxcbiAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIiwgbmFtZTogXCJyXCIsIHR5cGU6IFwiYnl0ZXMzMlwiIH0sXG4gICAgICB7IGludGVybmFsVHlwZTogXCJieXRlczMyXCIsIG5hbWU6IFwic1wiLCB0eXBlOiBcImJ5dGVzMzJcIiB9XG4gICAgXSxcbiAgICBuYW1lOiBcImNhbmNlbEF1dGhvcml6YXRpb25cIixcbiAgICBvdXRwdXRzOiBbXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiYXV0aG9yaXplclwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYnl0ZXMzMlwiLCBuYW1lOiBcIm5vbmNlXCIsIHR5cGU6IFwiYnl0ZXMzMlwiIH0sXG4gICAgICB7IGludGVybmFsVHlwZTogXCJieXRlc1wiLCBuYW1lOiBcInNpZ25hdHVyZVwiLCB0eXBlOiBcImJ5dGVzXCIgfVxuICAgIF0sXG4gICAgbmFtZTogXCJjYW5jZWxBdXRob3JpemF0aW9uXCIsXG4gICAgb3V0cHV0czogW10sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcIm1pbnRlclwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcIm1pbnRlckFsbG93ZWRBbW91bnRcIiwgdHlwZTogXCJ1aW50MjU2XCIgfVxuICAgIF0sXG4gICAgbmFtZTogXCJjb25maWd1cmVNaW50ZXJcIixcbiAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYm9vbFwiLCBuYW1lOiBcIlwiLCB0eXBlOiBcImJvb2xcIiB9XSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXSxcbiAgICBuYW1lOiBcImN1cnJlbmN5XCIsXG4gICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcInN0cmluZ1wiLCBuYW1lOiBcIlwiLCB0eXBlOiBcInN0cmluZ1wiIH1dLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwiZGVjaW1hbHNcIixcbiAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwidWludDhcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJ1aW50OFwiIH1dLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJzcGVuZGVyXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwiZGVjcmVtZW50XCIsIHR5cGU6IFwidWludDI1NlwiIH1cbiAgICBdLFxuICAgIG5hbWU6IFwiZGVjcmVhc2VBbGxvd2FuY2VcIixcbiAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYm9vbFwiLCBuYW1lOiBcIlwiLCB0eXBlOiBcImJvb2xcIiB9XSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwic3BlbmRlclwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcImluY3JlbWVudFwiLCB0eXBlOiBcInVpbnQyNTZcIiB9XG4gICAgXSxcbiAgICBuYW1lOiBcImluY3JlYXNlQWxsb3dhbmNlXCIsXG4gICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImJvb2xcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJib29sXCIgfV0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAgeyBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsIG5hbWU6IFwidG9rZW5OYW1lXCIsIHR5cGU6IFwic3RyaW5nXCIgfSxcbiAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInN0cmluZ1wiLCBuYW1lOiBcInRva2VuU3ltYm9sXCIsIHR5cGU6IFwic3RyaW5nXCIgfSxcbiAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInN0cmluZ1wiLCBuYW1lOiBcInRva2VuQ3VycmVuY3lcIiwgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDhcIiwgbmFtZTogXCJ0b2tlbkRlY2ltYWxzXCIsIHR5cGU6IFwidWludDhcIiB9LFxuICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcIm5ld01hc3Rlck1pbnRlclwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcIm5ld1BhdXNlclwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcIm5ld0JsYWNrbGlzdGVyXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwibmV3T3duZXJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfVxuICAgIF0sXG4gICAgbmFtZTogXCJpbml0aWFsaXplXCIsXG4gICAgb3V0cHV0czogW10sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW3sgaW50ZXJuYWxUeXBlOiBcInN0cmluZ1wiLCBuYW1lOiBcIm5ld05hbWVcIiwgdHlwZTogXCJzdHJpbmdcIiB9XSxcbiAgICBuYW1lOiBcImluaXRpYWxpemVWMlwiLFxuICAgIG91dHB1dHM6IFtdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFt7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwibG9zdEFuZEZvdW5kXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH1dLFxuICAgIG5hbWU6IFwiaW5pdGlhbGl6ZVYyXzFcIixcbiAgICBvdXRwdXRzOiBbXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzW11cIixcbiAgICAgICAgbmFtZTogXCJhY2NvdW50c1RvQmxhY2tsaXN0XCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1tdXCJcbiAgICAgIH0sXG4gICAgICB7IGludGVybmFsVHlwZTogXCJzdHJpbmdcIiwgbmFtZTogXCJuZXdTeW1ib2xcIiwgdHlwZTogXCJzdHJpbmdcIiB9XG4gICAgXSxcbiAgICBuYW1lOiBcImluaXRpYWxpemVWMl8yXCIsXG4gICAgb3V0cHV0czogW10sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJfYWNjb3VudFwiLCB0eXBlOiBcImFkZHJlc3NcIiB9XSxcbiAgICBuYW1lOiBcImlzQmxhY2tsaXN0ZWRcIixcbiAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYm9vbFwiLCBuYW1lOiBcIlwiLCB0eXBlOiBcImJvb2xcIiB9XSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcImFjY291bnRcIiwgdHlwZTogXCJhZGRyZXNzXCIgfV0sXG4gICAgbmFtZTogXCJpc01pbnRlclwiLFxuICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJib29sXCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwiYm9vbFwiIH1dLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwibWFzdGVyTWludGVyXCIsXG4gICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfV0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcIl90b1wiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcIl9hbW91bnRcIiwgdHlwZTogXCJ1aW50MjU2XCIgfVxuICAgIF0sXG4gICAgbmFtZTogXCJtaW50XCIsXG4gICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImJvb2xcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJib29sXCIgfV0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJtaW50ZXJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfV0sXG4gICAgbmFtZTogXCJtaW50ZXJBbGxvd2FuY2VcIixcbiAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcIlwiLCB0eXBlOiBcInVpbnQyNTZcIiB9XSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXSxcbiAgICBuYW1lOiBcIm5hbWVcIixcbiAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwic3RyaW5nXCIgfV0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJvd25lclwiLCB0eXBlOiBcImFkZHJlc3NcIiB9XSxcbiAgICBuYW1lOiBcIm5vbmNlc1wiLFxuICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwidWludDI1NlwiIH1dLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwib3duZXJcIixcbiAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcIlwiLCB0eXBlOiBcImFkZHJlc3NcIiB9XSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXSxcbiAgICBuYW1lOiBcInBhdXNlXCIsXG4gICAgb3V0cHV0czogW10sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW10sXG4gICAgbmFtZTogXCJwYXVzZWRcIixcbiAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYm9vbFwiLCBuYW1lOiBcIlwiLCB0eXBlOiBcImJvb2xcIiB9XSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXSxcbiAgICBuYW1lOiBcInBhdXNlclwiLFxuICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH1dLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJvd25lclwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcInNwZW5kZXJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJ2YWx1ZVwiLCB0eXBlOiBcInVpbnQyNTZcIiB9LFxuICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcImRlYWRsaW5lXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXG4gICAgICB7IGludGVybmFsVHlwZTogXCJieXRlc1wiLCBuYW1lOiBcInNpZ25hdHVyZVwiLCB0eXBlOiBcImJ5dGVzXCIgfVxuICAgIF0sXG4gICAgbmFtZTogXCJwZXJtaXRcIixcbiAgICBvdXRwdXRzOiBbXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwib3duZXJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJzcGVuZGVyXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwidmFsdWVcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJkZWFkbGluZVwiLCB0eXBlOiBcInVpbnQyNTZcIiB9LFxuICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDhcIiwgbmFtZTogXCJ2XCIsIHR5cGU6IFwidWludDhcIiB9LFxuICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYnl0ZXMzMlwiLCBuYW1lOiBcInJcIiwgdHlwZTogXCJieXRlczMyXCIgfSxcbiAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIiwgbmFtZTogXCJzXCIsIHR5cGU6IFwiYnl0ZXMzMlwiIH1cbiAgICBdLFxuICAgIG5hbWU6IFwicGVybWl0XCIsXG4gICAgb3V0cHV0czogW10sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcImZyb21cIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJ0b1wiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcInZhbHVlXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXG4gICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwidmFsaWRBZnRlclwiLCB0eXBlOiBcInVpbnQyNTZcIiB9LFxuICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcInZhbGlkQmVmb3JlXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXG4gICAgICB7IGludGVybmFsVHlwZTogXCJieXRlczMyXCIsIG5hbWU6IFwibm9uY2VcIiwgdHlwZTogXCJieXRlczMyXCIgfSxcbiAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImJ5dGVzXCIsIG5hbWU6IFwic2lnbmF0dXJlXCIsIHR5cGU6IFwiYnl0ZXNcIiB9XG4gICAgXSxcbiAgICBuYW1lOiBcInJlY2VpdmVXaXRoQXV0aG9yaXphdGlvblwiLFxuICAgIG91dHB1dHM6IFtdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJmcm9tXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwidG9cIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJ2YWx1ZVwiLCB0eXBlOiBcInVpbnQyNTZcIiB9LFxuICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcInZhbGlkQWZ0ZXJcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJ2YWxpZEJlZm9yZVwiLCB0eXBlOiBcInVpbnQyNTZcIiB9LFxuICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYnl0ZXMzMlwiLCBuYW1lOiBcIm5vbmNlXCIsIHR5cGU6IFwiYnl0ZXMzMlwiIH0sXG4gICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50OFwiLCBuYW1lOiBcInZcIiwgdHlwZTogXCJ1aW50OFwiIH0sXG4gICAgICB7IGludGVybmFsVHlwZTogXCJieXRlczMyXCIsIG5hbWU6IFwiclwiLCB0eXBlOiBcImJ5dGVzMzJcIiB9LFxuICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYnl0ZXMzMlwiLCBuYW1lOiBcInNcIiwgdHlwZTogXCJieXRlczMyXCIgfVxuICAgIF0sXG4gICAgbmFtZTogXCJyZWNlaXZlV2l0aEF1dGhvcml6YXRpb25cIixcbiAgICBvdXRwdXRzOiBbXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcIm1pbnRlclwiLCB0eXBlOiBcImFkZHJlc3NcIiB9XSxcbiAgICBuYW1lOiBcInJlbW92ZU1pbnRlclwiLFxuICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJib29sXCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwiYm9vbFwiIH1dLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImNvbnRyYWN0IElFUkMyMFwiLFxuICAgICAgICBuYW1lOiBcInRva2VuQ29udHJhY3RcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH0sXG4gICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwidG9cIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJhbW91bnRcIiwgdHlwZTogXCJ1aW50MjU2XCIgfVxuICAgIF0sXG4gICAgbmFtZTogXCJyZXNjdWVFUkMyMFwiLFxuICAgIG91dHB1dHM6IFtdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwicmVzY3VlclwiLFxuICAgIG91dHB1dHM6IFt7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH1dLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwic3ltYm9sXCIsXG4gICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcInN0cmluZ1wiLCBuYW1lOiBcIlwiLCB0eXBlOiBcInN0cmluZ1wiIH1dLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwidG90YWxTdXBwbHlcIixcbiAgICBvdXRwdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcIlwiLCB0eXBlOiBcInVpbnQyNTZcIiB9XSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwidG9cIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJ2YWx1ZVwiLCB0eXBlOiBcInVpbnQyNTZcIiB9XG4gICAgXSxcbiAgICBuYW1lOiBcInRyYW5zZmVyXCIsXG4gICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImJvb2xcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJib29sXCIgfV0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcImZyb21cIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJ0b1wiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcInZhbHVlXCIsIHR5cGU6IFwidWludDI1NlwiIH1cbiAgICBdLFxuICAgIG5hbWU6IFwidHJhbnNmZXJGcm9tXCIsXG4gICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImJvb2xcIiwgbmFtZTogXCJcIiwgdHlwZTogXCJib29sXCIgfV0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW3sgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJuZXdPd25lclwiLCB0eXBlOiBcImFkZHJlc3NcIiB9XSxcbiAgICBuYW1lOiBcInRyYW5zZmVyT3duZXJzaGlwXCIsXG4gICAgb3V0cHV0czogW10sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcImZyb21cIiwgdHlwZTogXCJhZGRyZXNzXCIgfSxcbiAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIiwgbmFtZTogXCJ0b1wiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcInZhbHVlXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXG4gICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwidmFsaWRBZnRlclwiLCB0eXBlOiBcInVpbnQyNTZcIiB9LFxuICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLCBuYW1lOiBcInZhbGlkQmVmb3JlXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXG4gICAgICB7IGludGVybmFsVHlwZTogXCJieXRlczMyXCIsIG5hbWU6IFwibm9uY2VcIiwgdHlwZTogXCJieXRlczMyXCIgfSxcbiAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImJ5dGVzXCIsIG5hbWU6IFwic2lnbmF0dXJlXCIsIHR5cGU6IFwiYnl0ZXNcIiB9XG4gICAgXSxcbiAgICBuYW1lOiBcInRyYW5zZmVyV2l0aEF1dGhvcml6YXRpb25cIixcbiAgICBvdXRwdXRzOiBbXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiZnJvbVwiLCB0eXBlOiBcImFkZHJlc3NcIiB9LFxuICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcInRvXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH0sXG4gICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwidmFsdWVcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICAgIHsgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIiwgbmFtZTogXCJ2YWxpZEFmdGVyXCIsIHR5cGU6IFwidWludDI1NlwiIH0sXG4gICAgICB7IGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsIG5hbWU6IFwidmFsaWRCZWZvcmVcIiwgdHlwZTogXCJ1aW50MjU2XCIgfSxcbiAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIiwgbmFtZTogXCJub25jZVwiLCB0eXBlOiBcImJ5dGVzMzJcIiB9LFxuICAgICAgeyBpbnRlcm5hbFR5cGU6IFwidWludDhcIiwgbmFtZTogXCJ2XCIsIHR5cGU6IFwidWludDhcIiB9LFxuICAgICAgeyBpbnRlcm5hbFR5cGU6IFwiYnl0ZXMzMlwiLCBuYW1lOiBcInJcIiwgdHlwZTogXCJieXRlczMyXCIgfSxcbiAgICAgIHsgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIiwgbmFtZTogXCJzXCIsIHR5cGU6IFwiYnl0ZXMzMlwiIH1cbiAgICBdLFxuICAgIG5hbWU6IFwidHJhbnNmZXJXaXRoQXV0aG9yaXphdGlvblwiLFxuICAgIG91dHB1dHM6IFtdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFt7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiX2FjY291bnRcIiwgdHlwZTogXCJhZGRyZXNzXCIgfV0sXG4gICAgbmFtZTogXCJ1bkJsYWNrbGlzdFwiLFxuICAgIG91dHB1dHM6IFtdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwidW5wYXVzZVwiLFxuICAgIG91dHB1dHM6IFtdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFt7IGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsIG5hbWU6IFwiX25ld0JsYWNrbGlzdGVyXCIsIHR5cGU6IFwiYWRkcmVzc1wiIH1dLFxuICAgIG5hbWU6IFwidXBkYXRlQmxhY2tsaXN0ZXJcIixcbiAgICBvdXRwdXRzOiBbXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcIl9uZXdNYXN0ZXJNaW50ZXJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfV0sXG4gICAgbmFtZTogXCJ1cGRhdGVNYXN0ZXJNaW50ZXJcIixcbiAgICBvdXRwdXRzOiBbXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcIl9uZXdQYXVzZXJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfV0sXG4gICAgbmFtZTogXCJ1cGRhdGVQYXVzZXJcIixcbiAgICBvdXRwdXRzOiBbXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbeyBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLCBuYW1lOiBcIm5ld1Jlc2N1ZXJcIiwgdHlwZTogXCJhZGRyZXNzXCIgfV0sXG4gICAgbmFtZTogXCJ1cGRhdGVSZXNjdWVyXCIsXG4gICAgb3V0cHV0czogW10sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW10sXG4gICAgbmFtZTogXCJ2ZXJzaW9uXCIsXG4gICAgb3V0cHV0czogW3sgaW50ZXJuYWxUeXBlOiBcInN0cmluZ1wiLCBuYW1lOiBcIlwiLCB0eXBlOiBcInN0cmluZ1wiIH1dLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJwdXJlXCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH1cbl07XG5cbi8vIHNyYy90eXBlcy9zaGFyZWQvZXZtL3dhbGxldC50c1xudmFyIGltcG9ydF92aWVtID0gcmVxdWlyZShcInZpZW1cIik7XG52YXIgaW1wb3J0X2NoYWlucyA9IHJlcXVpcmUoXCJ2aWVtL2NoYWluc1wiKTtcbnZhciBpbXBvcnRfYWNjb3VudHMgPSByZXF1aXJlKFwidmllbS9hY2NvdW50c1wiKTtcbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudFNlcG9saWEoKSB7XG4gIHJldHVybiAoMCwgaW1wb3J0X3ZpZW0uY3JlYXRlUHVibGljQ2xpZW50KSh7XG4gICAgY2hhaW46IGltcG9ydF9jaGFpbnMuYmFzZVNlcG9saWEsXG4gICAgdHJhbnNwb3J0OiAoMCwgaW1wb3J0X3ZpZW0uaHR0cCkoKVxuICB9KS5leHRlbmQoaW1wb3J0X3ZpZW0ucHVibGljQWN0aW9ucyk7XG59XG5mdW5jdGlvbiBjcmVhdGVDbGllbnRBdmFsYW5jaGVGdWppKCkge1xuICByZXR1cm4gKDAsIGltcG9ydF92aWVtLmNyZWF0ZVB1YmxpY0NsaWVudCkoe1xuICAgIGNoYWluOiBpbXBvcnRfY2hhaW5zLmF2YWxhbmNoZUZ1amksXG4gICAgdHJhbnNwb3J0OiAoMCwgaW1wb3J0X3ZpZW0uaHR0cCkoKVxuICB9KS5leHRlbmQoaW1wb3J0X3ZpZW0ucHVibGljQWN0aW9ucyk7XG59XG5mdW5jdGlvbiBjcmVhdGVTaWduZXJTZXBvbGlhKHByaXZhdGVLZXkpIHtcbiAgcmV0dXJuICgwLCBpbXBvcnRfdmllbS5jcmVhdGVXYWxsZXRDbGllbnQpKHtcbiAgICBjaGFpbjogaW1wb3J0X2NoYWlucy5iYXNlU2Vwb2xpYSxcbiAgICB0cmFuc3BvcnQ6ICgwLCBpbXBvcnRfdmllbS5odHRwKSgpLFxuICAgIGFjY291bnQ6ICgwLCBpbXBvcnRfYWNjb3VudHMucHJpdmF0ZUtleVRvQWNjb3VudCkocHJpdmF0ZUtleSlcbiAgfSkuZXh0ZW5kKGltcG9ydF92aWVtLnB1YmxpY0FjdGlvbnMpO1xufVxuZnVuY3Rpb24gY3JlYXRlU2lnbmVyQXZhbGFuY2hlRnVqaShwcml2YXRlS2V5KSB7XG4gIHJldHVybiAoMCwgaW1wb3J0X3ZpZW0uY3JlYXRlV2FsbGV0Q2xpZW50KSh7XG4gICAgY2hhaW46IGltcG9ydF9jaGFpbnMuYXZhbGFuY2hlRnVqaSxcbiAgICB0cmFuc3BvcnQ6ICgwLCBpbXBvcnRfdmllbS5odHRwKSgpLFxuICAgIGFjY291bnQ6ICgwLCBpbXBvcnRfYWNjb3VudHMucHJpdmF0ZUtleVRvQWNjb3VudCkocHJpdmF0ZUtleSlcbiAgfSkuZXh0ZW5kKGltcG9ydF92aWVtLnB1YmxpY0FjdGlvbnMpO1xufVxuZnVuY3Rpb24gaXNTaWduZXJXYWxsZXQod2FsbGV0KSB7XG4gIHJldHVybiBcImNoYWluXCIgaW4gd2FsbGV0ICYmIFwidHJhbnNwb3J0XCIgaW4gd2FsbGV0O1xufVxuZnVuY3Rpb24gaXNBY2NvdW50KHdhbGxldCkge1xuICByZXR1cm4gXCJhZGRyZXNzXCIgaW4gd2FsbGV0ICYmIFwidHlwZVwiIGluIHdhbGxldDtcbn1cblxuLy8gc3JjL3R5cGVzL3ZlcmlmeS94NDAyU3BlY3MudHNcbnZhciBpbXBvcnRfem9kMyA9IHJlcXVpcmUoXCJ6b2RcIik7XG52YXIgRXZtTWF4QXRvbWljVW5pdHMgPSAxODtcbnZhciBFdm1BZGRyZXNzUmVnZXggPSAvXjB4WzAtOWEtZkEtRl17NDB9JC87XG52YXIgTWl4ZWRBZGRyZXNzUmVnZXggPSAvXjB4W2EtZkEtRjAtOV17NDB9fFtBLVphLXowLTldW0EtWmEtejAtOS1dezAsMzR9W0EtWmEtejAtOV0kLztcbnZhciBIZXhFbmNvZGVkNjRCeXRlUmVnZXggPSAvXjB4WzAtOWEtZkEtRl17NjR9JC87XG52YXIgRXZtU2lnbmF0dXJlUmVnZXggPSAvXjB4WzAtOWEtZkEtRl17MTMwfSQvO1xudmFyIHNjaGVtZXMgPSBbXCJleGFjdFwiXTtcbnZhciB4NDAyVmVyc2lvbnMgPSBbMV07XG52YXIgRXJyb3JSZWFzb25zID0gW1xuICBcImluc3VmZmljaWVudF9mdW5kc1wiLFxuICBcImludmFsaWRfZXhhY3RfZXZtX3BheWxvYWRfYXV0aG9yaXphdGlvbl92YWxpZF9hZnRlclwiLFxuICBcImludmFsaWRfZXhhY3RfZXZtX3BheWxvYWRfYXV0aG9yaXphdGlvbl92YWxpZF9iZWZvcmVcIixcbiAgXCJpbnZhbGlkX2V4YWN0X2V2bV9wYXlsb2FkX2F1dGhvcml6YXRpb25fdmFsdWVcIixcbiAgXCJpbnZhbGlkX2V4YWN0X2V2bV9wYXlsb2FkX3NpZ25hdHVyZVwiLFxuICBcImludmFsaWRfZXhhY3RfZXZtX3BheWxvYWRfcmVjaXBpZW50X21pc21hdGNoXCIsXG4gIFwiaW52YWxpZF9uZXR3b3JrXCIsXG4gIFwiaW52YWxpZF9wYXlsb2FkXCIsXG4gIFwiaW52YWxpZF9wYXltZW50X3JlcXVpcmVtZW50c1wiLFxuICBcImludmFsaWRfc2NoZW1lXCIsXG4gIFwidW5zdXBwb3J0ZWRfc2NoZW1lXCIsXG4gIFwiaW52YWxpZF94NDAyX3ZlcnNpb25cIixcbiAgXCJpbnZhbGlkX3RyYW5zYWN0aW9uX3N0YXRlXCIsXG4gIFwidW5leHBlY3RlZF92ZXJpZnlfZXJyb3JcIixcbiAgXCJ1bmV4cGVjdGVkX3NldHRsZV9lcnJvclwiXG5dO1xudmFyIGlzSW50ZWdlciA9ICh2YWx1ZSkgPT4gTnVtYmVyLmlzSW50ZWdlcihOdW1iZXIodmFsdWUpKSAmJiBOdW1iZXIodmFsdWUpID49IDA7XG52YXIgaGFzTWF4TGVuZ3RoID0gKG1heExlbmd0aCkgPT4gKHZhbHVlKSA9PiB2YWx1ZS5sZW5ndGggPD0gbWF4TGVuZ3RoO1xudmFyIFBheW1lbnRSZXF1aXJlbWVudHNTY2hlbWEgPSBpbXBvcnRfem9kMy56Lm9iamVjdCh7XG4gIHNjaGVtZTogaW1wb3J0X3pvZDMuei5lbnVtKHNjaGVtZXMpLFxuICBuZXR3b3JrOiBOZXR3b3JrU2NoZW1hLFxuICBtYXhBbW91bnRSZXF1aXJlZDogaW1wb3J0X3pvZDMuei5zdHJpbmcoKS5yZWZpbmUoaXNJbnRlZ2VyKSxcbiAgcmVzb3VyY2U6IGltcG9ydF96b2QzLnouc3RyaW5nKCkudXJsKCksXG4gIGRlc2NyaXB0aW9uOiBpbXBvcnRfem9kMy56LnN0cmluZygpLFxuICBtaW1lVHlwZTogaW1wb3J0X3pvZDMuei5zdHJpbmcoKSxcbiAgb3V0cHV0U2NoZW1hOiBpbXBvcnRfem9kMy56LnJlY29yZChpbXBvcnRfem9kMy56LmFueSgpKS5vcHRpb25hbCgpLFxuICBwYXlUbzogaW1wb3J0X3pvZDMuei5zdHJpbmcoKS5yZWdleChNaXhlZEFkZHJlc3NSZWdleCksXG4gIG1heFRpbWVvdXRTZWNvbmRzOiBpbXBvcnRfem9kMy56Lm51bWJlcigpLmludCgpLFxuICBhc3NldDogaW1wb3J0X3pvZDMuei5zdHJpbmcoKS5yZWdleChNaXhlZEFkZHJlc3NSZWdleCksXG4gIGV4dHJhOiBpbXBvcnRfem9kMy56LnJlY29yZChpbXBvcnRfem9kMy56LmFueSgpKS5vcHRpb25hbCgpXG59KTtcbnZhciBFeGFjdEV2bVBheWxvYWRBdXRob3JpemF0aW9uU2NoZW1hID0gaW1wb3J0X3pvZDMuei5vYmplY3Qoe1xuICBmcm9tOiBpbXBvcnRfem9kMy56LnN0cmluZygpLnJlZ2V4KEV2bUFkZHJlc3NSZWdleCksXG4gIHRvOiBpbXBvcnRfem9kMy56LnN0cmluZygpLnJlZ2V4KEV2bUFkZHJlc3NSZWdleCksXG4gIHZhbHVlOiBpbXBvcnRfem9kMy56LnN0cmluZygpLnJlZmluZShpc0ludGVnZXIpLnJlZmluZShoYXNNYXhMZW5ndGgoRXZtTWF4QXRvbWljVW5pdHMpKSxcbiAgdmFsaWRBZnRlcjogaW1wb3J0X3pvZDMuei5zdHJpbmcoKS5yZWZpbmUoaXNJbnRlZ2VyKSxcbiAgdmFsaWRCZWZvcmU6IGltcG9ydF96b2QzLnouc3RyaW5nKCkucmVmaW5lKGlzSW50ZWdlciksXG4gIG5vbmNlOiBpbXBvcnRfem9kMy56LnN0cmluZygpLnJlZ2V4KEhleEVuY29kZWQ2NEJ5dGVSZWdleClcbn0pO1xudmFyIEV4YWN0RXZtUGF5bG9hZFNjaGVtYSA9IGltcG9ydF96b2QzLnoub2JqZWN0KHtcbiAgc2lnbmF0dXJlOiBpbXBvcnRfem9kMy56LnN0cmluZygpLnJlZ2V4KEV2bVNpZ25hdHVyZVJlZ2V4KSxcbiAgYXV0aG9yaXphdGlvbjogRXhhY3RFdm1QYXlsb2FkQXV0aG9yaXphdGlvblNjaGVtYVxufSk7XG52YXIgUGF5bWVudFBheWxvYWRTY2hlbWEgPSBpbXBvcnRfem9kMy56Lm9iamVjdCh7XG4gIHg0MDJWZXJzaW9uOiBpbXBvcnRfem9kMy56Lm51bWJlcigpLnJlZmluZSgodmFsKSA9PiB4NDAyVmVyc2lvbnMuaW5jbHVkZXModmFsKSksXG4gIHNjaGVtZTogaW1wb3J0X3pvZDMuei5lbnVtKHNjaGVtZXMpLFxuICBuZXR3b3JrOiBOZXR3b3JrU2NoZW1hLFxuICBwYXlsb2FkOiBFeGFjdEV2bVBheWxvYWRTY2hlbWFcbn0pO1xudmFyIFZlcmlmeVJlc3BvbnNlU2NoZW1hID0gaW1wb3J0X3pvZDMuei5vYmplY3Qoe1xuICBpc1ZhbGlkOiBpbXBvcnRfem9kMy56LmJvb2xlYW4oKSxcbiAgaW52YWxpZFJlYXNvbjogaW1wb3J0X3pvZDMuei5lbnVtKEVycm9yUmVhc29ucykub3B0aW9uYWwoKSxcbiAgcGF5ZXI6IGltcG9ydF96b2QzLnouc3RyaW5nKCkucmVnZXgoTWl4ZWRBZGRyZXNzUmVnZXgpLm9wdGlvbmFsKClcbn0pO1xudmFyIFNldHRsZVJlc3BvbnNlU2NoZW1hID0gaW1wb3J0X3pvZDMuei5vYmplY3Qoe1xuICBzdWNjZXNzOiBpbXBvcnRfem9kMy56LmJvb2xlYW4oKSxcbiAgZXJyb3JSZWFzb246IGltcG9ydF96b2QzLnouZW51bShFcnJvclJlYXNvbnMpLm9wdGlvbmFsKCksXG4gIHBheWVyOiBpbXBvcnRfem9kMy56LnN0cmluZygpLnJlZ2V4KE1peGVkQWRkcmVzc1JlZ2V4KS5vcHRpb25hbCgpLFxuICB0cmFuc2FjdGlvbjogaW1wb3J0X3pvZDMuei5zdHJpbmcoKS5yZWdleChNaXhlZEFkZHJlc3NSZWdleCksXG4gIG5ldHdvcms6IE5ldHdvcmtTY2hlbWFcbn0pO1xudmFyIFN1cHBvcnRlZFBheW1lbnRLaW5kU2NoZW1hID0gaW1wb3J0X3pvZDMuei5vYmplY3Qoe1xuICB4NDAyVmVyc2lvbjogaW1wb3J0X3pvZDMuei5udW1iZXIoKS5yZWZpbmUoKHZhbCkgPT4geDQwMlZlcnNpb25zLmluY2x1ZGVzKHZhbCkpLFxuICBzY2hlbWU6IGltcG9ydF96b2QzLnouZW51bShzY2hlbWVzKSxcbiAgbmV0d29yazogTmV0d29ya1NjaGVtYVxufSk7XG52YXIgU3VwcG9ydGVkUGF5bWVudEtpbmRzUmVzcG9uc2VTY2hlbWEgPSBpbXBvcnRfem9kMy56Lm9iamVjdCh7XG4gIGtpbmRzOiBpbXBvcnRfem9kMy56LmFycmF5KFN1cHBvcnRlZFBheW1lbnRLaW5kU2NoZW1hKVxufSk7XG5cbi8vIHNyYy90eXBlcy92ZXJpZnkvZmFjaWxpdGF0b3IudHNcbnZhciBpbXBvcnRfem9kNCA9IHJlcXVpcmUoXCJ6b2RcIik7XG5cbi8vIHNyYy9zaGFyZWQvYmFzZTY0LnRzXG5mdW5jdGlvbiBzYWZlQmFzZTY0RW5jb2RlKGRhdGEpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBnbG9iYWxUaGlzLmJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBnbG9iYWxUaGlzLmJ0b2EoZGF0YSk7XG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGRhdGEpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xufVxuZnVuY3Rpb24gc2FmZUJhc2U2NERlY29kZShkYXRhKSB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgZ2xvYmFsVGhpcy5hdG9iID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gZ2xvYmFsVGhpcy5hdG9iKGRhdGEpO1xuICB9XG4gIHJldHVybiBCdWZmZXIuZnJvbShkYXRhLCBcImJhc2U2NFwiKS50b1N0cmluZyhcInV0Zi04XCIpO1xufVxuXG4vLyBzcmMvdHlwZXMvdmVyaWZ5L2ZhY2lsaXRhdG9yLnRzXG52YXIgZmFjaWxpdGF0b3JSZXF1ZXN0U2NoZW1hID0gaW1wb3J0X3pvZDQuei5vYmplY3Qoe1xuICBwYXltZW50SGVhZGVyOiBpbXBvcnRfem9kNC56LnN0cmluZygpLFxuICBwYXltZW50UmVxdWlyZW1lbnRzOiBQYXltZW50UmVxdWlyZW1lbnRzU2NoZW1hXG59KTtcbmZ1bmN0aW9uIHNldHRsZVJlc3BvbnNlSGVhZGVyKHJlc3BvbnNlKSB7XG4gIHJldHVybiBzYWZlQmFzZTY0RW5jb2RlKEpTT04uc3RyaW5naWZ5KHJlc3BvbnNlKSk7XG59XG5mdW5jdGlvbiBzZXR0bGVSZXNwb25zZUZyb21IZWFkZXIoaGVhZGVyKSB7XG4gIGNvbnN0IGRlY29kZWQgPSBzYWZlQmFzZTY0RGVjb2RlKGhlYWRlcik7XG4gIHJldHVybiBKU09OLnBhcnNlKGRlY29kZWQpO1xufVxuLy8gQW5ub3RhdGUgdGhlIENvbW1vbkpTIGV4cG9ydCBuYW1lcyBmb3IgRVNNIGltcG9ydCBpbiBub2RlOlxuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gIENoYWluSWRUb05ldHdvcmssXG4gIEVycm9yUmVhc29ucyxcbiAgRXZtTmV0d29ya1RvQ2hhaW5JZCxcbiAgRXhhY3RFdm1QYXlsb2FkQXV0aG9yaXphdGlvblNjaGVtYSxcbiAgRXhhY3RFdm1QYXlsb2FkU2NoZW1hLFxuICBOZXR3b3JrU2NoZW1hLFxuICBQYXltZW50UGF5bG9hZFNjaGVtYSxcbiAgUGF5bWVudFJlcXVpcmVtZW50c1NjaGVtYSxcbiAgU2V0dGxlUmVzcG9uc2VTY2hlbWEsXG4gIFN1cHBvcnRlZEVWTU5ldHdvcmtzLFxuICBTdXBwb3J0ZWRQYXltZW50S2luZFNjaGVtYSxcbiAgU3VwcG9ydGVkUGF5bWVudEtpbmRzUmVzcG9uc2VTY2hlbWEsXG4gIFZlcmlmeVJlc3BvbnNlU2NoZW1hLFxuICBldm0sXG4gIGZhY2lsaXRhdG9yUmVxdWVzdFNjaGVtYSxcbiAgbW9uZXlTY2hlbWEsXG4gIHNjaGVtZXMsXG4gIHNldHRsZVJlc3BvbnNlRnJvbUhlYWRlcixcbiAgc2V0dGxlUmVzcG9uc2VIZWFkZXIsXG4gIHg0MDJWZXJzaW9uc1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/x402-axios/node_modules/x402/dist/cjs/types/index.js\n");

/***/ })

};
;